diff --git a/.gitignore b/.gitignore
index 2ee883bc..9dda3408 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,45 +1,19 @@
 *.o
-*.so
 *.a
-*lwip_unittests.xml
-*.suo
-*.log
-.depend
-
 /doc/doxygen/output/html
-
+/src/apps/snmp/LwipMibCompiler/CCodeGeneration/bin/
+/src/apps/snmp/LwipMibCompiler/CCodeGeneration/obj/
+/src/apps/snmp/LwipMibCompiler/LwipMibCompiler/bin/
+/src/apps/snmp/LwipMibCompiler/LwipMibCompiler/obj/
+/src/apps/snmp/LwipMibCompiler/MibViewer/bin/
+/src/apps/snmp/LwipMibCompiler/MibViewer/obj/
+/src/apps/snmp/LwipMibCompiler/LwipSnmpCodeGeneration/bin/
+/src/apps/snmp/LwipMibCompiler/LwipSnmpCodeGeneration/obj/
+/src/apps/snmp/LwipMibCompiler/SharpSnmpLib/bin/
+/src/apps/snmp/LwipMibCompiler/SharpSnmpLib/obj/
+/src/apps/snmp/LwipMibCompiler/LwipMibCompiler.userprefs
+/src/apps/snmp/LwipMibCompiler/*.suo
 /test/fuzz/output
 /test/fuzz/lwip_fuzz
 /test/fuzz/.depend
-
-/build
-
-/contrib/examples/example_app/lwipcfg.h
-/contrib/examples/example_app/lwipopts_test.h
-
-/contrib/ports/unix/example_app/build
-/contrib/ports/unix/example_app/example_app
-/contrib/ports/unix/example_app/makefsdata
-
-/contrib/ports/unix/check/build
-/contrib/ports/unix/lib/build
-/contrib/ports/unix/check/lwip_unittests
-
-/contrib/ports/win32/example_app/build
-/contrib/ports/win32/lwipcfg_msvc.h
-
-/contrib/ports/win32/msvc/Debug
-/contrib/ports/win32/msvc/Debug unittests
-/contrib/ports/win32/msvc/Release
-/contrib/ports/win32/msvc/Release unittests
-/contrib/ports/win32/msvc/*.user
-/contrib/ports/win32/msvc/*.ncb
-/contrib/ports/win32/msvc/*.cache
-/contrib/ports/win32/msvc/*.suo
-/contrib/ports/win32/msvc/ipch
-/contrib/ports/win32/msvc/*.opensdf
-/contrib/ports/win32/msvc/*.sdf
-/contrib/ports/win32/mingw/*.exe
-/contrib/ports/win32/mingw/*.map
-/contrib/ports/win32/mingw/cov-int
-/contrib/ports/win32/msvc/.vs
+/build
\ No newline at end of file
diff --git a/.travis.yml b/.travis.yml
deleted file mode 100644
index 4faeb6c4..00000000
--- a/.travis.yml
+++ /dev/null
@@ -1,42 +0,0 @@
-language: c
-os: linux
-sudo: required
-
-matrix:
-  include:
-    - compiler: gcc-7
-      addons:
-        apt:
-          sources:
-            - ubuntu-toolchain-r-test
-          packages:
-            - check
-            - libsubunit-dev
-            - gcc-7
-            - ninja-build
-            - doxygen
-      env:
-        - LSAN_OPTIONS=verbosity=1:log_threads=1
-
-    - compiler: clang-7
-      addons:
-        apt:
-          sources:
-            - ubuntu-toolchain-r-test
-            - llvm-toolchain-trusty-7
-          packages:
-            - check
-            - libsubunit-dev
-            - clang-7
-            - ninja-build
-            - doxygen
-      env:
-        - LSAN_OPTIONS=verbosity=1:log_threads=1
-
-before_install:
-  # Install cmake
-  - wget -O cmake.sh https://cmake.org/files/v3.12/cmake-3.12.0-Linux-x86_64.sh
-  - sudo sh cmake.sh --skip-license --exclude-subdir --prefix=/usr/local
-
-script:
-  - ./travis.sh
diff --git a/.vscode/c_cpp_properties.json b/.vscode/c_cpp_properties.json
deleted file mode 100644
index e7eb6a69..00000000
--- a/.vscode/c_cpp_properties.json
+++ /dev/null
@@ -1,28 +0,0 @@
-{
-    "configurations": [
-        {
-            "name": "Linux",
-            "includePath": [
-                "${workspaceFolder}/src/include",
-                "${workspaceFolder}/contrib",
-                "${workspaceFolder}/contrib/examples/example_app",
-                "${workspaceFolder}/contrib/ports/unix/port/include",
-                "${workspaceFolder}/contrib/ports/unix/example_app"
-            ],
-            "defines": [],
-            "intelliSenseMode": "gcc-x64",
-            "browse": {
-                "path": [
-                    "${workspaceFolder}/**"
-                ],
-                "limitSymbolsToIncludedHeaders": true,
-                "databaseFilename": ""
-            },
-            "compilerPath": "/usr/bin/gcc",
-            "cStandard": "c11",
-            "cppStandard": "c++17",
-            "configurationProvider": "vector-of-bool.cmake-tools"
-        }
-    ],
-    "version": 4
-}
\ No newline at end of file
diff --git a/.vscode/launch.json b/.vscode/launch.json
deleted file mode 100644
index b0de9554..00000000
--- a/.vscode/launch.json
+++ /dev/null
@@ -1,60 +0,0 @@
-{
-    // Use IntelliSense to learn about possible attributes.
-    // Hover to view descriptions of existing attributes.
-    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
-    "version": "0.2.0",
-    "configurations": [
-        {
-            "name": "(gdb) Launch example_app",
-            "type": "cppdbg",
-            "request": "launch",
-            "args": [],
-            "stopAtEntry": true,
-            "environment": [],
-            "externalConsole": true,
-            "MIMode": "gdb",
-            "preLaunchTask": "Build example_app",
-            "setupCommands": [
-                {
-                    "description": "Enable pretty-printing for gdb",
-                    "text": "-enable-pretty-printing",
-                    "ignoreFailures": true
-                }
-            ],
-            "linux": {
-                "cwd": "${workspaceFolder}/build/contrib/ports/unix/example_app",
-                "program": "${workspaceFolder}/build/contrib/ports/unix/example_app/example_app",
-            },
-            "windows": {
-                "cwd": "${workspaceFolder}/build/contrib/ports/win32/example_app",
-                "program": "${workspaceFolder}/build/contrib/ports/win32/example_app/example_app",
-            }
-        },
-        {
-            "name": "(gdb) Launch unit tests",
-            "type": "cppdbg",
-            "request": "launch",
-            "args": [],
-            "stopAtEntry": true,
-            "environment": [],
-            "externalConsole": false,
-            "MIMode": "gdb",
-            "preLaunchTask": "Build unit tests",
-            "setupCommands": [
-                {
-                    "description": "Enable pretty-printing for gdb",
-                    "text": "-enable-pretty-printing",
-                    "ignoreFailures": true
-                }
-            ],
-            "linux": {
-                "cwd": "${workspaceFolder}/contrib/ports/unix/check/build",
-                "program": "${workspaceFolder}/contrib/ports/unix/check/build/lwip_unittests",
-            },
-            "windows": {
-                "cwd": "${workspaceFolder}/contrib/ports/win32/check/build",
-                "program": "${workspaceFolder}/contrib/ports/win32/check/build/lwip_unittests",
-            }
-        }
-    ]
-}
diff --git a/.vscode/settings.json b/.vscode/settings.json
deleted file mode 100644
index 5940f404..00000000
--- a/.vscode/settings.json
+++ /dev/null
@@ -1,10 +0,0 @@
-{
-    "editor.tabSize": 2,
-    "editor.insertSpaces": true,
-    "files.insertFinalNewline": true,
-    "files.trimFinalNewlines": true,
-    "files.trimTrailingWhitespace": true,
-    "files.associations": {
-        "*.h": "c"
-    }
-}
diff --git a/.vscode/tasks.json b/.vscode/tasks.json
deleted file mode 100644
index ccc3c7e3..00000000
--- a/.vscode/tasks.json
+++ /dev/null
@@ -1,54 +0,0 @@
-{
-    // See https://go.microsoft.com/fwlink/?LinkId=733558
-    // for the documentation about the tasks.json format
-    "version": "2.0.0",
-    "tasks": [
-        {
-            "label": "Build example_app",
-            "type": "shell",
-            "options": {
-                "cwd": "${workspaceFolder}/build"
-            },
-            "problemMatcher": "$gcc",
-            "group": {
-                "kind": "build",
-                "isDefault": true
-            },
-            "command": "cmake --build ."
-        },
-        {
-            "label": "Build unit tests",
-            "type": "shell",
-            "problemMatcher": "$gcc",
-            "group": "build",
-            "linux": {
-                "options": {
-                    "cwd": "${workspaceFolder}/contrib/ports/unix/check/build"
-                },
-            },
-            "windows": {
-                "options": {
-                    "cwd": "${workspaceFolder}/contrib/ports/win32/check/build"
-                },
-            },
-            "command": "cmake --build ."
-        },
-        {
-            "label": "Configure example_app",
-            "type": "shell",
-            "problemMatcher": "$gcc",
-            "group": "build",
-            "command": "cd ${workspaceFolder}; mkdir build; cd build; cmake .."
-        },
-        {
-            "label": "Generate documentation",
-            "type": "shell",
-            "problemMatcher": [],
-            "group": "none",
-            "options": {
-                "cwd": "${workspaceFolder}/build"
-            },
-            "command": "cmake --build . --target lwipdocs"
-        }
-    ]
-}
diff --git a/BUILDING b/BUILDING
deleted file mode 100644
index 8202f5f8..00000000
--- a/BUILDING
+++ /dev/null
@@ -1,107 +0,0 @@
-Building lwIP
-=============
-
-lwIP uses a CMake based build system.
-
-The CMake files in this project are designed to
-be included into your own CMake files. They are
-mainly variable definitions containing a list of
-source files and predefined static libraries to
-be linked against application code.
-
-1) lwIP sources:
-   src/Filelists.cmake provides file lists containing
-   the lwIP core library.
-   The file also contains two static libraries, lwipcore
-   and lwipallapps, where you can link your app against.
-   This is the file that is useful to all lwIP users.
-
-2) Example applications:
-   contrib/Filelists.cmake provides several file lists
-   containing the example applications.
-   The file also contains several static libraries
-   for these example apps.
-   This file is only useful for you, if you can use one
-   of the examples in your application, which is normally
-   not the case.
-
-3) OS/platform port:
-   Usually the OS port needs to be provided by the user.
-   If a port to Linux, Windows or MacOS is useful for
-   you, you can use
-   contrib/ports/{win32, unix}/Filelists.cmake
-   that contains file lists and libraries for
-   these operating systems.
-
-VARIABLES
-=========
-In all cases, you need to provide two variables.
-
-"LWIP_DIR" pointing to the lwIP directory
-Example:
-set(LWIP_DIR ${CMAKE_CURRENT_SOURCE_DIR}/externals/lwip)
-
-"LWIP_INCLUDE_DIRS" that contains the include base paths
-- for lwIP itself (${LWIP_DIR}/src/include)
-- for lwIP contrib if you use it (${LWIP_DIR}/contrib)
-- to a directory containing an OS port
-- to a directory containing lwipopts.h
-
-Example:
-set (LWIP_INCLUDE_DIRS
-    "${LWIP_DIR}/src/include"
-    "${LWIP_DIR}/contrib"
-    "${LWIP_DIR}/contrib/ports/unix/port/include"
-    "${LWIP_DIR}/contrib/examples/example_app"
-)
-
-Putting it all together
-=======================
-To get a working application, your CMake system
-needs to provide the variables described above, e.g.
-set (LWIP_DIR <path to lwip sources>)
-set (LWIP_INCLUDE_DIRS
-    "${LWIP_DIR}/src/include"
-    "${LWIP_DIR}/contrib"
-    "<path to my port>/include"
-    "<path to lwipopts.h>"
-)
-
-You may add some defines:
-set (LWIP_DEFINITIONS LWIP_DEBUG=1)
-
-Then include the filelists you need:
-include(${LWIP_DIR}/src/Filelists.cmake)
-include(${LWIP_DIR}/contrib/Filelists.cmake)
-
-Then, declare you executable:
-add_executable(my_app <my source files> <my lwip port files>)
-
-Add lwIP include dirs to your app:
-target_include_directories(my_app PRIVATE ${LWIP_INCLUDE_DIRS})
-
-Link your app against the lwIP libs from the filelists you need:
-target_link_libraries(my_app lwipcontribapps lwipallapps lwipcore)
-
-Working example
-===============
-Working build examples can be found in the
-contrib/ports/{win32, unix}/example_app
-subdirectory.
-To use them, create a build directory and call cmake with
-the lwIP root dir:
-
-- mkdir build
-- cd build
-- cmake ..
-- cmake --build .
-
-The CMakeLists.txt will autoselect the correct port
-for your system (supported: Linux, Windows, Darwin).
-
-Makefile based build system
-===========================
-lwIP also maintains file lists for Makefile-based
-build systems. Look for Filelists.mk files
-in the source tree. We try to maintain them,
-but lwIP's mainly focused build system is CMake.
diff --git a/CHANGELOG b/CHANGELOG
index df33490f..5f797e77 100644
--- a/CHANGELOG
+++ b/CHANGELOG
@@ -6,11 +6,21 @@ HISTORY
 
   * [Enter new changes just after this line - do not remove this line]
 
-  2018-10-04: Jasper Verschueren
-  * Implement IPv4 ACD (Address Conflict Detection)
+(STABLE-2.1.2):
 
-  2018-10-02: Dirk Ziegelmeier
-  * Integrate contrib repository into main lwIP rep, tag STABLE-2_1_0_RELEASE
+  ++ Bugfixes:
+
+  2018-11-21: Jens Nielsen
+  * netbiosns.c: fix expecting too large packet (bug #55069)
+
+  2018-11-19: Dirk Ziegelmeier
+  * smtp.c: fix compiling with strict C compatibility because of strnlen (bug #55034)
+
+  2018-11-12: Simon Goldschmidt
+  * tcp.c: fix overflow check in tcp_recved triggering invalid assertion (bug #55015)
+
+  2018-11-12: Simon Goldschmidt
+  * tcp.c: fix a bug in sending RST segments (sent from port 0)
 
 (STABLE-2.1.1):
 
@@ -167,7 +177,7 @@ HISTORY
 
   2017-01-20: Joel Cunningham
   * sockets: add interface name/index APIs (task #14314)
-
+  
   2017-01-08: David van Moolenbroek
   * Extensions to RAW API (patch #9208)
     - Connected RAW PCBs
@@ -256,7 +266,7 @@ HISTORY
 
   2017-08-02: Abroz Bizjak/Simon Goldschmidt
   * multiple fixes in IPv4 reassembly (leading to corrupted datagrams received)
-
+  
   2017-03-30: Simon Goldschmidt
   * dhcp.c: return ERR_VAL instead of asserting on offset-out-of-pbuf
 
@@ -401,7 +411,7 @@ HISTORY
 
   2016-11-14: Joel Cunningham
   * tcp_out.c: fixed bug #49533 (start persist timer when unsent seg can't fit
-    in window)
+    in window) 
 
   2016-11-16: Roberto Barbieri Carrera
   * autoip.c: fixed bug #49610 (sometimes AutoIP fails to reuse the same address)
@@ -676,7 +686,7 @@ HISTORY
       implementation which is under a BSD-ish license.
     - Also switched to PolarSSL MD4,MD5,SHA1 implementations, which are meant to be
       used in embedded devices with reduced memory footprint.
-    - Removed PPP configuration file parsing support.
+    - Removed PPP configuration file parsing support. 
     - Added macro definition EAP_SUPPORT to make EAP support optional.
     - Added macro definition CHAP_SUPPORT to make CHAP support optional.
     - Added macro definition MSCHAP_SUPPORT to make MSCHAP support optional.
@@ -1208,7 +1218,7 @@ HISTORY
   2012-03-25: Simon Goldschmidt (idea by Mason)
   * posix/*: added posix-compatibility include files posix/netdb.h and posix/sys/socket.h
     which are a simple wrapper to the correct lwIP include files.
-
+ 
   2012-01-16: Simon Goldschmidt
   * opt.h, icmp.c: Added option CHECKSUM_GEN_ICMP
 
@@ -1290,10 +1300,10 @@ HISTORY
 
   2012-03-22: Simon Goldschmidt
   * ip4.c: fixed bug #35927: missing refragmentaion in ip_forward
-
+ 
   2012-03-20: Simon Goldschmidt (patch by Mason)
   * netdb.c: fixed bug #35907: lwip_gethostbyname_r returns an invalid h_addr_list
-
+ 
   2012-03-12: Simon Goldschmidt (patch by Bostjan Meglic)
   * ppp.c: fixed bug #35809: PPP GetMask(): Compiler warning on big endian,
     possible bug on little endian system
@@ -1748,7 +1758,7 @@ HISTORY
   2011-03-27: Simon Goldschmidt
   * sockets.c: Fixed bug #32906: lwip_connect+lwip_send did not work for udp and
     raw pcbs with LWIP_TCPIP_CORE_LOCKING==1.
-
+  
   2011-03-27: Simon Goldschmidt
   * tcp_out.c: Fixed bug #32820 (Outgoing TCP connections created before route
     is present never times out) by starting retransmission timer before checking
@@ -1801,7 +1811,7 @@ HISTORY
   2010-11-23: Simon Goldschmidt
   * tcp_in.c: Fixed bug #30577: tcp_input: don't discard ACK-only packets after
     refusing 'refused_data' again.
-
+  
   2010-11-22: Simon Goldschmidt
   * sockets.c: Fixed bug #31590: getsockopt(... SO_ERROR ...) gives EINPROGRESS
     after a successful nonblocking connection.
@@ -1846,21 +1856,21 @@ HISTORY
   2010-08-01: Simon Goldschmidt (patch by Greg Renda)
   * ppp.c: Applied patch #7264 (PPP protocols are rejected incorrectly on big
     endian architectures)
-
+  
   2010-07-28: Simon Goldschmidt
   * api_lib.c, api_msg.c, sockets.c, mib2.c: Fixed compilation with TCP or UDP
     disabled.
-
+  
   2010-07-27: Simon Goldschmidt
   * tcp.c: Fixed bug #30565 (tcp_connect() check bound list): that check did no
     harm but never did anything
-
+  
   2010-07-21: Simon Goldschmidt
   * ip.c: Fixed invalid fix for bug #30402 (CHECKSUM_GEN_IP_INLINE does not
     add IP options)
 
   2010-07-16: Kieran Mansley
-  * msg_in.c: Fixed SNMP ASN constant defines to not use ! operator
+  * msg_in.c: Fixed SNMP ASN constant defines to not use ! operator 
 
   2010-07-10: Simon Goldschmidt
   * ip.c: Fixed bug #30402: CHECKSUM_GEN_IP_INLINE does not add IP options
@@ -1964,7 +1974,7 @@ HISTORY
 
   2010-03-05: Simon Goldschmidt
   * api_msg.c: Correctly set TCP_WRITE_FLAG_MORE when netconn_write is split
-    into multiple calls to tcp_write.
+    into multiple calls to tcp_write.    
 
   2010-02-21: Simon Goldschmidt
   * opt.h, mem.h, dns.c: task #10140: Remove DNS_USES_STATIC_BUF (keep
@@ -2424,7 +2434,7 @@ HISTORY
     sent to mbox
 
   2009-06-25 Kieran Mansley
-  * api_msg.c api.h: BUG26722: initialise netconn write variables
+  * api_msg.c api.h: BUG26722: initialise netconn write variables 
     in netconn_alloc
 
   2009-06-25 Kieran Mansley
@@ -2432,7 +2442,7 @@ HISTORY
 
   2009-06-25 Kieran Mansley
   * tcp.c, tcp_in.c, tcp_out.c, tcp.h: BUG26301 and BUG26267: correct
-    simultaneous close behaviour, and make snd_nxt have the same meaning
+    simultaneous close behaviour, and make snd_nxt have the same meaning 
     as in the RFCs.
 
   2009-05-12 Simon Goldschmidt
@@ -2568,7 +2578,7 @@ HISTORY
   * tcp.c, tcp_in.c, tcp.h: add tcp_abandon() to cope with dropping
     connections where no reset required (bug #25622)
 
-  * tcp_out.c: set TCP_ACK flag on keepalive and zero window probes
+  * tcp_out.c: set TCP_ACK flag on keepalive and zero window probes 
     (bug #20779)
 
   2009-02-18 Simon Goldschmidt (Jonathan Larmour and Bill Auerbach)
@@ -2604,7 +2614,7 @@ HISTORY
     out of pool pbufs.
 
   2008-12-19 Simon Goldschmidt
-  * many files: patch #6699: fixed some warnings on platform where sizeof(int) == 2
+  * many files: patch #6699: fixed some warnings on platform where sizeof(int) == 2 
 
   2008-12-10 Tamas Somogyi, Frédéric Bernon
   * sockets.c: fixed bug #25051: lwip_recvfrom problem with udp: fromaddr and
@@ -2689,7 +2699,7 @@ HISTORY
     made from lwipopts.h. Fix comment on how to override LWIP_CHKSUM.
 
   2008-01-22 Frédéric Bernon
-  * tcp.c, tcp_in.c, tcp.h, opt.h: Rename LWIP_CALCULATE_EFF_SEND_MSS in
+  * tcp.c, tcp_in.c, tcp.h, opt.h: Rename LWIP_CALCULATE_EFF_SEND_MSS in 
     TCP_CALCULATE_EFF_SEND_MSS to have coherent TCP options names.
 
   2008-01-14 Frédéric Bernon
@@ -2699,7 +2709,7 @@ HISTORY
 
   2008-01-14 Frédéric Bernon, Marc Chaland
   * ip.c: Integrate patch #6369" ip_input : checking before realloc".
-
+  
   2008-01-12 Frédéric Bernon
   * tcpip.h, tcpip.c, api.h, api_lib.c, api_msg.c, sockets.c: replace the field
     netconn::sem per netconn::op_completed like suggested for the task #7490
@@ -2725,8 +2735,8 @@ HISTORY
     Introduce changes for task #7490 "Add return value to sys_mbox_post" with some
     modifications in the sys_mbox api: sys_mbox_new take a "size" parameters which
     indicate the number of pointers query by the mailbox. There is three defines
-    in opt.h to indicate sizes for tcpip::mbox, netconn::recvmbox, and for the
-    netconn::acceptmbox. Port maintainers, you can decide to just add this new
+    in opt.h to indicate sizes for tcpip::mbox, netconn::recvmbox, and for the 
+    netconn::acceptmbox. Port maintainers, you can decide to just add this new 
     parameter in your implementation, but to ignore it to keep the previous behavior.
     The new sys_mbox_trypost function return a value to know if the mailbox is
     full or if the message is posted. Take a look to sys_arch.txt for more details.
@@ -2850,7 +2860,7 @@ HISTORY
     Note that previous "copy" parameter for "write" APIs is now called "apiflags".
 
   2007-10-24 Frédéric Bernon
-  * api.h, api_lib.c, api_msg.c: Add macro API_EVENT in the same spirit than
+  * api.h, api_lib.c, api_msg.c: Add macro API_EVENT in the same spirit than 
     TCP_EVENT_xxx macros to get a code more readable. It could also help to remove
     some code (like we have talk in "patch #5919 : Create compile switch to remove
     select code"), but it could be done later.
@@ -2870,7 +2880,7 @@ HISTORY
     all netifs (or ports) can use it.
 
   2007-10-05 Frédéric Bernon
-  * netifapi.h, netifapi.c: add function netifapi_netif_set_default. Change the
+  * netifapi.h, netifapi.c: add function netifapi_netif_set_default. Change the 
     common function to reduce a little bit the footprint (for all functions using
     only the "netif" parameter).
 
@@ -2894,7 +2904,7 @@ HISTORY
     or snmp_add_sysuptime(), and to define the SNMP_GET_SYSUPTIME(sysuptime) macro.
     This one is undefined by default in mib2.c. SNMP_GET_SYSUPTIME is called inside
     snmp_get_sysuptime(u32_t *value), and enable to change "sysuptime" value only
-    when it's queried (any direct call to "sysuptime" is changed by a call to
+    when it's queried (any direct call to "sysuptime" is changed by a call to 
     snmp_get_sysuptime).
 
   2007-09-09 Frédéric Bernon, Bill Florac
@@ -2975,7 +2985,7 @@ HISTORY
   2007-08-26 Marc Boucher
   * api_msg.c: do_close_internal(): Reset the callbacks and arg (conn) to NULL
     since they can under certain circumstances be called with an invalid conn
-    pointer after the connection has been closed (and conn has been freed).
+    pointer after the connection has been closed (and conn has been freed). 
 
   2007-08-25 Frédéric Bernon (Artem Migaev's Patch)
   * netif.h, netif.c: Integrate "patch #6163 : Function to check if link layer is up".
@@ -2987,11 +2997,11 @@ HISTORY
 
   2007-08-22 Frédéric Bernon
   * tcpip.h, tcpip.c, ethernetif.c, opt.h: remove options ETHARP_TCPIP_INPUT &
-    ETHARP_TCPIP_ETHINPUT, now, only "ethinput" code is supported, even if the
+    ETHARP_TCPIP_ETHINPUT, now, only "ethinput" code is supported, even if the 
     name is tcpip_input (we keep the name of 1.2.0 function).
 
   2007-08-17 Jared Grubb
-  * memp_std.h, memp.h, memp.c, mem.c, stats.c: (Task #7136) Centralize mempool
+  * memp_std.h, memp.h, memp.c, mem.c, stats.c: (Task #7136) Centralize mempool 
     settings into new memp_std.h and optional user file lwippools.h. This adds
     more dynamic mempools, and allows the user to create an arbitrary number of
     mempools for mem_malloc.
@@ -3198,32 +3208,32 @@ HISTORY
     snmp_set_sysname.
 
   2007-03-28 Frédéric Bernon
-  * netif.h, netif.c: A new NETIF_FLAG_ETHARP flag is defined in netif.h, to allow to
+  * netif.h, netif.c: A new NETIF_FLAG_ETHARP flag is defined in netif.h, to allow to 
     initialize a network interface's flag with. It tell this interface is an ethernet
     device, and we can use ARP with it to do a "gratuitous ARP" (RFC 3220 "IP Mobility
     Support for IPv4" section 4.6) when interface is "up" with netif_set_up().
 
   2007-03-26 Frédéric Bernon, Jonathan Larmour
   * opt.h, tcpip.c: New configuration option LWIP_ARP allow to disable ARP init at build
-    time if you only use PPP or SLIP. The default is enable. Note we don't have to call
+    time if you only use PPP or SLIP. The default is enable. Note we don't have to call 
     etharp_init in your port's initilization sequence if you use tcpip.c, because this call
     is done in tcpip_init function.
 
   2007-03-22 Frédéric Bernon
   * stats.h, stats.c, msg_in.c: Stats counters can be change to u32_t if necessary with the
     new option LWIP_STATS_LARGE. If you need this option, define LWIP_STATS_LARGE to 1 in
-    your lwipopts.h. More, unused counters are not defined in the stats structs, and not
+    your lwipopts.h. More, unused counters are not defined in the stats structs, and not 
     display by stats_display(). Note that some options (SYS_STATS and RAW_STATS) are defined
     but never used. Fix msg_in.c with the correct #if test for a stat display.
 
   2007-03-21 Kieran Mansley
-  * netif.c, netif.h: Apply patch#4197 with some changes (originator: rireland@hmgsl.com).
+  * netif.c, netif.h: Apply patch#4197 with some changes (originator: rireland@hmgsl.com). 
     Provides callback on netif up/down state change.
 
   2007-03-11 Frédéric Bernon, Mace Gael, Steve Reynolds
   * sockets.h, sockets.c, api.h, api_lib.c, api_msg.h, api_msg.c, igmp.h, igmp.c,
     ip.c, netif.h, tcpip.c, opt.h:
-    New configuration option LWIP_IGMP to enable IGMP processing. Based on only one
+    New configuration option LWIP_IGMP to enable IGMP processing. Based on only one 
     filter per all network interfaces. Declare a new function in netif to enable to
     control the MAC filter (to reduce lwIP traffic processing).
 
@@ -3246,7 +3256,7 @@ HISTORY
   * snmp_msg.h, msg_in.c: SNMP UDP ports can be configured at compile time.
 
   2007-03-06 Frédéric Bernon
-  * api.h, api_lib.c, sockets.h, sockets.c, tcpip.c, sys.h, sys.c, err.h:
+  * api.h, api_lib.c, sockets.h, sockets.c, tcpip.c, sys.h, sys.c, err.h: 
     Implement SO_RCVTIMEO on UDP sockets/netconn.
 
   2007-02-28 Kieran Mansley (based on patch from Simon Goldschmidt)
@@ -3288,7 +3298,7 @@ HISTORY
   and/or warnings on some systems where mem_size_t and size_t differ.
   * pbuf.c, ppp.c: Fix warnings on some systems with mem_malloc.
 
-  2008-03-04 Kieran Mansley (contributions by others)
+  2008-03-04 Kieran Mansley (contributions by others) 
   * Numerous small compiler error/warning fixes from contributions to
     mailing list after 1.3.0 release candidate made.
 
@@ -3405,7 +3415,7 @@ HISTORY
     type change. Any compiler should cause an error without any changes in
     yours netconn_peer calls (so, it can't be a "silent change"). It also
     reduce a little bit the footprint for socket layer (lwip_getpeername &
-    lwip_getsockname use now a common lwip_getaddrname function since
+    lwip_getsockname use now a common lwip_getaddrname function since 
     netconn_peer & netconn_addr have the same parameters).
 
   2007-09-20 Simon Goldschmidt
@@ -3425,13 +3435,13 @@ HISTORY
     if they are not defined in cc.h, in the same spirit than "lwip/opt.h" for lwipopts.h.
 
   2007-08-30 Frédéric Bernon
-  * igmp.h, igmp.c: Some changes to remove some redundant code, add some traces,
+  * igmp.h, igmp.c: Some changes to remove some redundant code, add some traces, 
     and fix some coding style.
 
   2007-08-28 Frédéric Bernon
   * tcpip.c: Fix TCPIP_MSG_INPKT processing: now, tcpip_input can be used for any
-    kind of packets. These packets are considered like Ethernet packets (payload
-    pointing to ethhdr) if the netif got the NETIF_FLAG_ETHARP flag. Else, packets
+    kind of packets. These packets are considered like Ethernet packets (payload 
+    pointing to ethhdr) if the netif got the NETIF_FLAG_ETHARP flag. Else, packets 
     are considered like IP packets (payload pointing to iphdr).
 
   2007-08-27 Frédéric Bernon
@@ -3529,7 +3539,7 @@ HISTORY
   2007-06-28 Frédéric Bernon
   * netifapi.h, netifapi.c, tcpip.h, tcpip.c: Update code to handle the option
     LWIP_TCPIP_CORE_LOCKING, and do some changes to be coherent with last modifications
-    in api_lib/api_msg (use pointers and not type with table, etc...)
+    in api_lib/api_msg (use pointers and not type with table, etc...) 
 
   2007-06-26 Simon Goldschmidt
   * udp.h: Fixed bug #20259: struct udp_hdr was lacking the packin defines.
@@ -3631,7 +3641,7 @@ HISTORY
 
   2007-05-16 Frédéric Bernon
   * tcpip.c, igmp.h, igmp.c: Fixed bug "#19800 : IGMP: igmp_tick() will not work
-    with NO_SYS=1". Note that igmp_init is always in tcpip_thread (and not in
+    with NO_SYS=1". Note that igmp_init is always in tcpip_thread (and not in 
     tcpip_init) because we have to be sure that network interfaces are already
     added (mac filter is updated only in igmp_init for the moment).
 
@@ -3778,7 +3788,7 @@ HISTORY
 
   2007-03-20 Frédéric Bernon
   * tcpip.c: Initialize tcpip's mbox, and verify if initialized in tcpip_input,
-    tcpip_ethinput, tcpip_callback, tcpip_apimsg, to fix a init problem with
+    tcpip_ethinput, tcpip_callback, tcpip_apimsg, to fix a init problem with 
     network interfaces. Also fix a compiler warning.
 
   2007-03-20 Kieran Mansley
@@ -3870,13 +3880,13 @@ HISTORY
   * rawapi.txt: Fix documentation mismatch with etharp.h about etharp_tmr's call
     interval.
 
-  2007-02-28 Kieran Mansley
+  2007-02-28 Kieran Mansley 
   * pbuf.c: Fix BUG#17645 - ensure pbuf payload pointer is not moved
     outside the region of the pbuf by pbuf_header()
 
-  2007-02-28 Kieran Mansley
+  2007-02-28 Kieran Mansley 
   * sockets.c: Fix BUG#19161 - ensure milliseconds timeout is non-zero
-    when supplied timeout is also non-zero
+    when supplied timeout is also non-zero 
 
 (STABLE-1.2.0)
 
@@ -3960,7 +3970,7 @@ HISTORY
     in accept() by Kevin Lawson.
 
   2006-05-26 Christiaan Simons
-  * api_lib.c: Removed conn->sem creation and destruction
+  * api_lib.c: Removed conn->sem creation and destruction 
     from netconn_write() and added sys_sem_new to netconn_new_*.
 
 (STABLE-1_1_1)
@@ -4030,7 +4040,7 @@ HISTORY
   * dhcp.c: Decline messages were not multicast but unicast.
   * etharp.c: ETHARP_CREATE is renamed to ETHARP_TRY_HARD.
     Do not try hard to insert arbitrary packet's source address,
-    etharp_ip_input() now calls etharp_update() without ETHARP_TRY_HARD.
+    etharp_ip_input() now calls etharp_update() without ETHARP_TRY_HARD. 
     etharp_query() now always DOES call ETHARP_TRY_HARD so that users
     querying an address will see it appear in the cache (DHCP could
     suffer from this when a server invalidly gave an in-use address.)
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 55fc44a1..f05c0f61 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,23 +1,11 @@
-cmake_minimum_required(VERSION 3.10)
-
-set (CMAKE_CONFIGURATION_TYPES "Debug;Release")
+cmake_minimum_required(VERSION 3.7)
 
 project(lwIP)
 
-# Example lwIP application
 set(LWIP_DIR ${CMAKE_CURRENT_SOURCE_DIR})
+include(src/Filelists.cmake)
 
-set (LWIP_DEFINITIONS LWIP_DEBUG=1)
-
-if (${CMAKE_SYSTEM_NAME} STREQUAL "Windows")
-  add_subdirectory(${LWIP_DIR}/contrib/ports/win32/example_app)
-elseif(${CMAKE_SYSTEM_NAME} STREQUAL "Linux" OR ${CMAKE_SYSTEM_NAME} STREQUAL "Darwin")
-  add_subdirectory(${LWIP_DIR}/contrib/ports/unix/example_app)
-else()
-  message(WARNING "Host ${CMAKE_SYSTEM_NAME} is not supported to build example_app")
-endif()
-
-# Source package generation
+# Package generation
 set(CPACK_SOURCE_GENERATOR "ZIP")
 set(CPACK_SOURCE_PACKAGE_DESCRIPTION_SUMMARY "lwIP lightweight IP stack")
 set(CPACK_PACKAGE_VERSION_MAJOR "${LWIP_VERSION_MAJOR}")
@@ -27,9 +15,6 @@ set(CPACK_SOURCE_IGNORE_FILES "/build/;${CPACK_SOURCE_IGNORE_FILES};.git")
 set(CPACK_SOURCE_PACKAGE_FILE_NAME "lwip-${LWIP_VERSION_MAJOR}.${LWIP_VERSION_MINOR}.${LWIP_VERSION_REVISION}")
 include(CPack)
 
-# Generate docs before creating source package
-include(src/Filelists.cmake)
+# Target for package generation
 add_custom_target(dist COMMAND ${CMAKE_MAKE_PROGRAM} package_source)
-if (TARGET lwipdocs)
-  add_dependencies(dist lwipdocs)
-endif()
+add_dependencies(dist lwipdocs)
diff --git a/FEATURES b/FEATURES
index 87802d13..a50c5a5e 100644
--- a/FEATURES
+++ b/FEATURES
@@ -4,7 +4,7 @@ The focus of the lwIP TCP/IP implementation is to reduce resource usage while st
 
 Main features include:
 - Protocols: IP, IPv6, ICMP, ND, MLD, UDP, TCP, IGMP, ARP, PPPoS, PPPoE, 6LowPAN (via IEEE 802.15.4, BLE or ZEP; since v2.1.0)
-- DHCP client, stateless DHCPv6 (since v2.1.0), DNS client (incl. mDNS hostname resolver), AutoIP/APIPA (Zeroconf), ACD (Address Conflict Detection), SNMP agent (v1, v2c, v3 (since v2.1.0), private MIB support & MIB compiler)
+- DHCP client, stateless DHCPv6 (since v2.1.0), DNS client (incl. mDNS hostname resolver), AutoIP/APIPA (Zeroconf), SNMP agent (v1, v2c, v3 (since v2.1.0), private MIB support & MIB compiler)
 - APIs: specialized APIs for enhanced performance & zero copy, optional Berkeley-alike socket API
 - Extended features: IP forwarding over multiple network interfaces
 - Extended TCP features: congestion control, RTT estimation and fast recovery/fast retransmit, sending SACKs (since v2.1.0), "altcp": nearly transparent TLS for any tcp pcb (since v2.1.0)
diff --git a/FILES b/FILES
index 2a7086c1..e6e09989 100644
--- a/FILES
+++ b/FILES
@@ -1,4 +1,3 @@
-contrib/  - lwIP examples, ports, and small apps (formerly http://git.savannah.gnu.org/cgit/lwip/lwip-contrib.git/)
 src/      - The source code for the lwIP TCP/IP stack.
 doc/      - The documentation for lwIP.
 test/     - Some code to test whether the sources do what they should.
diff --git a/README b/README
index f5df8d1c..b95f1552 100644
--- a/README
+++ b/README
@@ -17,13 +17,12 @@ FEATURES
     multiple network interfaces
   * ICMP (Internet Control Message Protocol) for network maintenance and debugging
   * IGMP (Internet Group Management Protocol) for multicast traffic management
-  * MLD (Multicast listener discovery for IPv6). Aims to be compliant with
+  * MLD (Multicast listener discovery for IPv6). Aims to be compliant with 
     RFC 2710. No support for MLDv2
   * ND (Neighbor discovery and stateless address autoconfiguration for IPv6).
     Aims to be compliant with RFC 4861 (Neighbor discovery) and RFC 4862
     (Address autoconfiguration)
-  * DHCP, AutoIP/APIPA (Zeroconf), ACD (Address Conflict Detection)
-    and (stateless) DHCPv6
+  * DHCP, AutoIP/APIPA (Zeroconf) and (stateless) DHCPv6
   * UDP (User Datagram Protocol) including experimental UDP-lite extensions
   * TCP (Transmission Control Protocol) with congestion control, RTT estimation
     fast recovery/fast retransmit and sending SACKs
@@ -78,7 +77,7 @@ Submit patches and bugs via the lwIP project page:
   http://savannah.nongnu.org/projects/lwip/
 
 Continuous integration builds (GCC, clang):
-  https://travis-ci.org/lwip-tcpip/lwip
+  https://travis-ci.org/yarrick/lwip-merged
 
 
 DOCUMENTATION
@@ -87,17 +86,15 @@ Self documentation of the source code is regularly extracted from the current
 Git sources and is available from this web page:
   http://www.nongnu.org/lwip/
 
+There is now a constantly growing wiki about lwIP at
+  http://lwip.wikia.com/wiki/LwIP_Wiki
+
 Also, there are mailing lists you can subscribe at
   http://savannah.nongnu.org/mail/?group=lwip
 plus searchable archives:
   http://lists.nongnu.org/archive/html/lwip-users/
   http://lists.nongnu.org/archive/html/lwip-devel/
 
-There is a wiki about lwIP at
-  http://lwip.wikia.com/wiki/LwIP_Wiki
-You might get questions answered there, but unfortunately, it is not as
-well maintained as it should be.
-
 lwIP was originally written by Adam Dunkels:
   http://dunkels.com/adam/
 
diff --git a/contrib/Coverity/coverity.c b/contrib/Coverity/coverity.c
deleted file mode 100644
index 99bebae9..00000000
--- a/contrib/Coverity/coverity.c
+++ /dev/null
@@ -1,106 +0,0 @@
-typedef unsigned char err_t;
-typedef unsigned int u32_t;
-typedef unsigned short u16_t;
-typedef unsigned char u8_t;
-typedef void sys_sem_t;
-typedef void sys_mutex_t;
-typedef size_t mem_size_t;
-typedef size_t memp_t;
-struct pbuf;
-struct netif;
-
-void* mem_malloc(mem_size_t size)
-{
-  __coverity_alloc__(size);
-}
-void mem_free(void* mem)
-{
-  __coverity_free__(mem);
-}
-
-void* memp_malloc(memp_t type)
-{
-  __coverity_alloc_nosize__();  
-}
-void memp_free(memp_t type, void* mem)
-{
-  __coverity_free__(mem);  
-}
-
-void sys_mutex_lock(sys_mutex_t* mutex)
-{
-  __coverity_exclusive_lock_acquire__(mutex);
-}
-void sys_mutex_unlock(sys_mutex_t* mutex)
-{
-  __coverity_exclusive_lock_release__(mutex);
-}
-
-u32_t sys_arch_sem_wait(sys_sem_t *sem, u32_t timeout)
-{
-  __coverity_recursive_lock_acquire__(sem);
-}
-void sys_sem_signal(sys_sem_t *sem)
-{
-  __coverity_recursive_lock_release__(sem);
-}
-
-err_t ethernet_input(struct pbuf *p, struct netif *inp)
-{
-  __coverity_tainted_string_sink_content__(p); 
-}
-err_t tcpip_input(struct pbuf *p, struct netif *inp)
-{
-  __coverity_tainted_string_sink_content__(p); 
-}
-err_t ip_input(struct pbuf *p, struct netif *inp)
-{
-  __coverity_tainted_string_sink_content__(p); 
-}
-err_t ip4_input(struct pbuf *p, struct netif *inp)
-{
-  __coverity_tainted_string_sink_content__(p); 
-}
-err_t ip6_input(struct pbuf *p, struct netif *inp)
-{
-  __coverity_tainted_string_sink_content__(p); 
-}
-
-err_t pbuf_take(struct pbuf *buf, const void *dataptr, u16_t len)
-{
-  __coverity_tainted_string_argument__(buf);
-  __coverity_tainted_data_argument__(buf);
-}
-err_t pbuf_take_at(struct pbuf *buf, const void *dataptr, u16_t len, u16_t offset)
-{
-  __coverity_tainted_string_argument__(buf);
-  __coverity_tainted_data_argument__(buf);
-}
-err_t pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
-{
-  __coverity_tainted_data_transitive__(p_to, p_from);
-}
-u16_t pbuf_copy_partial(struct pbuf *p, void *dataptr, u16_t len, u16_t offset)
-{
-  __coverity_tainted_string_argument__(dataptr);
-  __coverity_tainted_data_argument__(dataptr);
-}
-u8_t pbuf_get_at(struct pbuf* p, u16_t offset)
-{
-  __coverity_tainted_data_return__();
-}
-
-void abort(void)
-{
-  __coverity_panic__();
-}
-
-int check_path(char* path, size_t size)
-{
-  if (size) {
-    __coverity_tainted_data_sanitize__(path);
-    return 1;
-  } else {
-    return 0;
-  }
-}
diff --git a/contrib/Filelists.cmake b/contrib/Filelists.cmake
deleted file mode 100644
index c603026e..00000000
--- a/contrib/Filelists.cmake
+++ /dev/null
@@ -1,60 +0,0 @@
-# This file is indended to be included in end-user CMakeLists.txt
-# include(/path/to/Filelists.cmake)
-# It assumes the variable LWIP_CONTRIB_DIR is defined pointing to the
-# root path of lwIP/contrib sources.
-#
-# This file is NOT designed (on purpose) to be used as cmake
-# subdir via add_subdirectory()
-# The intention is to provide greater flexibility to users to
-# create their own targets using the *_SRCS variables.
-
-if(NOT ${CMAKE_VERSION} VERSION_LESS "3.10.0")
-    include_guard(GLOBAL)
-endif()
-
-set(lwipcontribexamples_SRCS
-    ${LWIP_CONTRIB_DIR}/examples/httpd/fs_example/fs_example.c
-    ${LWIP_CONTRIB_DIR}/examples/httpd/ssi_example/ssi_example.c
-    ${LWIP_CONTRIB_DIR}/examples/lwiperf/lwiperf_example.c
-    ${LWIP_CONTRIB_DIR}/examples/mdns/mdns_example.c
-    ${LWIP_CONTRIB_DIR}/examples/mqtt/mqtt_example.c
-    ${LWIP_CONTRIB_DIR}/examples/ppp/pppos_example.c
-    ${LWIP_CONTRIB_DIR}/examples/snmp/snmp_private_mib/lwip_prvmib.c
-    ${LWIP_CONTRIB_DIR}/examples/snmp/snmp_v3/snmpv3_dummy.c
-    ${LWIP_CONTRIB_DIR}/examples/snmp/snmp_example.c
-    ${LWIP_CONTRIB_DIR}/examples/sntp/sntp_example.c
-    ${LWIP_CONTRIB_DIR}/examples/tftp/tftp_example.c
-)
-add_library(lwipcontribexamples EXCLUDE_FROM_ALL ${lwipcontribexamples_SRCS})
-target_compile_options(lwipcontribexamples PRIVATE ${LWIP_COMPILER_FLAGS})
-target_compile_definitions(lwipcontribexamples PRIVATE ${LWIP_DEFINITIONS} ${LWIP_MBEDTLS_DEFINITIONS})
-target_include_directories(lwipcontribexamples PRIVATE ${LWIP_INCLUDE_DIRS} ${LWIP_MBEDTLS_INCLUDE_DIRS})
-
-set(lwipcontribapps_SRCS
-    ${LWIP_CONTRIB_DIR}/apps/httpserver/httpserver-netconn.c
-    ${LWIP_CONTRIB_DIR}/apps/chargen/chargen.c
-    ${LWIP_CONTRIB_DIR}/apps/udpecho/udpecho.c
-    ${LWIP_CONTRIB_DIR}/apps/tcpecho/tcpecho.c
-    ${LWIP_CONTRIB_DIR}/apps/shell/shell.c
-    ${LWIP_CONTRIB_DIR}/apps/udpecho_raw/udpecho_raw.c
-    ${LWIP_CONTRIB_DIR}/apps/tcpecho_raw/tcpecho_raw.c
-    ${LWIP_CONTRIB_DIR}/apps/netio/netio.c
-    ${LWIP_CONTRIB_DIR}/apps/ping/ping.c
-    ${LWIP_CONTRIB_DIR}/apps/socket_examples/socket_examples.c
-    ${LWIP_CONTRIB_DIR}/apps/rtp/rtp.c
-)
-add_library(lwipcontribapps EXCLUDE_FROM_ALL ${lwipcontribapps_SRCS})
-target_compile_options(lwipcontribapps PRIVATE ${LWIP_COMPILER_FLAGS})
-target_compile_definitions(lwipcontribapps PRIVATE ${LWIP_DEFINITIONS} ${LWIP_MBEDTLS_DEFINITIONS})
-target_include_directories(lwipcontribapps PRIVATE ${LWIP_INCLUDE_DIRS} ${LWIP_MBEDTLS_INCLUDE_DIRS})
-
-set(lwipcontribaddons_SRCS
-    ${LWIP_CONTRIB_DIR}/addons/tcp_isn/tcp_isn.c
-    ${LWIP_CONTRIB_DIR}/addons/ipv6_static_routing/ip6_route_table.c
-#    ${LWIP_CONTRIB_DIR}/addons/netconn/external_resolve/dnssd.c
-#    ${LWIP_CONTRIB_DIR}/addons/tcp_md5/tcp_md5.c
-)
-add_library(lwipcontribaddons EXCLUDE_FROM_ALL ${lwipcontribaddons_SRCS})
-target_compile_options(lwipcontribaddons PRIVATE ${LWIP_COMPILER_FLAGS})
-target_compile_definitions(lwipcontribaddons PRIVATE ${LWIP_DEFINITIONS} ${LWIP_MBEDTLS_DEFINITIONS})
-target_include_directories(lwipcontribaddons PRIVATE ${LWIP_INCLUDE_DIRS} ${LWIP_MBEDTLS_INCLUDE_DIRS})
diff --git a/contrib/Filelists.mk b/contrib/Filelists.mk
deleted file mode 100644
index e330295f..00000000
--- a/contrib/Filelists.mk
+++ /dev/null
@@ -1,56 +0,0 @@
-#
-# Copyright (c) 2001, 2002 Swedish Institute of Computer Science.
-# All rights reserved. 
-# 
-# Redistribution and use in source and binary forms, with or without modification, 
-# are permitted provided that the following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice,
-#    this list of conditions and the following disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright notice,
-#    this list of conditions and the following disclaimer in the documentation
-#    and/or other materials provided with the distribution.
-# 3. The name of the author may not be used to endorse or promote products
-#    derived from this software without specific prior written permission. 
-#
-# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
-# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
-# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
-# SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
-# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
-# OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
-# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
-# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
-# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# This file is part of the lwIP TCP/IP stack.
-# 
-# Author: Adam Dunkels <adam@sics.se>
-#
-
-# CONTRIBAPPFILES: Contrib Applications.
-CONTRIBAPPFILES=$(CONTRIBDIR)/apps/httpserver/httpserver-netconn.c \
-	$(CONTRIBDIR)/apps/chargen/chargen.c \
-	$(CONTRIBDIR)/apps/udpecho/udpecho.c \
-	$(CONTRIBDIR)/apps/tcpecho/tcpecho.c \
-	$(CONTRIBDIR)/apps/shell/shell.c \
-	$(CONTRIBDIR)/apps/udpecho_raw/udpecho_raw.c \
-	$(CONTRIBDIR)/apps/tcpecho_raw/tcpecho_raw.c \
-	$(CONTRIBDIR)/apps/netio/netio.c \
-	$(CONTRIBDIR)/apps/ping/ping.c \
-	$(CONTRIBDIR)/apps/socket_examples/socket_examples.c \
-	$(CONTRIBDIR)/apps/rtp/rtp.c \
-	$(CONTRIBDIR)/examples/httpd/fs_example/fs_example.c \
-	$(CONTRIBDIR)/examples/httpd/ssi_example/ssi_example.c \
-	$(CONTRIBDIR)/examples/lwiperf/lwiperf_example.c \
-	$(CONTRIBDIR)/examples/mdns/mdns_example.c \
-	$(CONTRIBDIR)/examples/mqtt/mqtt_example.c \
-	$(CONTRIBDIR)/examples/ppp/pppos_example.c \
-	$(CONTRIBDIR)/examples/snmp/snmp_private_mib/lwip_prvmib.c \
-	$(CONTRIBDIR)/examples/snmp/snmp_v3/snmpv3_dummy.c \
-	$(CONTRIBDIR)/examples/snmp/snmp_example.c \
-	$(CONTRIBDIR)/examples/sntp/sntp_example.c \
-	$(CONTRIBDIR)/examples/tftp/tftp_example.c \
-	$(CONTRIBDIR)/addons/tcp_isn/tcp_isn.c \
-	$(CONTRIBDIR)/addons/ipv6_static_routing/ip6_route_table.c
diff --git a/contrib/addons/ipv6_static_routing/README b/contrib/addons/ipv6_static_routing/README
deleted file mode 100644
index 0c3b06cc..00000000
--- a/contrib/addons/ipv6_static_routing/README
+++ /dev/null
@@ -1,43 +0,0 @@
-A simple routing table implementation for addition, deletion and lookup of IPv6 routes. 
-
-APIs are:
-1) s8_t ip6_add_route_entry(struct ip6_prefix *ip6_prefix,
-                            struct netif *netif,
-                            ip6_addr_t *gateway,
-                            s8_t *index);
-
-2) err_t ip6_remove_route_entry(struct ip6_prefix *ip6_prefix);
-
-3) s8_t ip6_find_route_entry(ip6_addr_t *ip6_dest_addr);
-
-4) struct netif *ip6_static_route(ip6_addr_t *src, ip6_addr_t *dest);
-
-5) ip6_addr_t *ip6_get_gateway(struct netif *netif, ip6_addr_t *dest);
-
-6) struct ip6_route_entry *ip6_get_route_table(void);
-
-For route lookup from the table, The LWIP_HOOK_IP6_ROUTE hook in ip6_route(..) of ip6.c
-could be assigned to the ip6_static_route() API of this implementation to return the 
-appropriate netif.
-
--- The application can add routes using the API ip6_add_route_entry(..). 
-   This API adds the ip6 prefix route into the static route table while
-   keeping all entries sorted in decreasing order of prefix length.
-   Subsequently, a linear search down the list can be performed to retrieve a
-   matching route entry for a Longest Prefix Match.
-   The prefix length is expected to be at an 8-bit boundary. While this is 
-   a limitation, it would serve most practical purposes.
-
--- The application can remove routes using the API ip6_remove_route_entry(..).
-
--- The application can find a route entry for a specific address using the 
-   ip6_find_route_entry() function which returns the index of the found entry. 
-   This is used internally by the route lookup function ip6_static_route() API.
-
--- To fetch the gateway IPv6 address for a specific destination IPv6 
-   address and target netif, the application can call ip6_get_gateway(..).
-   This API could be assigned to the LWIP_HOOK_ND6_GET_GW() if a gateway has
-   been added as part of the ip6_add_route_entry().
-
--- To fetch a pointer to the head of the table, the application can call 
-   ip6_get_route_table().
diff --git a/contrib/addons/ipv6_static_routing/ip6_route_table.c b/contrib/addons/ipv6_static_routing/ip6_route_table.c
deleted file mode 100644
index a92dd337..00000000
--- a/contrib/addons/ipv6_static_routing/ip6_route_table.c
+++ /dev/null
@@ -1,248 +0,0 @@
-/**
- * @file
- * IPv6 static route table.
- */
-
-/*
- * Copyright (c) 2015 Nest Labs, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * Author: Pradip De <pradipd@google.com>
- *
- *
- * Please coordinate changes and requests with Pradip De
- * <pradipd@google.com>
- */
-
-#include "lwip/opt.h"
-
-#if LWIP_IPV6  /* don't build if not configured for use in lwipopts.h */
-
-#include "ip6_route_table.h"
-#include "lwip/def.h"
-#include "lwip/mem.h"
-#include "lwip/netif.h"
-#include "lwip/ip6.h"
-#include "lwip/ip6_addr.h"
-#include "lwip/nd6.h"
-#include "lwip/debug.h"
-#include "lwip/stats.h"
-
-#include "string.h"
-
-static struct ip6_route_entry static_route_table[LWIP_IPV6_NUM_ROUTE_ENTRIES];
-
-/**
- * Add the ip6 prefix route and target netif into the static route table while
- * keeping all entries sorted in decreasing order of prefix length.
- * 1. Search from the last entry up to find the correct slot to insert while
- *    moving entries one position down to create room.
- * 2. Insert into empty slot created.
- *
- * Subsequently, a linear search down the list can be performed to retrieve a
- * matching route entry for a Longest Prefix Match.
- *
- * @param ip6_prefix the route prefix entry to add.
- * @param netif pointer to target netif.
- * @param gateway the gateway address to use to send through. Has to be link local.
- * @param idx return value argument of index where route entry was added in table.
- * @return ERR_OK  if addition was successful.
- *         ERR_MEM if table is already full.
- *         ERR_ARG if passed argument is bad or route already exists in table.
- */
-err_t
-ip6_add_route_entry(const struct ip6_prefix *ip6_prefix, struct netif *netif, const ip6_addr_t *gateway, s8_t *idx)
-{
-  s8_t i = -1;
-  err_t retval = ERR_OK;
-
-  if (!ip6_prefix_valid(ip6_prefix->prefix_len) || (netif == NULL)) {
-    retval = ERR_ARG;
-    goto exit;
-  }
-
-  /* Check if an entry already exists with matching prefix; If so, replace it. */
-  for (i = 0; i < LWIP_IPV6_NUM_ROUTE_ENTRIES; i++) {
-    if ((ip6_prefix->prefix_len == static_route_table[i].prefix.prefix_len) &&
-        memcmp(&ip6_prefix->addr, &static_route_table[i].prefix.addr,
-               ip6_prefix->prefix_len / 8) == 0) {
-      /* Prefix matches; replace the netif with the one being added. */
-      goto insert;
-    }
-  }
-
-  /* Check if the table is full */
-  if (static_route_table[LWIP_IPV6_NUM_ROUTE_ENTRIES - 1].netif != NULL) {
-    retval = ERR_MEM;
-    goto exit;
-  }
-
-  /* Shift all entries down the table until slot is found */
-  for (i = LWIP_IPV6_NUM_ROUTE_ENTRIES - 1;
-       i > 0 && (ip6_prefix->prefix_len > static_route_table[i - 1].prefix.prefix_len); i--) {
-    SMEMCPY(&static_route_table[i], &static_route_table[i - 1], sizeof(struct ip6_route_entry));
-  }
-
-insert:
-  /* Insert into the slot selected */
-  SMEMCPY(&static_route_table[i].prefix, ip6_prefix, sizeof(struct ip6_prefix));
-  static_route_table[i].netif = netif;
-
-  /* Add gateway to route table */
-  static_route_table[i].gateway = gateway;
-
-  if (idx != NULL) {
-    *idx = i;
-  }
-
-exit:
-  return retval;
-}
-
-/**
- * Removes the route entry from the static route table.
- *
- * @param ip6_prefix the route prefix entry to delete.
- */
-void
-ip6_remove_route_entry(const struct ip6_prefix *ip6_prefix)
-{
-  int i, pos = -1;
-
-  for (i = 0; i < LWIP_IPV6_NUM_ROUTE_ENTRIES; i++) {
-    /* compare prefix to find position to delete */
-    if (ip6_prefix->prefix_len == static_route_table[i].prefix.prefix_len &&
-        memcmp(&ip6_prefix->addr, &static_route_table[i].prefix.addr,
-               ip6_prefix->prefix_len / 8) == 0) {
-      pos = i;
-      break;
-    }
-  }
-
-  if (pos >= 0) {
-    /* Shift everything beyond pos one slot up */
-    for (i = pos; i < LWIP_IPV6_NUM_ROUTE_ENTRIES - 1; i++) {
-      SMEMCPY(&static_route_table[i], &static_route_table[i+1], sizeof(struct ip6_route_entry));
-      if (static_route_table[i].netif == NULL) {
-        break;
-      }
-    }
-    /* Zero the remaining entries */
-    for (; i < LWIP_IPV6_NUM_ROUTE_ENTRIES; i++) {
-      ip6_addr_set_zero((&static_route_table[i].prefix.addr));
-      static_route_table[i].netif = NULL;
-    }
-  }
-}
-
-/**
- * Finds the appropriate route entry in the static route table corresponding to the given
- * destination IPv6 address. Since the entries in the route table are kept sorted in decreasing
- * order of prefix length, a linear search down the list is performed to retrieve a matching
- * index.
- *
- * @param ip6_dest_addr the destination address to match
- * @return the idx of the found route entry; -1 if not found.
- */
-s8_t
-ip6_find_route_entry(const ip6_addr_t *ip6_dest_addr)
-{
-  s8_t i, idx = -1;
-
-  /* Search prefix in the sorted(decreasing order of prefix length) list */
-  for(i = 0; i < LWIP_IPV6_NUM_ROUTE_ENTRIES; i++) {
-    if (memcmp(ip6_dest_addr, &static_route_table[i].prefix.addr,
-        static_route_table[i].prefix.prefix_len / 8) == 0) {
-      idx = i;
-      break;
-    }
-  }
-
-  return idx;
-}
-
-/**
- * Finds the appropriate network interface for a given IPv6 address from a routing table with
- * static IPv6 routes.
- *
- * @param src the source IPv6 address, if known
- * @param dest the destination IPv6 address for which to find the route
- * @return the netif on which to send to reach dest
- */
-struct netif *
-ip6_static_route(const ip6_addr_t *src, const ip6_addr_t *dest)
-{
-  int i;
-
-  LWIP_UNUSED_ARG(src);
-
-  /* Perform table lookup */
-  i = ip6_find_route_entry(dest);
-
-  if (i >= 0) {
-    return static_route_table[i].netif;
-  } else {
-    return NULL;
-  }
-}
-
-/**
- * Finds the gateway IP6 address for a given destination IPv6 address and target netif
- * from a routing table with static IPv6 routes.
- *
- * @param netif the netif used for sending
- * @param dest the destination IPv6 address
- * @return the ip6 address of the gateway to forward packet to
- */
-const ip6_addr_t *
-ip6_get_gateway(struct netif *netif, const ip6_addr_t *dest)
-{
-  const ip6_addr_t *ret_gw = NULL;
-  const int i = ip6_find_route_entry(dest);
-
-  LWIP_UNUSED_ARG(netif);
-
-  if (i >= 0) {
-    if (static_route_table[i].gateway != NULL) {
-      ret_gw = static_route_table[i].gateway;
-    }
-  }
-
-  return ret_gw;
-}
-
-/**
- * Returns the top of the route table.
- * This should be used for debug printing only.
- *
- * @return the top of the route table.
- */
-const struct ip6_route_entry *
-ip6_get_route_table(void)
-{
-    return static_route_table;
-}
-
-#endif /* LWIP_IPV6 */
diff --git a/contrib/addons/ipv6_static_routing/ip6_route_table.h b/contrib/addons/ipv6_static_routing/ip6_route_table.h
deleted file mode 100644
index 478328e4..00000000
--- a/contrib/addons/ipv6_static_routing/ip6_route_table.h
+++ /dev/null
@@ -1,94 +0,0 @@
-/**
- * @file
- *
- * IPv6 static route table.
- */
-
-/*
- * Copyright (c) 2015 Nest Labs, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * Author: Pradip De <pradipd@google.com>
- *
- *
- * Please coordinate changes and requests with Pradip De
- * <pradipd@google.com>
- */
-
-#ifndef __LWIP_IP6_ROUTE_TABLE_H__
-#define __LWIP_IP6_ROUTE_TABLE_H__
-
-#include "lwip/opt.h"
-
-#if LWIP_IPV6  /* don't build if not configured for use in lwipopts.h */
-
-#include "lwip/ip6_addr.h"
-#include "lwip/err.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-struct netif;
-
-/**
- * LWIP_IPV6_NUM_ROUTES: Number of IPV6 routes that can be kept in the static route table.
- */
-#ifndef LWIP_IPV6_NUM_ROUTE_ENTRIES
-#define LWIP_IPV6_NUM_ROUTE_ENTRIES         (8)
-#endif
-
-#define IP6_MAX_PREFIX_LEN                  (128)
-#define IP6_PREFIX_ALLOWED_GRANULARITY      (8)
-/* Prefix length cannot be greater than 128 bits and needs to be at a byte boundary */
-#define ip6_prefix_valid(prefix_len)        (((prefix_len) <= IP6_MAX_PREFIX_LEN) &&                 \
-                                             (((prefix_len) % IP6_PREFIX_ALLOWED_GRANULARITY) == 0))
-
-struct ip6_prefix {
-  ip6_addr_t addr;
-  u8_t prefix_len; /* prefix length in bits at byte boundaries */
-};
-
-struct ip6_route_entry {
-  struct ip6_prefix prefix;
-  struct netif *netif;
-  const ip6_addr_t *gateway;
-};
-
-err_t ip6_add_route_entry(const struct ip6_prefix *ip6_prefix, struct netif *netif,
-                          const ip6_addr_t *gateway, s8_t *idx);
-void ip6_remove_route_entry(const struct ip6_prefix *ip6_prefix);
-s8_t ip6_find_route_entry(const ip6_addr_t *ip6_dest_addr);
-struct netif *ip6_static_route(const ip6_addr_t *src, const ip6_addr_t *dest);
-const ip6_addr_t *ip6_get_gateway(struct netif *netif, const ip6_addr_t *dest);
-const struct ip6_route_entry *ip6_get_route_table(void);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* LWIP_IPV6 */
-
-#endif /* __LWIP_IP6_ROUTE_TABLE_H__ */
diff --git a/contrib/addons/netconn/external_resolve/dnssd.c b/contrib/addons/netconn/external_resolve/dnssd.c
deleted file mode 100644
index d26743bc..00000000
--- a/contrib/addons/netconn/external_resolve/dnssd.c
+++ /dev/null
@@ -1,164 +0,0 @@
-/**
- * @file
- * DNS-SD APIs used by LWIP_HOOK_NETCONN_EXTERNAL_RESOLVE
- *
- * This implementation assumes the DNS-SD API implementation (most likely provided by
- * mDNSResponder) is implemented in the same process space as LwIP and can directly
- * invoke the callback for DNSServiceGetAddrInfo.  This is the typical deployment in
- * an embedded environment where as a traditional OS requires pumping the callback results
- * through an IPC mechanism (see DNSServiceRefSockFD/DNSServiceProcessResult)
- *
- * @defgroup dnssd DNS-SD
- * @ingroup dns
- */
-
-/*
- * Copyright (c) 2017 Joel Cunningham, Garmin International, Inc. <joel.cunningham@garmin.com>
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Joel Cunningham <joel.cunningham@me.com>
- *
- */
-#include "lwip/opt.h"
-
-#include "lwip/err.h"
-#include "lwip/inet.h"
-#include "lwip/sockets.h"
-#include "lwip/sys.h"
-
-#include "dnssd.h"
-
-/* External headers */
-#include <string.h>
-#include <dns_sd.h>
-
-/* This timeout should allow for multiple queries.
-mDNSResponder has the following query timeline:
-  Query 1: time = 0s
-  Query 2: time = 1s
-  Query 3: time = 4s
-*/
-#define GETADDR_TIMEOUT_MS  5000
-#define LOCAL_DOMAIN        ".local"
-
-/* Only consume .local hosts */
-#ifndef CONSUME_LOCAL_ONLY
-#define CONSUME_LOCAL_ONLY  1
-#endif
-
-struct addr_clbk_msg {
-  sys_sem_t sem;
-  struct sockaddr_storage addr;
-  err_t err;
-};
-
-static void addr_info_callback(DNSServiceRef ref, DNSServiceFlags flags, u32_t interface_index,
-                               DNSServiceErrorType error_code, char const* hostname,
-                               const struct sockaddr* address, u32_t ttl, void* context);
-
-int
-lwip_dnssd_gethostbyname(const char *name, ip_addr_t *addr, u8_t addrtype, err_t *err)
-{
-  DNSServiceErrorType result;
-  DNSServiceRef ref;
-  struct addr_clbk_msg msg;
-  char *p;
-
-  /* @todo: use with IPv6 */
-  LWIP_UNUSED_ARG(addrtype);
-
-#if CONSUME_LOCAL_ONLY
-  /* check if this is a .local host. If it is, then we consume the query */
-  p = strstr(name, LOCAL_DOMAIN);
-  if (p == NULL) {
-    return 0; /* not consumed */
-  }
-  p += (sizeof(LOCAL_DOMAIN) - 1);
-  /* check to make sure .local isn't a substring (only allow .local\0 or .local.\0) */
-  if ((*p != '.' && *p != '\0') ||
-      (*p == '.' && *(p + 1) != '\0')) {
-    return 0; /* not consumed */
-  }
-#endif /* CONSUME_LOCAL_ONLY */
-
-  msg.err = sys_sem_new(&msg.sem, 0);
-  if (msg.err != ERR_OK) {
-    goto query_done;
-  }
-
-  msg.err = ERR_TIMEOUT;
-  result = DNSServiceGetAddrInfo(&ref, 0, 0, kDNSServiceProtocol_IPv4, name, addr_info_callback, &msg);
-  if (result == kDNSServiceErr_NoError) {
-    sys_arch_sem_wait(&msg.sem, GETADDR_TIMEOUT_MS);
-    DNSServiceRefDeallocate(ref);
-
-    /* We got a response */
-    if (msg.err == ERR_OK) {
-      struct sockaddr_in* addr_in = (struct sockaddr_in *)&msg.addr;
-      if (addr_in->sin_family == AF_INET) {
-        inet_addr_to_ip4addr(ip_2_ip4(addr), &addr_in->sin_addr);
-      } else {
-        /* @todo add IPv6 support */
-        msg.err = ERR_VAL;
-      }
-    }
-  }
-  sys_sem_free(&msg.sem);
-
-/* Query has been consumed and is finished */
-query_done:
-*err = msg.err;
-return 1;
-}
-
-static void
-addr_info_callback(DNSServiceRef ref, DNSServiceFlags flags, u32_t interface_index,
-                   DNSServiceErrorType error_code, char const* hostname,
-                   const struct sockaddr* address, u32_t ttl, void* context)
-{
-  struct addr_clbk_msg* msg = (struct addr_clbk_msg*)context;
-  struct sockaddr_in*  addr_in = (struct sockaddr_in *)address;
-
-  LWIP_UNUSED_ARG(ref);
-  LWIP_UNUSED_ARG(flags);
-  LWIP_UNUSED_ARG(interface_index);
-  LWIP_UNUSED_ARG(hostname);
-  LWIP_UNUSED_ARG(ttl);
-  LWIP_UNUSED_ARG(context);
-
-  if ((error_code == kDNSServiceErr_NoError) &&
-      (addr_in->sin_family == AF_INET)) {
-    MEMCPY(&msg->addr, addr_in, sizeof(*addr_in));
-    msg->err = ERR_OK;
-  }
-  else {
-   /* @todo add IPv6 support */
-   msg->err = ERR_VAL;
-  }
-
-  sys_sem_signal(&msg->sem);
-} /* addr_info_callback() */
diff --git a/contrib/addons/netconn/external_resolve/dnssd.h b/contrib/addons/netconn/external_resolve/dnssd.h
deleted file mode 100644
index e2d71d93..00000000
--- a/contrib/addons/netconn/external_resolve/dnssd.h
+++ /dev/null
@@ -1,50 +0,0 @@
-/**
- * @file
- * DNS-SD APIs used by LWIP_HOOK_NETCONN_EXTERNAL_RESOLVE
- *
- * @defgroup dnssd DNS-SD
- * @ingroup dns
- */
-
-/*
- * Copyright (c) 2017 Joel Cunningham, Garmin International, Inc. <joel.cunningham@garmin.com>
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Joel Cunningham <joel.cunningham@me.com>
- *
- */
-#include "lwip/opt.h"
-
-#ifndef LWIP_HDR_DNSSD_H
-#define LWIP_HDR_DNSSD_H
-
-#include "lwip/err.h"
-#include "lwip/ip_addr.h"
-
-int lwip_dnssd_gethostbyname(const char *name, ip_addr_t *addr, u8_t addrtype, err_t *err);
-
-#endif /* LWIP_HDR_DNSSD_H */
diff --git a/contrib/addons/tcp_isn/tcp_isn.c b/contrib/addons/tcp_isn/tcp_isn.c
deleted file mode 100644
index c1614996..00000000
--- a/contrib/addons/tcp_isn/tcp_isn.c
+++ /dev/null
@@ -1,182 +0,0 @@
-/**
- * @file
- *
- * Reference implementation of the TCP ISN algorithm standardized in RFC 6528.
- * Produce TCP Initial Sequence Numbers by combining an MD5-generated hash
- * based on the new TCP connection's identity and a stable secret, with the
- * current time at 4-microsecond granularity.
- *
- * Specifically, the implementation uses MD5 to compute a hash of the input
- * buffer, which contains both the four-tuple of the new TCP connection (local
- * and remote IP address and port), as well as a 16-byte secret to make the
- * results unpredictable to external parties.  The secret must be given at
- * initialization time and should ideally remain the same across system
- * reboots.  To be sure: the spoofing-resistance of the resulting ISN depends
- * mainly on the strength of the supplied secret!
- *
- * The implementation takes 32 bits from the computed hash, and adds to it the
- * current time, in 4-microsecond units.  The current time is computed from a
- * boot time given at initialization, and the current uptime as provided by
- * sys_now().  Thus, it assumes that sys_now() returns a time value that is
- * relative to the boot time, i.e., that it starts at 0 at system boot, and
- * only ever increases monotonically.
- *
- * For efficiency reasons, a single MD5 input buffer is used, and partially
- * filled in at initialization time.  Specifically, of this 64-byte buffer, the
- * first 36 bytes are used for the four-way TCP tuple data, followed by the
- * 16-byte secret, followed by 12-byte zero padding.  The 64-byte size of the
- * buffer should achieve the best performance for the actual MD5 computation.
- *
- * Basic usage:
- *
- * 1. in your lwipopts.h, add the following lines:
- *
- *    #include <lwip/arch.h>
- *    struct ip_addr;
- *    u32_t lwip_hook_tcp_isn(const struct ip_addr *local_ip, u16_t local_port,
- *      const struct ip_addr *remote_ip, u16_t remote_port);
- *   "#define LWIP_HOOK_TCP_ISN lwip_hook_tcp_isn";
- *
- * 2. from your own code, call lwip_init_tcp_isn() at initialization time, with
- *    appropriate parameters.
- */
-
-/*
- * Copyright (c) 2016 The MINIX 3 Project.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * Author: David van Moolenbroek <david@minix3.org>
- */
-
-#include "tcp_isn.h"
-#include "lwip/ip_addr.h"
-#include "lwip/sys.h"
-#include <string.h>
-
-#ifdef LWIP_HOOK_TCP_ISN
-
-/* pull in md5 of ppp? */
-#include "netif/ppp/ppp_opts.h"
-#if !PPP_SUPPORT || (!LWIP_USE_EXTERNAL_POLARSSL && !LWIP_USE_EXTERNAL_MBEDTLS)
-#undef  LWIP_INCLUDED_POLARSSL_MD5
-#define LWIP_INCLUDED_POLARSSL_MD5 1
-#include "netif/ppp/polarssl/md5.h"
-#endif
-
-static u8_t input[64];
-static u32_t base_time;
-
-/**
- * Initialize the TCP ISN module, with the boot time and a secret.
- *
- * @param boot_time Wall clock boot time of the system, in seconds.
- * @param secret_16_bytes A 16-byte secret used to randomize the TCP ISNs.
- */
-void
-lwip_init_tcp_isn(u32_t boot_time, const u8_t *secret_16_bytes)
-{
-  /* Initialize the input buffer with the secret and trailing zeroes. */
-  memset(input, 0, sizeof(input));
-
-  MEMCPY(&input[36], secret_16_bytes, 16);
-
-  /* Save the boot time in 4-us units. Overflow is no problem here. */
-  base_time = boot_time * 250000;
-}
-
-/**
- * Hook to generate an Initial Sequence Number (ISN) for a new TCP connection.
- *
- * @param local_ip The local IP address.
- * @param local_port The local port number, in host-byte order.
- * @param remote_ip The remote IP address.
- * @param remote_port The remote port number, in host-byte order.
- * @return The ISN to use for the new TCP connection.
- */
-u32_t
-lwip_hook_tcp_isn(const ip_addr_t *local_ip, u16_t local_port,
-    const ip_addr_t *remote_ip, u16_t remote_port)
-{
-  md5_context ctx;
-  u8_t output[16];
-  u32_t isn;
-
-#if LWIP_IPV4 && LWIP_IPV6
-  if (IP_IS_V6(local_ip))
-#endif /* LWIP_IPV4 && LWIP_IPV6 */
-#if LWIP_IPV6
-  {
-    const ip6_addr_t *local_ip6, *remote_ip6;
-
-    local_ip6  = ip_2_ip6(local_ip);
-    remote_ip6 = ip_2_ip6(remote_ip);
-
-    SMEMCPY(&input[0],  &local_ip6->addr,  16);
-    SMEMCPY(&input[16], &remote_ip6->addr, 16);
-  }
-#endif /* LWIP_IPV6 */
-#if LWIP_IPV4 && LWIP_IPV6
-  else
-#endif /* LWIP_IPV4 && LWIP_IPV6 */
-#if LWIP_IPV4
-  {
-    const ip4_addr_t *local_ip4, *remote_ip4;
-
-    local_ip4  = ip_2_ip4(local_ip);
-    remote_ip4 = ip_2_ip4(remote_ip);
-
-    /* Represent IPv4 addresses as IPv4-mapped IPv6 addresses, to ensure that
-     * the IPv4 and IPv6 address spaces are completely disjoint. */
-    memset(&input[0], 0, 10);
-    input[10] = 0xff;
-    input[11] = 0xff;
-    SMEMCPY(&input[12], &local_ip4->addr, 4);
-    memset(&input[16], 0, 10);
-    input[26] = 0xff;
-    input[27] = 0xff;
-    SMEMCPY(&input[28], &remote_ip4->addr, 4);
-  }
-#endif /* LWIP_IPV4 */
-
-  input[32] = (u8_t)(local_port >> 8);
-  input[33] = (u8_t)(local_port & 0xff);
-  input[34] = (u8_t)(remote_port >> 8);
-  input[35] = (u8_t)(remote_port & 0xff);
-
-  /* The secret and padding are already filled in. */
-
-  /* Generate the hash, using MD5. */
-  md5_starts(&ctx);
-  md5_update(&ctx, input, sizeof(input));
-  md5_finish(&ctx, output);
-
-  /* Arbitrarily take the first 32 bits from the generated hash. */
-  MEMCPY(&isn, output, sizeof(isn));
-
-  /* Add the current time in 4-microsecond units. */
-  return isn + base_time + sys_now() * 250;
-}
-
-#endif /* LWIP_HOOK_TCP_ISN */
diff --git a/contrib/addons/tcp_isn/tcp_isn.h b/contrib/addons/tcp_isn/tcp_isn.h
deleted file mode 100644
index ebaeca24..00000000
--- a/contrib/addons/tcp_isn/tcp_isn.h
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (c) 2016 The MINIX 3 Project.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * Author: David van Moolenbroek <david@minix3.org>
- */
-
-#ifndef LWIP_HDR_CONTRIB_ADDONS_TCP_ISN_H
-#define LWIP_HDR_CONTRIB_ADDONS_TCP_ISN_H
-
-#include "lwip/opt.h"
-#include "lwip/ip_addr.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-void lwip_init_tcp_isn(u32_t boot_time, const u8_t *secret_16_bytes);
-u32_t lwip_hook_tcp_isn(const ip_addr_t *local_ip, u16_t local_port,
-                        const ip_addr_t *remote_ip, u16_t remote_port);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* LWIP_HDR_CONTRIB_ADDONS_TCP_ISN_H */
diff --git a/contrib/addons/tcp_md5/README b/contrib/addons/tcp_md5/README
deleted file mode 100644
index a6408ca2..00000000
--- a/contrib/addons/tcp_md5/README
+++ /dev/null
@@ -1,27 +0,0 @@
-This folder provides an example implementation of how to add custom tcp header
-options and custom socket options.
-
-It does this by implementing the (seldom used) tcp md5 signature.
-
-To enable it, add an LWIP_HOOK_FILENAME hook file, include tcp_md5.h in it and
-define these hooks:
-
-  #define LWIP_HOOK_TCP_INPACKET_PCB(pcb, hdr, optlen, opt1len, opt2, p) tcp_md5_check_inpacket(pcb, hdr, optlen, opt1len, opt2, p)
-  #define LWIP_HOOK_TCP_OPT_LENGTH_SEGMENT(pcb, internal_len)            tcp_md5_get_additional_option_length(pcb, internal_len)
-  #define LWIP_HOOK_TCP_ADD_TX_OPTIONS(p, hdr, pcb, opts)                tcp_md5_add_tx_options(p, hdr, pcb,  opts)
-  #define LWIP_HOOK_SOCKETS_SETSOCKOPT(s, sock, level, optname, optval, optlen, err) tcp_md5_setsockopt_hook(sock, level, optname, optval, optlen, err)
-
-Then, in your sockets application, enable md5 signature on a socket like this:
-
-  struct tcp_md5sig md5;
-  struct sockaddr_storage addr_remote; /* Initialize this to remote address and port */
-  memcpy(&md5.tcpm_addr, &addr_remote, sizeof(addr_remote));
-  strcpy(md5.tcpm_key, key); /* this is the md5 key per connection */
-  md5.tcpm_keylen = strlen(key);
-  if ((ret = setsockopt(sockfd, IPPROTO_TCP, TCP_MD5SIG, &md5, sizeof(md5))) < 0) {
-    perror("setsockopt TCP_MD5SIG");
-    return;
-  }
-
-After that, your connection (client) or all incoming connections (server) require
-tcp md5 signatures.
diff --git a/contrib/addons/tcp_md5/tcp_md5.c b/contrib/addons/tcp_md5/tcp_md5.c
deleted file mode 100644
index 1e50eb68..00000000
--- a/contrib/addons/tcp_md5/tcp_md5.c
+++ /dev/null
@@ -1,534 +0,0 @@
-/**
- * @file: An implementation of TCP MD5 signatures by using various hooks in
- * lwIP to implement custom tcp options and custom socket options.
- */
-
-/*
- * Copyright (c) 2018 Simon Goldschmidt
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * Author: Simon Goldschmidt <goldsimon@gmx.de>
- */
-
-#include "tcp_md5.h"
-#include "lwip/ip_addr.h"
-#include "lwip/sys.h"
-#include "lwip/prot/tcp.h"
-#include "lwip/priv/tcp_priv.h"
-#include "lwip/sockets.h"
-#include "lwip/priv/sockets_priv.h"
-#include "lwip/api.h"
-#include <string.h>
-
-/* pull in md5 of ppp? */
-#include "netif/ppp/ppp_opts.h"
-#if !PPP_SUPPORT || (!LWIP_USE_EXTERNAL_POLARSSL && !LWIP_USE_EXTERNAL_MBEDTLS)
-#undef  LWIP_INCLUDED_POLARSSL_MD5
-#define LWIP_INCLUDED_POLARSSL_MD5 1
-#include "netif/ppp/polarssl/md5.h"
-#endif
-
-#if !LWIP_TCP_PCB_NUM_EXT_ARGS
-#error tcp_md5 needs LWIP_TCP_PCB_NUM_EXT_ARGS
-#endif
-
-#define LWIP_TCP_OPT_MD5          19 /* number of the md5 option */
-#define LWIP_TCP_OPT_LEN_MD5      18 /* length of the md5 option */
-#define LWIP_TCP_OPT_LEN_MD5_OUT  20 /* 18 + alignment */
-
-#define LWIP_TCP_MD5_DIGEST_LEN   16
-
-/* This keeps the md5 state internally */
-struct tcp_md5_conn_info {
-  struct tcp_md5_conn_info *next;
-  ip_addr_t remote_addr;
-  u16_t remote_port;
-  u8_t key[TCP_MD5SIG_MAXKEYLEN];
-  u16_t key_len;
-};
-
-/* Callback function prototypes: */
-static void tcp_md5_extarg_destroy(u8_t id, void *data);
-static err_t tcp_md5_extarg_passive_open(u8_t id, struct tcp_pcb_listen *lpcb, struct tcp_pcb *cpcb);
-/* Define our tcp ext arg callback structure: */
-const struct tcp_ext_arg_callbacks tcp_md5_ext_arg_callbacks = {
-  tcp_md5_extarg_destroy,
-  tcp_md5_extarg_passive_open
-};
-
-static u8_t tcp_md5_extarg_id = LWIP_TCP_PCB_NUM_EXT_ARG_ID_INVALID;
-static u8_t tcp_md5_opts_buf[40];
-
-/** Initialize this module (allocates a tcp ext arg id) */
-void
-tcp_md5_init(void)
-{
-  tcp_md5_extarg_id = tcp_ext_arg_alloc_id();
-}
-
-/* Create a conn-info structure that holds the md5 state per connection */
-static struct tcp_md5_conn_info *
-tcp_md5_conn_info_alloc(void)
-{
-  return (struct tcp_md5_conn_info *)mem_malloc(sizeof(struct tcp_md5_conn_info));
-}
-
-/* Frees a conn-info structure that holds the md5 state per connection */
-static void
-tcp_md5_conn_info_free(struct tcp_md5_conn_info *info)
-{
-  mem_free(info);
-}
-
-/* A pcb is about to be destroyed. Free its extdata */
-static void
-tcp_md5_extarg_destroy(u8_t id, void *data)
-{
-  struct tcp_md5_conn_info *iter;
-
-  LWIP_ASSERT("tcp_md5_extarg_id != LWIP_TCP_PCB_NUM_EXT_ARG_ID_INVALID",
-    tcp_md5_extarg_id != LWIP_TCP_PCB_NUM_EXT_ARG_ID_INVALID);
-  LWIP_ASSERT("id == tcp_md5_extarg_id", id == tcp_md5_extarg_id);
-  LWIP_UNUSED_ARG(id);
-
-  iter = (struct tcp_md5_conn_info *)data;
-  while (iter != NULL) {
-    struct tcp_md5_conn_info *info = iter;
-    iter = iter->next;
-    tcp_md5_conn_info_free(info);
-  }
-}
-
-/* Try to find an md5 connection info for the specified remote connection */
-static struct tcp_md5_conn_info *
-tcp_md5_get_info(const struct tcp_pcb *pcb, const ip_addr_t *remote_ip, u16_t remote_port)
-{
-  if (pcb != NULL) {
-    struct tcp_md5_conn_info *info = (struct tcp_md5_conn_info *)tcp_ext_arg_get(pcb, tcp_md5_extarg_id);
-    while (info != NULL) {
-      if (ip_addr_cmp(&info->remote_addr, remote_ip)) {
-        if (info->remote_port == remote_port) {
-          return info;
-        }
-      }
-      info = info->next;
-    }
-  }
-  return NULL;
-}
-
-/* Passive open: copy md5 connection info from listen pcb to connection pcb
- * or return error (connection will be closed)
- */
-static err_t
-tcp_md5_extarg_passive_open(u8_t id, struct tcp_pcb_listen *lpcb, struct tcp_pcb *cpcb)
-{
-  struct tcp_md5_conn_info *iter;
-
-  LWIP_ASSERT("lpcb != NULL", lpcb != NULL);
-  LWIP_ASSERT("cpcb != NULL", cpcb != NULL);
-  LWIP_ASSERT("tcp_md5_extarg_id != LWIP_TCP_PCB_NUM_EXT_ARG_ID_INVALID",
-    tcp_md5_extarg_id != LWIP_TCP_PCB_NUM_EXT_ARG_ID_INVALID);
-  LWIP_ASSERT("id == tcp_md5_extarg_id", id == tcp_md5_extarg_id);
-  LWIP_UNUSED_ARG(id);
-
-  iter = (struct tcp_md5_conn_info *)tcp_ext_arg_get((struct tcp_pcb *)lpcb, id);
-  while (iter != NULL) {
-    if (iter->remote_port == cpcb->remote_port) {
-      if (ip_addr_cmp(&iter->remote_addr, &cpcb->remote_ip)) {
-        struct tcp_md5_conn_info *info = tcp_md5_conn_info_alloc();
-        if (info != NULL) {
-          memcpy(info, iter, sizeof(struct tcp_md5_conn_info));
-          tcp_ext_arg_set(cpcb, id, info);
-          tcp_ext_arg_set_callbacks(cpcb, id, &tcp_md5_ext_arg_callbacks);
-          return ERR_OK;
-        } else {
-          return ERR_MEM;
-        }
-      }
-    }
-    iter = iter->next;
-  }
-  /* remote connection not found */
-  return ERR_VAL;
-}
-
-/* Parse tcp header options and return 1 if an md5 signature option was found */
-static int
-tcp_md5_parseopt(const u8_t *opts, u16_t optlen, u8_t *md5_digest_out)
-{
-  u8_t data;
-  u16_t optidx;
-
-  /* Parse the TCP MSS option, if present. */
-  if (optlen != 0) {
-    for (optidx = 0; optidx < optlen; ) {
-      u8_t opt = opts[optidx++];
-      switch (opt) {
-        case LWIP_TCP_OPT_EOL:
-          /* End of options. */
-          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: EOL\n"));
-          return 0;
-        case LWIP_TCP_OPT_NOP:
-          /* NOP option. */
-          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: NOP\n"));
-          break;
-        case LWIP_TCP_OPT_MD5:
-          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MD5\n"));
-          if (opts[optidx++] != LWIP_TCP_OPT_LEN_MD5 || (optidx - 2 + LWIP_TCP_OPT_LEN_MD5) > optlen) {
-            /* Bad length */
-            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
-            return 0;
-          }
-          /* An MD5 option with the right option length. */
-          memcpy(md5_digest_out, &opts[optidx], LWIP_TCP_MD5_DIGEST_LEN);
-          /* no need to process the options further */
-          return 1;
-          break;
-        default:
-          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
-          data = opts[optidx++];
-          if (data < 2) {
-            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
-            /* If the length field is zero, the options are malformed
-               and we don't process them further. */
-            return 0;
-          }
-          /* All other options have a length field, so that we easily
-             can skip past them. */
-          optidx += data - 2;
-      }
-    }
-  }
-  return 0;
-}
-
-/* Get tcp options into contiguous memory. May be required if input pbufs
- * are chained.
- */
-static const u8_t*
-tcp_md5_options_singlebuf(struct tcp_hdr *hdr, u16_t optlen, u16_t opt1len, u8_t *opt2)
-{
-  const u8_t *opts;
-  LWIP_ASSERT("hdr != NULL", hdr != NULL);
-  LWIP_ASSERT("optlen >= opt1len", optlen >= opt1len);
-  opts = (const u8_t *)hdr + TCP_HLEN;
-  if (optlen == opt1len) {
-    /* arleady in one piece */
-    return opts;
-  }
-  if (optlen > sizeof(tcp_md5_opts_buf)) {
-    /* options too long */
-    return NULL;
-  }
-  LWIP_ASSERT("opt2 != NULL", opt2 != NULL);
-  /* copy first part */
-  memcpy(tcp_md5_opts_buf, opts, opt1len);
-  /* copy second part */
-  memcpy(&tcp_md5_opts_buf[opt1len], opt2, optlen - opt1len);
-  return tcp_md5_opts_buf;
-}
-
-/* Create the md5 digest for a given segment */
-static int
-tcp_md5_create_digest(const ip_addr_t *ip_src, const ip_addr_t *ip_dst, const struct tcp_hdr *hdr,
-                      const u8_t *key, size_t key_len, u8_t *digest_out, struct pbuf *p)
-{
-  md5_context ctx;
-  u8_t tmp8;
-  u16_t tmp16;
-  const size_t addr_len = IP_ADDR_RAW_SIZE(*ip_src);
-
-  if (p != NULL) {
-    LWIP_ASSERT("pbuf must not point to tcp header here!", (const void *)hdr != p->payload);
-  }
-
-  /* Generate the hash, using MD5. */
-  md5_starts(&ctx);
-  /* 1. the TCP pseudo-header (in the order: source IP address,
-          destination IP address, zero-padded protocol number, and
-          segment length) */
-  md5_update(&ctx, (const unsigned char*)ip_src, addr_len);
-  md5_update(&ctx, (const unsigned char*)ip_dst, addr_len);
-  tmp8 = 0; /* zero-padded */
-  md5_update(&ctx, &tmp8, 1);
-  tmp8 = IP_PROTO_TCP;
-  md5_update(&ctx, &tmp8, 1);
-  tmp16 = lwip_htons(TCPH_HDRLEN_BYTES(hdr) + (p ? p->tot_len : 0));
-  md5_update(&ctx, (const unsigned char*)&tmp16, 2);
-  /* 2. the TCP header, excluding options, and assuming a checksum of
-          zero */
-  md5_update(&ctx, (const unsigned char*)hdr, sizeof(struct tcp_hdr));
-  /* 3. the TCP segment data (if any) */
-  if ((p != NULL) && (p->tot_len != 0)) {
-    struct pbuf *q;
-    for (q = p; q != NULL; q = q->next) {
-      md5_update(&ctx, (const unsigned char*)q->payload, q->len);
-    }
-  }
-  /* 4. an independently-specified key or password, known to both TCPs
-          and presumably connection-specific */
-  md5_update(&ctx, key, key_len);
-
-  md5_finish(&ctx, digest_out);
-  return 1;
-}
-
-/* Duplicate a tcp header and make sure the fields are in network byte order */
-static void
-tcp_md5_dup_tcphdr(struct tcp_hdr *tcphdr_copy, const struct tcp_hdr *tcphdr_in, int tcphdr_in_is_host_order)
-{
-  memcpy(tcphdr_copy, tcphdr_in, sizeof(struct tcp_hdr));
-  tcphdr_copy->chksum = 0; /* checksum is zero for the pseudo header */
-  if (tcphdr_in_is_host_order) {
-    /* lwIP writes the TCP header values back to the buffer, we need to invert that here: */
-    tcphdr_copy->src = lwip_htons(tcphdr_copy->src);
-    tcphdr_copy->dest = lwip_htons(tcphdr_copy->dest);
-    tcphdr_copy->seqno = lwip_htonl(tcphdr_copy->seqno);
-    tcphdr_copy->ackno = lwip_htonl(tcphdr_copy->ackno);
-    tcphdr_copy->wnd = lwip_htons(tcphdr_copy->wnd);
-    tcphdr_copy->urgp = lwip_htons(tcphdr_copy->urgp);
-  }
-}
-
-/* Check if md5 is enabled on a given pcb */
-static int
-tcp_md5_is_enabled_on_pcb(const struct tcp_pcb *pcb)
-{
-  if (tcp_md5_extarg_id != LWIP_TCP_PCB_NUM_EXT_ARG_ID_INVALID) {
-    struct tcp_md5_conn_info *info = (struct tcp_md5_conn_info *)tcp_ext_arg_get(pcb, tcp_md5_extarg_id);
-    if (info != NULL) {
-      return 1;
-    }
-  }
-  return 0;
-}
-
-/* Check if md5 is enabled on a given listen pcb */
-static int
-tcp_md5_is_enabled_on_lpcb(const struct tcp_pcb_listen *lpcb)
-{
-  /* same as for connection pcbs */
-  return tcp_md5_is_enabled_on_pcb((const struct tcp_pcb *)lpcb);
-}
-
-/* Hook implementation for LWIP_HOOK_TCP_OPT_LENGTH_SEGMENT */
-u8_t
-tcp_md5_get_additional_option_length(const struct tcp_pcb *pcb, u8_t internal_option_length)
-{
-  if ((pcb != NULL) && tcp_md5_is_enabled_on_pcb(pcb)) {
-    u8_t new_option_length = internal_option_length + LWIP_TCP_OPT_LEN_MD5_OUT;
-    LWIP_ASSERT("overflow", new_option_length > internal_option_length);
-    LWIP_ASSERT("options too long", new_option_length <= TCP_MAX_OPTION_BYTES);
-    return new_option_length;
-  }
-  return internal_option_length;
-}
-
-/* Hook implementation for LWIP_HOOK_TCP_INPACKET_PCB when called for listen pcbs */
-static err_t
-tcp_md5_check_listen(struct tcp_pcb_listen* lpcb, struct tcp_hdr *hdr, u16_t optlen, u16_t opt1len, u8_t *opt2)
-{
-  LWIP_ASSERT("lpcb != NULL", lpcb != NULL);
-
-  if (tcp_md5_is_enabled_on_lpcb(lpcb)) {
-    const u8_t *opts;
-    u8_t digest_received[LWIP_TCP_MD5_DIGEST_LEN];
-    u8_t digest_calculated[LWIP_TCP_MD5_DIGEST_LEN];
-    const struct tcp_md5_conn_info *info = tcp_md5_get_info((struct tcp_pcb *)lpcb, ip_current_src_addr(), hdr->src);
-    if (info != NULL) {
-      opts = tcp_md5_options_singlebuf(hdr, optlen, opt1len, opt2);
-      if (opts != NULL) {
-        if (tcp_md5_parseopt(opts, optlen, digest_received)) {
-          struct tcp_hdr tcphdr_copy;
-          tcp_md5_dup_tcphdr(&tcphdr_copy, hdr, 1);
-          if (tcp_md5_create_digest(ip_current_src_addr(), ip_current_dest_addr(), &tcphdr_copy, info->key, info->key_len, digest_calculated, NULL)) {
-            /* everything set up, compare the digests */
-            if (!memcmp(digest_received, digest_calculated, LWIP_TCP_MD5_DIGEST_LEN)) {
-              /* equal */
-              return ERR_OK;
-            }
-            /* not equal */
-          }
-        }
-      }
-    }
-    /* md5 enabled on this pcb but no match or other error -> fail */
-    return ERR_VAL;
-  }
-  return ERR_OK;
-}
-
-/* Hook implementation for LWIP_HOOK_TCP_INPACKET_PCB */
-err_t
-tcp_md5_check_inpacket(struct tcp_pcb* pcb, struct tcp_hdr *hdr, u16_t optlen, u16_t opt1len, u8_t *opt2, struct pbuf *p)
-{
-  LWIP_ASSERT("pcb != NULL", pcb != NULL);
-
-  if (pcb->state == LISTEN) {
-    return tcp_md5_check_listen((struct tcp_pcb_listen *)pcb, hdr, optlen, opt1len, opt2);
-  }
-
-  if (tcp_md5_is_enabled_on_pcb(pcb)) {
-    const struct tcp_md5_conn_info *info = tcp_md5_get_info(pcb, ip_current_src_addr(), hdr->src);
-    if (info != NULL) {
-      const u8_t *opts;
-      u8_t digest_received[LWIP_TCP_MD5_DIGEST_LEN];
-      u8_t digest_calculated[LWIP_TCP_MD5_DIGEST_LEN];
-      opts = tcp_md5_options_singlebuf(hdr, optlen, opt1len, opt2);
-      if (opts != NULL) {
-        if (tcp_md5_parseopt(opts, optlen, digest_received)) {
-          struct tcp_hdr hdr_copy;
-          tcp_md5_dup_tcphdr(&hdr_copy, hdr, 1);
-          if (tcp_md5_create_digest(&pcb->remote_ip, &pcb->local_ip, &hdr_copy, info->key, info->key_len, digest_calculated, p)) {
-            /* everything set up, compare the digests */
-            if (!memcmp(digest_received, digest_calculated, LWIP_TCP_MD5_DIGEST_LEN)) {
-              /* equal */
-              return ERR_OK;
-            }
-            /* not equal */
-          }
-        }
-      }
-    }
-    /* md5 enabled on this pcb but no match or other error -> fail */
-    return ERR_VAL;
-  }
-  return ERR_OK;
-}
-
-/* Hook implementation for LWIP_HOOK_TCP_ADD_TX_OPTIONS */
-u32_t *
-tcp_md5_add_tx_options(struct pbuf *p, struct tcp_hdr *hdr, const struct tcp_pcb *pcb, u32_t *opts)
-{
-  LWIP_ASSERT("p != NULL", p != NULL);
-  LWIP_ASSERT("hdr != NULL", hdr != NULL);
-  LWIP_ASSERT("pcb != NULL", pcb != NULL);
-  LWIP_ASSERT("opts != NULL", opts != NULL);
-
-  if (tcp_md5_is_enabled_on_pcb(pcb)) {
-    u8_t digest_calculated[LWIP_TCP_MD5_DIGEST_LEN];
-    u32_t *opts_ret = opts + 5; /* we use 20 bytes: 2 bytes padding + 18 bytes for this option */
-    u8_t *ptr = (u8_t*)opts;
-
-    const struct tcp_md5_conn_info *info = tcp_md5_get_info(pcb, &pcb->remote_ip, pcb->remote_port);
-    if (info != NULL) {
-      struct tcp_hdr hdr_copy;
-      size_t hdrsize = TCPH_HDRLEN_BYTES(hdr);
-      tcp_md5_dup_tcphdr(&hdr_copy, hdr, 0);
-      /* p->payload points to the tcp header */
-      LWIP_ASSERT("p->payload == hdr", p->payload == hdr);
-      if (!pbuf_remove_header(p, hdrsize)) {
-        u8_t ret;
-        if (!tcp_md5_create_digest(&pcb->local_ip, &pcb->remote_ip, &hdr_copy, info->key, info->key_len, digest_calculated, p)) {
-          info = NULL;
-        }
-        ret = pbuf_add_header_force(p, hdrsize);
-        LWIP_ASSERT("tcp_md5_add_tx_options: pbuf_add_header_force failed", !ret);
-        LWIP_UNUSED_ARG(ret);
-      } else  {
-        LWIP_ASSERT("error", 0);
-      }
-    }
-    if (info == NULL) {
-      /* create an invalid signature by zeroing the digest */
-      memset(&digest_calculated, 0, sizeof(digest_calculated));
-    }
-
-    *ptr++ = LWIP_TCP_OPT_NOP;
-    *ptr++ = LWIP_TCP_OPT_NOP;
-    *ptr++ = LWIP_TCP_OPT_MD5;
-    *ptr++ = LWIP_TCP_OPT_LEN_MD5;
-    memcpy(ptr, digest_calculated, LWIP_TCP_MD5_DIGEST_LEN);
-    ptr += LWIP_TCP_MD5_DIGEST_LEN;
-    LWIP_ASSERT("ptr == opts_ret", ptr == (u8_t *)opts_ret);
-    return opts_ret;
-  }
-  return opts;
-}
-
-/* Hook implementation for LWIP_HOOK_SOCKETS_SETSOCKOPT */
-int
-tcp_md5_setsockopt_hook(struct lwip_sock *sock, int level, int optname, const void *optval, socklen_t optlen, int *err)
-{
-  LWIP_ASSERT("sock != NULL", sock != NULL);
-  LWIP_ASSERT("err != NULL", err != NULL);
-
-  if ((level == IPPROTO_TCP) && (optname == TCP_MD5SIG)) {
-    const struct tcp_md5sig *md5 = (const struct tcp_md5sig*)optval;
-    if ((optval == NULL) || (optlen < sizeof(struct tcp_md5sig))) {
-      *err = EINVAL;
-    } else {
-      if (sock->conn && (NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP) && (sock->conn->pcb.tcp != NULL)) {
-        if (tcp_md5_extarg_id == LWIP_TCP_PCB_NUM_EXT_ARG_ID_INVALID) {
-          /* not initialized */
-          *err = EINVAL;
-        } else {
-          struct tcp_md5_conn_info *info = tcp_md5_conn_info_alloc();
-          if (info == NULL) {
-            *err = ENOMEM;
-          } else {
-            int addr_valid = 0;
-            /* OK, fill and link this request */
-            memcpy(info->key, md5->tcpm_key, TCP_MD5SIG_MAXKEYLEN);
-            info->key_len = md5->tcpm_keylen;
-            memset(&info->remote_addr, 0, sizeof(info->remote_addr));
-            if (md5->tcpm_addr.ss_family == AF_INET) {
-#if LWIP_IPV4
-              const struct sockaddr_in *sin = (const struct sockaddr_in *)&md5->tcpm_addr;
-              memcpy(&info->remote_addr, &sin->sin_addr, sizeof(sin->sin_addr));
-              IP_SET_TYPE_VAL(info->remote_addr, IPADDR_TYPE_V4);
-              info->remote_port = lwip_htons(sin->sin_port);
-              addr_valid = 1;
-#endif /* LWIP_IPV4 */
-            } else if (md5->tcpm_addr.ss_family == AF_INET6) {
-#if LWIP_IPV6
-              const struct sockaddr_in6 *sin6 = (const struct sockaddr_in6 *)&md5->tcpm_addr;
-              memcpy(&info->remote_addr, &sin6->sin6_addr, sizeof(sin6->sin6_addr));
-              IP_SET_TYPE_VAL(info->remote_addr, IPADDR_TYPE_V6);
-              info->remote_port = lwip_htons(sin6->sin6_port);
-              addr_valid = 1;
-#endif /* LWIP_IPV6 */
-            }
-            if (addr_valid) {
-              /* store it */
-              tcp_ext_arg_set_callbacks(sock->conn->pcb.tcp, tcp_md5_extarg_id, &tcp_md5_ext_arg_callbacks);
-              info->next = (struct tcp_md5_conn_info *)tcp_ext_arg_get(sock->conn->pcb.tcp, tcp_md5_extarg_id);
-              tcp_ext_arg_set(sock->conn->pcb.tcp, tcp_md5_extarg_id, info);
-            } else {
-              *err = EINVAL;
-              tcp_md5_conn_info_free(info);
-            }
-          }
-        }
-      } else {
-        /* not a tcp netconn */
-        *err = EINVAL;
-      }
-    }
-    return 1;
-  }
-  return 0;
-}
diff --git a/contrib/addons/tcp_md5/tcp_md5.h b/contrib/addons/tcp_md5/tcp_md5.h
deleted file mode 100644
index e55740a4..00000000
--- a/contrib/addons/tcp_md5/tcp_md5.h
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- * Copyright (c) 2018 Simon Goldschmidt
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * Author: Simon Goldschmidt <goldsimon@gmx.de>
- *
- * To use the hooks in this file, make sure this file is included in LWIP_HOOK_FILENAME
- * and define these hooks:
- *
- * #define LWIP_HOOK_TCP_INPACKET_PCB(pcb, hdr, optlen, opt1len, opt2, p) tcp_md5_check_inpacket(pcb, hdr, optlen, opt1len, opt2, p)
- * #define LWIP_HOOK_TCP_OPT_LENGTH_SEGMENT(pcb, internal_len)            tcp_md5_get_additional_option_length(pcb, internal_len)
- * #define LWIP_HOOK_TCP_ADD_TX_OPTIONS(p, hdr, pcb, opts)                tcp_md5_add_tx_options(p, hdr, pcb,  opts)
- *
- * #define LWIP_HOOK_SOCKETS_SETSOCKOPT(s, sock, level, optname, optval, optlen, err) tcp_md5_setsockopt_hook(sock, level, optname, optval, optlen, err)
- */
-
-#ifndef LWIP_HDR_CONTRIB_ADDONS_TCP_MD5_H
-#define LWIP_HDR_CONTRIB_ADDONS_TCP_MD5_H
-
-#include "lwip/opt.h"
-#include "lwip/ip_addr.h"
-#include "lwip/err.h"
-
-#include "lwip/priv/sockets_priv.h"
-#include "lwip/priv/tcp_priv.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* setsockopt definitions and structs: */
-
-/* This is the optname (for level = IPPROTO_TCP) */
-#ifndef TCP_MD5SIG
-#define TCP_MD5SIG 14
-#endif
-
-#define TCP_MD5SIG_MAXKEYLEN 80
-
-/* This is the optval type */
-struct tcp_md5sig {
-  struct  sockaddr_storage tcpm_addr;
-  u16_t   __tcpm_pad1;
-  u16_t   tcpm_keylen;
-  u32_t   __tcpm_pad2;
-  u8_t    tcpm_key[TCP_MD5SIG_MAXKEYLEN];
-};
-
-/* socket setsockopt hook: */
-int tcp_md5_setsockopt_hook(struct lwip_sock *sock, int level, int optname, const void *optval, u32_t optlen, int *err);
-
-/* Internal hook functions */
-void tcp_md5_init(void);
-err_t tcp_md5_check_inpacket(struct tcp_pcb* pcb, struct tcp_hdr *hdr, u16_t optlen, u16_t opt1len, u8_t *opt2, struct pbuf *p);
-u8_t tcp_md5_get_additional_option_length(const struct tcp_pcb *pcb, u8_t internal_option_length);
-u32_t *tcp_md5_add_tx_options(struct pbuf *p, struct tcp_hdr *hdr, const struct tcp_pcb *pcb, u32_t *opts);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* LWIP_HDR_CONTRIB_ADDONS_TCP_MD5_H */
diff --git a/contrib/apps/LwipMibCompiler/CCodeGeneration/CCodeGeneration.csproj b/contrib/apps/LwipMibCompiler/CCodeGeneration/CCodeGeneration.csproj
deleted file mode 100644
index 06d5075e..00000000
--- a/contrib/apps/LwipMibCompiler/CCodeGeneration/CCodeGeneration.csproj
+++ /dev/null
@@ -1,67 +0,0 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <PropertyGroup>
-    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
-    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
-    <ProductVersion>8.0.30703</ProductVersion>
-    <SchemaVersion>2.0</SchemaVersion>
-    <ProjectGuid>{7DA7C0AB-0982-4BF5-9324-F59A7A08D65B}</ProjectGuid>
-    <OutputType>Library</OutputType>
-    <AppDesignerFolder>Properties</AppDesignerFolder>
-    <RootNamespace>CCodeGeneration</RootNamespace>
-    <AssemblyName>CCodeGeneration</AssemblyName>
-    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
-    <FileAlignment>512</FileAlignment>
-    <TargetFrameworkProfile />
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
-    <DebugSymbols>true</DebugSymbols>
-    <DebugType>full</DebugType>
-    <Optimize>false</Optimize>
-    <OutputPath>bin\Debug\</OutputPath>
-    <DefineConstants>DEBUG;TRACE</DefineConstants>
-    <ErrorReport>prompt</ErrorReport>
-    <WarningLevel>4</WarningLevel>
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
-    <DebugType>pdbonly</DebugType>
-    <Optimize>true</Optimize>
-    <OutputPath>bin\Release\</OutputPath>
-    <DefineConstants>TRACE</DefineConstants>
-    <ErrorReport>prompt</ErrorReport>
-    <WarningLevel>4</WarningLevel>
-  </PropertyGroup>
-  <ItemGroup>
-    <Reference Include="System" />
-  </ItemGroup>
-  <ItemGroup>
-    <Compile Include="CFile.cs" />
-    <Compile Include="Code.cs" />
-    <Compile Include="CodeContainerBase.cs" />
-    <Compile Include="CodeElement.cs" />
-    <Compile Include="Comment.cs" />
-    <Compile Include="EmptyLine.cs" />
-    <Compile Include="Function.cs" />
-    <Compile Include="CGenerator.cs" />
-    <Compile Include="IfThenElse.cs" />
-    <Compile Include="PlainText.cs" />
-    <Compile Include="Switch.cs" />
-    <Compile Include="PP_If.cs" />
-    <Compile Include="PP_Ifdef.cs" />
-    <Compile Include="PP_Include.cs" />
-    <Compile Include="FunctionDeclaration.cs" />
-    <Compile Include="PP_Macro.cs" />
-    <Compile Include="Properties\AssemblyInfo.cs" />
-    <Compile Include="VariableDeclaration.cs" />
-    <Compile Include="VariablePrototype.cs" />
-    <Compile Include="VariableType.cs" />
-  </ItemGroup>
-  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
-  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
-       Other similar extension points exist, see Microsoft.Common.targets.
-  <Target Name="BeforeBuild">
-  </Target>
-  <Target Name="AfterBuild">
-  </Target>
-  -->
-</Project>
\ No newline at end of file
diff --git a/contrib/apps/LwipMibCompiler/CCodeGeneration/CFile.cs b/contrib/apps/LwipMibCompiler/CCodeGeneration/CFile.cs
deleted file mode 100644
index 6f122742..00000000
--- a/contrib/apps/LwipMibCompiler/CCodeGeneration/CFile.cs
+++ /dev/null
@@ -1,54 +0,0 @@
-﻿/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Martin Hentschel <info@cl-soft.de>
- *
- */
-
-using System;
-
-namespace CCodeGeneration
-{
-	public class CFile: CodeContainerBase
-	{
-		public CFile()
-		{
-			base.IncreaseLevel = false;
-		}
-
-		public void Save(CGenerator generator)
-		{
-			if (generator == null)
-			{
-				throw new ArgumentNullException("generator");
-			}
-
-			this.GenerateCode(0, generator);
-		}
-	}
-}
diff --git a/contrib/apps/LwipMibCompiler/CCodeGeneration/CGenerator.cs b/contrib/apps/LwipMibCompiler/CCodeGeneration/CGenerator.cs
deleted file mode 100644
index 4e8dfbc7..00000000
--- a/contrib/apps/LwipMibCompiler/CCodeGeneration/CGenerator.cs
+++ /dev/null
@@ -1,119 +0,0 @@
-﻿/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Martin Hentschel <info@cl-soft.de>
- *
- */
-
-using System;
-using System.IO;
-
-namespace CCodeGeneration
-{
-	public class CGenerator
-	{
-		public TextWriter OutputStream { get; private set; }
-		public string File { get; private set; }
-		public uint IndentCount { get; private set; }
-		public string IndentChar { get; private set; }
-		public string NewLine { get; private set; }
-
-		public CGenerator(System.IO.TextWriter outputStream, string file, uint indentCount, string indentChar, string newLine)
-		{
-			this.OutputStream = outputStream;
-			this.File     = file;
-			this.IndentCount  = indentCount;
-			this.IndentChar   = indentChar;
-			this.NewLine      = newLine;
-		}
-
-		public string FileName
-		{
-			get
-			{
-				if (!String.IsNullOrWhiteSpace(this.File))
-				{
-					return Path.GetFileName(this.File);
-				}
-
-				return null;
-			}
-		}
-
-		public void WriteSequence(string value, uint repetitions)
-		{
-			while (repetitions > 0)
-			{
-				this.OutputStream.Write(value);
-				repetitions--;
-			}
-		}
-
-		public void IndentLine(int level)
-		{
-			while (level > 0)
-			{
-				WriteSequence(this.IndentChar, this.IndentCount);
-				level--;
-			}
-		}
-
-		public void WriteNewLine()
-		{
-			this.OutputStream.Write(this.NewLine);
-		}
-
-		public void WriteMultilineString(string value, int level = 0)
-		{
-			if (String.IsNullOrEmpty(value))
-			{
-				return;
-			}
-
-			// only \n and \r\n are recognized as linebreaks
-			string[] lines = value.Split(new char[] { '\n' }, StringSplitOptions.None);
-
-			for (int l = 0; l < (lines.Length - 1); l++)
-			{
-				if (lines[l].EndsWith("\r"))
-				{
-					this.OutputStream.Write(lines[l].Substring(0, lines[l].Length-1));
-				}
-				else
-				{
-					this.OutputStream.Write(lines[l]);
-				}
-
-				this.WriteNewLine();
-				this.IndentLine(level);
-			}
-
-			this.OutputStream.Write(lines[lines.Length - 1]);
-		}
-	}
-}
diff --git a/contrib/apps/LwipMibCompiler/CCodeGeneration/Code.cs b/contrib/apps/LwipMibCompiler/CCodeGeneration/Code.cs
deleted file mode 100644
index 4834508a..00000000
--- a/contrib/apps/LwipMibCompiler/CCodeGeneration/Code.cs
+++ /dev/null
@@ -1,56 +0,0 @@
-﻿/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Martin Hentschel <info@cl-soft.de>
- *
- */
-
-namespace CCodeGeneration
-{
-	public class Code: CodeElement
-	{
-		public string Code_ { get; set; }
-
-		public Code()
-		{
-		}
-
-		public Code(string code)
-		{
-			this.Code_ = code;
-		}
-
-		public override void GenerateCode(int level, CGenerator generator)
-		{
-			generator.IndentLine(level);
-			generator.WriteMultilineString(this.Code_, level);
-			generator.WriteNewLine();
-		}
-
-	}
-}
diff --git a/contrib/apps/LwipMibCompiler/CCodeGeneration/CodeContainerBase.cs b/contrib/apps/LwipMibCompiler/CCodeGeneration/CodeContainerBase.cs
deleted file mode 100644
index 4327d92d..00000000
--- a/contrib/apps/LwipMibCompiler/CCodeGeneration/CodeContainerBase.cs
+++ /dev/null
@@ -1,139 +0,0 @@
-﻿/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Martin Hentschel <info@cl-soft.de>
- *
- */
-
-using System.Collections.Generic;
-using System;
-
-namespace CCodeGeneration
-{
-	public class CodeContainerBase: CodeElement
-	{
-		private readonly List<CodeElement> declarations = new List<CodeElement>();
-		private readonly List<CodeElement> innerElements = new List<CodeElement>();
-		private bool increaseLevel = true;
-
-		public List<CodeElement> Declarations
-		{
-			get { return this.declarations; }
-		}
-
-		public List<CodeElement> InnerElements
-		{
-			get { return this.innerElements; }
-		}
-
-		protected bool IncreaseLevel
-		{
-			get { return this.increaseLevel; }
-			set { this.increaseLevel = value; }
-		}
-
-		public void AddElements(IList<CodeElement> elements, params CodeElement[] spacerElements)
-		{
-			if (elements != null)
-			{
-				if ((spacerElements == null) || (spacerElements.Length == 0))
-				{
-					this.innerElements.AddRange(elements);
-				}
-				else
-				{
-					bool spacerAdded = false;
-
-					foreach (CodeElement element in elements)
-					{
-						this.innerElements.Add(element);
-						this.innerElements.AddRange(spacerElements);
-						spacerAdded = true;
-					}
-
-					if (spacerAdded)
-					{
-						// remove last spacer again
-						this.innerElements.RemoveRange(this.innerElements.Count - spacerElements.Length, spacerElements.Length);
-					}					
-				}
-			}
-		}
- 
-		public CodeElement AddElement(CodeElement element)
-		{
-			if (element != null)
-			{
-				this.innerElements.Add(element);
-			}
-
-			return element;
-		}
-
-		public Code AddCode(string code)
-		{
-			return this.AddElement(new Code(code)) as Code;
-		}
-
-		public Code AddCodeFormat(string codeFormat, params object[] args)
-		{
-			return this.AddElement(new Code(String.Format(codeFormat, args))) as Code;
-		}
-
-		public CodeElement AddDeclaration(CodeElement declaration)
-		{
-			if (declaration != null)
-			{
-				this.declarations.Add(declaration);
-			}
-
-			return declaration;
-		}
-
-		public override void GenerateCode(int level, CGenerator generator)
-		{
-			if (this.increaseLevel)
-				level++;
-
-			if (this.declarations.Count > 0)
-			{
-				foreach (CodeElement element in this.declarations)
-				{
-					element.GenerateCode(level, generator);
-				}
-
-				EmptyLine.SingleLine.GenerateCode(level, generator);
-			}
-
-			foreach (CodeElement element in this.innerElements)
-			{
-				element.GenerateCode(level, generator);
-			}
-		}
-	}
-}
diff --git a/contrib/apps/LwipMibCompiler/CCodeGeneration/CodeElement.cs b/contrib/apps/LwipMibCompiler/CCodeGeneration/CodeElement.cs
deleted file mode 100644
index 51cf2d24..00000000
--- a/contrib/apps/LwipMibCompiler/CCodeGeneration/CodeElement.cs
+++ /dev/null
@@ -1,41 +0,0 @@
-﻿/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Martin Hentschel <info@cl-soft.de>
- *
- */
-
-namespace CCodeGeneration
-{
-	public class CodeElement
-	{
-		public virtual void GenerateCode(int level, CGenerator generator)
-		{
-		}
-	}
-}
diff --git a/contrib/apps/LwipMibCompiler/CCodeGeneration/Comment.cs b/contrib/apps/LwipMibCompiler/CCodeGeneration/Comment.cs
deleted file mode 100644
index 51779bea..00000000
--- a/contrib/apps/LwipMibCompiler/CCodeGeneration/Comment.cs
+++ /dev/null
@@ -1,75 +0,0 @@
-﻿/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Martin Hentschel <info@cl-soft.de>
- *
- */
-
-namespace CCodeGeneration
-{
-	public class Comment: CodeElement
-	{
-		public const string CommentStart = "/*";
-		public const string CommentEnd = "*/";
-
-		public string Comment_ { get; set; }
-		public bool SingleLine { get; set; }
-
-		public Comment()
-		{
-		}
-
-		public Comment(string comment, bool singleLine = false)
-		{
-			this.Comment_   = comment;
-			this.SingleLine = singleLine;
-		}
-
-		public override void GenerateCode(int level, CGenerator generator)
-		{
-			generator.IndentLine(level);
-			generator.OutputStream.Write(CommentStart);
-
-			if (!this.SingleLine)
-			{
-				generator.WriteNewLine();
-				generator.IndentLine(level);
-				generator.WriteMultilineString(this.Comment_, level);
-				generator.WriteNewLine();
-				generator.IndentLine(level);
-			}
-			else
-			{
-				generator.OutputStream.Write(" " + Comment_ + " ");
-			}
-
-			generator.OutputStream.Write(CommentEnd);
-			generator.WriteNewLine();
-		}
-	}
-}
diff --git a/contrib/apps/LwipMibCompiler/CCodeGeneration/EmptyLine.cs b/contrib/apps/LwipMibCompiler/CCodeGeneration/EmptyLine.cs
deleted file mode 100644
index 604c9477..00000000
--- a/contrib/apps/LwipMibCompiler/CCodeGeneration/EmptyLine.cs
+++ /dev/null
@@ -1,64 +0,0 @@
-﻿/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Martin Hentschel <info@cl-soft.de>
- *
- */
-
-namespace CCodeGeneration
-{
-	public class EmptyLine : CodeElement
-	{
-		public static readonly EmptyLine SingleLine = new EmptyLine();
-		public static readonly EmptyLine TwoLines = new EmptyLine(2);
-		public static readonly EmptyLine ThreeLines = new EmptyLine(3);
-
-		public uint Count { get; set; }
-
-		public EmptyLine()
-		{
-			this.Count = 1;
-		}
-
-		public EmptyLine(uint count)
-		{
-			this.Count = count;
-		}
-
-		public override void GenerateCode(int level, CGenerator generator)
-		{
-			uint c = this.Count;
-
-			while (c > 0)
-			{
-				generator.WriteNewLine();
-				c--;
-			}
-		}
-	}
-}
diff --git a/contrib/apps/LwipMibCompiler/CCodeGeneration/Function.cs b/contrib/apps/LwipMibCompiler/CCodeGeneration/Function.cs
deleted file mode 100644
index d81f6e56..00000000
--- a/contrib/apps/LwipMibCompiler/CCodeGeneration/Function.cs
+++ /dev/null
@@ -1,129 +0,0 @@
-﻿/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Martin Hentschel <info@cl-soft.de>
- *
- */
-
-using System;
-using System.Collections.Generic;
-
-namespace CCodeGeneration
-{
-	public class Function: CodeContainerBase
-	{
-		public string Name { get; set; }
-		public bool IsStatic { get; set; }
-
-		private readonly List<VariableType> parameter = new List<VariableType>();
-		private VariableType returnType = VariableType.Void;
-
-		public Function()
-		{
-		}
-
-		public Function(string name, bool isStatic = false)
-		{
-			this.Name = name;
-			this.IsStatic = isStatic;
-		}
-
-		public List<VariableType> Parameter
-		{
-			get { return this.parameter; }
-		}
-
-		public VariableType ReturnType
-		{
-			get { return this.returnType; }
-			set
-			{
-				if (value == null)
-				{
-					throw new ArgumentNullException("ReturnValue");
-				}
-				this.returnType = value;
-			}
-		}
-
-		public static Function FromDeclaration(FunctionDeclaration decl)
-		{
-			Function result = new Function(decl.Name, decl.IsStatic);
-			result.ReturnType = decl.ReturnType.Clone() as VariableType;
-
-			foreach (VariableType param in decl.Parameter)
-			{
-				result.parameter.Add(param.Clone() as VariableType);
-			}
-
-			return result;
-		}
-
-		public override void GenerateCode(int level, CGenerator generator)
-		{
-			generator.IndentLine(level);
-
-			if (this.IsStatic)
-			{
-				generator.OutputStream.Write("static ");
-			}
-
-			this.returnType.GenerateCode(generator);
-			generator.OutputStream.Write(" " + this.Name + "(");
-
-			if (this.Parameter.Count > 0)
-			{
-				for (int i = 0; i < this.parameter.Count; i++)
-				{
-					this.parameter[i].GenerateCode(generator);
-
-					if (i < (this.parameter.Count - 1))
-					{
-						generator.OutputStream.Write(", ");
-					}
-				}
-			}
-			else
-			{
-				generator.OutputStream.Write("void");
-			}
-
-			generator.OutputStream.Write(")");
-			generator.WriteNewLine();
-			generator.IndentLine(level);
-			generator.OutputStream.Write("{");
-			generator.WriteNewLine();
-
-			base.GenerateCode(level, generator);
-
-			generator.IndentLine(level);
-			generator.OutputStream.Write("}");
-			generator.WriteNewLine();
-		}
-	}
-}
diff --git a/contrib/apps/LwipMibCompiler/CCodeGeneration/FunctionDeclaration.cs b/contrib/apps/LwipMibCompiler/CCodeGeneration/FunctionDeclaration.cs
deleted file mode 100644
index 3bc42888..00000000
--- a/contrib/apps/LwipMibCompiler/CCodeGeneration/FunctionDeclaration.cs
+++ /dev/null
@@ -1,114 +0,0 @@
-﻿/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Martin Hentschel <info@cl-soft.de>
- *
- */
-
-using System;
-using System.Collections.Generic;
-
-namespace CCodeGeneration
-{
-	public class FunctionDeclaration: CodeElement
-	{
-		public string Name { get; set; }
-		public bool IsStatic { get; set; }
-		public bool IsExtern { get; set; }
-
-		private readonly List<VariableType> parameter = new List<VariableType>();
-		private VariableType returnType = VariableType.Void;
-
-		public FunctionDeclaration()
-		{
-		}
-
-		public FunctionDeclaration(string name, bool isStatic = false, bool isExtern = false)
-		{
-			this.Name = name;
-			this.IsStatic = isStatic;
-			this.IsExtern = isExtern;
-		}
-
-		public List<VariableType> Parameter
-		{
-			get { return this.parameter; }
-		}
-
-		public VariableType ReturnType
-		{
-			get { return this.returnType; }
-			set
-			{
-				if (value == null)
-				{
-					throw new ArgumentNullException("ReturnValue");
-				}
-				this.returnType = value;
-			}
-		}
-
-		public override void GenerateCode(int level, CGenerator generator)
-		{
-			generator.IndentLine(level);
-
-			if (this.IsExtern)
-			{
-				generator.OutputStream.Write("extern ");
-			}
-
-			if (this.IsStatic)
-			{
-				generator.OutputStream.Write("static ");
-			}
-
-			this.returnType.GenerateCode(generator);
-			generator.OutputStream.Write(" " + this.Name + "(");
-
-			if (this.Parameter.Count > 0)
-			{
-				for (int i = 0; i < this.parameter.Count; i++)
-				{
-					this.parameter[i].GenerateCode(generator);
-
-					if (i < (this.parameter.Count - 1))
-					{
-						generator.OutputStream.Write(", ");
-					}
-				}
-			}
-			else
-			{
-				generator.OutputStream.Write("void");
-			}
-
-			generator.OutputStream.Write(");");
-			generator.WriteNewLine();
-		}
-	}
-}
diff --git a/contrib/apps/LwipMibCompiler/CCodeGeneration/IfThenElse.cs b/contrib/apps/LwipMibCompiler/CCodeGeneration/IfThenElse.cs
deleted file mode 100644
index c4710225..00000000
--- a/contrib/apps/LwipMibCompiler/CCodeGeneration/IfThenElse.cs
+++ /dev/null
@@ -1,137 +0,0 @@
-﻿/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Martin Hentschel <info@cl-soft.de>
- *
- */
-
-using System;
-using System.Collections.Generic;
-
-namespace CCodeGeneration
-{
-	public class ElseIf : CodeContainerBase
-	{
-		public string Condition { get; set; }
-
-		public ElseIf()
-		{
-		}
-
-		public ElseIf(string condition)
-		{
-			this.Condition = condition;
-		}
-
-		public override void GenerateCode(int level, CGenerator generator)
-		{
-			if (!String.IsNullOrWhiteSpace(this.Condition))
-			{
-				generator.IndentLine(level);
-				generator.OutputStream.Write(String.Format("else if ({0})", this.Condition));
-				generator.WriteNewLine();
-				generator.IndentLine(level);
-				generator.OutputStream.Write("{");
-				generator.WriteNewLine();
-
-				base.GenerateCode(level, generator);
-
-				generator.IndentLine(level);
-				generator.OutputStream.Write("}");
-				generator.WriteNewLine();
-			}
-		}
-	}
-
-	public class IfThenElse: CodeContainerBase
-	{
-		public string Condition { get; set; }
-
-		private List<ElseIf> elseIf = new List<ElseIf>();
-		private CodeContainerBase else_ = new CodeContainerBase();
-
-		public IfThenElse()
-		{
-		}
-
-		public IfThenElse(string condition)
-		{
-			this.Condition = condition;
-		}
-
-		public List<ElseIf> ElseIf
-		{
-			get { return this.elseIf; }
-		}
-
-		public CodeContainerBase Else
-		{
-			get { return this.else_; }
-		}
-
-		public override void GenerateCode(int level, CGenerator generator)
-		{
-			if (!String.IsNullOrWhiteSpace(this.Condition))
-			{
-				generator.IndentLine(level);
-				generator.OutputStream.Write(String.Format("if ({0})", this.Condition));
-				generator.WriteNewLine();
-				generator.IndentLine(level);
-				generator.OutputStream.Write("{");
-				generator.WriteNewLine();
-
-				base.GenerateCode(level, generator);
-
-				generator.IndentLine(level);
-				generator.OutputStream.Write("}");
-				generator.WriteNewLine();
-
-				foreach (ElseIf elif in this.elseIf)
-				{
-					elif.GenerateCode(level, generator);
-				}
-
-				if (this.else_.InnerElements.Count > 0)
-				{
-					generator.IndentLine(level);
-					generator.OutputStream.Write("else");
-					generator.WriteNewLine();
-					generator.IndentLine(level);
-					generator.OutputStream.Write("{");
-					generator.WriteNewLine();
-
-					this.else_.GenerateCode(level, generator);
-
-					generator.IndentLine(level);
-					generator.OutputStream.Write("}");
-					generator.WriteNewLine();
-				}
-			}
-		}
-	}
-}
diff --git a/contrib/apps/LwipMibCompiler/CCodeGeneration/PP_If.cs b/contrib/apps/LwipMibCompiler/CCodeGeneration/PP_If.cs
deleted file mode 100644
index 55682155..00000000
--- a/contrib/apps/LwipMibCompiler/CCodeGeneration/PP_If.cs
+++ /dev/null
@@ -1,67 +0,0 @@
-﻿/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Martin Hentschel <info@cl-soft.de>
- *
- */
-
-using System;
-
-namespace CCodeGeneration
-{
-	public class PP_If: CodeContainerBase
-	{
-		public string Condition { get; set; }
-
-		public PP_If()
-		{
-			base.IncreaseLevel = false;
-		}
-
-		public PP_If(string condition)
-			: this()
-		{
-			this.Condition = condition;
-		}
-
-
-		public override void GenerateCode(int level, CGenerator generator)
-		{
-			if (!String.IsNullOrWhiteSpace(this.Condition))
-			{
-				generator.OutputStream.Write("#if " + this.Condition);
-				generator.WriteNewLine();
-
-				base.GenerateCode(level, generator);
-
-				generator.OutputStream.Write("#endif /* " + this.Condition + " */");
-				generator.WriteNewLine();
-			}
-		}
-	}
-}
diff --git a/contrib/apps/LwipMibCompiler/CCodeGeneration/PP_Ifdef.cs b/contrib/apps/LwipMibCompiler/CCodeGeneration/PP_Ifdef.cs
deleted file mode 100644
index fd4f45af..00000000
--- a/contrib/apps/LwipMibCompiler/CCodeGeneration/PP_Ifdef.cs
+++ /dev/null
@@ -1,76 +0,0 @@
-﻿/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Martin Hentschel <info@cl-soft.de>
- *
- */
-
-using System;
-
-namespace CCodeGeneration
-{
-	public class PP_Ifdef: CodeContainerBase
-	{
-		public string Macro { get; set; }
-		public bool Inverted { get; set; }
-
-		public PP_Ifdef()
-		{
-			base.IncreaseLevel = false;
-		}
-
-		public PP_Ifdef(string macro, bool inverted = false)
-			: this()
-		{
-			this.Macro = macro;
-			this.Inverted = inverted;
-		}
-
-
-		public override void GenerateCode(int level, CGenerator generator)
-		{
-			if (!String.IsNullOrWhiteSpace(this.Macro))
-			{
-				if (this.Inverted)
-				{
-					generator.OutputStream.Write("#ifndef " + this.Macro);
-				}
-				else
-				{
-					generator.OutputStream.Write("#ifdef " + this.Macro);
-				}
-				generator.WriteNewLine();
-
-				base.GenerateCode(level, generator);
-
-				generator.OutputStream.Write("#endif /* " + this.Macro + " */");
-				generator.WriteNewLine();
-			}
-		}
-	}
-}
diff --git a/contrib/apps/LwipMibCompiler/CCodeGeneration/PP_Include.cs b/contrib/apps/LwipMibCompiler/CCodeGeneration/PP_Include.cs
deleted file mode 100644
index 0393d271..00000000
--- a/contrib/apps/LwipMibCompiler/CCodeGeneration/PP_Include.cs
+++ /dev/null
@@ -1,71 +0,0 @@
-﻿/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Martin Hentschel <info@cl-soft.de>
- *
- */
-
-using System;
-
-namespace CCodeGeneration
-{
-	public class PP_Include : CodeElement
-	{
-		public string File { get; set; }
-		public bool IsLocal { get; set; }
-
-		public PP_Include()
-		{
-			this.IsLocal = true;				 
-		}
-
-		public PP_Include(string file, bool isLocal = true)
-		{
-			this.File = file;
-			this.IsLocal = isLocal;
-		}
-
-		public override void GenerateCode(int level, CGenerator generator)
-		{
-			if (!String.IsNullOrWhiteSpace(this.File))
-			{
-				// includes are never indented
-				if (this.IsLocal)
-				{
-					generator.OutputStream.Write("#include \"" + this.File + "\"");
-				}
-				else
-				{
-					generator.OutputStream.Write("#include <" + this.File + ">");
-				}
-
-				generator.WriteNewLine();			
-			}
-		}
-	}
-}
diff --git a/contrib/apps/LwipMibCompiler/CCodeGeneration/PP_Macro.cs b/contrib/apps/LwipMibCompiler/CCodeGeneration/PP_Macro.cs
deleted file mode 100644
index 6f302aa9..00000000
--- a/contrib/apps/LwipMibCompiler/CCodeGeneration/PP_Macro.cs
+++ /dev/null
@@ -1,59 +0,0 @@
-﻿/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Martin Hentschel <info@cl-soft.de>
- *
- */
-
-namespace CCodeGeneration
-{
-	public class PP_Macro: CodeElement
-	{
-		public string Name { get; set; }
-		public string Value { get; set; }
-
-		public PP_Macro()
-		{
-		}
-
-		public PP_Macro(string name, string value)
-		{
-			this.Name  = name;
-			this.Value = value;
-		}
-
-		
-		public override void GenerateCode(int level, CGenerator generator)
-		{
-			// macros are not indented at all
-			generator.OutputStream.Write("#define " + this.Name + " ");
-			generator.WriteMultilineString(this.Value);
-			generator.WriteNewLine();
-		}
-	}
-}
diff --git a/contrib/apps/LwipMibCompiler/CCodeGeneration/PlainText.cs b/contrib/apps/LwipMibCompiler/CCodeGeneration/PlainText.cs
deleted file mode 100644
index d5e076fe..00000000
--- a/contrib/apps/LwipMibCompiler/CCodeGeneration/PlainText.cs
+++ /dev/null
@@ -1,49 +0,0 @@
-﻿/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Martin Hentschel <info@cl-soft.de>
- *
- */
-
-namespace CCodeGeneration
-{
-	public class PlainText : CodeElement
-	{
-		public string Value { get; set; }
-
-		public PlainText(string value)
-		{
-			this.Value = value;
-		}
-
-		public override void GenerateCode(int level, CGenerator generator)
-		{
-			generator.WriteMultilineString(this.Value);
-		}
-	}
-}
diff --git a/contrib/apps/LwipMibCompiler/CCodeGeneration/Properties/AssemblyInfo.cs b/contrib/apps/LwipMibCompiler/CCodeGeneration/Properties/AssemblyInfo.cs
deleted file mode 100644
index 4c716ad3..00000000
--- a/contrib/apps/LwipMibCompiler/CCodeGeneration/Properties/AssemblyInfo.cs
+++ /dev/null
@@ -1,36 +0,0 @@
-﻿using System.Reflection;
-using System.Runtime.CompilerServices;
-using System.Runtime.InteropServices;
-
-// Allgemeine Informationen über eine Assembly werden über die folgenden 
-// Attribute gesteuert. Ändern Sie diese Attributwerte, um die Informationen zu ändern,
-// die mit einer Assembly verknüpft sind.
-[assembly: AssemblyTitle("CCodeGeneration")]
-[assembly: AssemblyDescription("")]
-[assembly: AssemblyConfiguration("")]
-[assembly: AssemblyCompany("")]
-[assembly: AssemblyProduct("CCodeGeneration")]
-[assembly: AssemblyCopyright("Copyright ©  2015")]
-[assembly: AssemblyTrademark("")]
-[assembly: AssemblyCulture("")]
-
-// Durch Festlegen von ComVisible auf "false" werden die Typen in dieser Assembly unsichtbar 
-// für COM-Komponenten. Wenn Sie auf einen Typ in dieser Assembly von 
-// COM zugreifen müssen, legen Sie das ComVisible-Attribut für diesen Typ auf "true" fest.
-[assembly: ComVisible(false)]
-
-// Die folgende GUID bestimmt die ID der Typbibliothek, wenn dieses Projekt für COM verfügbar gemacht wird
-[assembly: Guid("8f07a0fa-86f4-48a0-97c7-f94fc5c3f103")]
-
-// Versionsinformationen für eine Assembly bestehen aus den folgenden vier Werten:
-//
-//      Hauptversion
-//      Nebenversion 
-//      Buildnummer
-//      Revision
-//
-// Sie können alle Werte angeben oder die standardmäßigen Build- und Revisionsnummern 
-// übernehmen, indem Sie "*" eingeben:
-// [assembly: AssemblyVersion("1.0.*")]
-[assembly: AssemblyVersion("1.0.0.0")]
-[assembly: AssemblyFileVersion("1.0.0.0")]
diff --git a/contrib/apps/LwipMibCompiler/CCodeGeneration/Switch.cs b/contrib/apps/LwipMibCompiler/CCodeGeneration/Switch.cs
deleted file mode 100644
index 9166fb89..00000000
--- a/contrib/apps/LwipMibCompiler/CCodeGeneration/Switch.cs
+++ /dev/null
@@ -1,146 +0,0 @@
-﻿/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Martin Hentschel <info@cl-soft.de>
- *
- */
-
-using System;
-using System.Collections.Generic;
-
-namespace CCodeGeneration
-{
-	public class SwitchCase : CodeContainerBase
-	{
-		public string Value { get; set; }
-
-		public SwitchCase()
-		{
-		}
-
-		public SwitchCase(string value)
-		{
-			this.Value = value;
-		}
-
-		public bool IsDefault
-		{
-			get { return (this.Value.ToLowerInvariant() == "default"); }
-		}
-
-		public static SwitchCase GenerateDefault()
-		{
-			return new SwitchCase("default");
-		}
-
-		public override void GenerateCode(int level, CGenerator generator)
-		{
-			if (!String.IsNullOrWhiteSpace(this.Value))
-			{
-				generator.IndentLine(level);
-				if (this.IsDefault)
-				{
-					generator.OutputStream.Write("default:");
-				}
-				else
-				{
-					generator.OutputStream.Write(String.Format("case {0}:", this.Value));
-				}
-				generator.WriteNewLine();
-				generator.IndentLine(level + 1);
-				generator.OutputStream.Write("{");
-				generator.WriteNewLine();
-
-				base.GenerateCode(level + 1, generator);
-
-				generator.IndentLine(level + 1);
-				generator.OutputStream.Write("}");
-				generator.WriteNewLine();
-
-				generator.IndentLine(level + 1);
-				generator.OutputStream.Write("break;");
-				generator.WriteNewLine();
-			}
-		}
-	}
-
-	public class Switch: CodeElement
-	{
-		public string SwitchVar { get; set; }
-
-		private List<SwitchCase> switches = new List<SwitchCase>();
-
-		public Switch()
-		{
-		}
-
-		public Switch(string switchVar)
-		{
-			this.SwitchVar = switchVar;
-		}
-
-		public List<SwitchCase> Switches
-		{
-			get { return this.switches; }
-		}
-
-		public override void GenerateCode(int level, CGenerator generator)
-		{
-			if (!String.IsNullOrWhiteSpace(this.SwitchVar))
-			{
-				generator.IndentLine(level);
-				generator.OutputStream.Write(String.Format("switch ({0})", this.SwitchVar));
-				generator.WriteNewLine();
-				generator.IndentLine(level);
-				generator.OutputStream.Write("{");
-				generator.WriteNewLine();
-
-				SwitchCase defaultCase = null; // generate 'default' always as last case
-				foreach (SwitchCase switchCase in this.switches)
-				{
-					if (switchCase.IsDefault)
-					{
-						defaultCase = switchCase;
-					}
-					else
-					{
-						switchCase.GenerateCode(level + 1, generator);
-					}
-				}
-				if (defaultCase != null)
-				{
-					defaultCase.GenerateCode(level + 1, generator);
-				}
-
-				generator.IndentLine(level);
-				generator.OutputStream.Write("}");
-				generator.WriteNewLine();
-			}
-		}
-	}
-}
diff --git a/contrib/apps/LwipMibCompiler/CCodeGeneration/VariableDeclaration.cs b/contrib/apps/LwipMibCompiler/CCodeGeneration/VariableDeclaration.cs
deleted file mode 100644
index bf2c9026..00000000
--- a/contrib/apps/LwipMibCompiler/CCodeGeneration/VariableDeclaration.cs
+++ /dev/null
@@ -1,82 +0,0 @@
-﻿/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Martin Hentschel <info@cl-soft.de>
- *
- */
-
-using System;
-
-namespace CCodeGeneration
-{
-	public class VariableDeclaration : CodeElement
-	{
-		public VariableType Type { get; set; }
-		public string InitialValue { get; set; }
-		public bool IsStatic { get; set; }
-
-		public VariableDeclaration()
-			: base()
-		{
-		}
-
-		public VariableDeclaration(VariableType type, string initialValue = null, bool isStatic = false) :
-			base()
-		{
-			this.Type         = type;
-			this.InitialValue = initialValue;
-			this.IsStatic     = isStatic;
-		}
-
-		public override void GenerateCode(int level, CGenerator generator)
-		{
-			if (this.Type != null)
-			{
-				generator.IndentLine(level);
-
-				if (this.IsStatic)
-				{
-					generator.OutputStream.Write("static ");
-				}
-
-				// declare the variable
-				this.Type.GenerateCode(generator);
-
-				if (!String.IsNullOrWhiteSpace(this.InitialValue))
-				{
-					// add initialization value
-					generator.OutputStream.Write(" = ");
-					generator.WriteMultilineString(this.InitialValue, level);
-				}
-
-				generator.OutputStream.Write(";");
-				generator.WriteNewLine();
-			}
-		}
-	}
-}
diff --git a/contrib/apps/LwipMibCompiler/CCodeGeneration/VariablePrototype.cs b/contrib/apps/LwipMibCompiler/CCodeGeneration/VariablePrototype.cs
deleted file mode 100644
index 38a41663..00000000
--- a/contrib/apps/LwipMibCompiler/CCodeGeneration/VariablePrototype.cs
+++ /dev/null
@@ -1,73 +0,0 @@
-﻿/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Martin Hentschel <info@cl-soft.de>
- *
- */
-
-namespace CCodeGeneration
-{
-	public class VariablePrototype : CodeElement
-	{
-		public VariableType Type { get; set; }
-
-		public VariablePrototype()
-			: base()
-		{
-		}
-
-		public VariablePrototype(VariableType type) :
-			base()
-		{
-			Type = type;
-		}
-
-		public static VariablePrototype FromVariableDeclaration(VariableDeclaration declaration)
-		{
-			return new VariablePrototype(declaration.Type);
-		}
-
-
-		public override void GenerateCode(int level, CGenerator generator)
-		{
-			if (this.Type != null)
-			{
-				generator.IndentLine(level);
-
-				generator.OutputStream.Write("extern ");
-
-				// declare the variable
-				this.Type.GenerateCode(generator);
-
-				generator.OutputStream.Write(";");
-				generator.WriteNewLine();
-			}
-		}
-
-	}
-}
diff --git a/contrib/apps/LwipMibCompiler/CCodeGeneration/VariableType.cs b/contrib/apps/LwipMibCompiler/CCodeGeneration/VariableType.cs
deleted file mode 100644
index 313abbee..00000000
--- a/contrib/apps/LwipMibCompiler/CCodeGeneration/VariableType.cs
+++ /dev/null
@@ -1,130 +0,0 @@
-﻿/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Martin Hentschel <info@cl-soft.de>
- *
- */
-
-using System;
-using System.Text;
-
-namespace CCodeGeneration
-{
-	public enum ConstType
-	{
-		None,
-		Value,
-		Indirection,
-		Both
-	}
-
-	public class VariableType : ICloneable
-	{
-		public const string VoidString = "void";
-		public static readonly VariableType Void = new VariableType(null, "void");
-
-		public string Name { get; set; }
-		public string Type { get; set; }
-		public string Indirection { get; set; }
-		public ConstType Const { get; set; }
-		public string ArraySpecifier { get; set; }
-
-		public VariableType()
-		{
-		}
-
-		public VariableType(string name, string type, string indirection = null, ConstType const_ = ConstType.None, string arraySpecifier = null)
-		{
-			this.Name           = name;
-			this.Type           = type;
-			this.Indirection    = indirection;
-			this.Const          = const_;
-			this.ArraySpecifier = arraySpecifier;
-		}
-
-		public void GenerateCode(CGenerator generator)
-		{
-			if (!String.IsNullOrWhiteSpace(this.Type))
-			{
-				generator.OutputStream.Write(this.ToString().Trim());
-			}
-		}
-
-		public override string ToString()
-		{
-			if (!String.IsNullOrWhiteSpace(this.Type))
-			{
-				StringBuilder vt = new StringBuilder();
-
-				if ((this.Const == ConstType.Value) || (this.Const == ConstType.Both))
-				{
-					vt.Append("const ");
-				}
-
-				vt.Append(this.Type);
-				vt.Append(" ");
-
-				if (!String.IsNullOrWhiteSpace(this.Indirection))
-				{
-					vt.Append(this.Indirection);
-				}
-
-				if ((this.Const == ConstType.Indirection) || (this.Const == ConstType.Both))
-				{
-					vt.Append("const ");
-				}
-
-				if (!String.IsNullOrWhiteSpace(this.Name))
-				{
-					vt.Append(this.Name);
-				}
-
-				if (this.ArraySpecifier != null)
-				{
-					vt.Append("[");
-					vt.Append(this.ArraySpecifier);
-					vt.Append("]");
-				}
-
-				return vt.ToString().Trim();
-			}
-
-			return base.ToString();
-		}
-
-		#region ICloneable Member
-
-		public object Clone()
-		{
-			// we only have value types as members -> simply use .net base function
-			return this.MemberwiseClone();
-		}
-
-		#endregion
-	}
-}
diff --git a/contrib/apps/LwipMibCompiler/LwipMibCompiler.sln b/contrib/apps/LwipMibCompiler/LwipMibCompiler.sln
deleted file mode 100644
index ee041413..00000000
--- a/contrib/apps/LwipMibCompiler/LwipMibCompiler.sln
+++ /dev/null
@@ -1,47 +0,0 @@
-﻿
-Microsoft Visual Studio Solution File, Format Version 11.00
-# Visual Studio 2010
-Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "LwipMibCompiler", "LwipMibCompiler\LwipMibCompiler.csproj", "{C25D5640-D999-49BD-82E0-A1975296A91E}"
-EndProject
-Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "LwipSnmpCodeGeneration", "LwipSnmpCodeGeneration\LwipSnmpCodeGeneration.csproj", "{AABCAB90-1540-45D4-A159-14831A54E9A3}"
-EndProject
-Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "CCodeGeneration", "CCodeGeneration\CCodeGeneration.csproj", "{7DA7C0AB-0982-4BF5-9324-F59A7A08D65B}"
-EndProject
-Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "SharpSnmpLib.Mib", "SharpSnmpLib\SharpSnmpLib.Mib.csproj", "{CBE20411-5DB7-487D-825D-7694267BB6F5}"
-EndProject
-Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "MibViewer", "MibViewer\MibViewer.csproj", "{86CC0B65-7985-4017-A252-0A7A18DCAEF3}"
-EndProject
-Global
-	GlobalSection(SolutionConfigurationPlatforms) = preSolution
-		Debug|Any CPU = Debug|Any CPU
-		Release|Any CPU = Release|Any CPU
-	EndGlobalSection
-	GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		{7DA7C0AB-0982-4BF5-9324-F59A7A08D65B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-		{7DA7C0AB-0982-4BF5-9324-F59A7A08D65B}.Debug|Any CPU.Build.0 = Debug|Any CPU
-		{7DA7C0AB-0982-4BF5-9324-F59A7A08D65B}.Release|Any CPU.ActiveCfg = Release|Any CPU
-		{7DA7C0AB-0982-4BF5-9324-F59A7A08D65B}.Release|Any CPU.Build.0 = Release|Any CPU
-		{86CC0B65-7985-4017-A252-0A7A18DCAEF3}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-		{86CC0B65-7985-4017-A252-0A7A18DCAEF3}.Debug|Any CPU.Build.0 = Debug|Any CPU
-		{86CC0B65-7985-4017-A252-0A7A18DCAEF3}.Release|Any CPU.ActiveCfg = Release|Any CPU
-		{86CC0B65-7985-4017-A252-0A7A18DCAEF3}.Release|Any CPU.Build.0 = Release|Any CPU
-		{AABCAB90-1540-45D4-A159-14831A54E9A3}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-		{AABCAB90-1540-45D4-A159-14831A54E9A3}.Debug|Any CPU.Build.0 = Debug|Any CPU
-		{AABCAB90-1540-45D4-A159-14831A54E9A3}.Release|Any CPU.ActiveCfg = Release|Any CPU
-		{AABCAB90-1540-45D4-A159-14831A54E9A3}.Release|Any CPU.Build.0 = Release|Any CPU
-		{C25D5640-D999-49BD-82E0-A1975296A91E}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-		{C25D5640-D999-49BD-82E0-A1975296A91E}.Debug|Any CPU.Build.0 = Debug|Any CPU
-		{C25D5640-D999-49BD-82E0-A1975296A91E}.Release|Any CPU.ActiveCfg = Release|Any CPU
-		{C25D5640-D999-49BD-82E0-A1975296A91E}.Release|Any CPU.Build.0 = Release|Any CPU
-		{CBE20411-5DB7-487D-825D-7694267BB6F5}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-		{CBE20411-5DB7-487D-825D-7694267BB6F5}.Debug|Any CPU.Build.0 = Debug|Any CPU
-		{CBE20411-5DB7-487D-825D-7694267BB6F5}.Release|Any CPU.ActiveCfg = Release|Any CPU
-		{CBE20411-5DB7-487D-825D-7694267BB6F5}.Release|Any CPU.Build.0 = Release|Any CPU
-	EndGlobalSection
-	GlobalSection(MonoDevelopProperties) = preSolution
-		StartupItem = LwipMibCompiler\LwipMibCompiler.csproj
-	EndGlobalSection
-	GlobalSection(SolutionProperties) = preSolution
-		HideSolutionNode = FALSE
-	EndGlobalSection
-EndGlobal
diff --git a/contrib/apps/LwipMibCompiler/LwipMibCompiler/LwipMibCompiler.csproj b/contrib/apps/LwipMibCompiler/LwipMibCompiler/LwipMibCompiler.csproj
deleted file mode 100644
index 694263aa..00000000
--- a/contrib/apps/LwipMibCompiler/LwipMibCompiler/LwipMibCompiler.csproj
+++ /dev/null
@@ -1,73 +0,0 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <PropertyGroup>
-    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
-    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
-    <ProductVersion>8.0.30703</ProductVersion>
-    <SchemaVersion>2.0</SchemaVersion>
-    <ProjectGuid>{C25D5640-D999-49BD-82E0-A1975296A91E}</ProjectGuid>
-    <OutputType>Exe</OutputType>
-    <AppDesignerFolder>Properties</AppDesignerFolder>
-    <RootNamespace>LwipMibCompiler</RootNamespace>
-    <AssemblyName>LwipMibCompiler</AssemblyName>
-    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
-    <FileAlignment>512</FileAlignment>
-    <TargetFrameworkProfile />
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|AnyCPU'">
-    <DebugSymbols>true</DebugSymbols>
-    <OutputPath>bin\Debug\</OutputPath>
-    <DefineConstants>DEBUG;TRACE</DefineConstants>
-    <DebugType>full</DebugType>
-    <PlatformTarget>AnyCPU</PlatformTarget>
-    <ErrorReport>prompt</ErrorReport>
-    <CodeAnalysisIgnoreBuiltInRuleSets>false</CodeAnalysisIgnoreBuiltInRuleSets>
-    <CodeAnalysisIgnoreBuiltInRules>false</CodeAnalysisIgnoreBuiltInRules>
-    <WarningLevel>4</WarningLevel>
-    <Optimize>false</Optimize>
-    <UseVSHostingProcess>false</UseVSHostingProcess>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|AnyCPU'">
-    <OutputPath>bin\Release\</OutputPath>
-    <DefineConstants>TRACE</DefineConstants>
-    <Optimize>true</Optimize>
-    <DebugType>pdbonly</DebugType>
-    <PlatformTarget>AnyCPU</PlatformTarget>
-    <ErrorReport>prompt</ErrorReport>
-    <WarningLevel>4</WarningLevel>
-    <UseVSHostingProcess>false</UseVSHostingProcess>
-  </PropertyGroup>
-  <ItemGroup>
-    <Reference Include="System" />
-  </ItemGroup>
-  <ItemGroup>
-    <Compile Include="Program.cs" />
-    <Compile Include="Properties\AssemblyInfo.cs" />
-  </ItemGroup>
-  <ItemGroup>
-    <None Include="app.config" />
-  </ItemGroup>
-  <ItemGroup>
-    <ProjectReference Include="..\CCodeGeneration\CCodeGeneration.csproj">
-      <Project>{7DA7C0AB-0982-4BF5-9324-F59A7A08D65B}</Project>
-      <Name>CCodeGeneration</Name>
-    </ProjectReference>
-    <ProjectReference Include="..\LwipSnmpCodeGeneration\LwipSnmpCodeGeneration.csproj">
-      <Project>{AABCAB90-1540-45D4-A159-14831A54E9A3}</Project>
-      <Name>LwipSnmpCodeGeneration</Name>
-    </ProjectReference>
-    <ProjectReference Include="..\SharpSnmpLib\SharpSnmpLib.Mib.csproj">
-      <Project>{CBE20411-5DB7-487D-825D-7694267BB6F5}</Project>
-      <Name>SharpSnmpLib.Mib</Name>
-    </ProjectReference>
-  </ItemGroup>
-  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
-  <PropertyGroup />
-  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
-       Other similar extension points exist, see Microsoft.Common.targets.
-  <Target Name="BeforeBuild">
-  </Target>
-  <Target Name="AfterBuild">
-  </Target>
-  -->
-</Project>
\ No newline at end of file
diff --git a/contrib/apps/LwipMibCompiler/LwipMibCompiler/Program.cs b/contrib/apps/LwipMibCompiler/LwipMibCompiler/Program.cs
deleted file mode 100644
index a00d74b1..00000000
--- a/contrib/apps/LwipMibCompiler/LwipMibCompiler/Program.cs
+++ /dev/null
@@ -1,480 +0,0 @@
-﻿/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Martin Hentschel <info@cl-soft.de>
- *
- */
-
-using System;
-using System.Collections.Generic;
-using System.IO;
-using System.Reflection;
-using System.Text.RegularExpressions;
-using CCodeGeneration;
-using Lextm.SharpSnmpLib.Mib;
-using Lextm.SharpSnmpLib.Mib.Elements.Entities;
-using Lextm.SharpSnmpLib.Mib.Elements.Types;
-using LwipSnmpCodeGeneration;
-
-namespace LwipMibCompiler
-{
-	class Program
-	{
-		private static readonly Regex _alphaNumericRegex = new Regex("[^a-zA-Z0-9]");
-
-		static void Main(string[] args)
-		{
-			Console.WriteLine("lwIP MIB Compiler");
-			Console.WriteLine("");
-
-			// check args
-			if ((args.Length < 2) || String.IsNullOrWhiteSpace(args[0]) || String.IsNullOrWhiteSpace(args[1]))
-			{
-				PrintUsage();
-				return;
-			}
-
-			string mibFile = args[0];
-			if (!File.Exists(mibFile))
-			{
-				Console.WriteLine(String.Format("Unable to find file '{0}'!", mibFile));
-			}
-
-			string destFile = args[1];
-			string destHeaderFile;
-
-			if (Directory.Exists(destFile))
-			{
-				// only directory passed -> create dest filename from mib filename
-				string mibFileName = Path.GetFileNameWithoutExtension(mibFile).ToLowerInvariant();
-				destFile = Path.Combine(destFile, mibFileName + ".c");
-			}
-			
-			string destFileExt = Path.GetExtension(destFile);
-			if (!String.IsNullOrEmpty(destFileExt))
-			{
-				destHeaderFile = destFile.Substring(0, destFile.Length - destFileExt.Length);
-			}
-			else
-			{
-				destHeaderFile = destFile;
-			}
-			destHeaderFile += ".h";
-
-			for (int i=2; i<args.Length; i++)
-			{
-				if (!String.IsNullOrWhiteSpace(args[i]) && Directory.Exists(args[i]))
-				{
-					MibTypesResolver.RegisterResolver(new FileSystemMibResolver(args[i], true));
-				}
-			}
-
-			
-			// read and resolve MIB
-			Console.WriteLine(" Reading MIB file...");
-			
-			MibDocument md = new MibDocument(mibFile);
-			MibTypesResolver.ResolveTypes(md.Modules[0]);
-			MibTree mt = new MibTree(md.Modules[0] as MibModule);
-
-			if (mt.Root.Count == 0)
-			{
-				Console.WriteLine("No root element found inside MIB!");
-				return;
-			}
-
-			MibCFile generatedFile = new MibCFile();
-			MibHeaderFile generatedHeaderFile = new MibHeaderFile();
-
-			foreach (MibTreeNode mibTreeNode in mt.Root)
-			{
-				// create LWIP object tree from MIB structure
-				Console.WriteLine(" Creating lwIP object tree " + mibTreeNode.Entity.Name);
-
-				SnmpMib snmpMib = new SnmpMib();
-				snmpMib.Oid = mibTreeNode.Entity.Value;
-				snmpMib.BaseOid = MibTypesResolver.ResolveOid(mibTreeNode.Entity).GetOidValues();
-				snmpMib.Name = mibTreeNode.Entity.Name;
-
-				ProcessMibTreeNode(mibTreeNode, snmpMib);
-
-				// let the tree transform itself depending on node structure
-				snmpMib.Analyze();
-
-				if (snmpMib.ChildNodes.Count != 0)
-				{
-					// generate code from LWIP object tree
-					Console.WriteLine(" Generating code " + snmpMib.Name);
-					snmpMib.Generate(generatedFile, generatedHeaderFile);
-				}
-			}
-
-			string preservedCode = MibCFile.GetPreservedCode(destFile);
-			if (!string.IsNullOrEmpty(preservedCode))
-			{
-				generatedFile.PreservedCode.Add(new PlainText(preservedCode));
-			}
-			else
-			{
-				generatedFile.PreservedCode.AddRange(generatedFile.Implementation);
-			}
-			generatedFile.Implementation.Clear();
-
-
-			using (StreamWriter fileWriter = new StreamWriter(destHeaderFile))
-			{
-				CGenerator cGenerator = new CGenerator(fileWriter, destHeaderFile, 3, " ", Environment.NewLine);
-				generatedHeaderFile.Save(cGenerator);
-			}
-			using (StreamWriter fileWriter = new StreamWriter(destFile))
-			{
-				CGenerator cGenerator = new CGenerator(fileWriter, destFile, 3, " ", Environment.NewLine);
-				generatedFile.Save(cGenerator);
-			}
-
-			Console.WriteLine(" Done");
-		}
-
-		private static void PrintUsage()
-		{
-			string codeBase = Assembly.GetExecutingAssembly().CodeBase;
-			string appName = Path.GetFileName(codeBase);
-
-			Console.WriteLine("Usage:");
-			Console.WriteLine(String.Format("  {0} <source MIB file> <dest C file> [<search path 1 for referred MIB's> <search path 2 for referred MIB's> ...]", appName));
-			Console.WriteLine("");
-			Console.WriteLine("    <source MIB file>");
-			Console.WriteLine("      Path and filename of MIB file to convert.");
-			Console.WriteLine("");
-			Console.WriteLine("    <dest C file>");
-			Console.WriteLine("      Destination path and file. If a path is passed only, filename is auto");
-			Console.WriteLine("      generated from MIB file name.");
-			Console.WriteLine("");
-			Console.WriteLine("    <search path X for referred MIB's>");
-			Console.WriteLine("      It's important to provide all referred MIB's in order to correctly ");
-			Console.WriteLine("      resolve all used types.");
-			Console.WriteLine("");
-		}
-
-
-		#region Generation of LWIP Object Tree
-
-		private static void ProcessMibTreeNode(MibTreeNode mibTreeNode, SnmpTreeNode assignedSnmpNode)
-		{
-			foreach (MibTreeNode mtn in mibTreeNode.ChildNodes)
-			{
-				// in theory container nodes may also be scalars or tables at the same time (for now only process real containers)
-				if (mtn.NodeType == MibTreeNodeType.Container)
-				{
-					SnmpTreeNode snmpTreeNode = GenerateSnmpTreeNode(mtn, assignedSnmpNode);
-					assignedSnmpNode.ChildNodes.Add(snmpTreeNode);
-
-					ProcessMibTreeNode(mtn, snmpTreeNode);
-				}
-				else if ((mtn.NodeType & MibTreeNodeType.Scalar) != 0)
-				{
-					SnmpScalarNode snmpScalarNode = GenerateSnmpScalarNode(mtn, assignedSnmpNode);
-					if (snmpScalarNode != null)
-					{
-						assignedSnmpNode.ChildNodes.Add(snmpScalarNode);
-					}
-				}
-				else if ((mtn.NodeType & MibTreeNodeType.Table) != 0)
-				{
-					SnmpTableNode snmpTableNode = GenerateSnmpTableNode(mtn, assignedSnmpNode);
-					if (snmpTableNode != null)
-					{
-						assignedSnmpNode.ChildNodes.Add(snmpTableNode);
-					}
-				}
-			}
-		}
-
-		private static SnmpTreeNode GenerateSnmpTreeNode(MibTreeNode mibTreeNode, SnmpTreeNode parentNode)
-		{
-			SnmpTreeNode result = new SnmpTreeNode(parentNode);
-			result.Name    = _alphaNumericRegex.Replace (mibTreeNode.Entity.Name, "");
-			result.Oid     = mibTreeNode.Entity.Value;
-			result.FullOid = MibTypesResolver.ResolveOid(mibTreeNode.Entity).GetOidString();
-
-			return result;
-		}
-
-		private static SnmpScalarNode GenerateSnmpScalarNode(MibTreeNode mibTreeNode, SnmpTreeNode parentNode, bool ignoreAccessibleFlag = false)
-		{
-			ObjectType ote = mibTreeNode.Entity as ObjectType;
-			if (ote != null)
-			{
-				return GenerateSnmpScalarNode(ote, parentNode, ignoreAccessibleFlag);
-			}
-
-			return null;
-		}
-
-		private static SnmpScalarNode GenerateSnmpScalarNode(ObjectType ote, SnmpTreeNode parentNode, bool ignoreAccessibleFlag = false)
-		{
-			SnmpScalarNode result;
-
-			ITypeAssignment mibType = ote.BaseType;
-			IntegerType it = (mibType as IntegerType);
-			if (it != null)
-			{
-				if (ote.ReferredType.Name == Symbol.TruthValue.ToString())
-				{
-					result = new SnmpScalarNodeTruthValue(parentNode);
-				}
-				else if ((it.Type == IntegerType.Types.Integer) || (it.Type == IntegerType.Types.Integer32))
-				{
-					result = new SnmpScalarNodeInt(parentNode);
-				}
-				else
-				{
-					Console.WriteLine(String.Format("Unsupported IntegerType '{0}'!", it.Type));
-					return null;
-				}
-				if (it.IsEnumeration)
-				{
-					result.Restrictions.AddRange(CreateRestrictions(it.Enumeration));
-				}
-				else
-				{
-					result.Restrictions.AddRange(CreateRestrictions(it.Ranges));
-				}
-			}
-			else
-			{
-				UnsignedType ut = (mibType as UnsignedType);
-				if (ut != null)
-				{
-					if ((ut.Type == UnsignedType.Types.Unsigned32) ||
-							  (ut.Type == UnsignedType.Types.Gauge32))
-					{
-						result = new SnmpScalarNodeUint(SnmpDataType.Gauge, parentNode);
-					}
-					else if (ut.Type == UnsignedType.Types.Counter32)
-					{
-						result = new SnmpScalarNodeUint(SnmpDataType.Counter, parentNode);
-					}
-					else if (ut.Type == UnsignedType.Types.TimeTicks)
-					{
-						result = new SnmpScalarNodeUint(SnmpDataType.TimeTicks, parentNode);
-					}
-					else if (ut.Type == UnsignedType.Types.Counter64)
-					{
-						result = new SnmpScalarNodeCounter64(parentNode);
-						if ((ut.Ranges != null) && (ut.Ranges.Count > 0))
-						{
-							Console.WriteLine(String.Format("Generation of ranges is not supported for Counter64 type!"));
-							return null;
-						}
-					}
-					else
-					{
-						Console.WriteLine(String.Format("Unsupported UnsignedType '{0}'!", ut.Type));
-						return null;
-					}
-					result.Restrictions.AddRange(CreateRestrictions(ut.Ranges));
-				}
-				else if (mibType is IpAddressType)
-				{
-					result = new SnmpScalarNodeOctetString(SnmpDataType.IpAddress, parentNode);
-					result.Restrictions.AddRange(CreateRestrictions((mibType as OctetStringType).Size));
-				}
-				else if (mibType is OpaqueType)
-				{
-					result = new SnmpScalarNodeOctetString(SnmpDataType.Opaque, parentNode);
-					result.Restrictions.AddRange(CreateRestrictions((mibType as OctetStringType).Size));
-				}
-				else if (mibType is OctetStringType)
-				{
-					result = new SnmpScalarNodeOctetString(SnmpDataType.OctetString, parentNode);
-					result.Restrictions.AddRange(CreateRestrictions((mibType as OctetStringType).Size));
-				}
-				else if (mibType is ObjectIdentifierType)
-				{
-					result = new SnmpScalarNodeObjectIdentifier(parentNode);
-				}
-				else if (mibType is BitsType)
-				{
-					result = new SnmpScalarNodeBits(parentNode, (uint)((mibType as BitsType).Map.GetHighestValue() + 1));
-					result.Restrictions.AddRange(CreateRestrictions(mibType as BitsType));
-				}
-				else
-				{
-					TypeAssignment ta = mibType as TypeAssignment;
-					if (ta != null)
-					{
-						Console.WriteLine(String.Format("Unsupported BaseType: Module='{0}', Name='{1}', Type='{2}'!", ta.Module.Name, ta.Name, ta.Type));
-					}
-					else
-					{
-						Console.WriteLine(String.Format("Unsupported BaseType: Module='{0}', Name='{1}'!", mibType.Module, mibType.Name));
-					}
-					
-					return null;
-				}
-			}
-
-			result.Name = _alphaNumericRegex.Replace(ote.Name, "");
-			result.Oid  = ote.Value;
-
-			if (ote.Access == MaxAccess.readWrite)
-			{
-				result.AccessMode = SnmpAccessMode.ReadWrite;
-			}
-			else if (ote.Access == MaxAccess.readOnly)
-			{
-				result.AccessMode = SnmpAccessMode.ReadOnly;
-			}
-			else if (ote.Access == MaxAccess.readCreate)
-			{
-				result.AccessMode = SnmpAccessMode.ReadOnly;
-			}
-			else if (ignoreAccessibleFlag && (ote.Access == MaxAccess.notAccessible))
-			{
-				result.AccessMode = SnmpAccessMode.NotAccessible;
-			}
-			else
-			{
-				// not accessible or unsupported accress type
-				return null;
-			}
-
-			return result;
-		}
-
-		private static IEnumerable<IRestriction> CreateRestrictions(ValueRanges ranges)
-		{
-			List<IRestriction> result = new List<IRestriction>();
-
-			if (ranges != null)
-			{
-				foreach (ValueRange range in ranges)
-				{
-					if (!range.End.HasValue)
-					{
-						result.Add(new IsEqualRestriction(range.Start));
-					}
-					else
-					{
-						result.Add(new IsInRangeRestriction(range.Start, range.End.Value));
-					}
-				}
-			}
-
-			return result;
-		}
-
-		private static IEnumerable<IRestriction> CreateRestrictions(ValueMap map)
-		{
-			if ((map != null) && (map.Count > 0))
-			{
-				return CreateRestrictions(map.GetContinousRanges());
-			}
-
-			return new List<IRestriction>();
-		}
-
-		private static IEnumerable<IRestriction> CreateRestrictions(BitsType bt)
-		{
-			List<IRestriction> result = new List<IRestriction>();
-
-			if ((bt != null) && (bt.Map != null))
-			{
-				result.Add(new BitMaskRestriction(bt.Map.GetBitMask()));
-			}
-
-			return result;
-		}
-
-		private static SnmpTableNode GenerateSnmpTableNode(MibTreeNode mibTreeNode, SnmpTreeNode parentNode)
-		{
-			SnmpTableNode result = new SnmpTableNode(parentNode);
-			result.Name = mibTreeNode.Entity.Name;
-			result.Oid  = mibTreeNode.Entity.Value;
-
-			// expect exactly one row entry
-			if ((mibTreeNode.ChildNodes.Count != 1) || ((mibTreeNode.ChildNodes[0].NodeType & MibTreeNodeType.TableRow) == 0) || (mibTreeNode.ChildNodes[0].Entity.Value != 1))
-			{
-				Console.WriteLine("Found table with unsupported properties! Table needs exactly one (fixed) TableRow with OID=1 ! (" + mibTreeNode.Entity.Name + ")");
-				return null;
-			}
-
-			MibTreeNode rowNode = mibTreeNode.ChildNodes[0];
-			
-			ObjectType rot = rowNode.Entity as ObjectType;
-			if (rot != null)
-			{
-				if (!String.IsNullOrWhiteSpace(rot.Augments))
-				{
-					result.AugmentedTableRow = rot.Augments;
-
-					// the indeces from another table shall be used because this table is only an extension of it
-					rot = MibTypesResolver.ResolveDeclaration(rot.Module, rot.Augments) as ObjectType;
-				}
-
-				if (rot.Indices != null)
-				{
-					foreach (string index in rot.Indices)
-					{
-						ObjectType indexEntity = MibTypesResolver.ResolveDeclaration(rot.Module, index) as ObjectType;
-						if (indexEntity == null)
-						{
-							Console.WriteLine(String.Format("Could not resolve index '{0}' for table '{1}'! Table omitted!", index, result.Name));
-							return null;
-						}
-
-						result.IndexNodes.Add(GenerateSnmpScalarNode(indexEntity, parentNode, ignoreAccessibleFlag: true));
-					}
-				}
-			}
-
-			if (result.IndexNodes.Count == 0)
-			{
-				// a table cannot be used without index
-				Console.WriteLine("Found table without any index column ! (" + mibTreeNode.Entity.Name + ")");
-				return null;
-			}
-
-			// add child nodes
-			foreach (MibTreeNode cellNode in rowNode.ChildNodes)
-			{
-				SnmpScalarNode ssn = GenerateSnmpScalarNode(cellNode, parentNode);
-				if (ssn != null)
-				{
-					result.CellNodes.Add(ssn);
-				}
-			}
-
-			return result;
-		}
-
-		#endregion
-
-	}
-}
diff --git a/contrib/apps/LwipMibCompiler/LwipMibCompiler/Properties/AssemblyInfo.cs b/contrib/apps/LwipMibCompiler/LwipMibCompiler/Properties/AssemblyInfo.cs
deleted file mode 100644
index d30b8425..00000000
--- a/contrib/apps/LwipMibCompiler/LwipMibCompiler/Properties/AssemblyInfo.cs
+++ /dev/null
@@ -1,36 +0,0 @@
-﻿using System.Reflection;
-using System.Runtime.CompilerServices;
-using System.Runtime.InteropServices;
-
-// Allgemeine Informationen über eine Assembly werden über die folgenden 
-// Attribute gesteuert. Ändern Sie diese Attributwerte, um die Informationen zu ändern,
-// die mit einer Assembly verknüpft sind.
-[assembly: AssemblyTitle("ConsoleApplication28")]
-[assembly: AssemblyDescription("")]
-[assembly: AssemblyConfiguration("")]
-[assembly: AssemblyCompany("")]
-[assembly: AssemblyProduct("ConsoleApplication28")]
-[assembly: AssemblyCopyright("Copyright ©  2015")]
-[assembly: AssemblyTrademark("")]
-[assembly: AssemblyCulture("")]
-
-// Durch Festlegen von ComVisible auf "false" werden die Typen in dieser Assembly unsichtbar 
-// für COM-Komponenten. Wenn Sie auf einen Typ in dieser Assembly von 
-// COM zugreifen müssen, legen Sie das ComVisible-Attribut für diesen Typ auf "true" fest.
-[assembly: ComVisible(false)]
-
-// Die folgende GUID bestimmt die ID der Typbibliothek, wenn dieses Projekt für COM verfügbar gemacht wird
-[assembly: Guid("0abf7541-6a96-43cd-9e24-462e074b2c96")]
-
-// Versionsinformationen für eine Assembly bestehen aus den folgenden vier Werten:
-//
-//      Hauptversion
-//      Nebenversion 
-//      Buildnummer
-//      Revision
-//
-// Sie können alle Werte angeben oder die standardmäßigen Build- und Revisionsnummern 
-// übernehmen, indem Sie "*" eingeben:
-// [assembly: AssemblyVersion("1.0.*")]
-[assembly: AssemblyVersion("1.0.0.0")]
-[assembly: AssemblyFileVersion("1.0.0.0")]
diff --git a/contrib/apps/LwipMibCompiler/LwipMibCompiler/app.config b/contrib/apps/LwipMibCompiler/LwipMibCompiler/app.config
deleted file mode 100644
index e3656033..00000000
--- a/contrib/apps/LwipMibCompiler/LwipMibCompiler/app.config
+++ /dev/null
@@ -1,3 +0,0 @@
-<?xml version="1.0"?>
-<configuration>
-<startup><supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.0"/></startup></configuration>
diff --git a/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/IRestriction.cs b/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/IRestriction.cs
deleted file mode 100644
index ee2f4536..00000000
--- a/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/IRestriction.cs
+++ /dev/null
@@ -1,120 +0,0 @@
-﻿/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Martin Hentschel <info@cl-soft.de>
- *
- */
-
-using System;
-
-namespace LwipSnmpCodeGeneration
-{
-	public interface IRestriction
-	{
-		string GetCheckCodeValid(string varNameToCheck);
-		string GetCheckCodeInvalid(string varNameToCheck);
-	}
-
-	public class BitMaskRestriction : IRestriction
-	{
-		UInt32 mask;
-
-		public BitMaskRestriction(UInt32 mask)
-		{
-			this.mask = mask;
-		}
-
-		public string GetCheckCodeValid(string varNameToCheck)
-		{
-			return String.Format("(({0} & {1}) == {0})", varNameToCheck, this.mask);
-		}
-
-		public string GetCheckCodeInvalid(string varNameToCheck)
-		{
-			return String.Format("(({0} & {1}) != {0})", varNameToCheck, this.mask);
-		}
-	}
-
-	public class IsEqualRestriction : IRestriction
-	{
-		private Int64 value;
-
-		public IsEqualRestriction(Int64 value)
-		{
-			this.value = value;
-		}
-
-		public long Value
-		{
-			get { return value; }
-		}
-
-		public string GetCheckCodeValid(string varNameToCheck)
-		{
-			return String.Format("({0} == {1})", varNameToCheck, this.value);
-		}
-
-		public string GetCheckCodeInvalid(string varNameToCheck)
-		{
-			return String.Format("({0} != {1})", varNameToCheck, this.value);
-		}
-	}
-
-	public class IsInRangeRestriction : IRestriction
-	{
-		private Int64 rangeStart;
-		private Int64 rangeEnd;
-
-		public IsInRangeRestriction(Int64 rangeStart, Int64 rangeEnd)
-		{
-			this.rangeStart = rangeStart;
-			this.rangeEnd   = rangeEnd;
-		}
-
-		public long RangeStart
-		{
-			get { return this.rangeStart; }
-		}
-
-		public long RangeEnd
-		{
-			get { return this.rangeEnd; }
-		}
-
-		public string GetCheckCodeValid(string varNameToCheck)
-		{
-			return String.Format("(({0} >= {1}) && ({0} <= {2}))", varNameToCheck, this.rangeStart, this.rangeEnd);
-		}
-
-		public string GetCheckCodeInvalid(string varNameToCheck)
-		{
-			return String.Format("(({0} < {1}) || ({0} > {2}))", varNameToCheck, this.rangeStart, this.rangeEnd);
-		}
-	}
-
-}
diff --git a/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/LwipSnmp.cs b/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/LwipSnmp.cs
deleted file mode 100644
index edac59e0..00000000
--- a/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/LwipSnmp.cs
+++ /dev/null
@@ -1,199 +0,0 @@
-﻿/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Martin Hentschel <info@cl-soft.de>
- *
- */
-
-using System;
-
-namespace LwipSnmpCodeGeneration
-{
-	public static class LwipOpts
-	{
-		public static bool GenerateEmptyFolders = false;
-		/// <summary>
-		/// If a tree node only has scalar nodes as child nodes, it is replaced by
-		/// a single scalar array node in order to save memory and have only one single get/test/set method for all scalars.
-		/// </summary>
-		public static bool GenerateScalarArrays = true;
-		/// <summary>
-		/// If a tree node has multiple scalars as subnodes as well as other treenodes it
-		/// defines a single get/test/set method for all scalar child node.
-		/// (without other treenodes as child it would have been converted to scalar array node).
-		/// </summary>
-		public static bool GenerateSingleAccessMethodsForTreeNodeScalars = GenerateScalarArrays;
-	}
-
-	public static class LwipDefs
-	{
-		public const string Null        = "NULL";
-		public const string Vt_U8       = "u8_t";
-		public const string Vt_U16      = "u16_t";
-		public const string Vt_U32      = "u32_t";
-		public const string Vt_S8       = "s8_t";
-		public const string Vt_S16      = "s16_t";
-		public const string Vt_S32      = "s32_t";
-		public const string Vt_Snmp_err = "snmp_err_t";
-
-		public const string Incl_SnmpOpts = "lwip/apps/snmp_opts.h";
-		public const string Opt_SnmpEnabled = "LWIP_SNMP";
-
-		public const string Vt_StMib                = "struct snmp_mib";
-		public const string Vt_StObjectId           = "struct snmp_obj_id";
-		public const string Vt_StNode               = "struct snmp_node";
-		public const string Vt_StNodeInstance       = "struct snmp_node_instance";
-		public const string Vt_StTreeNode           = "struct snmp_tree_node";
-		public const string Vt_StScalarNode         = "struct snmp_scalar_node";
-		public const string Vt_StScalarArrayNode    = "struct snmp_scalar_array_node";
-		public const string Vt_StScalarArrayNodeDef = "struct snmp_scalar_array_node_def";
-		public const string Vt_StTableNode          = "struct snmp_table_node";
-		public const string Vt_StTableColumnDef     = "struct snmp_table_col_def";
-		public const string Vt_StNextOidState       = "struct snmp_next_oid_state";
-
-		public const string Def_NodeAccessReadOnly      = "SNMP_NODE_INSTANCE_READ_ONLY";
-		public const string Def_NodeAccessReadWrite     = "SNMP_NODE_INSTANCE_READ_WRITE";
-		public const string Def_NodeAccessWriteOnly     = "SNMP_NODE_INSTANCE_WRITE_ONLY";
-		public const string Def_NodeAccessNotAccessible = "SNMP_NODE_INSTANCE_NOT_ACCESSIBLE";
-
-		public const string Def_ErrorCode_Ok             = "SNMP_ERR_NOERROR";
-		public const string Def_ErrorCode_WrongValue     = "SNMP_ERR_WRONGVALUE";
-		public const string Def_ErrorCode_NoSuchInstance = "SNMP_ERR_NOSUCHINSTANCE";
-
-		public const string FnctSuffix_GetValue        = "_get_value";
-		public const string FnctSuffix_SetTest         = "_set_test";
-		public const string FnctSuffix_SetValue        = "_set_value";
-		public const string FnctSuffix_GetInstance     = "_get_instance";
-		public const string FnctSuffix_GetNextInstance = "_get_next_instance";
-
-		public const string FnctName_SetTest_Ok         = "snmp_set_test_ok";
-
-		public static string GetLwipDefForSnmpAccessMode(SnmpAccessMode am)
-		{
-			switch (am)
-			{
-				case SnmpAccessMode.ReadOnly: return Def_NodeAccessReadOnly;
-				case SnmpAccessMode.ReadWrite: return Def_NodeAccessReadWrite;
-				case SnmpAccessMode.NotAccessible: return Def_NodeAccessNotAccessible;
-				case SnmpAccessMode.WriteOnly: return Def_NodeAccessWriteOnly;
-				default: throw new NotSupportedException("Unknown SnmpAccessMode!");
-			}
-		}
-
-		public static string GetAsn1DefForSnmpDataType(SnmpDataType dt)
-		{
-			switch (dt)
-			{
-				// primitive
-				case SnmpDataType.Null:
-					return "SNMP_ASN1_TYPE_NULL";
-				case SnmpDataType.Bits:
-				case SnmpDataType.OctetString:
-					return "SNMP_ASN1_TYPE_OCTET_STRING";
-				case SnmpDataType.ObjectIdentifier:
-					return "SNMP_ASN1_TYPE_OBJECT_ID";				
-				case SnmpDataType.Integer:
-					return "SNMP_ASN1_TYPE_INTEGER";
-
-				// application
-				case SnmpDataType.IpAddress:
-					return "SNMP_ASN1_TYPE_IPADDR";
-				case SnmpDataType.Counter:
-					return "SNMP_ASN1_TYPE_COUNTER";
-				case SnmpDataType.Gauge:
-					return "SNMP_ASN1_TYPE_GAUGE";
-				case SnmpDataType.TimeTicks:
-					return "SNMP_ASN1_TYPE_TIMETICKS";
-				case SnmpDataType.Opaque:
-					return "SNMP_ASN1_TYPE_OPAQUE";
-				case SnmpDataType.Counter64:
-					return "SNMP_ASN1_TYPE_COUNTER64";
-				default:
-					throw new NotSupportedException("Unknown SnmpDataType!");
-			}
-		}
-
-		public static string GetLengthForSnmpDataType(SnmpDataType dt)
-		{
-			switch (dt)
-			{
-				case SnmpDataType.Null:
-					return "0";
-
-				case SnmpDataType.Integer:
-				case SnmpDataType.Counter:
-				case SnmpDataType.IpAddress:
-				case SnmpDataType.Gauge:
-				case SnmpDataType.TimeTicks:
-					return "4";
-
-				case SnmpDataType.Counter64:
-					return "8";
-
-				case SnmpDataType.OctetString:
-				case SnmpDataType.ObjectIdentifier:
-				case SnmpDataType.Bits:
-				case SnmpDataType.Opaque:
-					return null;
-
-				default:
-					throw new NotSupportedException("Unknown SnmpDataType!");
-			}
-		}
-	}
-
-	public enum SnmpDataType
-	{
-		Null,
-
-		Integer, // INTEGER, Integer32
-
-		Counter, // Counter, Counter32
-		Gauge,  // Gauge, Gauge32, Unsigned32
-		TimeTicks,
-
-		Counter64,
-
-		OctetString,
-		Opaque,
-		Bits,
-
-		ObjectIdentifier,
-		
-		IpAddress,
-	}
-
-	public enum SnmpAccessMode
-	{
-		ReadOnly,
-		ReadWrite,
-		WriteOnly,
-		NotAccessible
-	}
-
-}
diff --git a/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/LwipSnmpCodeGeneration.csproj b/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/LwipSnmpCodeGeneration.csproj
deleted file mode 100644
index f4541c0c..00000000
--- a/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/LwipSnmpCodeGeneration.csproj
+++ /dev/null
@@ -1,72 +0,0 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <PropertyGroup>
-    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
-    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
-    <ProductVersion>8.0.30703</ProductVersion>
-    <SchemaVersion>2.0</SchemaVersion>
-    <ProjectGuid>{AABCAB90-1540-45D4-A159-14831A54E9A3}</ProjectGuid>
-    <OutputType>Library</OutputType>
-    <AppDesignerFolder>Properties</AppDesignerFolder>
-    <RootNamespace>LwipSnmpCodeGeneration</RootNamespace>
-    <AssemblyName>LwipSnmpCodeGeneration</AssemblyName>
-    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
-    <FileAlignment>512</FileAlignment>
-    <TargetFrameworkProfile />
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
-    <DebugSymbols>true</DebugSymbols>
-    <DebugType>full</DebugType>
-    <Optimize>false</Optimize>
-    <OutputPath>bin\Debug\</OutputPath>
-    <DefineConstants>DEBUG;TRACE</DefineConstants>
-    <ErrorReport>prompt</ErrorReport>
-    <WarningLevel>4</WarningLevel>
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
-    <DebugType>pdbonly</DebugType>
-    <Optimize>true</Optimize>
-    <OutputPath>bin\Release\</OutputPath>
-    <DefineConstants>TRACE</DefineConstants>
-    <ErrorReport>prompt</ErrorReport>
-    <WarningLevel>4</WarningLevel>
-  </PropertyGroup>
-  <ItemGroup>
-    <Reference Include="System" />
-  </ItemGroup>
-  <ItemGroup>
-    <Compile Include="IRestriction.cs" />
-    <Compile Include="SnmpScalarNodeCounter64.cs" />
-    <Compile Include="SnmpScalarNodeTruthValue.cs" />
-    <Compile Include="SnmpScalarAggregationNode.cs" />
-    <Compile Include="SnmpTableNode.cs" />
-    <Compile Include="SnmpScalarArrayNode.cs" />
-    <Compile Include="MibHeaderFile.cs" />
-    <Compile Include="SnmpScalarNodeBits.cs" />
-    <Compile Include="SnmpMib.cs" />
-    <Compile Include="SnmpScalarNodeInt.cs" />
-    <Compile Include="SnmpScalarNodeObjectIdentifier.cs" />
-    <Compile Include="SnmpScalarNodeOctetString.cs" />
-    <Compile Include="SnmpScalarNodeUint.cs" />
-    <Compile Include="SnmpTreeNode.cs" />
-    <Compile Include="LwipSnmp.cs" />
-    <Compile Include="MibCFile.cs" />
-    <Compile Include="Properties\AssemblyInfo.cs" />
-    <Compile Include="SnmpNode.cs" />
-    <Compile Include="SnmpScalarNode.cs" />
-  </ItemGroup>
-  <ItemGroup>
-    <ProjectReference Include="..\CCodeGeneration\CCodeGeneration.csproj">
-      <Project>{7DA7C0AB-0982-4BF5-9324-F59A7A08D65B}</Project>
-      <Name>CCodeGeneration</Name>
-    </ProjectReference>
-  </ItemGroup>
-  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
-  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
-       Other similar extension points exist, see Microsoft.Common.targets.
-  <Target Name="BeforeBuild">
-  </Target>
-  <Target Name="AfterBuild">
-  </Target>
-  -->
-</Project>
\ No newline at end of file
diff --git a/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/MibCFile.cs b/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/MibCFile.cs
deleted file mode 100644
index c48ec29d..00000000
--- a/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/MibCFile.cs
+++ /dev/null
@@ -1,196 +0,0 @@
-﻿/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Martin Hentschel <info@cl-soft.de>
- *
- */
-
-using System.Collections.Generic;
-using CCodeGeneration;
-using System;
-using System.IO;
-
-namespace LwipSnmpCodeGeneration
-{
-	public class MibCFile
-	{
-		#region Fields
-
-		private const string PreservedSectionMarker = "LWIP MIB generator - preserved section begin";
-		private const string PreservedSectionHeader = 
-			"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n" +
-			PreservedSectionMarker + "\n" +
-			"Code below is preserved on regeneration. Remove these comment lines to regenerate code.\n" +
-			"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++";
-
-		private readonly List<CodeElement> includes = new List<CodeElement>();
-		private readonly List<CodeElement> defines = new List<CodeElement>();
-		private readonly List<CodeElement> declarations = new List<CodeElement>();
-		private readonly List<CodeElement> implementation = new List<CodeElement>();
-		private readonly List<CodeElement> preservedCode = new List<CodeElement>();
-
-		#endregion
-
-		public MibCFile()
-		{
-		}
-
-		#region Accessors
-
-		public List<CodeElement> Includes
-		{
-			get { return this.includes; }
-		}
-
-		public List<CodeElement> Defines
-		{
-			get { return this.defines; }
-		}
-
-		public List<CodeElement> Declarations
-		{
-			get { return this.declarations; }
-		}
-
-		public List<CodeElement> Implementation
-		{
-			get { return this.implementation; }
-		}
-
-		public List<CodeElement> PreservedCode
-		{
-			get { return this.preservedCode; }
-		}
-
-		#endregion
-
-		#region Methods
-
-		public void Save(CGenerator cGenerator)
-		{
-			CFile cFile = new CFile();
-
-			cFile.AddElement(new Comment("Generated by LwipMibCompiler"));
-			cFile.AddElement(EmptyLine.SingleLine);
-
-			cFile.AddElement(new PP_Include(LwipDefs.Incl_SnmpOpts));
-			CodeContainerBase e = cFile.AddElement(new PP_If(LwipDefs.Opt_SnmpEnabled)) as CodeContainerBase;
-			e.AddElement(EmptyLine.SingleLine);
-
-			// include header file
-			string file = cGenerator.FileName;
-			if (!String.IsNullOrWhiteSpace(file))
-			{
-				string ext = System.IO.Path.GetExtension(file);
-
-				string headerFile = !String.IsNullOrEmpty(ext) ? file.Substring(0, file.Length - ext.Length) : file;
-				headerFile += ".h";
-
-				e.AddElement(new PP_Include(headerFile));								
-			}
-
-			// include common snmp files
-			e.AddElement(new PP_Include("lwip/apps/snmp.h"));
-			e.AddElement(new PP_Include("lwip/apps/snmp_core.h"));
-			e.AddElement(new PP_Include("lwip/apps/snmp_scalar.h"));
-			e.AddElement(new PP_Include("lwip/apps/snmp_table.h"));
-
-			if (this.includes.Count > 0)
-			{
-				e.AddElement(EmptyLine.SingleLine);
-				e.AddElements(this.includes);
-			}
-
-			if (this.defines.Count > 0)
-			{
-				e.AddElement(EmptyLine.SingleLine);
-				e.AddElements(this.defines);
-			}
-
-			if (this.declarations.Count > 0)
-			{
-				e.AddElement(EmptyLine.TwoLines);
-				e.AddElements(this.declarations);
-			}
-
-			if (this.implementation.Count > 0)
-			{
-				e.AddElement(EmptyLine.TwoLines);
-				e.AddElements(this.implementation);
-			}
-
-			if (this.preservedCode.Count > 0)
-			{
-				e.AddElement(EmptyLine.TwoLines);
-				e.AddElement(new Comment(PreservedSectionHeader));
-				e.AddElement(EmptyLine.SingleLine);
-				e.AddElements(this.preservedCode);
-			}
-
-			cFile.Save(cGenerator);
-		}
-
-		public static string GetPreservedCode(string file)
-		{
-			if (File.Exists(file))
-			{
-				using (StreamReader fileStream = new StreamReader(file))
-				{
-					while (!fileStream.EndOfStream)
-					{
-						string line = fileStream.ReadLine();
-						if (line == PreservedSectionMarker)
-						{
-							break;
-						}
-					}
-
-					if (!fileStream.EndOfStream)
-					{
-						// skip the rest of the comment + spacer line
-						fileStream.ReadLine(); // "Code below is preserved...
-						fileStream.ReadLine(); // "+++++++++++++++++++++++...
-						fileStream.ReadLine(); // */
-						fileStream.ReadLine(); //
-
-						string preservedCode = fileStream.ReadToEnd();
-
-						int lastEndif    = preservedCode.LastIndexOf("#endif", StringComparison.Ordinal);
-						preservedCode    = preservedCode.Remove(lastEndif);
-
-						return preservedCode;
-					}
-				}
-			}
-
-			return null;
-		}
-
-		#endregion
-	}
-}
diff --git a/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/MibHeaderFile.cs b/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/MibHeaderFile.cs
deleted file mode 100644
index 95f2a06c..00000000
--- a/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/MibHeaderFile.cs
+++ /dev/null
@@ -1,129 +0,0 @@
-﻿/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Martin Hentschel <info@cl-soft.de>
- *
- */
-
-using System.Collections.Generic;
-using System.Text.RegularExpressions;
-using CCodeGeneration;
-
-namespace LwipSnmpCodeGeneration
-{
-	public class MibHeaderFile
-	{
-
-		#region Fields
-
-		private readonly List<CodeElement> defines = new List<CodeElement>();
-		private readonly List<CodeElement> includes = new List<CodeElement>();
-		private readonly List<CodeElement> functionDeclarations = new List<CodeElement>();
-		private readonly List<CodeElement> variableDeclarations = new List<CodeElement>();
-
-		#endregion
-
-		public MibHeaderFile()
-		{
-		}
-
-		#region Accessors
-
-		public List<CodeElement> Defines
-		{
-			get { return this.defines; }
-		}
-
-		public List<CodeElement> Includes
-		{
-			get { return this.includes; }
-		}
-
-		public List<CodeElement> FunctionDeclarations
-		{
-			get { return this.functionDeclarations; }
-		}
-
-		public List<CodeElement> VariableDeclarations
-		{
-			get { return this.variableDeclarations; }
-		}
-
-		#endregion
-
-		#region Methods
-
-		public void Save(CGenerator cGenerator)
-		{
-			CFile cFile = new CFile();
-
-			cFile.AddElement(new Comment("Generated by LwipMibCompiler"));
-			cFile.AddElement(EmptyLine.SingleLine);
-			
-			string headerDefine = cGenerator.FileName;
-			headerDefine = new Regex("[^a-zA-Z0-9]").Replace(headerDefine, "_");
-			headerDefine = headerDefine.ToUpperInvariant();
-
-			CodeContainerBase e = cFile.AddElement(new PP_Ifdef(headerDefine, inverted: true)) as CodeContainerBase;
-			e.AddElement(new PP_Macro(headerDefine, headerDefine));
-			e.AddElement(EmptyLine.SingleLine);
-
-			e.AddElement(new PP_Include(LwipDefs.Incl_SnmpOpts));
-			e = e.AddElement(new PP_If(LwipDefs.Opt_SnmpEnabled)) as CodeContainerBase;
-			e.AddElement(EmptyLine.SingleLine);
-
-			CodeContainerBase cplusplusopen = e.AddElement(new PP_Ifdef("__cplusplus")) as CodeContainerBase;
-			cplusplusopen.AddElement(new Code("extern \"C\" {"));
-			e.AddElement(EmptyLine.SingleLine);
-
-			if (this.includes.Count > 0)
-			{
-				e.AddElements(this.includes);
-				e.AddElement(EmptyLine.SingleLine);
-			}
-
-			if (this.defines.Count > 0)
-			{
-				e.AddElements(this.defines);
-				e.AddElement(EmptyLine.SingleLine);
-			}
-			
-			e.AddElements(this.functionDeclarations, EmptyLine.SingleLine);
-			e.AddElements(this.variableDeclarations, EmptyLine.SingleLine);
-
-			e.AddElement(EmptyLine.SingleLine);
-			CodeContainerBase cplusplusclose = e.AddElement(new PP_Ifdef("__cplusplus")) as CodeContainerBase;
-			cplusplusclose.AddElement(new Code("}"));
-
-			e.AddElement(EmptyLine.SingleLine);
-			cFile.Save(cGenerator);
-		}
-
-		#endregion
-	}
-}
diff --git a/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/Properties/AssemblyInfo.cs b/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/Properties/AssemblyInfo.cs
deleted file mode 100644
index e68b43d5..00000000
--- a/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/Properties/AssemblyInfo.cs
+++ /dev/null
@@ -1,36 +0,0 @@
-﻿using System.Reflection;
-using System.Runtime.CompilerServices;
-using System.Runtime.InteropServices;
-
-// Allgemeine Informationen über eine Assembly werden über die folgenden 
-// Attribute gesteuert. Ändern Sie diese Attributwerte, um die Informationen zu ändern,
-// die mit einer Assembly verknüpft sind.
-[assembly: AssemblyTitle("LwipSnmpCodeGeneration")]
-[assembly: AssemblyDescription("")]
-[assembly: AssemblyConfiguration("")]
-[assembly: AssemblyCompany("")]
-[assembly: AssemblyProduct("LwipSnmpCodeGeneration")]
-[assembly: AssemblyCopyright("Copyright ©  2015")]
-[assembly: AssemblyTrademark("")]
-[assembly: AssemblyCulture("")]
-
-// Durch Festlegen von ComVisible auf "false" werden die Typen in dieser Assembly unsichtbar 
-// für COM-Komponenten. Wenn Sie auf einen Typ in dieser Assembly von 
-// COM zugreifen müssen, legen Sie das ComVisible-Attribut für diesen Typ auf "true" fest.
-[assembly: ComVisible(false)]
-
-// Die folgende GUID bestimmt die ID der Typbibliothek, wenn dieses Projekt für COM verfügbar gemacht wird
-[assembly: Guid("8cfbbb8b-dfbb-4dd5-80c9-e07845dd58c9")]
-
-// Versionsinformationen für eine Assembly bestehen aus den folgenden vier Werten:
-//
-//      Hauptversion
-//      Nebenversion 
-//      Buildnummer
-//      Revision
-//
-// Sie können alle Werte angeben oder die standardmäßigen Build- und Revisionsnummern 
-// übernehmen, indem Sie "*" eingeben:
-// [assembly: AssemblyVersion("1.0.*")]
-[assembly: AssemblyVersion("1.0.0.0")]
-[assembly: AssemblyFileVersion("1.0.0.0")]
diff --git a/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/SnmpMib.cs b/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/SnmpMib.cs
deleted file mode 100644
index 477a18b6..00000000
--- a/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/SnmpMib.cs
+++ /dev/null
@@ -1,97 +0,0 @@
-﻿/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Martin Hentschel <info@cl-soft.de>
- *
- */
-
-using System;
-using System.Text;
-using CCodeGeneration;
-
-namespace LwipSnmpCodeGeneration
-{
-	public class SnmpMib : SnmpTreeNode
-	{
-		public uint[] BaseOid { get; set; }
-
-		public SnmpMib()
-			: base(null)
-		{
-		}
-
-		public SnmpMib(uint[] baseOid)
-			: base(null)
-		{
-			this.BaseOid = baseOid;
-		}
-
-		public override string FullNodeName
-		{
-			get { return this.Name.ToLowerInvariant() + "_root"; }
-		}
-
-		public override void GenerateCode(MibCFile mibFile)
-		{
-			base.GenerateCode(mibFile);
-
-			System.Diagnostics.Debug.Assert((this.BaseOid != null) && (this.BaseOid.Length > 0));
-			
-			// create and add BaseOID declarations
-			StringBuilder boidInitialization = new StringBuilder("{");
-			foreach (uint t in this.BaseOid)
-			{
-				boidInitialization.Append(t);
-				boidInitialization.Append(",");
-			}
-			boidInitialization.Length -= 1;
-			boidInitialization.Append("}");
-
-			VariableDeclaration boidDecl = new VariableDeclaration(
-				new VariableType(this.Name.ToLowerInvariant() + "_base_oid", LwipDefs.Vt_U32, null, ConstType.Value, String.Empty),
-				boidInitialization.ToString(), true);
-
-			mibFile.Declarations.Add(boidDecl);
-			mibFile.Declarations.Add(GetExportDeclaration());
-		}
-
-		public override void GenerateHeaderCode(MibHeaderFile mibHeaderFile)
-		{
-			mibHeaderFile.Includes.Add(new PP_Include("lwip/apps/snmp_core.h"));
-
-			mibHeaderFile.VariableDeclarations.Add(VariablePrototype.FromVariableDeclaration(GetExportDeclaration()));
-		}
-
-		VariableDeclaration GetExportDeclaration()
-		{
-			return new VariableDeclaration(
-				new VariableType(this.Name.ToLowerInvariant(), LwipDefs.Vt_StMib, null, ConstType.Value),
-				String.Format("{{{0}_base_oid, LWIP_ARRAYSIZE({0}_base_oid), &{1}.node}}", this.Name.ToLowerInvariant(), this.FullNodeName));
-		}
-	}
-}
diff --git a/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/SnmpNode.cs b/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/SnmpNode.cs
deleted file mode 100644
index fceb4d52..00000000
--- a/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/SnmpNode.cs
+++ /dev/null
@@ -1,119 +0,0 @@
-﻿/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Martin Hentschel <info@cl-soft.de>
- *
- */
-
-using System;
-using System.Text.RegularExpressions;
-using CCodeGeneration;
-
-namespace LwipSnmpCodeGeneration
-{
-	public abstract class SnmpNode
-	{
-		public static readonly Regex NameValidationRegex = new Regex(@"^\w+$");
-
-		private string name;
-		private readonly SnmpTreeNode parentNode;
-
-		protected SnmpNode(SnmpTreeNode parentNode)
-		{
-			this.parentNode = parentNode;
-		}
-
-		public SnmpTreeNode ParentNode
-		{
-			get { return this.parentNode; }
-		}
-
-		public virtual uint Oid { get; set; }
-
-		public abstract string FullNodeName
-		{
-			get;
-		}
-
-		public virtual string Name
-		{
-			get { return this.name; }
-			set
-			{
-				if (value != this.name)
-				{
-					// check for valid name
-					if (!NameValidationRegex.IsMatch(value))
-					{
-						throw new ArgumentOutOfRangeException("Name");
-					}
-
-					this.name = value;
-				}
-			}
-		}
-
-		public virtual void Generate(MibCFile generatedFile, MibHeaderFile generatedHeaderFile)
-		{
-			int declCount = generatedFile.Declarations.Count;
-			int implCount = generatedFile.Implementation.Count;
-
-			this.GenerateHeaderCode(generatedHeaderFile);
-			this.GenerateCode(generatedFile);
-
-			if (generatedFile.Declarations.Count != declCount)
-			{
-				generatedFile.Declarations.Add(EmptyLine.SingleLine);
-			}
-			if (generatedFile.Implementation.Count != implCount)
-			{
-				generatedFile.Implementation.Add(EmptyLine.SingleLine);
-			}
-		}
-
-		public abstract void GenerateCode(MibCFile mibFile);
-
-		public virtual void GenerateHeaderCode(MibHeaderFile mibHeaderFile)
-		{
-		}
-
-		/// <summary>
-		/// Called after node structure creation is completed and before code is created.
-		/// Offers the possibility to perform operations depending on properties/subnodes.
-		/// If the node shall be transformed to another node(-type) than the own instance
-		/// may be replaced on parent node by the transformed instance.
-		/// Calling sequence is always from leafs up to root. So a tree node can assume
-		/// that the analyze method was already called on all child nodes.
-		/// E.g. a tree node only has scalar sub nodes -> it transforms itself to a scalar array node
-		/// </summary>
-		/// <returns>The transformed node or null if nothing shall be changed in parent structure.</returns>
-		public virtual void Analyze()
-		{
-		}
-	}
-}
diff --git a/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/SnmpScalarAggregationNode.cs b/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/SnmpScalarAggregationNode.cs
deleted file mode 100644
index f5c558c5..00000000
--- a/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/SnmpScalarAggregationNode.cs
+++ /dev/null
@@ -1,293 +0,0 @@
-﻿/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Martin Hentschel <info@cl-soft.de>
- *
- */
-
-using System.Collections.Generic;
-using System.Globalization;
-using CCodeGeneration;
-
-namespace LwipSnmpCodeGeneration
-{
-	public abstract class SnmpScalarAggregationNode: SnmpNode
-	{
-		private bool getMethodRequired  = false;
-		private bool testMethodRequired = false;
-		private bool setMethodRequired  = false;
-
-		protected SnmpScalarAggregationNode(SnmpTreeNode parentNode)
-			: base(parentNode)
-		{
-		}
-
-		protected virtual string GetMethodName
-		{
-			get { return this.FullNodeName + LwipDefs.FnctSuffix_GetValue; }
-		}
-
-		protected bool GetMethodRequired
-		{
-			get { return this.getMethodRequired; }
-		}
-
-		protected virtual string TestMethodName
-		{
-			get { return this.FullNodeName + LwipDefs.FnctSuffix_SetTest; }
-		}
-
-		protected bool TestMethodRequired
-		{
-			get { return this.testMethodRequired; }
-		}
-
-		protected virtual string SetMethodName
-		{
-			get { return this.FullNodeName + LwipDefs.FnctSuffix_SetValue; }
-		}
-
-		protected bool SetMethodRequired
-		{
-			get { return this.setMethodRequired; }
-		}
-
-		protected abstract IEnumerable<SnmpScalarNode> AggregatedScalarNodes
-		{
-			get;
-		}
-
-		public override void Analyze()
-		{
-			base.Analyze();
-
-			this.getMethodRequired  = false;
-			this.testMethodRequired = false;
-			this.setMethodRequired  = false;
-
-			foreach (SnmpScalarNode scalarNode in this.AggregatedScalarNodes)
-			{
-				if ((scalarNode.AccessMode == SnmpAccessMode.ReadOnly) || (scalarNode.AccessMode == SnmpAccessMode.ReadWrite))
-				{
-					this.getMethodRequired = true;
-				}
-				if ((scalarNode.AccessMode == SnmpAccessMode.WriteOnly) || (scalarNode.AccessMode == SnmpAccessMode.ReadWrite))
-				{
-					this.testMethodRequired = true;
-					this.setMethodRequired = true;
-				}
-
-				if (this.getMethodRequired && this.setMethodRequired)
-				{
-					break;
-				}
-			}
-		}
-
-		protected void GenerateAggregatedCode(MibCFile mibFile, VariableType instanceType, string switchSelector, bool generateDeclarations = true, bool generateImplementations = true)
-		{
-			if (this.getMethodRequired)
-			{
-				FunctionDeclaration getMethodDecl = new FunctionDeclaration(this.GetMethodName, isStatic: true);
-				getMethodDecl.Parameter.Add(instanceType);
-				getMethodDecl.Parameter.Add(new VariableType("value", VariableType.VoidString, "*"));
-				getMethodDecl.ReturnType = new VariableType(null, LwipDefs.Vt_S16);
-
-				if (generateDeclarations)
-				{
-					mibFile.Declarations.Add(getMethodDecl);
-				}
-				if (generateImplementations)
-				{
-					Function getMethod = Function.FromDeclaration(getMethodDecl);
-					GenerateGetMethodCode(getMethod, switchSelector);
-					mibFile.Implementation.Add(getMethod);
-				}
-			}
-	
-			if (this.testMethodRequired)
-			{
-				FunctionDeclaration testMethodDecl = new FunctionDeclaration(this.TestMethodName, isStatic: true);
-				testMethodDecl.Parameter.Add(instanceType);
-				testMethodDecl.Parameter.Add(new VariableType("len", LwipDefs.Vt_U16));
-				testMethodDecl.Parameter.Add(new VariableType("value", VariableType.VoidString, "*"));
-				testMethodDecl.ReturnType = new VariableType(null, LwipDefs.Vt_Snmp_err);
-
-				if (generateDeclarations)
-				{
-					mibFile.Declarations.Add(testMethodDecl);
-				}
-				if (generateImplementations)
-				{
-					Function testMethod = Function.FromDeclaration(testMethodDecl);
-					GenerateTestMethodCode(testMethod, switchSelector);
-					mibFile.Implementation.Add(testMethod);
-				}
-			}
-
-			if (this.setMethodRequired)
-			{
-				FunctionDeclaration setMethodDecl = new FunctionDeclaration(this.SetMethodName, isStatic: true);
-				setMethodDecl.Parameter.Add(instanceType);
-				setMethodDecl.Parameter.Add(new VariableType("len", LwipDefs.Vt_U16));
-				setMethodDecl.Parameter.Add(new VariableType("value", VariableType.VoidString, "*"));
-				setMethodDecl.ReturnType = new VariableType(null, LwipDefs.Vt_Snmp_err);
-				
-				if (generateDeclarations)
-				{
-					mibFile.Declarations.Add(setMethodDecl);
-				}
-				if (generateImplementations)
-				{
-					Function setMethod = Function.FromDeclaration(setMethodDecl);
-					GenerateSetMethodCode(setMethod, switchSelector);
-					mibFile.Implementation.Add(setMethod);
-				}
-			}
-		}
-
-		protected virtual void GenerateGetMethodCode(Function getMethod, string switchSelector)
-		{
-			VariableDeclaration returnValue = new VariableDeclaration((VariableType)getMethod.ReturnType.Clone());
-			returnValue.Type.Name = "value_len";
-			getMethod.Declarations.Add(returnValue);
-			Switch sw = new Switch(switchSelector);
-
-			bool valueVarUsed = false;
-
-			foreach (SnmpScalarNode scalarNode in this.AggregatedScalarNodes)
-			{
-				if ((scalarNode.AccessMode == SnmpAccessMode.ReadOnly) || (scalarNode.AccessMode == SnmpAccessMode.ReadWrite))
-				{
-					SwitchCase sc = new SwitchCase(scalarNode.Oid.ToString(CultureInfo.InvariantCulture));
-					sc.Declarations.Add(new Comment(scalarNode.Name, singleLine: true));
-
-					scalarNode.GenerateGetMethodCode(sc, getMethod.Parameter[1].Name, ref valueVarUsed, returnValue.Type.Name);
-
-					sw.Switches.Add(sc);
-				}
-			}
-
-			SwitchCase scd = SwitchCase.GenerateDefault();
-			scd.AddCodeFormat("LWIP_DEBUGF(SNMP_MIB_DEBUG,(\"{0}(): unknown id: %\"S32_F\"\\n\", {1}));", getMethod.Name, switchSelector);
-			scd.AddCodeFormat("{0} = 0;", returnValue.Type.Name);
-			sw.Switches.Add(scd);
-
-			if (!valueVarUsed)
-			{
-				getMethod.AddCodeFormat("LWIP_UNUSED_ARG({0});", getMethod.Parameter[1].Name);
-			}
-
-			getMethod.AddElement(sw);
-
-			getMethod.AddCodeFormat("return {0};", returnValue.Type.Name);
-		}
-
-		protected virtual void GenerateTestMethodCode(Function testMethod, string switchSelector)
-		{
-			VariableDeclaration returnValue = new VariableDeclaration((VariableType)testMethod.ReturnType.Clone(), LwipDefs.Def_ErrorCode_WrongValue);
-			returnValue.Type.Name = "err";
-			testMethod.Declarations.Add(returnValue);
-			Switch sw = new Switch(switchSelector);
-
-			bool valueVarUsed = false;
-			bool lenVarUsed = false;
-
-			foreach (SnmpScalarNode scalarNode in this.AggregatedScalarNodes)
-			{
-				if ((scalarNode.AccessMode == SnmpAccessMode.WriteOnly) || (scalarNode.AccessMode == SnmpAccessMode.ReadWrite))
-				{
-					SwitchCase sc = new SwitchCase(scalarNode.Oid.ToString(CultureInfo.InvariantCulture));
-					sc.Declarations.Add(new Comment(scalarNode.Name, singleLine: true));
-
-					scalarNode.GenerateTestMethodCode(sc, testMethod.Parameter[2].Name, ref valueVarUsed, testMethod.Parameter[1].Name, ref lenVarUsed, returnValue.Type.Name);
-
-					sw.Switches.Add(sc);
-				}
-			}
-
-			SwitchCase scd = SwitchCase.GenerateDefault();
-			scd.AddCodeFormat("LWIP_DEBUGF(SNMP_MIB_DEBUG,(\"{0}(): unknown id: %\"S32_F\"\\n\", {1}));", testMethod.Name, switchSelector);
-			sw.Switches.Add(scd);
-
-			if (!valueVarUsed)
-			{
-				testMethod.AddCodeFormat("LWIP_UNUSED_ARG({0});", testMethod.Parameter[2].Name);
-			}
-			if (!lenVarUsed)
-			{
-				testMethod.AddCodeFormat("LWIP_UNUSED_ARG({0});", testMethod.Parameter[1].Name);
-			}
-
-			testMethod.AddElement(sw);
-
-			testMethod.AddCodeFormat("return {0};", returnValue.Type.Name);
-		}
-
-		protected virtual void GenerateSetMethodCode(Function setMethod, string switchSelector)
-		{
-			VariableDeclaration returnValue = new VariableDeclaration((VariableType)setMethod.ReturnType.Clone(), LwipDefs.Def_ErrorCode_Ok);
-			returnValue.Type.Name = "err";
-			setMethod.Declarations.Add(returnValue);
-			Switch sw = new Switch(switchSelector);
-
-			bool valueVarUsed = false;
-			bool lenVarUsed = false;
-			
-			foreach (SnmpScalarNode scalarNode in this.AggregatedScalarNodes)
-			{
-				if ((scalarNode.AccessMode == SnmpAccessMode.WriteOnly) || (scalarNode.AccessMode == SnmpAccessMode.ReadWrite))
-				{
-					SwitchCase sc = new SwitchCase(scalarNode.Oid.ToString(CultureInfo.InvariantCulture));
-					sc.Declarations.Add(new Comment(scalarNode.Name, singleLine: true));
-
-					scalarNode.GenerateSetMethodCode(sc, setMethod.Parameter[2].Name, ref valueVarUsed, setMethod.Parameter[1].Name, ref lenVarUsed, returnValue.Type.Name);
-
-					sw.Switches.Add(sc);
-				}
-			}
-
-			SwitchCase scd = SwitchCase.GenerateDefault();
-			scd.AddCodeFormat("LWIP_DEBUGF(SNMP_MIB_DEBUG,(\"{0}(): unknown id: %\"S32_F\"\\n\", {1}));", setMethod.Name, switchSelector);
-			sw.Switches.Add(scd);
-
-			if (!valueVarUsed)
-			{
-				setMethod.AddCodeFormat("LWIP_UNUSED_ARG({0});", setMethod.Parameter[2].Name);
-			}
-			if (!lenVarUsed)
-			{
-				setMethod.AddCodeFormat("LWIP_UNUSED_ARG({0});", setMethod.Parameter[1].Name);
-			}
-
-			setMethod.AddElement(sw);
-
-			setMethod.AddCodeFormat("return {0};", returnValue.Type.Name);
-		}
-	}
-}
diff --git a/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/SnmpScalarArrayNode.cs b/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/SnmpScalarArrayNode.cs
deleted file mode 100644
index 086fbb9f..00000000
--- a/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/SnmpScalarArrayNode.cs
+++ /dev/null
@@ -1,105 +0,0 @@
-﻿/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Martin Hentschel <info@cl-soft.de>
- *
- */
-
-using System;
-using System.Collections.Generic;
-using System.Text;
-using CCodeGeneration;
-
-namespace LwipSnmpCodeGeneration
-{
-	public class SnmpScalarArrayNode : SnmpScalarAggregationNode
-	{
-		private readonly List<SnmpScalarNode> scalarNodes;
-
-		public SnmpScalarArrayNode(List<SnmpScalarNode> scalarNodes, SnmpTreeNode parentNode)
-			: base(parentNode)
-		{
-			this.scalarNodes = scalarNodes;
-		}
-
-		public override string FullNodeName
-		{
-			get { return this.Name.ToLowerInvariant() + "_scalars"; }
-		}
-
-		protected override IEnumerable<SnmpScalarNode> AggregatedScalarNodes
-		{
-			get { return this.scalarNodes; }
-		}
-
-		public override void GenerateCode(MibCFile mibFile)
-		{
-			VariableType instanceType = new VariableType("node", LwipDefs.Vt_StScalarArrayNodeDef, "*", ConstType.Value);
-			GenerateAggregatedCode(
-				mibFile,
-				instanceType,
-				instanceType.Name + "->oid");
-
-
-			// create and add node definitions
-			StringBuilder nodeDefs = new StringBuilder();
-			foreach (SnmpScalarNode scalarNode in this.scalarNodes)
-			{
-				nodeDefs.AppendFormat("  {{{0}, {1}, {2}}}, /* {3} */ \n",
-					scalarNode.Oid,
-					LwipDefs.GetAsn1DefForSnmpDataType(scalarNode.DataType),
-					LwipDefs.GetLwipDefForSnmpAccessMode(scalarNode.AccessMode),
-					scalarNode.Name);
-			}
-			if (nodeDefs.Length > 0)
-				nodeDefs.Length--;
-
-			VariableDeclaration nodeDefsDecl = new VariableDeclaration(
-				new VariableType(this.FullNodeName + "_nodes", LwipDefs.Vt_StScalarArrayNodeDef, null, ConstType.Value, String.Empty),
-				"{\n" + nodeDefs + "\n}" ,
-				isStatic: true);
-
-			mibFile.Declarations.Add(nodeDefsDecl);
-
-
-			// create and add node declaration
-			string nodeInitialization = String.Format("SNMP_SCALAR_CREATE_ARRAY_NODE({0}, {1}, {2}, {3}, {4})",
-				this.Oid,
-				nodeDefsDecl.Type.Name,
-				(this.GetMethodRequired) ? this.GetMethodName : LwipDefs.Null,
-				(this.TestMethodRequired) ? this.TestMethodName : LwipDefs.Null,
-				(this.SetMethodRequired) ? this.SetMethodName : LwipDefs.Null
-				);
-
-			mibFile.Declarations.Add(new VariableDeclaration(
-				new VariableType(this.FullNodeName, LwipDefs.Vt_StScalarArrayNode, null, ConstType.Value),
-				nodeInitialization,
-				isStatic: true));
-		}
-	}
-}
diff --git a/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/SnmpScalarNode.cs b/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/SnmpScalarNode.cs
deleted file mode 100644
index 6be54c49..00000000
--- a/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/SnmpScalarNode.cs
+++ /dev/null
@@ -1,395 +0,0 @@
-﻿/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Martin Hentschel <info@cl-soft.de>
- *
- */
-
-using System;
-using System.Collections.Generic;
-using CCodeGeneration;
-
-namespace LwipSnmpCodeGeneration
-{
-	public class SnmpScalarNode: SnmpNode
-	{
-		protected const string LocalValueName = "v"; // name of (casted) local value variable
-
-		private SnmpDataType dataType;
-		private SnmpAccessMode accessMode;
-		private readonly List<IRestriction> restrictions = new List<IRestriction>();
-
-		private bool   useExternalMethods = false;
-		private string externalGetMethod;
-		private string externalTestMethod;
-		private string externalSetMethod;
-
-
-		public SnmpScalarNode(SnmpTreeNode parentNode)
-			: base(parentNode)
-		{
-		}
-
-		public override string FullNodeName
-		{
-			get { return this.Name.ToLowerInvariant() + "_scalar"; }
-		}
-
-		public SnmpDataType DataType
-		{
-			get { return this.dataType; }
-			set { this.dataType = value; }
-		}
-
-		public List<IRestriction> Restrictions
-		{
-			get { return this.restrictions; }
-		}
-
-		public SnmpAccessMode AccessMode
-		{
-			get { return this.accessMode; }
-			set { this.accessMode = value; }
-		}
-
-		public virtual string FixedValueLength
-		{
-			get { return null; }
-		}
-
-		/// <summary>
-		/// If scalar is used as a table index its value becomes part of the OID. This value returns how many OID parts are required to represent this value.
-		/// </summary>
-		public virtual int OidRepresentationLen
-		{
-			get { return -1; }
-		}
-
-		public bool UseExternalMethods
-		{
-			get { return this.useExternalMethods; }
-			set { this.useExternalMethods = value; }
-		}
-
-		public string ExternalGetMethod
-		{
-			get { return this.externalGetMethod; }
-			set { this.externalGetMethod = value; }
-		}
-		public string ExternalTestMethod
-		{
-			get { return this.externalTestMethod; }
-			set { this.externalTestMethod = value; }
-		}
-		public string ExternalSetMethod
-		{
-			get { return this.externalSetMethod; }
-			set { this.externalSetMethod = value; }
-		}
-
-		public override void GenerateCode(MibCFile mibFile)
-		{
-			string getMethodName;
-			string testMethodName;
-			string setMethodName;
-
-			if (this.useExternalMethods)
-			{
-				getMethodName  = this.externalGetMethod;
-				testMethodName = this.externalTestMethod;
-				setMethodName  = this.externalSetMethod;
-			}
-			else
-			{
-				getMethodName  = LwipDefs.Null;
-				testMethodName = LwipDefs.Null;
-				setMethodName  = LwipDefs.Null;
-				
-				if ((this.accessMode == SnmpAccessMode.ReadWrite) || (this.accessMode == SnmpAccessMode.ReadOnly))
-				{
-					FunctionDeclaration  getMethodDecl = new FunctionDeclaration(this.Name + LwipDefs.FnctSuffix_GetValue, isStatic: true);
-					getMethodDecl.Parameter.Add(new VariableType("instance", LwipDefs.Vt_StNodeInstance, "*"));
-					getMethodDecl.Parameter.Add(new VariableType("value", VariableType.VoidString, "*"));
-					getMethodDecl.ReturnType = new VariableType(null, LwipDefs.Vt_S16);
-					mibFile.Declarations.Add(getMethodDecl);
-
-					Function getMethod = Function.FromDeclaration(getMethodDecl);
-					getMethodName = getMethod.Name;
-
-					VariableDeclaration returnValue = new VariableDeclaration((VariableType)getMethod.ReturnType.Clone());
-					returnValue.Type.Name = "value_len";
-					getMethod.Declarations.Add(returnValue);
-					getMethod.AddCodeFormat("LWIP_UNUSED_ARG({0});", getMethod.Parameter[0].Name);
-
-					bool valueVarUsed = false;
-					GenerateGetMethodCode(getMethod, getMethod.Parameter[1].Name, ref valueVarUsed, returnValue.Type.Name);
-					if (!valueVarUsed)
-					{
-						getMethod.AddCodeFormat("LWIP_UNUSED_ARG({0});", getMethod.Parameter[1].Name);
-					}
-
-					getMethod.AddCodeFormat("return {0};", returnValue.Type.Name);
-
-					mibFile.Implementation.Add(getMethod);
-				}
-
-				if ((this.accessMode == SnmpAccessMode.ReadWrite) || (this.accessMode == SnmpAccessMode.WriteOnly))
-				{
-					bool valueVarUsed;
-					bool lenVarUsed;
-					VariableDeclaration returnValue;
-
-					if (this.restrictions.Count > 0)
-					{
-						FunctionDeclaration testMethodDecl = new FunctionDeclaration(this.Name + LwipDefs.FnctSuffix_SetTest, isStatic: true);
-						testMethodDecl.Parameter.Add(new VariableType("instance", LwipDefs.Vt_StNodeInstance, "*"));
-						testMethodDecl.Parameter.Add(new VariableType("len", LwipDefs.Vt_U16));
-						testMethodDecl.Parameter.Add(new VariableType("value", VariableType.VoidString, "*"));
-						testMethodDecl.ReturnType = new VariableType(null, LwipDefs.Vt_Snmp_err);
-						mibFile.Declarations.Add(testMethodDecl);
-
-						Function testMethod = Function.FromDeclaration(testMethodDecl);
-						testMethodName = testMethod.Name;
-
-						returnValue = new VariableDeclaration((VariableType)testMethod.ReturnType.Clone(), LwipDefs.Def_ErrorCode_WrongValue);
-						returnValue.Type.Name = "err";
-						testMethod.Declarations.Add(returnValue);
-						testMethod.AddCodeFormat("LWIP_UNUSED_ARG({0});", testMethod.Parameter[0].Name);
-
-						valueVarUsed = false;
-						lenVarUsed = false;
-
-						GenerateTestMethodCode(testMethod, testMethod.Parameter[2].Name, ref valueVarUsed, testMethod.Parameter[1].Name, ref lenVarUsed, returnValue.Type.Name);
-
-						if (!valueVarUsed)
-						{
-							testMethod.AddCodeFormat("LWIP_UNUSED_ARG({0});", testMethod.Parameter[2].Name);
-						}
-						if (!lenVarUsed)
-						{
-							testMethod.AddCodeFormat("LWIP_UNUSED_ARG({0});", testMethod.Parameter[1].Name);
-						}
-
-						testMethod.AddCodeFormat("return {0};", returnValue.Type.Name);
-
-						mibFile.Implementation.Add(testMethod);
-
-					}
-					else
-					{
-						testMethodName = LwipDefs.FnctName_SetTest_Ok;
-					}
-
-					FunctionDeclaration setMethodDecl  = null;
-					setMethodDecl = new FunctionDeclaration(this.Name + LwipDefs.FnctSuffix_SetValue, isStatic: true);
-					setMethodDecl.Parameter.Add(new VariableType("instance", LwipDefs.Vt_StNodeInstance, "*"));
-					setMethodDecl.Parameter.Add(new VariableType("len", LwipDefs.Vt_U16));
-					setMethodDecl.Parameter.Add(new VariableType("value", VariableType.VoidString, "*"));
-					setMethodDecl.ReturnType = new VariableType(null, LwipDefs.Vt_Snmp_err);
-					mibFile.Declarations.Add(setMethodDecl);
-
-					Function setMethod = Function.FromDeclaration(setMethodDecl);
-					setMethodName = setMethod.Name;
-
-					returnValue = new VariableDeclaration((VariableType)setMethod.ReturnType.Clone(), LwipDefs.Def_ErrorCode_Ok);
-					returnValue.Type.Name = "err";
-					setMethod.Declarations.Add(returnValue);
-					setMethod.AddCodeFormat("LWIP_UNUSED_ARG({0});", setMethod.Parameter[0].Name);
-
-					valueVarUsed = false;
-					lenVarUsed = false;
-
-					GenerateSetMethodCode(setMethod, setMethod.Parameter[2].Name, ref valueVarUsed, setMethod.Parameter[1].Name, ref lenVarUsed, returnValue.Type.Name);
-
-					if (!valueVarUsed)
-					{
-						setMethod.AddCodeFormat("LWIP_UNUSED_ARG({0});", setMethod.Parameter[2].Name);
-					}
-					if (!lenVarUsed)
-					{
-						setMethod.AddCodeFormat("LWIP_UNUSED_ARG({0});", setMethod.Parameter[1].Name);
-					}
-
-					setMethod.AddCodeFormat("return {0};", returnValue.Type.Name);
-
-					mibFile.Implementation.Add(setMethod);
-				}
-			}
-
-			// create and add node declaration
-			string nodeInitialization;
-			if (this.accessMode == SnmpAccessMode.ReadOnly)
-			{
-				nodeInitialization = String.Format("SNMP_SCALAR_CREATE_NODE_READONLY({0}, {1}, {2})",
-					this.Oid,
-					LwipDefs.GetAsn1DefForSnmpDataType(this.dataType),
-					getMethodName);
-			}
-			else
-			{
-				nodeInitialization = String.Format("SNMP_SCALAR_CREATE_NODE({0}, {1}, {2}, {3}, {4}, {5})",
-					this.Oid,
-					LwipDefs.GetLwipDefForSnmpAccessMode(this.accessMode),
-					LwipDefs.GetAsn1DefForSnmpDataType(this.dataType),
-					getMethodName,
-					testMethodName,
-					setMethodName);
-			}
-
-			mibFile.Declarations.Add(new VariableDeclaration(
-				new VariableType(this.FullNodeName, LwipDefs.Vt_StScalarNode, null, ConstType.Value),
-				nodeInitialization, isStatic: true));
-		}
-
-		public virtual void GenerateGetMethodCode(CodeContainerBase container, string valueVarName, ref bool valueVarUsed, string retLenVarName)
-		{
-			bool localValueVarUsed;
-			if (GenerateValueDeclaration(container, LocalValueName, valueVarName))
-			{
-				valueVarUsed = true;
-				localValueVarUsed = false;
-			}
-			else
-			{
-				localValueVarUsed = true;  // do not generate UNUSED_ARG code
-			}
-
-			if (this.FixedValueLength == null)
-			{
-				// check that value with variable length fits into buffer
-				container.AddElement(new Comment(String.Format("TODO: take care that value with variable length fits into buffer: ({0} <= SNMP_MAX_VALUE_SIZE)", retLenVarName), singleLine: true));
-			}
-
-			GenerateGetMethodCodeCore(container, LocalValueName, ref localValueVarUsed, retLenVarName);
-			if (!localValueVarUsed)
-			{
-				container.AddCode(String.Format("LWIP_UNUSED_ARG({0});", LocalValueName));
-			}
-		}
-
-		protected virtual void GenerateGetMethodCodeCore(CodeContainerBase container, string localValueVarName, ref bool localValueVarUsed, string retLenVarName)
-		{
-			container.AddElement(new Comment(String.Format("TODO: put requested value to '*{0}' here", localValueVarName), singleLine: true));
-			container.AddCodeFormat("{0} = {1};", 
-				retLenVarName,
-				(!String.IsNullOrWhiteSpace(this.FixedValueLength)) ? this.FixedValueLength : "0");
-		}
-
-		public virtual void GenerateTestMethodCode(CodeContainerBase container, string valueVarName, ref bool valueVarUsed, string lenVarName, ref bool lenVarUsed, string retErrVarName)
-		{
-			if (this.Restrictions.Count > 0)
-			{
-				bool localVarUsed;
-				if (GenerateValueDeclaration(container, LocalValueName, valueVarName))
-				{
-					valueVarUsed = true;
-					localVarUsed = false;
-				}
-				else
-				{
-					localVarUsed = true;  // do not generate UNUSED_ARG code
-				}
-
-				if (!String.IsNullOrWhiteSpace(this.FixedValueLength))
-				{
-					// check for fixed value
-					container.AddCodeFormat("LWIP_ASSERT(\"Invalid length for datatype\", ({0} == {1}));", lenVarName, this.FixedValueLength);
-					lenVarUsed = true;
-				}
-
-				GenerateTestMethodCodeCore(container, LocalValueName, ref localVarUsed, lenVarName, ref lenVarUsed, retErrVarName);
-
-				if (!localVarUsed)
-				{
-					container.AddCode(String.Format("LWIP_UNUSED_ARG({0});", LocalValueName));
-				}
-			}
-			else
-			{
-				container.AddCodeFormat("{0} = {1};", retErrVarName, LwipDefs.Def_ErrorCode_Ok);
-			}
-		}
-
-		protected virtual void GenerateTestMethodCodeCore(CodeContainerBase container, string localValueVarName, ref bool localValueVarUsed, string lenVarName, ref bool lenVarUsed, string retErrVarName)
-		{
-			container.AddElement(new Comment(String.Format("TODO: test new value here:\nif (*{0} == ) {1} = {2};", localValueVarName, retErrVarName, LwipDefs.Def_ErrorCode_Ok)));
-		}
-
-		public virtual void GenerateSetMethodCode(CodeContainerBase container, string valueVarName, ref bool valueVarUsed, string lenVarName, ref bool lenVarUsed, string retErrVarName)
-		{
-			bool localVarUsed;
-			if (GenerateValueDeclaration(container, LocalValueName, valueVarName))
-			{
-				valueVarUsed = true;
-				localVarUsed = false;
-			}
-			else
-			{
-				localVarUsed = true; // do not generate UNUSED_ARG code
-			}
-
-			GenerateSetMethodCodeCore(container, LocalValueName, ref localVarUsed, lenVarName, ref lenVarUsed, retErrVarName);
-
-			if (!localVarUsed)
-			{
-				container.AddCode(String.Format("LWIP_UNUSED_ARG({0});", LocalValueName));
-			}
-		}
-
-		protected virtual void GenerateSetMethodCodeCore(CodeContainerBase container, string localValueVarName, ref bool localValueVarUsed, string lenVarName, ref bool lenVarUsed, string retErrVarName)
-		{
-			container.AddElement(new Comment(String.Format("TODO: store new value contained in '*{0}' here", localValueVarName), singleLine: true)); 
-		}
-
-
-		protected virtual bool GenerateValueDeclaration(CodeContainerBase container, string variableName, string sourceName)
-		{
-			container.AddDeclaration(new VariableDeclaration(
-				new VariableType(variableName, LwipDefs.Vt_U8, "*"),
-				"(" + new VariableType(null, LwipDefs.Vt_U8, "*") + ")" + sourceName));
-
-			return true;
-		}
-
-		public static SnmpScalarNode CreateFromDatatype(SnmpDataType dataType, SnmpTreeNode parentNode)
-		{
-			switch (dataType)
-			{
-				case SnmpDataType.Integer:
-					return new SnmpScalarNodeInt(parentNode);
-
-				case SnmpDataType.Gauge:
-				case SnmpDataType.Counter:
-				case SnmpDataType.TimeTicks:
-					return new SnmpScalarNodeUint(dataType, parentNode);
-			}
-
-			return new SnmpScalarNode(parentNode);
-		}
-	}
-}
diff --git a/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/SnmpScalarNodeBits.cs b/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/SnmpScalarNodeBits.cs
deleted file mode 100644
index 906a5a6c..00000000
--- a/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/SnmpScalarNodeBits.cs
+++ /dev/null
@@ -1,121 +0,0 @@
-﻿/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Martin Hentschel <info@cl-soft.de>
- *
- */
-
-using System;
-using System.Text;
-using CCodeGeneration;
-
-namespace LwipSnmpCodeGeneration
-{
-	public class SnmpScalarNodeBits : SnmpScalarNode
-	{
-		private readonly uint bitCount;
-
-		public SnmpScalarNodeBits(SnmpTreeNode parentNode, uint bitCount)
-			: base(parentNode)
-		{
-			this.DataType = SnmpDataType.Bits;
-			this.bitCount = bitCount;
-		}
-
-		public override void GenerateGetMethodCode(CodeContainerBase container, string valueVarName, ref bool valueVarUsed, string retLenVarName)
-		{
-			container.AddCode(String.Format(
-				"{0} = snmp_encode_bits(({1} *){2}, SNMP_MAX_VALUE_SIZE, 0 /* TODO: pass real value here */, {3});",
-				retLenVarName, 
-				LwipDefs.Vt_U8,
-				valueVarName,
-				this.bitCount));
-			
-			valueVarUsed = true;
-		}
-
-		public override void GenerateTestMethodCode(CodeContainerBase container, string valueVarName, ref bool valueVarUsed, string lenVarName, ref bool lenVarUsed, string retErrVarName)
-		{
-			if (this.Restrictions.Count > 0)
-			{
-				const string bitVarName = "bits";
-
-				container.Declarations.Add(new VariableDeclaration(new VariableType(bitVarName, LwipDefs.Vt_U32)));
-
-				IfThenElse ite = new IfThenElse(String.Format(
-					"snmp_decode_bits(({0} *){1}, {2}, &{3}) == ERR_OK",
-					LwipDefs.Vt_U8,
-					valueVarName,
-					lenVarName,
-					bitVarName));
-
-				valueVarUsed = true;
-				lenVarUsed = true;
-
-				StringBuilder innerIfCond = new StringBuilder();
-				foreach (IRestriction restriction in this.Restrictions)
-				{
-					innerIfCond.Append(restriction.GetCheckCodeValid(bitVarName));
-					innerIfCond.Append(" || ");
-				}
-
-				innerIfCond.Length -= 4;
-
-				IfThenElse innerIte = new IfThenElse(innerIfCond.ToString());
-				innerIte.AddCode(String.Format("{0} = {1};", retErrVarName, LwipDefs.Def_ErrorCode_Ok));
-				ite.AddElement(innerIte);
-				container.AddElement(ite);
-			}
-			else
-			{
-				base.GenerateTestMethodCode(container, valueVarName, ref valueVarUsed, lenVarName, ref lenVarUsed, retErrVarName);
-			}
-		}
-
-		public override void GenerateSetMethodCode(CodeContainerBase container, string valueVarName, ref bool valueVarUsed, string lenVarName, ref bool lenVarUsed, string retErrVarName)
-		{
-			const string bitVarName = "bits";
-
-			container.Declarations.Add(new VariableDeclaration(new VariableType(bitVarName, LwipDefs.Vt_U32)));
-
-			IfThenElse ite = new IfThenElse(String.Format(
-				"snmp_decode_bits(({0} *){1}, {2}, &{3}) == ERR_OK",
-				LwipDefs.Vt_U8,
-				valueVarName,
-				lenVarName,
-				bitVarName));
-
-			valueVarUsed = true;
-			lenVarUsed = true;
-
-			ite.AddElement(new Comment(String.Format("TODO: store new value contained in '{0}' here", bitVarName), singleLine: true));
-
-			container.AddElement(ite);
-		}
-	}
-}
diff --git a/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/SnmpScalarNodeCounter64.cs b/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/SnmpScalarNodeCounter64.cs
deleted file mode 100644
index 8f450c8a..00000000
--- a/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/SnmpScalarNodeCounter64.cs
+++ /dev/null
@@ -1,72 +0,0 @@
-﻿/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Martin Hentschel <info@cl-soft.de>
- *
- */
-
-using System;
-using System.Text;
-using CCodeGeneration;
-
-namespace LwipSnmpCodeGeneration
-{
-	public class SnmpScalarNodeCounter64 : SnmpScalarNode
-	{
-		public SnmpScalarNodeCounter64(SnmpTreeNode parentNode)
-			: base(parentNode)
-		{
-			this.DataType = SnmpDataType.Counter64;
-		}
-
-		protected override bool GenerateValueDeclaration(CodeContainerBase container, string variableName, string sourceName)
-		{
-			container.AddDeclaration(new VariableDeclaration(
-				new VariableType(variableName + "_high", LwipDefs.Vt_U32, "*"),
-				"(" + new VariableType(null, LwipDefs.Vt_U32, "*").ToString() + ")" + sourceName));
-			container.AddDeclaration(new VariableDeclaration(
-				new VariableType(variableName + "_low", LwipDefs.Vt_U32, "*"),
-				variableName + "_high + 1"));
-
-			container.AddCode(String.Format("LWIP_UNUSED_ARG({0}_high);", variableName));
-			container.AddCode(String.Format("LWIP_UNUSED_ARG({0}_low);", variableName));
-
-			return false;
-		}
-
-		public override string FixedValueLength
-		{
-			get { return String.Format("(2 * sizeof({0}))", LwipDefs.Vt_U32); }
-		}
-
-		public override int OidRepresentationLen
-		{
-			get { return 1; }
-		}
-	}
-}
diff --git a/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/SnmpScalarNodeInt.cs b/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/SnmpScalarNodeInt.cs
deleted file mode 100644
index a381234c..00000000
--- a/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/SnmpScalarNodeInt.cs
+++ /dev/null
@@ -1,86 +0,0 @@
-﻿/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Martin Hentschel <info@cl-soft.de>
- *
- */
-
-using System;
-using System.Text;
-using CCodeGeneration;
-
-namespace LwipSnmpCodeGeneration
-{
-	public class SnmpScalarNodeInt : SnmpScalarNode
-	{
-		public SnmpScalarNodeInt(SnmpTreeNode parentNode)
-			: base(parentNode)
-		{
-			this.DataType = SnmpDataType.Integer;
-		}
-
-		protected override void GenerateTestMethodCodeCore(CodeContainerBase container, string localValueVarName, ref bool localValueVarUsed, string lenVarName, ref bool lenVarUsed, string retErrVarName)
-		{
-			System.Diagnostics.Trace.Assert(this.Restrictions.Count > 0);
-
-			StringBuilder ifCond = new StringBuilder();
-			foreach (IRestriction restriction in this.Restrictions)
-			{
-				ifCond.Append(restriction.GetCheckCodeValid("*" + localValueVarName));
-				ifCond.Append(" || ");
-
-				localValueVarUsed = true;
-			}
-
-			ifCond.Length -= 4;
-
-			IfThenElse ite = new IfThenElse(ifCond.ToString());
-			ite.AddCode(String.Format("{0} = {1};", retErrVarName, LwipDefs.Def_ErrorCode_Ok));
-			container.AddElement(ite);
-		}
-
-		protected override bool GenerateValueDeclaration(CodeContainerBase container, string variableName, string sourceName)
-		{
-			container.AddDeclaration(new VariableDeclaration(
-				new VariableType(variableName, LwipDefs.Vt_S32, "*"),
-				"(" + new VariableType(null, LwipDefs.Vt_S32, "*") + ")" + sourceName));
-
-			return true;
-		}
-
-		public override string FixedValueLength
-		{
-			get { return String.Format("sizeof({0})", LwipDefs.Vt_S32); }
-		}
-
-		public override int OidRepresentationLen
-		{
-			get { return 1; }
-		}
-	}
-}
diff --git a/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/SnmpScalarNodeObjectIdentifier.cs b/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/SnmpScalarNodeObjectIdentifier.cs
deleted file mode 100644
index 5ce8d146..00000000
--- a/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/SnmpScalarNodeObjectIdentifier.cs
+++ /dev/null
@@ -1,90 +0,0 @@
-﻿/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Martin Hentschel <info@cl-soft.de>
- *
- */
-
-using System;
-using CCodeGeneration;
-
-namespace LwipSnmpCodeGeneration
-{
-	public class SnmpScalarNodeObjectIdentifier: SnmpScalarNode
-	{
-		public SnmpScalarNodeObjectIdentifier(SnmpTreeNode parentNode)
-			: base(parentNode)
-		{
-			this.DataType = SnmpDataType.ObjectIdentifier;
-		}
-
-		protected override bool GenerateValueDeclaration(CodeContainerBase container, string variableName, string sourceName)
-		{
-			container.AddDeclaration(new VariableDeclaration(
-				new VariableType(variableName, LwipDefs.Vt_U32, "*"),
-				"(" + new VariableType(null, LwipDefs.Vt_U32, "*") + ")" + sourceName));
-
-			return true;
-		}
-
-		protected override void GenerateGetMethodCodeCore(CodeContainerBase container, string localValueVarName, ref bool localValueVarUsed, string retLenVarName)
-		{
-			container.AddElement(new Comment(String.Format("TODO: put requested value to '*{0}' here. '{0}' has to be interpreted as {1}[]", localValueVarName, LwipDefs.Vt_U32), singleLine: true));
-			container.AddElement(EmptyLine.SingleLine);
-			container.AddCode(String.Format("{0} = 0; // TODO: return real value length here (should be 'numOfElements * sizeof({1})')", retLenVarName, LwipDefs.Vt_U32));
-		}
-
-		protected override void GenerateTestMethodCodeCore(CodeContainerBase container, string localValueVarName, ref bool localValueVarUsed, string lenVarName, ref bool lenVarUsed, string retErrVarName)
-		{
-			VariableDeclaration objIdLenVar = new VariableDeclaration(
-				new VariableType(localValueVarName + "_len", LwipDefs.Vt_U8),
-				String.Format("{0} / sizeof({1})", lenVarName, LwipDefs.Vt_U32));
-			lenVarUsed = true;
-
-			container.Declarations.Add(objIdLenVar);
-
-			base.GenerateTestMethodCodeCore(container, localValueVarName, ref localValueVarUsed, lenVarName, ref lenVarUsed, retErrVarName);
-
-			container.AddCode(String.Format("LWIP_UNUSED_ARG({0});", objIdLenVar.Type.Name));
-		}
-
-		protected override void GenerateSetMethodCodeCore(CodeContainerBase container, string localValueVarName, ref bool localValueVarUsed, string lenVarName, ref bool lenVarUsed, string retErrVarName)
-		{
-			VariableDeclaration objIdLenVar = new VariableDeclaration(
-				new VariableType(localValueVarName + "_len", LwipDefs.Vt_U8),
-				String.Format("{0} / sizeof({1})", lenVarName, LwipDefs.Vt_U32));
-			lenVarUsed = true;
-
-			container.Declarations.Add(objIdLenVar);
-
-			base.GenerateSetMethodCodeCore(container, localValueVarName, ref localValueVarUsed, lenVarName, ref lenVarUsed, retErrVarName);
-
-			container.AddCode(String.Format("LWIP_UNUSED_ARG({0});", objIdLenVar.Type.Name));
-		}
-	}
-}
diff --git a/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/SnmpScalarNodeOctetString.cs b/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/SnmpScalarNodeOctetString.cs
deleted file mode 100644
index bf10f9a8..00000000
--- a/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/SnmpScalarNodeOctetString.cs
+++ /dev/null
@@ -1,118 +0,0 @@
-﻿/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Martin Hentschel <info@cl-soft.de>
- *
- */
-
-using System;
-using System.Text;
-using CCodeGeneration;
-
-namespace LwipSnmpCodeGeneration
-{
-	public class SnmpScalarNodeOctetString : SnmpScalarNode
-	{
-		public SnmpScalarNodeOctetString(SnmpDataType dataType, SnmpTreeNode parentNode)
-			: base(parentNode)
-		{
-			System.Diagnostics.Debug.Assert(
-				(dataType == SnmpDataType.OctetString) || 
-				 (dataType == SnmpDataType.Opaque) || 
-				 (dataType == SnmpDataType.IpAddress));
-
-			this.DataType = dataType;
-		}
-
-		protected override void GenerateGetMethodCodeCore(CodeContainerBase container, string localValueVarName, ref bool localValueVarUsed, string retLenVarName)
-		{
-			if (this.Restrictions.Count > 0)
-			{
-				StringBuilder ifCond = new StringBuilder();
-				foreach (IRestriction restriction in this.Restrictions)
-				{
-					ifCond.Append(restriction.GetCheckCodeValid(retLenVarName));
-					ifCond.Append(" || ");
-				}
-
-				ifCond.Length -= 4;
-				container.AddElement(new Comment("TODO: take care of len restrictions defined in MIB: " + ifCond, singleLine: true));
-			}
-			base.GenerateGetMethodCodeCore(container, localValueVarName, ref localValueVarUsed, retLenVarName);
-		}
-
-		protected override void GenerateTestMethodCodeCore(CodeContainerBase container, string localValueVarName, ref bool localValueVarUsed, string lenVarName, ref bool lenVarUsed, string retErrVarName)
-		{
-			System.Diagnostics.Trace.Assert(this.Restrictions.Count > 0);
-
-			// checks refer to length of octet string
-			StringBuilder ifCond = new StringBuilder();
-			foreach (IRestriction restriction in this.Restrictions)
-			{
-				ifCond.Append(restriction.GetCheckCodeValid(lenVarName));
-				ifCond.Append(" || ");
-
-				lenVarUsed = true;
-			}
-
-			ifCond.Length -= 4;
-
-			IfThenElse ite = new IfThenElse(ifCond.ToString());
-			ite.AddCode(String.Format("{0} = {1};", retErrVarName, LwipDefs.Def_ErrorCode_Ok));
-			container.AddElement(ite);
-		}
-
-		public override int OidRepresentationLen
-		{
-			get
-			{
-				// check restrictions if we are set to one fixed length
-				if ((this.Restrictions != null) && (this.Restrictions.Count > 0))
-				{
-					foreach (IRestriction restriction in this.Restrictions)
-					{
-						if (restriction is IsInRangeRestriction)
-						{
-							if ((restriction as IsInRangeRestriction).RangeStart == (restriction as IsInRangeRestriction).RangeEnd)
-							{
-								return (int)(restriction as IsInRangeRestriction).RangeStart;
-							}
-						}
-						else if (restriction is IsEqualRestriction)
-						{
-							return (int)(restriction as IsEqualRestriction).Value;
-						}
-					}
-				}
-
-				return -1; // variable length
-			}
-		}
-
-	}
-}
diff --git a/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/SnmpScalarNodeTruthValue.cs b/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/SnmpScalarNodeTruthValue.cs
deleted file mode 100644
index 0f557526..00000000
--- a/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/SnmpScalarNodeTruthValue.cs
+++ /dev/null
@@ -1,66 +0,0 @@
-﻿/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Martin Hentschel <info@cl-soft.de>
- *
- */
-
-using System;
-using CCodeGeneration;
-
-namespace LwipSnmpCodeGeneration
-{
-	public class SnmpScalarNodeTruthValue : SnmpScalarNodeInt
-	{
-		public SnmpScalarNodeTruthValue(SnmpTreeNode parentNode)
-			: base(parentNode)
-		{
-		}
-
-		protected override void GenerateGetMethodCodeCore(CodeContainerBase container, string localValueVarName, ref bool localValueVarUsed, string retLenVarName)
-		{
-			container.AddCodeFormat("snmp_encode_truthvalue({0}, /* TODO: put requested bool value here */ 0);", localValueVarName);
-			localValueVarUsed = true;
-			
-			container.AddCode(String.Format("{0} = {1};",
-				retLenVarName,
-				(!String.IsNullOrWhiteSpace(this.FixedValueLength)) ? this.FixedValueLength : "0"));
-		}
-
-		protected override void GenerateSetMethodCodeCore(CodeContainerBase container, string localValueVarName, ref bool localValueVarUsed, string lenVarName, ref bool lenVarUsed, string retErrVarName)
-		{
-			VariableType truthVar = new VariableType("bool_value", LwipDefs.Vt_U8);
-			container.Declarations.Add(new VariableDeclaration(truthVar));
-
-			container.AddCodeFormat("snmp_decode_truthvalue({0}, &{1});", localValueVarName, truthVar.Name);
-			localValueVarUsed = true;
-
-			container.AddElement(new Comment(String.Format("TODO: store new value contained in '{0}' here", truthVar.Name), singleLine: true)); 
-		}
-	}
-}
diff --git a/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/SnmpScalarNodeUint.cs b/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/SnmpScalarNodeUint.cs
deleted file mode 100644
index edc161ac..00000000
--- a/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/SnmpScalarNodeUint.cs
+++ /dev/null
@@ -1,91 +0,0 @@
-﻿/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Martin Hentschel <info@cl-soft.de>
- *
- */
-
-using System;
-using System.Text;
-using CCodeGeneration;
-
-namespace LwipSnmpCodeGeneration
-{
-	public class SnmpScalarNodeUint : SnmpScalarNode
-	{
-		public SnmpScalarNodeUint(SnmpDataType dataType, SnmpTreeNode parentNode)
-			: base(parentNode)
-		{
-			System.Diagnostics.Debug.Assert(
-				(dataType == SnmpDataType.Counter) || 
-				 (dataType == SnmpDataType.Gauge) || 
-				 (dataType == SnmpDataType.TimeTicks));
-
-			this.DataType = dataType;
-		}
-
-		protected override void GenerateTestMethodCodeCore(CodeContainerBase container, string localValueVarName, ref bool localValueVarUsed, string lenVarName, ref bool lenVarUsed, string retErrVarName)
-		{
-			System.Diagnostics.Trace.Assert(this.Restrictions.Count > 0);
-
-			StringBuilder ifCond = new StringBuilder();
-			foreach (IRestriction restriction in this.Restrictions)
-			{
-				ifCond.Append(restriction.GetCheckCodeValid("*" + localValueVarName));
-				ifCond.Append(" || ");
-
-				localValueVarUsed = true;
-			}
-
-			ifCond.Length -= 4;
-
-			IfThenElse ite = new IfThenElse(ifCond.ToString());
-			ite.AddCode(String.Format("{0} = {1};", retErrVarName, LwipDefs.Def_ErrorCode_Ok));
-			container.AddElement(ite);
-		}
-
-		protected override bool GenerateValueDeclaration(CodeContainerBase container, string variableName, string sourceName)
-		{
-			container.AddDeclaration(new VariableDeclaration(
-				new VariableType(variableName, LwipDefs.Vt_U32, "*"),
-				"(" + new VariableType(null, LwipDefs.Vt_U32, "*") + ")" + sourceName));
-
-			return true;
-		}
-
-		public override string FixedValueLength
-		{
-			get { return String.Format("sizeof({0})", LwipDefs.Vt_U32); }
-		}
-
-		public override int OidRepresentationLen
-		{
-			get { return 1; }
-		}
-	}
-}
diff --git a/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/SnmpTableNode.cs b/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/SnmpTableNode.cs
deleted file mode 100644
index 13a3bf27..00000000
--- a/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/SnmpTableNode.cs
+++ /dev/null
@@ -1,332 +0,0 @@
-﻿/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Martin Hentschel <info@cl-soft.de>
- *
- */
-
-using System;
-using System.Collections.Generic;
-using System.Text;
-using CCodeGeneration;
-
-namespace LwipSnmpCodeGeneration
-{
-	public class SnmpTableNode: SnmpScalarAggregationNode
-	{
-		private readonly List<SnmpScalarNode> cellNodes = new List<SnmpScalarNode>();
-		private readonly List<SnmpScalarNode> indexNodes = new List<SnmpScalarNode>();
-		private string augmentedTableRow = null;
-
-
-		public SnmpTableNode(SnmpTreeNode parentNode)
-			: base(parentNode)
-		{
-		}
-
-		public List<SnmpScalarNode> CellNodes
-		{
-			get { return cellNodes; }
-		}
-
-		public List<SnmpScalarNode> IndexNodes
-		{
-			get { return indexNodes; }
-		}
-
-		public string AugmentedTableRow
-		{
-			get { return this.augmentedTableRow; }
-			set { this.augmentedTableRow = value; }
-		}
-
-		public override string FullNodeName
-		{
-			get
-			{
-				string result = this.Name.ToLowerInvariant();
-				if (!result.Contains("table"))
-				{
-					result += "_table";
-				}
-
-				return result;				
-			}
-		}
-
-		protected override IEnumerable<SnmpScalarNode> AggregatedScalarNodes
-		{
-			get { return this.cellNodes; }
-		}
-
-		public override void GenerateCode(MibCFile mibFile)
-		{
-			FunctionDeclaration getInstanceMethodDecl = new FunctionDeclaration(this.FullNodeName + LwipDefs.FnctSuffix_GetInstance, isStatic: true);
-			getInstanceMethodDecl.Parameter.Add(new VariableType("column", LwipDefs.Vt_U32, "*", ConstType.Value));
-			getInstanceMethodDecl.Parameter.Add(new VariableType("row_oid", LwipDefs.Vt_U32, "*", ConstType.Value));
-			getInstanceMethodDecl.Parameter.Add(new VariableType("row_oid_len", LwipDefs.Vt_U8, ""));
-			getInstanceMethodDecl.Parameter.Add(new VariableType("cell_instance", LwipDefs.Vt_StNodeInstance, "*"));
-			getInstanceMethodDecl.ReturnType = new VariableType(null, LwipDefs.Vt_Snmp_err);
-			mibFile.Declarations.Add(getInstanceMethodDecl);
-
-			Function getInstanceMethod = Function.FromDeclaration(getInstanceMethodDecl);
-			GenerateGetInstanceMethodCode(getInstanceMethod);
-			mibFile.Implementation.Add(getInstanceMethod);
-
-
-			FunctionDeclaration getNextInstanceMethodDecl = new FunctionDeclaration(this.FullNodeName + LwipDefs.FnctSuffix_GetNextInstance, isStatic: true);
-			getNextInstanceMethodDecl.Parameter.Add(new VariableType("column", LwipDefs.Vt_U32, "*", ConstType.Value));
-			getNextInstanceMethodDecl.Parameter.Add(new VariableType("row_oid", LwipDefs.Vt_StObjectId, "*"));
-			getNextInstanceMethodDecl.Parameter.Add(new VariableType("cell_instance", LwipDefs.Vt_StNodeInstance, "*"));
-			getNextInstanceMethodDecl.ReturnType = new VariableType(null, LwipDefs.Vt_Snmp_err);
-			mibFile.Declarations.Add(getNextInstanceMethodDecl);
-
-			Function getNextInstanceMethod = Function.FromDeclaration(getNextInstanceMethodDecl);
-			GenerateGetNextInstanceMethodCode(getNextInstanceMethod);
-			mibFile.Implementation.Add(getNextInstanceMethod);
-
-			
-			VariableType instanceType = new VariableType("cell_instance", LwipDefs.Vt_StNodeInstance, "*");
-			GenerateAggregatedCode(
-				mibFile,
-				instanceType,
-				String.Format("SNMP_TABLE_GET_COLUMN_FROM_OID({0}->instance_oid.id)", instanceType.Name));
-
-
-			#region create and add column/table definitions
-
-			StringBuilder colDefs = new StringBuilder();
-			foreach (SnmpScalarNode colNode in this.cellNodes)
-			{
-				colDefs.AppendFormat("  {{{0}, {1}, {2}}}, /* {3} */ \n",
-					colNode.Oid,
-					LwipDefs.GetAsn1DefForSnmpDataType(colNode.DataType),
-					LwipDefs.GetLwipDefForSnmpAccessMode(colNode.AccessMode),
-					colNode.Name);
-			}
-			if (colDefs.Length > 0)
-			{
-				colDefs.Length--;
-			}
-
-			VariableDeclaration colDefsDecl = new VariableDeclaration(
-				new VariableType(this.FullNodeName + "_columns", LwipDefs.Vt_StTableColumnDef, null, ConstType.Value, String.Empty),
-				"{\n" + colDefs + "\n}",
-				isStatic: true);
-
-			mibFile.Declarations.Add(colDefsDecl);
-
-			string nodeInitialization = String.Format("SNMP_TABLE_CREATE({0}, {1}, {2}, {3}, {4}, {5}, {6})",
-				this.Oid,
-				colDefsDecl.Type.Name,
-				getInstanceMethodDecl.Name, getNextInstanceMethodDecl.Name,
-				(this.GetMethodRequired) ? this.GetMethodName : LwipDefs.Null,
-				(this.TestMethodRequired) ? this.TestMethodName : LwipDefs.Null,
-				(this.SetMethodRequired) ? this.SetMethodName : LwipDefs.Null
-				);
-
-			mibFile.Declarations.Add(new VariableDeclaration(
-				new VariableType(this.FullNodeName, LwipDefs.Vt_StTableNode, null, ConstType.Value),
-				nodeInitialization,
-				isStatic: true));
-							
-			#endregion
-		}
-
-		protected virtual void GenerateGetInstanceMethodCode(Function getInstanceMethod)
-		{
-			VariableDeclaration returnValue = new VariableDeclaration((VariableType)getInstanceMethod.ReturnType.Clone(), LwipDefs.Def_ErrorCode_NoSuchInstance);
-			returnValue.Type.Name = "err";
-			getInstanceMethod.Declarations.Add(returnValue);
-
-			int instanceOidLength = 0;
-			StringBuilder indexColumns = new StringBuilder();
-			foreach (SnmpScalarNode indexNode in this.indexNodes)
-			{
-				if (instanceOidLength >= 0)
-				{
-					if (indexNode.OidRepresentationLen >= 0)
-					{
-						instanceOidLength += indexNode.OidRepresentationLen;
-					}
-					else
-					{
-						// at least one index column has a variable length -> we cannot perform a static check
-						instanceOidLength = -1;
-					}
-				}
-
-				indexColumns.AppendFormat(
-					" {0} ({1}, OID length = {2})\n",
-					indexNode.Name,
-					indexNode.DataType,
-					(indexNode.OidRepresentationLen >= 0) ? indexNode.OidRepresentationLen.ToString() : "variable");
-			}
-			if (indexColumns.Length > 0)
-			{
-				indexColumns.Length--;
-
-				getInstanceMethod.Declarations.Insert(0, new Comment(String.Format(
-					"The instance OID of this table consists of following (index) column(s):\n{0}",
-					indexColumns)));
-			}
-
-			string augmentsHint = "";
-			if (!String.IsNullOrWhiteSpace(this.augmentedTableRow))
-			{
-				augmentsHint = String.Format(
-					"This table augments table '{0}'! Index columns therefore belong to table '{0}'!\n" + 
-					"You may simply call the '*{1}' method of this table.\n\n",
-					(this.augmentedTableRow.ToLowerInvariant().EndsWith("entry")) ? this.augmentedTableRow.Substring(0, this.augmentedTableRow.Length-5) : this.augmentedTableRow,
-					LwipDefs.FnctSuffix_GetInstance);
-			}
-
-			CodeContainerBase ccb = getInstanceMethod;
-			if (instanceOidLength > 0)
-			{
-				IfThenElse ite = new IfThenElse(String.Format("{0} == {1}", getInstanceMethod.Parameter[2].Name, instanceOidLength));
-				getInstanceMethod.AddElement(ite);
-				ccb = ite;
-			}
-
-			ccb.AddCodeFormat("LWIP_UNUSED_ARG({0});", getInstanceMethod.Parameter[0].Name);
-			ccb.AddCodeFormat("LWIP_UNUSED_ARG({0});", getInstanceMethod.Parameter[1].Name);
-			if (instanceOidLength <= 0)
-			{
-				ccb.AddCodeFormat("LWIP_UNUSED_ARG({0});", getInstanceMethod.Parameter[2].Name);
-			}
-			ccb.AddCodeFormat("LWIP_UNUSED_ARG({0});", getInstanceMethod.Parameter[3].Name);
-
-			ccb.AddElement(new Comment(String.Format(
-				"TODO: check if '{0}'/'{1}' params contain a valid instance oid for a row\n" +
-				"If so, set '{2} = {3};'\n\n" + 
-				"snmp_oid_* methods may be used for easier processing of oid\n\n" + 
-				"{4}" + 
-				"In order to avoid decoding OID a second time in subsequent get_value/set_test/set_value methods,\n" +
-				"you may store an arbitrary value (like a pointer to target value object) in '{5}->reference'/'{5}->reference_len'.\n" +
-				"But be aware that not always a subsequent method is called -> Do NOT allocate memory here and try to release it in subsequent methods!\n\n" +
-				"You also may replace function pointers in '{5}' param for get/test/set methods which contain the default values from table definition,\n" +
-				"in order to provide special methods, for the currently processed cell. Changed pointers are only valid for current request.",
-				getInstanceMethod.Parameter[1].Name,
-				getInstanceMethod.Parameter[2].Name,
-				returnValue.Type.Name,
-				LwipDefs.Def_ErrorCode_Ok,
-				augmentsHint,
-				getInstanceMethod.Parameter[3].Name
-				)));
-
-			getInstanceMethod.AddCodeFormat("return {0};", returnValue.Type.Name);
-		}
-
-		protected virtual void GenerateGetNextInstanceMethodCode(Function getNextInstanceMethod)
-		{
-			getNextInstanceMethod.AddCodeFormat("LWIP_UNUSED_ARG({0});", getNextInstanceMethod.Parameter[0].Name);
-			getNextInstanceMethod.AddCodeFormat("LWIP_UNUSED_ARG({0});", getNextInstanceMethod.Parameter[1].Name);
-			getNextInstanceMethod.AddCodeFormat("LWIP_UNUSED_ARG({0});", getNextInstanceMethod.Parameter[2].Name);
-
-			VariableDeclaration returnValue = new VariableDeclaration((VariableType)getNextInstanceMethod.ReturnType.Clone(), LwipDefs.Def_ErrorCode_NoSuchInstance);
-			returnValue.Type.Name = "err";
-			getNextInstanceMethod.Declarations.Add(returnValue);
-
-			StringBuilder indexColumns = new StringBuilder();
-			foreach (SnmpScalarNode indexNode in this.indexNodes)
-			{
-				indexColumns.AppendFormat(
-					" {0} ({1}, OID length = {2})\n",
-					indexNode.Name,
-					indexNode.DataType,
-					(indexNode.OidRepresentationLen >= 0) ? indexNode.OidRepresentationLen.ToString() : "variable");
-			}
-			if (indexColumns.Length > 0)
-			{
-				indexColumns.Length--;
-
-				getNextInstanceMethod.Declarations.Insert(0, new Comment(String.Format(
-					"The instance OID of this table consists of following (index) column(s):\n{0}",
-					indexColumns)));
-			}
-
-			string augmentsHint = "";
-			if (!String.IsNullOrWhiteSpace(this.augmentedTableRow))
-			{
-				augmentsHint = String.Format(
-					"This table augments table '{0}'! Index columns therefore belong to table '{0}'!\n" + 
-					"You may simply call the '*{1}' method of this table.\n\n",
-					(this.augmentedTableRow.ToLowerInvariant().EndsWith("entry")) ? this.augmentedTableRow.Substring(0, this.augmentedTableRow.Length-5) : this.augmentedTableRow,
-					LwipDefs.FnctSuffix_GetNextInstance);
-			}
-
-			getNextInstanceMethod.AddElement(new Comment(String.Format(
-				"TODO: analyze '{0}->id'/'{0}->len' and return the subsequent row instance\n" +
-				"Be aware that '{0}->id'/'{0}->len' must not point to a valid instance or have correct instance length.\n" +
-				"If '{0}->len' is 0, return the first instance. If '{0}->len' is longer than expected, cut superfluous OID parts.\n" +
-				"If a valid next instance is found, store it in '{0}->id'/'{0}->len' and set '{1} = {2};'\n\n" + 
-				"snmp_oid_* methods may be used for easier processing of oid\n\n" + 
-				"{3}" + 
-				"In order to avoid decoding OID a second time in subsequent get_value/set_test/set_value methods,\n" +
-				"you may store an arbitrary value (like a pointer to target value object) in '{4}->reference'/'{4}->reference_len'.\n" +
-				"But be aware that not always a subsequent method is called -> Do NOT allocate memory here and try to release it in subsequent methods!\n\n" +
-				"You also may replace function pointers in '{4}' param for get/test/set methods which contain the default values from table definition,\n" +
-				"in order to provide special methods, for the currently processed cell. Changed pointers are only valid for current request.",
-				getNextInstanceMethod.Parameter[1].Name,
-				returnValue.Type.Name,
-				LwipDefs.Def_ErrorCode_Ok,
-				augmentsHint,
-				getNextInstanceMethod.Parameter[2].Name
-				)));
-
-			getNextInstanceMethod.AddElement(new Comment(String.Format(
-				"For easier processing and getting the next instance, you may use the 'snmp_next_oid_*' enumerator.\n" +
-				"Simply pass all known instance OID's to it and it returns the next valid one:\n\n" +
-				"{0} state;\n" +
-				"{1} result_buf;\n" +
-				"snmp_next_oid_init(&state, {2}->id, {2}->len, result_buf.id, SNMP_MAX_OBJ_ID_LEN);\n" + 
-				"while ({{not all instances passed}}) {{\n" + 
-				"  {1} test_oid;\n" + 
-				"  {{fill test_oid to create instance oid for next instance}}\n" + 
-				"  snmp_next_oid_check(&state, test_oid.id, test_oid.len, {{target_data_ptr}});\n" + 
-				"}}\n" + 
-				"if(state.status == SNMP_NEXT_OID_STATUS_SUCCESS) {{\n" + 
-				"  snmp_oid_assign(row_oid, state.next_oid, state.next_oid_len);\n" +
-				"  {3}->reference.ptr = state.reference; //==target_data_ptr, for usage in subsequent get/test/set\n" + 
-				"  {4} = {5};\n" + 
-				"}}"
-				,
-				LwipDefs.Vt_StNextOidState,
-				LwipDefs.Vt_StObjectId,
-				getNextInstanceMethod.Parameter[1].Name,
-				getNextInstanceMethod.Parameter[2].Name,
-				returnValue.Type.Name,
-				LwipDefs.Def_ErrorCode_Ok
-				)));
-
-			getNextInstanceMethod.AddCodeFormat("return {0};", returnValue.Type.Name);
-		}
-
-	}
-}
diff --git a/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/SnmpTreeNode.cs b/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/SnmpTreeNode.cs
deleted file mode 100644
index bf0c604e..00000000
--- a/contrib/apps/LwipMibCompiler/LwipSnmpCodeGeneration/SnmpTreeNode.cs
+++ /dev/null
@@ -1,242 +0,0 @@
-﻿/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Martin Hentschel <info@cl-soft.de>
- *
- */
-
-using System;
-using System.Collections.Generic;
-using System.Text;
-using CCodeGeneration;
-
-namespace LwipSnmpCodeGeneration
-{
-	public class SnmpTreeNode: SnmpScalarAggregationNode
-	{
-		private readonly List<SnmpNode> childNodes       = new List<SnmpNode>();
-		private readonly List<SnmpScalarNode> childScalarNodes = new List<SnmpScalarNode>();
-		private string fullOid = "";
-
-		public SnmpTreeNode(SnmpTreeNode parentNode)
-			: base(parentNode)
-		{
-		}
-
-		public override string FullNodeName
-		{
-			get { return this.Name.ToLowerInvariant() + "_treenode"; }
-		}
-
-		public string FullOid
-		{
-			get { return this.fullOid; }
-			set { this.fullOid = value; }
-		}
-
-		public List<SnmpNode> ChildNodes
-		{
-			get { return this.childNodes; }
-		}
-
-		protected override IEnumerable<SnmpScalarNode> AggregatedScalarNodes
-		{
-			get { return this.childScalarNodes; }
-		}
-
-		private void GenerateAggregatedCode(MibCFile mibFile, bool generateDeclarations, bool generateImplementations)
-		{
-			VariableType instanceType = new VariableType("instance", LwipDefs.Vt_StNodeInstance, "*");
-			base.GenerateAggregatedCode(
-				mibFile,
-				instanceType,
-				String.Format("{0}->node->oid", instanceType.Name),
-				generateDeclarations,
-				generateImplementations);
-		}
-
-		private void GenerateAggregateMethodDeclarations(MibCFile mibFile)
-		{
-			if (LwipOpts.GenerateSingleAccessMethodsForTreeNodeScalars && (this.childScalarNodes.Count > 1))
-			{
-				GenerateAggregatedCode(mibFile, true, false);
-			}
-		}
-
-		public override void GenerateCode(MibCFile mibFile)
-		{
-			string nodeInitialization;
-
-			if (LwipOpts.GenerateSingleAccessMethodsForTreeNodeScalars && (this.childScalarNodes.Count > 1))
-			{
-				GenerateAggregatedCode(mibFile, false, true);
-			}
-
-			// create and add node declaration
-			if (this.childNodes.Count > 0)
-			{
-				StringBuilder subnodeArrayInitialization = new StringBuilder();
-
-				for (int i=0; i<this.childNodes.Count; i++)
-				{
-					subnodeArrayInitialization.Append("  &");
-					subnodeArrayInitialization.Append(this.childNodes[i].FullNodeName);
-					subnodeArrayInitialization.Append(".node");
-					if (!(this.childNodes[i] is SnmpTreeNode))
-					{
-						subnodeArrayInitialization.Append(".node");
-					}
-
-					if (i < (this.childNodes.Count - 1))
-					{
-						subnodeArrayInitialization.Append(",\n");
-					}
-				}
-
-				VariableDeclaration subnodeArray = new VariableDeclaration(
-					new VariableType(this.Name.ToLowerInvariant() + "_subnodes", LwipDefs.Vt_StNode, "*", ConstType.Both, String.Empty),
-					"{\n" + subnodeArrayInitialization + "\n}",
-					isStatic: true);
-
-				mibFile.Declarations.Add(subnodeArray);
-
-				nodeInitialization = String.Format("SNMP_CREATE_TREE_NODE({0}, {1})", this.Oid, subnodeArray.Type.Name);
-			}
-			else
-			{
-				nodeInitialization = String.Format("SNMP_CREATE_EMPTY_TREE_NODE({0})", this.Oid);
-			}
-
-			mibFile.Declarations.Add(new VariableDeclaration(
-				new VariableType(this.FullNodeName, LwipDefs.Vt_StTreeNode, null, ConstType.Value),
-				nodeInitialization,
-				isStatic: true));
-		}
-
-		public override void Analyze()
-		{
-			this.childScalarNodes.Clear();
-
-			// delegate analyze (don't use enumerator because the child node may change our child collection by e.g. removing or replacing itself)
-			for (int i=this.ChildNodes.Count-1; i>=0; i--)
-			{
-				this.ChildNodes[i].Analyze();
-			}
-
-			// collect scalar nodes
-			foreach (SnmpNode childNode in this.childNodes)
-			{
-				SnmpScalarNode scalarNode = childNode as SnmpScalarNode;
-				if (scalarNode != null)
-				{
-					this.childScalarNodes.Add(scalarNode);
-				}
-			}
-
-			base.Analyze();
-
-			// check if we can merge this node to a scalar array node (all childs need to be scalars)
-			if (this.childNodes.Count > 0)
-			{
-				if (LwipOpts.GenerateScalarArrays && (this.childScalarNodes.Count == this.childNodes.Count) && (this.ParentNode != null))
-				{
-					SnmpScalarArrayNode scalarArrayNode = new SnmpScalarArrayNode(this.childScalarNodes, this.ParentNode);
-					scalarArrayNode.Oid  = this.Oid;
-					scalarArrayNode.Name = this.Name;
-					scalarArrayNode.Analyze();
-
-					for (int i=0; i<this.ParentNode.ChildNodes.Count; i++)
-					{
-						if (this.ParentNode.ChildNodes[i] == this)
-						{
-							this.ParentNode.ChildNodes.RemoveAt(i);
-							this.ParentNode.ChildNodes.Insert(i, scalarArrayNode);
-							break;
-						}
-					}
-				}
-				else if (LwipOpts.GenerateSingleAccessMethodsForTreeNodeScalars && (this.childScalarNodes.Count > 1))
-				{
-					foreach (SnmpScalarNode scalarNode in this.childScalarNodes)
-					{
-						scalarNode.UseExternalMethods = true;
-						scalarNode.ExternalGetMethod  = this.GetMethodName;
-						scalarNode.ExternalTestMethod = this.TestMethodName;
-						scalarNode.ExternalSetMethod  = this.SetMethodName;
-					}
-				}
-			}
-			else // if (this.childNodes.Count == 0)
-			{
-				if (!LwipOpts.GenerateEmptyFolders && (this.ParentNode != null))
-				{
-					// do not generate this empty folder because it only waste (static) memory
-					for (int i=0; i<this.ParentNode.ChildNodes.Count; i++)
-					{
-						if (this.ParentNode.ChildNodes[i] == this)
-						{
-							this.ParentNode.ChildNodes.RemoveAt(i);
-							break;
-						}
-					}
-				}
-			}
-		}
-
-		public override void Generate(MibCFile generatedFile, MibHeaderFile generatedHeaderFile)
-		{
-			// generate code of child nodes
-			foreach (SnmpNode childNode in this.childNodes)
-			{
-				if (childNode is SnmpTreeNode)
-				{
-					childNode.Generate(generatedFile, generatedHeaderFile);
-				}
-			}
-
-			Comment dividerComment = new Comment(
-				String.Format("--- {0} {1} -----------------------------------------------------", this.Name, this.fullOid),
-				singleLine: true);
-
-			generatedFile.Declarations.Add(dividerComment);
-			generatedFile.Implementation.Add(dividerComment);
-
-			this.GenerateAggregateMethodDeclarations(generatedFile);
-
-			foreach (SnmpNode childNode in this.childNodes)
-			{
-				if (!(childNode is SnmpTreeNode))
-				{
-					childNode.Generate(generatedFile, generatedHeaderFile);
-				}
-			}
-
-			base.Generate(generatedFile, generatedHeaderFile);
-		}
-	}
-}
diff --git a/contrib/apps/LwipMibCompiler/MibViewer/FormMain.Designer.cs b/contrib/apps/LwipMibCompiler/MibViewer/FormMain.Designer.cs
deleted file mode 100644
index dcd19aa5..00000000
--- a/contrib/apps/LwipMibCompiler/MibViewer/FormMain.Designer.cs
+++ /dev/null
@@ -1,166 +0,0 @@
-﻿namespace LwipMibViewer
-{
-	partial class FormMain
-	{
-		/// <summary>
-		/// Erforderliche Designervariable.
-		/// </summary>
-		private System.ComponentModel.IContainer components = null;
-
-		/// <summary>
-		/// Verwendete Ressourcen bereinigen.
-		/// </summary>
-		/// <param name="disposing">True, wenn verwaltete Ressourcen gelöscht werden sollen; andernfalls False.</param>
-		protected override void Dispose(bool disposing)
-		{
-			if (disposing && (components != null))
-			{
-				components.Dispose();
-			}
-			base.Dispose(disposing);
-		}
-
-		#region Vom Windows Form-Designer generierter Code
-
-		/// <summary>
-		/// Erforderliche Methode für die Designerunterstützung.
-		/// Der Inhalt der Methode darf nicht mit dem Code-Editor geändert werden.
-		/// </summary>
-		private void InitializeComponent()
-		{
-            this.components = new System.ComponentModel.Container();
-            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(FormMain));
-            this.treeMib = new System.Windows.Forms.TreeView();
-            this.imagelistTreeNodeImages = new System.Windows.Forms.ImageList(this.components);
-            this.splitContainerMain = new System.Windows.Forms.SplitContainer();
-            this.listviewNodeDetails = new System.Windows.Forms.ListView();
-            this.columnHeader1 = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
-            this.columnHeader2 = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
-            this.toolStripMain = new System.Windows.Forms.ToolStrip();
-            this.toolbuttonOpenMib = new System.Windows.Forms.ToolStripButton();
-            this.dialogOpenMib = new System.Windows.Forms.OpenFileDialog();
-            ((System.ComponentModel.ISupportInitialize)(this.splitContainerMain)).BeginInit();
-            this.splitContainerMain.Panel1.SuspendLayout();
-            this.splitContainerMain.Panel2.SuspendLayout();
-            this.splitContainerMain.SuspendLayout();
-            this.toolStripMain.SuspendLayout();
-            this.SuspendLayout();
-            // 
-            // treeMib
-            // 
-            this.treeMib.Dock = System.Windows.Forms.DockStyle.Fill;
-            this.treeMib.ImageIndex = 0;
-            this.treeMib.ImageList = this.imagelistTreeNodeImages;
-            this.treeMib.Location = new System.Drawing.Point(0, 0);
-            this.treeMib.Name = "treeMib";
-            this.treeMib.SelectedImageIndex = 0;
-            this.treeMib.Size = new System.Drawing.Size(1028, 418);
-            this.treeMib.TabIndex = 0;
-            this.treeMib.AfterSelect += new System.Windows.Forms.TreeViewEventHandler(this.treeMib_AfterSelect);
-            // 
-            // imagelistTreeNodeImages
-            // 
-            this.imagelistTreeNodeImages.ImageStream = ((System.Windows.Forms.ImageListStreamer)(resources.GetObject("imagelistTreeNodeImages.ImageStream")));
-            this.imagelistTreeNodeImages.TransparentColor = System.Drawing.Color.Transparent;
-            this.imagelistTreeNodeImages.Images.SetKeyName(0, "ntimgContainer");
-            this.imagelistTreeNodeImages.Images.SetKeyName(1, "ntimgTable");
-            this.imagelistTreeNodeImages.Images.SetKeyName(2, "ntimgRow");
-            this.imagelistTreeNodeImages.Images.SetKeyName(3, "ntimgColumn");
-            this.imagelistTreeNodeImages.Images.SetKeyName(4, "ntimgScalar");
-            this.imagelistTreeNodeImages.Images.SetKeyName(5, "ntimgUnknown");
-            // 
-            // splitContainerMain
-            // 
-            this.splitContainerMain.Dock = System.Windows.Forms.DockStyle.Fill;
-            this.splitContainerMain.Location = new System.Drawing.Point(0, 25);
-            this.splitContainerMain.Name = "splitContainerMain";
-            this.splitContainerMain.Orientation = System.Windows.Forms.Orientation.Horizontal;
-            // 
-            // splitContainerMain.Panel1
-            // 
-            this.splitContainerMain.Panel1.Controls.Add(this.treeMib);
-            // 
-            // splitContainerMain.Panel2
-            // 
-            this.splitContainerMain.Panel2.Controls.Add(this.listviewNodeDetails);
-            this.splitContainerMain.Size = new System.Drawing.Size(1028, 625);
-            this.splitContainerMain.SplitterDistance = 418;
-            this.splitContainerMain.TabIndex = 1;
-            // 
-            // listviewNodeDetails
-            // 
-            this.listviewNodeDetails.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
-            this.columnHeader1,
-            this.columnHeader2});
-            this.listviewNodeDetails.Dock = System.Windows.Forms.DockStyle.Fill;
-            this.listviewNodeDetails.FullRowSelect = true;
-            this.listviewNodeDetails.HeaderStyle = System.Windows.Forms.ColumnHeaderStyle.None;
-            this.listviewNodeDetails.Location = new System.Drawing.Point(0, 0);
-            this.listviewNodeDetails.Name = "listviewNodeDetails";
-            this.listviewNodeDetails.Size = new System.Drawing.Size(1028, 203);
-            this.listviewNodeDetails.TabIndex = 0;
-            this.listviewNodeDetails.UseCompatibleStateImageBehavior = false;
-            this.listviewNodeDetails.View = System.Windows.Forms.View.Details;
-            // 
-            // columnHeader1
-            // 
-            this.columnHeader1.Text = "";
-            this.columnHeader1.Width = 150;
-            // 
-            // columnHeader2
-            // 
-            this.columnHeader2.Text = "";
-            this.columnHeader2.Width = 777;
-            // 
-            // toolStripMain
-            // 
-            this.toolStripMain.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
-            this.toolbuttonOpenMib});
-            this.toolStripMain.Location = new System.Drawing.Point(0, 0);
-            this.toolStripMain.Name = "toolStripMain";
-            this.toolStripMain.Size = new System.Drawing.Size(1028, 25);
-            this.toolStripMain.TabIndex = 2;
-            // 
-            // toolbuttonOpenMib
-            // 
-            this.toolbuttonOpenMib.Image = ((System.Drawing.Image)(resources.GetObject("toolbuttonOpenMib.Image")));
-            this.toolbuttonOpenMib.Name = "toolbuttonOpenMib";
-            this.toolbuttonOpenMib.Size = new System.Drawing.Size(65, 22);
-            this.toolbuttonOpenMib.Text = "Open...";
-            this.toolbuttonOpenMib.Click += new System.EventHandler(this.toolbuttonOpenMib_Click);
-            // 
-            // FormMain
-            // 
-            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
-            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
-            this.ClientSize = new System.Drawing.Size(1028, 650);
-            this.Controls.Add(this.splitContainerMain);
-            this.Controls.Add(this.toolStripMain);
-            this.Name = "FormMain";
-            this.Text = "MIB Viewer";
-            this.WindowState = System.Windows.Forms.FormWindowState.Maximized;
-            this.splitContainerMain.Panel1.ResumeLayout(false);
-            this.splitContainerMain.Panel2.ResumeLayout(false);
-            ((System.ComponentModel.ISupportInitialize)(this.splitContainerMain)).EndInit();
-            this.splitContainerMain.ResumeLayout(false);
-            this.toolStripMain.ResumeLayout(false);
-            this.toolStripMain.PerformLayout();
-            this.ResumeLayout(false);
-            this.PerformLayout();
-
-		}
-
-		#endregion
-
-		private System.Windows.Forms.TreeView treeMib;
-        private System.Windows.Forms.SplitContainer splitContainerMain;
-        private System.Windows.Forms.ListView listviewNodeDetails;
-        private System.Windows.Forms.ColumnHeader columnHeader1;
-        private System.Windows.Forms.ColumnHeader columnHeader2;
-        private System.Windows.Forms.ImageList imagelistTreeNodeImages;
-        private System.Windows.Forms.ToolStrip toolStripMain;
-        private System.Windows.Forms.ToolStripButton toolbuttonOpenMib;
-        private System.Windows.Forms.OpenFileDialog dialogOpenMib;
-	}
-}
-
diff --git a/contrib/apps/LwipMibCompiler/MibViewer/FormMain.cs b/contrib/apps/LwipMibCompiler/MibViewer/FormMain.cs
deleted file mode 100644
index 7d2490db..00000000
--- a/contrib/apps/LwipMibCompiler/MibViewer/FormMain.cs
+++ /dev/null
@@ -1,217 +0,0 @@
-﻿/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Martin Hentschel <info@cl-soft.de>
- *
- */
-
-using System.Windows.Forms;
-using Lextm.SharpSnmpLib.Mib;
-using Lextm.SharpSnmpLib.Mib.Elements;
-using Lextm.SharpSnmpLib.Mib.Elements.Types;
-using Lextm.SharpSnmpLib.Mib.Elements.Entities;
-using System.IO;
-
-namespace LwipMibViewer
-{
-	public partial class FormMain : Form
-	{
-		readonly ListViewGroup listviewgroupAbstract;
-		readonly ListViewGroup listviewgroupElement;
-		readonly ListViewGroup listviewgroupBaseType;
-		readonly ListViewGroup listviewgroupTypeChain;
-
-		public FormMain()
-		{
-			this.Font = SystemInformation.MenuFont;
-			InitializeComponent();
-
-			this.listviewgroupAbstract = new ListViewGroup("Abstract", System.Windows.Forms.HorizontalAlignment.Left);
-			this.listviewgroupElement = new ListViewGroup("Element Properties", System.Windows.Forms.HorizontalAlignment.Left);
-			this.listviewgroupBaseType = new ListViewGroup("Element Base Type", System.Windows.Forms.HorizontalAlignment.Left);
-			this.listviewgroupTypeChain = new ListViewGroup("Element Type Chain", System.Windows.Forms.HorizontalAlignment.Left);
-			this.listviewNodeDetails.Groups.AddRange(new System.Windows.Forms.ListViewGroup[] {
-					 listviewgroupAbstract,
-					 listviewgroupElement,
-					 listviewgroupBaseType,
-					 listviewgroupTypeChain});
-
-			try
-			{
-				DirectoryInfo dirInfo = new DirectoryInfo(Path.GetDirectoryName(Application.ExecutablePath));
-				if (dirInfo != null)
-				{
-					dirInfo = dirInfo.Parent;
-					if (dirInfo != null)
-					{
-						dirInfo = dirInfo.Parent;
-						if (dirInfo != null)
-						{
-							dirInfo = new DirectoryInfo(Path.Combine(dirInfo.FullName, "Mibs"));
-							if (dirInfo.Exists)
-							{
-								MibTypesResolver.RegisterResolver(new FileSystemMibResolver(dirInfo.FullName, true));
-							}
-						}
-					}
-				}
-			}
-			catch
-			{ }
-		}
-
-		#region GUI Event Handler
-
-		private void toolbuttonOpenMib_Click(object sender, System.EventArgs e)
-		{
-			if (this.dialogOpenMib.ShowDialog() == DialogResult.OK)
-			{
-				OpenMib(this.dialogOpenMib.FileName);
-			}
-		}
-
-		private void treeMib_AfterSelect(object sender, TreeViewEventArgs e)
-		{
-			listviewNodeDetails.Items.Clear();
-
-			if (e.Node != null)
-			{
-				MibTreeNode mtn = e.Node.Tag as MibTreeNode;
-				if (mtn != null)
-				{
-					listviewNodeDetails.Items.Add(new ListViewItem(new string[] { "Abstract", mtn.NodeType.ToString() }, this.listviewgroupAbstract));
-
-					listviewNodeDetails.Items.Add(new ListViewItem(new string[] { "Module", (mtn.Entity.Module != null) ? mtn.Entity.Module.Name : "" }, this.listviewgroupElement));
-					listviewNodeDetails.Items.Add(new ListViewItem(new string[] { "Type", mtn.Entity.GetType().Name }, this.listviewgroupElement));
-					listviewNodeDetails.Items.Add(new ListViewItem(new string[] { "Name", mtn.Entity.Name }, this.listviewgroupElement));
-					listviewNodeDetails.Items.Add(new ListViewItem(new string[] { "Description", mtn.Entity.Description }, this.listviewgroupElement));
-					listviewNodeDetails.Items.Add(new ListViewItem(new string[] { "OID", mtn.Entity.Value.ToString() }, this.listviewgroupElement));
-					listviewNodeDetails.Items.Add(new ListViewItem(new string[] { "Full OID", MibTypesResolver.ResolveOid(mtn.Entity).GetOidString() }, this.listviewgroupElement));
-					if (mtn.Entity is ObjectType)
-					{
-						listviewNodeDetails.Items.Add(new ListViewItem(new string[] { "Access", (mtn.Entity as ObjectType).Access.ToString() }, this.listviewgroupElement));
-					}
-
-					ITypeReferrer tr = mtn.Entity as ITypeReferrer;
-					if (tr != null)
-					{
-						ShowTypeDetails(listviewNodeDetails, this.listviewgroupBaseType, tr.BaseType);
-						ShowTypeChain(listviewNodeDetails, tr.ReferredType);
-					}
-				}
-			}
-		}
-
-		#endregion
-
-		#region Methods
-
-		private void OpenMib(string file)
-		{
-			try
-			{
-				MibDocument md = new MibDocument(file);
-				MibTypesResolver.ResolveTypes(md.Modules[0]);
-
-				this.treeMib.Nodes.Clear();
-				this.listviewNodeDetails.Items.Clear();
-
-				MibTree mt = new MibTree(md.Modules[0] as MibModule);
-				foreach (MibTreeNode mibTreeNode in mt.Root)
-				{
-					AddNode(mibTreeNode, this.treeMib.Nodes);
-
-					foreach (TreeNode node in this.treeMib.Nodes)
-					{
-						node.Expand();
-					}
-				}
-			}
-			catch
-			{
-			}
-		}
-
-		private void AddNode(MibTreeNode mibNode, TreeNodeCollection parentNodes)
-		{
-			int imgIndex = 5; //unknown
-			if ((mibNode.NodeType & MibTreeNodeType.Table) != 0)
-			{
-				imgIndex = 1;
-			}
-			else if ((mibNode.NodeType & MibTreeNodeType.TableRow) != 0)
-			{
-				imgIndex = 2;
-			}
-			else if ((mibNode.NodeType & MibTreeNodeType.TableCell) != 0)
-			{
-				imgIndex = 3;
-			}
-			else if ((mibNode.NodeType & MibTreeNodeType.Scalar) != 0)
-			{
-				imgIndex = 4;
-			}
-			else if ((mibNode.NodeType & MibTreeNodeType.Container) != 0)
-			{
-				imgIndex = 0;
-			}
-
-			TreeNode newNode = new TreeNode(mibNode.Entity.Name, imgIndex, imgIndex);
-			newNode.Tag = mibNode;
-
-			parentNodes.Add(newNode);
-
-			foreach (MibTreeNode child in mibNode.ChildNodes)
-			{
-				AddNode(child, newNode.Nodes);
-			}
-		}
-
-		private void ShowTypeChain(ListView lv, ITypeAssignment type)
-		{
-			ShowTypeDetails(lv, this.listviewgroupTypeChain, type);
-
-			ITypeReferrer tr = type as ITypeReferrer;
-			if ((tr != null) && (tr.ReferredType != null))
-			{
-				lv.Items.Add(new ListViewItem(new string[] { " >>>", "" }, this.listviewgroupTypeChain));
-				ShowTypeChain(listviewNodeDetails, tr.ReferredType);
-			}
-		}
-
-		private void ShowTypeDetails(ListView lv, ListViewGroup lvg, ITypeAssignment type)
-		{
-			lv.Items.Add(new ListViewItem(new string[] { "Module", (type.Module != null) ? type.Module.Name : "" }, lvg));
-			lv.Items.Add(new ListViewItem(new string[] { "Type", type.GetType().Name }, lvg));
-			lv.Items.Add(new ListViewItem(new string[] { "Name", type.Name }, lvg));
-		}
-
-		#endregion
-
-	}
-}
diff --git a/contrib/apps/LwipMibCompiler/MibViewer/FormMain.resx b/contrib/apps/LwipMibCompiler/MibViewer/FormMain.resx
deleted file mode 100644
index 973f546b..00000000
--- a/contrib/apps/LwipMibCompiler/MibViewer/FormMain.resx
+++ /dev/null
@@ -1,298 +0,0 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<root>
-  <!-- 
-    Microsoft ResX Schema 
-    
-    Version 2.0
-    
-    The primary goals of this format is to allow a simple XML format 
-    that is mostly human readable. The generation and parsing of the 
-    various data types are done through the TypeConverter classes 
-    associated with the data types.
-    
-    Example:
-    
-    ... ado.net/XML headers & schema ...
-    <resheader name="resmimetype">text/microsoft-resx</resheader>
-    <resheader name="version">2.0</resheader>
-    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
-    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
-    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
-    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
-    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
-        <value>[base64 mime encoded serialized .NET Framework object]</value>
-    </data>
-    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
-        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
-        <comment>This is a comment</comment>
-    </data>
-                
-    There are any number of "resheader" rows that contain simple 
-    name/value pairs.
-    
-    Each data row contains a name, and value. The row also contains a 
-    type or mimetype. Type corresponds to a .NET class that support 
-    text/value conversion through the TypeConverter architecture. 
-    Classes that don't support this are serialized and stored with the 
-    mimetype set.
-    
-    The mimetype is used for serialized objects, and tells the 
-    ResXResourceReader how to depersist the object. This is currently not 
-    extensible. For a given mimetype the value must be set accordingly:
-    
-    Note - application/x-microsoft.net.object.binary.base64 is the format 
-    that the ResXResourceWriter will generate, however the reader can 
-    read any of the formats listed below.
-    
-    mimetype: application/x-microsoft.net.object.binary.base64
-    value   : The object must be serialized with 
-            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
-            : and then encoded with base64 encoding.
-    
-    mimetype: application/x-microsoft.net.object.soap.base64
-    value   : The object must be serialized with 
-            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
-            : and then encoded with base64 encoding.
-
-    mimetype: application/x-microsoft.net.object.bytearray.base64
-    value   : The object must be serialized into a byte array 
-            : using a System.ComponentModel.TypeConverter
-            : and then encoded with base64 encoding.
-    -->
-  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
-    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
-    <xsd:element name="root" msdata:IsDataSet="true">
-      <xsd:complexType>
-        <xsd:choice maxOccurs="unbounded">
-          <xsd:element name="metadata">
-            <xsd:complexType>
-              <xsd:sequence>
-                <xsd:element name="value" type="xsd:string" minOccurs="0" />
-              </xsd:sequence>
-              <xsd:attribute name="name" use="required" type="xsd:string" />
-              <xsd:attribute name="type" type="xsd:string" />
-              <xsd:attribute name="mimetype" type="xsd:string" />
-              <xsd:attribute ref="xml:space" />
-            </xsd:complexType>
-          </xsd:element>
-          <xsd:element name="assembly">
-            <xsd:complexType>
-              <xsd:attribute name="alias" type="xsd:string" />
-              <xsd:attribute name="name" type="xsd:string" />
-            </xsd:complexType>
-          </xsd:element>
-          <xsd:element name="data">
-            <xsd:complexType>
-              <xsd:sequence>
-                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
-                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
-              </xsd:sequence>
-              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
-              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
-              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
-              <xsd:attribute ref="xml:space" />
-            </xsd:complexType>
-          </xsd:element>
-          <xsd:element name="resheader">
-            <xsd:complexType>
-              <xsd:sequence>
-                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
-              </xsd:sequence>
-              <xsd:attribute name="name" type="xsd:string" use="required" />
-            </xsd:complexType>
-          </xsd:element>
-        </xsd:choice>
-      </xsd:complexType>
-    </xsd:element>
-  </xsd:schema>
-  <resheader name="resmimetype">
-    <value>text/microsoft-resx</value>
-  </resheader>
-  <resheader name="version">
-    <value>2.0</value>
-  </resheader>
-  <resheader name="reader">
-    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
-  </resheader>
-  <resheader name="writer">
-    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
-  </resheader>
-  <metadata name="imagelistTreeNodeImages.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
-    <value>17, 17</value>
-  </metadata>
-  <data name="imagelistTreeNodeImages.ImageStream" mimetype="application/x-microsoft.net.object.binary.base64">
-    <value>
-        AAEAAAD/////AQAAAAAAAAAMAgAAAFdTeXN0ZW0uV2luZG93cy5Gb3JtcywgVmVyc2lvbj00LjAuMC4w
-        LCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPWI3N2E1YzU2MTkzNGUwODkFAQAAACZTeXN0
-        ZW0uV2luZG93cy5Gb3Jtcy5JbWFnZUxpc3RTdHJlYW1lcgEAAAAERGF0YQcCAgAAAAkDAAAADwMAAABo
-        IQAAAk1TRnQBSQFMAgEBBgEAARABAAEQAQABEAEAARABAAT/ASEBAAj/AUIBTQE2BwABNgMAASgDAAFA
-        AwABIAMAAQEBAAEgBgABIBIAAwQBBQMWAR4DIgEyAzEBTwJGAUQBhwMvAUsDHgErAxsBJgMYASIDFQEd
-        AxIBGAMNARIDCgENAwcBCQMEAQUDAQECAwQBBQMWAR4DIgEyAzEBTgJGAUQBhwMvAUsDHgErAxsBJgMb
-        ASYDIQExAyEBMAMdASoDGwEmAxgBIQMLAQ8DAQECgAADAgEDAwwBEAMrAUMCRgFEAYIC/wHwAf8CRgFE
-        AYIDKgFAAw8BFAMNAREDCwEPAwkBDAMHAQoDBQEHAwQBBQMCAQMDAAEBAwIBAwMLAQ8DKwFDAkYBRAGC
-        Av8B8AH/AkYBRAGCAyoBQAMOARMDEgEZAT0COwFpAVwBRQFCAawBZwE+AToBxAFaAUUBQwGqATwBOwE6
-        AWYDEAEWAwABAYQAAx4BKwJEAUIBewL/AfAB/wLpAdoD/wHxAf8CRAFCAXsDHgErJAADHgErAkQBQgF7
-        Av8B8AH/AukB2gP/AfEB/wJEAUIBewMeASsBLgItAUcBdwFHATwByQG7AVQBPQHxA+4B/wG7AVMBPAHx
-        AXcBRgE8AckBLgItAUeEAAMdASoCRAFCAXcC/wHwAf8B6wHdAbEB/wH3AcEBNwH/Ae0B3wGzA/8B8gH/
-        AkQBQgF3Ax0BKhwAAx0BKgJEAUIBdwL/AfAB/wLpAdoB/wLqAdwB/wLrAd4D/wHyAf8CRAFCAXcBZAFJ
-        AUIBrwG2AVkBQQHxAc0BVAEyAf8BvQF5AWIB/wHFAVABLgH/AbEBUQE1AfEBXAFIAUQBn4QAAkMBQQF2
-        Av8B8AH/AukB2gH/AecBqwEhAf8B5wGrASEB/wHnAasBIQH/AeoB2wGwA/8B9AH/AkMBQQF2Ax0BKhgA
-        AkMBQQF2Av8B8AH/AukB2gH/AuoB3AH/AusB3gH/AuwB3wH/Au0B4QP/AfQB/wGAAUQBMQHaAc4BcAFN
-        AfwBugFMASoB/wPSAf8BvgGLAXgB/wG7AVIBMgH8AW8BSQE/AbqEAAMdASkCQwFBAXQC/wHxAf8B5wHX
-        AasB/wHXAZYBDAH/AdcBlgEMAf8B1wGWAQwB/wHoAdgBrgP/AfUB/wJDAUEBdAMdASkUAAMdASkCQwFB
-        AXQC/wHxAf8C6wHeAf8C7AHfAf8C7QHhAf8C7gHjAf8C7wHlAf8BzQF5AV4B/wHOAXcBWAH3AbwBVAEy
-        Af8BtAFMASoB/wPmAf8BtwFlAUsB8AFdAUkBRAGdiAADHQEpAkIBQQFyAv8B8gH/AeUB1AGpAf8BzQGJ
-        AQAB/wHNAYkBAAH/Ac0BiQEAAf8B6AHXAa8D/wH3Af8CQgFBAXIDHAEoFAADHQEpAkIBQQFyAv8B8gH/
-        Au0B4QH/Au4B4wH/Au8B5QH/AvAB5wH/AeABuwGqAf8BzgFpAUgB/wHjAcsBwQH5BP8B3gHHAb0B9QF+
-        AU8BQgHEAi0BLAFFjAADHAEoAkEBQAFxAv8B9AH/AecB1gGsAf8B0QGOAQQB/wHRAY4BBAH/AdEBjgEE
-        Af8B7AHbAbMD/wH4Af8CQQFAAXEDHAEoFAADHAEoAkEBQAFxAv8B9AH/Au8B5QH/AvAB5wH/AvEB6QH/
-        AvMB6gH/AeQBvgGsAf8B1AGBAWIB/wGGAUoBNAHXAWYBTQFEAaoCLQEsAUWUAAMcAScCQQFAAW8C/wH1
-        Af8B7AHcAbMB/wHfAaEBFwH/Ad8BoQEXAf8B3wGhARcB/wHxAeIBuwP/AfoB/wJBAUABbwMcAScUAAMc
-        AScCQQFAAW8C/wH1Af8C8QHpAf8C8wHqAf8C9AHsAf8C9QHuAf8C9gHwA/8B+gH/AkEBQAFvAxwBJ5gA
-        AxwBJwJAAT8BbQL/AfcB/wHyAeMBuwH/AfABuAEuAf8B8AG4AS4B/wHwAbgBLgH/AvgB9AP/AfsB/wJA
-        AT8BbQMcAScUAAMcAScCQAE/AW0C/wH3Af8C9AHsAf8C9QHuAf8C9gHwAf8C9wHyAf8C+AH0A/8B+wH/
-        AkABPwFtAxwBJ5gAAxsBJgJAAT8BbAL/AfgB/wH3AeoBwwH/Af0ByQE/Af8B+QHsAccB/wL7AfcB/wL8
-        AfkD/wH8Af8CQAE/AWwDGwEmFAADGwEmAkABPwFsAv8B+AH/AvYB8AH/AvcB8gH/AvgB9AH/AvsB9wH/
-        AvwB+QP/AfwB/wJAAT8BbAMbASaYAAMbASYCPwE+AWsC/wH6Af8C+AH0Af8C+wH3Af8C3wHVAf8CyQG5
-        Af8C4AHWA/8B/gH/Aj8BPgFrGAADGwEmAj8BPgFrAv8B+gH/AvgB9AH/AvsB9wH/At8B1QH/AskBuQH/
-        AuAB1gP/Af4B/wI/AT4Ba5wAAxoBJQI/AT0BaQL/AfsB/wL8AfkB/wK8AawB/wQAArwBrAP/Af4B/wI/
-        AT0BaRwAAxoBJQI/AT0BaQL/AfsB/wL8AfkB/wK8AawB/wQAArwBrAP/Af4B/wI/AT0BaaAAAxoBJQI+
-        AT0BaAL/AfwB/wLLAcEB/wKgAZAB/wLLAcED/wH+Af8CPgE9AWggAAMaASUCPgE9AWgC/wH8Af8CywHB
-        Af8CoAGQAf8CywHBA/8B/gH/Aj4BPQFopAADGgElAj4BPQFnAv8B/gP/Af4D/wH+Bf8CPgE9AWckAAMa
-        ASUCPgE9AWcC/wH+A/8B/gP/Af4F/wI+AT0BZ6gAAxoBJAI+AT0BZgI+AT0BZgI+AT0BZgI+AT0BZgMx
-        AU0oAAMaASQCPgE9AWYCPgE9AWYCPgE9AWYCPgE9AWYDMQFNlAADIQEwAUABRgFIAXwBQwFOAVIBkgMF
-        AQccAAMHAQkDEAEWAxMBGgMTARoDEwEaAxMBGgMTARoDEwEaAxMBGgMTARoDEwEaAxMBGgMTARoDEwEa
-        AxABFgMHAQkDBwEJAxABFgMTARoDEwEaAxMBGgMTARoDEwEaAxMBGgMTARoDEwEaAxMBGgMTARoDEwEa
-        AxMBGgMQARYDBwEJAwcBCQMQARYDEwEaAxMBGgMTARoDEwEaAxMBGgMTARoDEwEaAxMBGgMTARoDEwEa
-        AxMBGgMTARoDEAEWAwcBCQwAAjIBMwFQAUMBUQFXAZkBRQFkAXQBwAFYAYsBogHgATwBWAFqAcEDEwEa
-        AwUBBxgAAjwBOwFpAkYBRAGHAkYBRAGHAkYBRAGHAkYBRAGHAkYBRAGHAkYBRAGHAkYBRAGHAkYBRAGH
-        AkYBRAGHAkYBRAGHAkYBRAGHAkYBRAGHAkYBRAGHAkYBRAGHAjwBOwFpAjkBNAFpAkABNwGHAkABNwGH
-        AkABNwGHAkABNwGHAkABNwGHAkABNwGHAkABNwGHAkABNwGHAkABNwGHAkABNwGHAkABNwGHAkABNwGH
-        AkABNwGHAkABNwGHAjkBNAFpAjwBOwFpAkYBRAGHAkYBRAGHAkYBRAGHAkYBRAGHAkYBRAGHAkYBRAGH
-        AkYBRAGHAkYBRAGHAkYBRAGHAkYBRAGHAkYBRAGHAkYBRAGHAkYBRAGHAkYBRAGHAjwBOwFpAw0BEQMa
-        ASQBRAFNAVEBmAE8AYkBrAHyAWcBrwHTAfoBggHLAewB/wGFAc4B7gH/ARUBWwGCAe8BOgFXAWYBxAE6
-        AVcBZgHEAT4BWgFqAb4BPgFaAWoBvgE+AVoBagG+AUQBTQFRAZgDGgEkAw0BEQJGAUMBgQL5AekB/wLz
-        AeIB/wLzAeIB/wLzAeIB/wLzAeIB/wLzAeIB/wLzAeIB/wLzAeIB/wLzAeIB/wLzAeIB/wLzAeIB/wLz
-        AeIB/wLzAeIB/wL5AekB/wJGAUMBgQJDAToBgQL5AekB/wLzAeIB/wLzAeIB/wLzAeIB/wLzAeIB/wLz
-        AeIB/wLzAeIB/wLzAeIB/wLzAeIB/wLzAeIB/wLzAeIB/wLzAeIB/wLzAeIB/wL5AekB/wJDAToBgQJG
-        AUMBgQL5AekB/wLzAeIB/wLzAeIB/wLzAeIB/wLzAeIB/wLzAeIB/wLzAeIB/wLzAeIB/wLzAeIB/wLz
-        AeIB/wLzAeIB/wLzAeIB/wLzAeIB/wL5AekB/wJGAUMBgQMHAQkDDQESAUIBWwFmAbIBiAHQAe8B/wF9
-        AcoB6QH/AX0BygHpAf8BhwHQAe8B/wEkAXsBqQH/AX0BvAHbAf8BfQG8AdsB/wGNAdEB8wH/AY0B0QHz
-        Af8BkAHUAfUB/wFCAVsBZgGyATACMQFNAwcBCQJEAUMBegL0AeQC/wHMAUIB/wH+AcsBQQH/AewB0gGG
-        Af8C2gHJAf8C2AHHAf8C1gHFAf8C1AHDAf8C0wHCAf8C0QHAAf8CzwG+Af8CzgG9Af8CzQG8Af8C9AHk
-        Af8CRAFDAXoCRgE+AXoC9AHkAv8BzAFDAf8B/gHLAUIB/wHsAdIBhgH/AtoByQH/AtgBxwH/AtYBxQH/
-        AtQBwwH/AtMBwgH/AtEBwAH/As8BvgH/As4BvQH/As0BvAH/AvQB5AH/AkYBPgF6AkQBQwF6AvQB5AL/
-        AcwBQgH/Af4BywFBAf8B7AHSAYYB/wLaAckB/wLYAccB/wHnAWEBPwH/AecBYQE/Af8B5wFhAT8B/wHn
-        AWEBPwH/As8BvgH/As4BvQH/As0BvAH/AvQB5AH/AkQBQwF6CAABQwFXAWABpAGKAdMB8AH/AYIBzQHr
-        Af8BggHNAesB/wGKAdMB8AH/ASQBfAGrAf8BegG5AdgB/wF6AbkB2AH/AYoBzgHwAf8BigHOAfAB/wGP
-        AdMB9AH/AfQBtgEsAf8BQwFXAWABpAQAAkQBQgF3AvUB5gL/AcwBQgL/Ae4BiAH/AewB0gGGAf8C9QHu
-        Af8C9QHuAf8C1gHFAf8C9QHuAf8C9QHuAf8C0QHAAf8C9QHuAf8C9QHuAf8CzQG8Af8C9QHmAf8CRAFC
-        AXcCRwE/AXcC9QHmAv8BzAFDAv8B7gGIAf8B7AHSAYYB/wL1Ae4B/wL1Ae4B/wLWAcUB/wL1Ae4B/wL1
-        Ae4B/wLRAcAB/wL1Ae4B/wL1Ae4B/wLNAbwB/wL1AeYB/wJHAT8BdwJEAUIBdwL1AeYC/wHMAUIC/wHu
-        AYgB/wHsAdIBhgH/AvUB7gH/AvUB7gH/AdkBWAE2Af8B8gHJAbgB/wHyAckBuAH/AdkBWAE2Af8C9QHu
-        Af8C9QHuAf8CzQG8Af8C9QHmAf8CRAFCAXcIAAFDAVUBXgGeAY4B1gHyAf8BhwHQAe0B/wGHAdAB7QH/
-        AY4B1gHyAf8BJgGCAa8B/wF7AboB2AH/AXsBugHYAf8BiwHPAfEB/wGLAc8B8QH/AZEB1QH1Af8B/gHJ
-        AT8B/wFDAVUBXgGeBAACQwFBAXUC9gHpAv8BzAFCAf8B/gHLAUEB/wHsAdIBhgH/AtoByQH/AtgBxwH/
-        AtwBzAH/AtQBwwH/AtMBwgH/AtgByAH/As8BvgH/As4BvQH/As0BvAH/AvYB6QH/AkMBQQF1AkcBPwF1
-        AvYB6QL/AcwBQwH/Af4BywFCAf8B7AHSAYYB/wLaAckB/wLYAccB/wLcAcwB/wLUAcMB/wLTAcIB/wLY
-        AcgB/wLPAb4B/wLOAb0B/wLNAbwB/wL2AekB/wJHAT8BdQJDAUEBdQL2AekC/wHMAUIB/wH+AcsBQQH/
-        AewB0gGGAf8C2gHJAf8C2AHHAf8ByAFPAS0B/wHeAbYBngH/Ad4BtQGdAf8ByAFPAS0B/wLPAb4B/wLO
-        Ab0B/wLNAbwB/wL2AekB/wJDAUEBdQgAAUQBVQFdAZsBkgHaAfQB/wGLAdQB8AH/AYsB1AHwAf8BkgHa
-        AfQB/wEpAYUBswH/AX0BvAHaAf8BfQG8AdoB/wGNAdEB8wH/AY0B0QHzAf8BkwHXAfYB/wLrAd0B/wFE
-        AVUBXQGbBAACQgFBAXMC9wHrAv8BzAFCAv8B7gGIAf8B7AHSAYYB/wL3AfEB/wL3AfEB/wLWAcUB/wL3
-        AfEB/wL3AfEB/wLRAcAB/wL3AfEB/wL3AfEB/wLNAbwB/wL3AesB/wJCAUEBcwJHAT8BcwL3AesC/wHM
-        AUMC/wHuAYgB/wHsAdIBhgH/AvcB8QH/AvcB8QH/AtYBxQH/AvcB8QH/AvcB8QH/AtEBwAH/AvcB8QH/
-        AvcB8QH/As0BvAH/AvcB6wH/AkcBPwFzAkIBQQFzAvcB6wL/AcwBQgL/Ae4BiAH/AewB0gGGAf8C9wHx
-        Af8C9wHxAf8BuAFHASUB/wHzAcsBuQH/AfMBywG5Af8BuAFHASUB/wL3AfEB/wL3AfEB/wLNAbwB/wL3
-        AesB/wJCAUEBcwgAAUQBUwFbApcB3gH2Af8BkAHYAfIB/wGQAdgB8gH/AZcB3gH2Af8BKwGJAbcB/wGA
-        Ab0B3AH/AYABvQHcAf8BjwHTAfUB/wGPAdMB9QH/AZUB2QH4Af8C9QHuAf8BRAFTAVsBlwQAAkIBQQFy
-        AvgB7gL/AcwBQgH/Af4BywFBAf8B7AHSAYYB/wLaAckB/wLYAccB/wLdAc4B/wLUAcMB/wLTAcIB/wLZ
-        AcoB/wLPAb4B/wLOAb0B/wLNAbwB/wL4Ae4B/wJCAUEBcgJIAUABcgL4Ae4B/wHsAYYBYwH/AeIBewFZ
-        Af8B1AFuAUwB/wHEAWABPgH/AbYBUgEwAf8BrQFHASUB/wGrAUMBIQH/AbEBRAEiAf8BvQFKASgB/wHM
-        AVIBMAH/AdsBWgE4Af8B6AFiAUAB/wL4Ae4B/wJIAUABcgJCAUEBcgL4Ae4C/wHMAUIB/wH+AcsBQQH/
-        AewB0gGGAf8C2gHJAf8C2AHHAf8BrQFCASAB/wHeAbYBngH/Ad4BtQGdAf8BrQFCASAB/wLPAb4B/wLO
-        Ab0B/wLNAbwB/wL4Ae4B/wJCAUEBcggAAUQBUwFaAZQBmwHhAfcB/wGUAdsB9AH/AZQB2wH0Af8BmwHh
-        AfcB/wEuAY0BvAH/AYEBvgHdAf8BgQG+Ad0B/wGQAdQB9gH/AZAB1AH2Af8BlwHbAfkB/wL+Af0B/wFE
-        AVMBWgGUBAACQQFAAXAC+QHxAv8BzAFCAv8B7gGIAf8B7AHSAYYB/wL5AfUB/wL5AfUB/wLWAcUB/wL5
-        AfUB/wL5AfUB/wLRAcAB/wL5AfUB/wL5AfUB/wLNAbwB/wL5AfEB/wJBAUABcAJHAUABcAL5AfEB/wHs
-        AYYBYwH/AfgBxQF5Af8B7QG1AXgB/wH1AcwBvAH/AfUBzAG8Af8B4AG3AZ8B/wH1AcwBvAH/AfUBzAG8
-        Af8B3QG0AZwB/wH1AcwBvAH/AfUBzAG8Af8B6AFiAUAB/wL5AfEB/wJHAUABcAJBAUABcAL5AfEC/wHM
-        AUIC/wHuAYgB/wHsAdIBhgH/AvkB9QH/AvkB9QH/AasBRAEiAf8B9QHMAbwB/wH1AcwBvAH/AasBRAEi
-        Af8C+QH1Af8C+QH1Af8CzQG8Af8C+QHxAf8CQQFAAXAIAAFEAVEBVwGQAZ4B5QH5Af8BmAHfAfYB/wGY
-        Ad8B9gH/AZ4B5QH5Af8BMAGQAcAB/wGDAcAB3wH/AYMBwAHfAf8BkgHWAfgB/wGSAdYB+AH/AZkB3QH6
-        Af8BRAFRAVcBkAMjATMEAAJBAUABbgL7AfQC/wHMAUIB/wH+AcsBQQH/AewB0gGGAf8C2gHJAf8C2AHH
-        Af8C3gHQAf8C1AHDAf8C0wHCAf8C2gHMAf8CzwG+Af8CzgG9Af8CzQG8Af8C+wH0Af8CQQFAAW4CRwFA
-        AW4C+wH0Af8B7AGGAWMB/wHiAXsBWQH/AdQBbgFMAf8BxAFgAT4B/wG2AVIBMAH/Aa0BRwElAf8BqwFD
-        ASEB/wGxAUQBIgH/Ab0BSgEoAf8BzAFSATAB/wHbAVoBOAH/AegBYgFAAf8C+wH0Af8CRwFAAW4CQQFA
-        AW4C+wH0Av8BzAFCAf8B/gHLAUEB/wHsAdIBhgH/AtoByQH/AtgBxwH/AbIBTAEqAf8B3gG2AZ4B/wHe
-        AbUBnQH/AbIBTAEqAf8CzwG+Af8CzgG9Af8CzQG8Af8C+wH0Af8CQQFAAW4IAAFDAU8BVQGNAaMB6AH7
-        Af8BnQHjAfkB/wGdAeMB+QH/AaMB6AH7Af8BMwGUAcUB/wGFAcIB4QH/AYUBwgHhAf8BlAHYAfoB/wGU
-        AdgB+gH/AZsB3wH8Af8BQwFPAVUBjQgAAkABPwFtAvwB9wL/AcwBQgL/Ae4BiAH/AewB0gGGAf8C/AH6
-        Af8C/AH6Af8C1gHFAf8C/AH6Af8C/AH6Af8C0QHAAf8C/AH6Af8C/AH6Af8CzQG8Af8C/AH3Af8CQAE/
-        AW0CRwFAAW0C/AH3Av8BzAFDAv8B7gGIAf8B7AHSAYYB/wL8AfoB/wL8AfoB/wLWAcUB/wL8AfoB/wL8
-        AfoB/wLRAcAB/wL8AfoB/wL8AfoB/wLNAbwB/wL8AfcB/wJHAUABbQJAAT8BbQL8AfcC/wHMAUIC/wHu
-        AYgB/wHsAdIBhgH/AvwB+gH/AvwB+gH/AcABWgE4Af8B9gHOAb8B/wH2Ac4BvwH/AcABWgE4Af8C/AH6
-        Af8C/AH6Af8CzQG8Af8C/AH3Af8CQAE/AW0IAAFDAU8BVAGKAaYB6wH8Af8BoQHmAfsB/wGhAeYB+wH/
-        AaYB6wH8Af8BOgGdAc8B/wGHAcQB4gH/AYcBxAHiAf8BlgHaAfwB/wGWAdoB/AH/AZ4B4gH9Af8BQwFP
-        AVQBiggAAj8BPgFrAv0B+QL/AcwBQgH/Af4BywFBAf8B9QHOAWIB/wHrAdIBhQH/AekB0AGDAf8B5wHO
-        AYEB/wHlAcwBgAH/AeQBywF8Af8B4gHJAXoB/wHgAccBeAH/Ad8BxgF3Af8B3gHFAXYB/wL9AfkB/wI/
-        AT4BawJHAUABawL9AfkC/wHMAUMB/wH+AcsBQgH/AfUBzgFjAf8B6wHSAYUB/wHpAdABgwH/AecBzgGB
-        Af8B5QHMAYAB/wHkAcsBfQH/AeIByQF7Af8B4AHHAXkB/wHfAcYBeAH/Ad4BxQF3Af8C/QH5Af8CRwFA
-        AWsCPwE+AWsC/QH5Av8BzAFCAf8B/gHLAUEB/wH1Ac4BYgH/AesB0gGFAf8B6QHQAYMB/wHRAWoBSAH/
-        AekBsQF0Af8B6AGwAXMB/wHRAWoBSAH/AeABxwF4Af8B3wHGAXcB/wHeAcUBdgH/Av0B+QH/Aj8BPgFr
-        CAABQgFNAVIBhwGpAe4B/QH/AaQB6QH8Af8BpAHpAfwB/wGqAe8B/QH/AUABoQHRAf8BkAHRAfEB/wGW
-        AdoB+wH/AZcB2wH9Af8BlwHbAf0B/wGfAeMB/gH/AUIBTQFSAYcIAAI/AT4BagL+AfwC/wHMAUIC/wHu
-        AYgB/wH9AcoBQAH/AfwB6wGFAf8B+wHqAYQB/wH4AcUBOwH/AfYB5QF9Af8B9AHjAXsB/wHzAcABNgH/
-        AfEB4AF4Af8B7wHeAXYB/wHvAbwBMgH/Av4B/AH/Aj8BPgFqAkcBQAFqAv4B/AL/AcwBQwL/Ae4BiAH/
-        Af0BygFBAf8B/AHrAYUB/wH7AeoBhAH/AfgBxQE8Af8B9gHlAX4B/wH0AeMBfAH/AfMBwAE3Af8B8QHg
-        AXkB/wHvAd4BdwH/Ae8BvAEzAf8C/gH8Af8CRwFAAWoCPwE+AWoC/gH8Av8BzAFCAv8B7gGIAf8B/QHK
-        AUAB/wH8AesBhQH/AfsB6gGEAf8B4QF5AVcB/wHzAcABcwH/AfIBvwFyAf8B4QF5AVcB/wHxAeABeAH/
-        Ae8B3gF2Af8B7wG8ATIB/wL+AfwB/wI/AT4BaggAAUMBTAFSAYUBrQHxAv8BqwHvAf4B/wGVAeIB+AH/
-        AWwByQHtAf8BRgGpAdkB/wGYAdwB/gH/AZgB3AH+Af8BmAHcAf4B/wGYAdwB/gH/AaEB5QL/AUMBTAFS
-        AYUIAAI+AT0BaAL/Af4C/wHMAUIB/wH+AcsBQQH/Af0BygFAAf8B/AHJAT8B/wH6AccBPQH/AfgBxQE7
-        Af8B9gHDAToB/wH1AcIBOAH/AfMBwAE2Af8B8QG+ATQB/wHwAb0BMwH/Ae8BvAEyA/8B/gH/Aj4BPQFo
-        AkcBQAFoAv8B/gL/AcwBQwH/Af4BywFCAf8B/QHKAUEB/wH8AckBQAH/AfoBxwE+Af8B+AHFATwB/wH2
-        AcMBOwH/AfUBwgE5Af8B8wHAATcB/wHxAb4BNQH/AfABvQE0Af8B7wG8ATMD/wH+Af8CRwFAAWgCPgE9
-        AWgC/wH+Av8BzAFCAf8B/gHLAUEB/wH9AcoBQAH/AfwByQE/Af8B+gHHAT0B/wHsAYYBYgH/AewBhgFi
-        Af8B7AGGAWIB/wHsAYYBYgH/AfEBvgE0Af8B8AG9ATMB/wHvAbwBMgP/Af4B/wI+AT0BaAgAAUMBTAFQ
-        AYMBiAHcAfQB/wFeAcAB6QH/AV0BvwHqAf8BgAHTAfQB/wGcAeMB/QH/AaIB5gL/AaIB5gL/AaIB5gL/
-        AaIB5gL/AaYB6gL/AUMBTAFQAYMIAAI+AT0BZzj/Aj4BPQFnAkcBQAFnOP8CRwFAAWcCPgE9AWc4/wI+
-        AT0BZwgAATkBOwE9AWEBQgFLAU8BgQFCAUsBTwGBAUIBSwFPAYEBQgFLAU8BgQFCAUsBTwGBAUIBSwFP
-        AYEBQgFLAU8BgQFCAUsBTwGBAUIBSwFPAYEBQgFLAU8BgQE5ATsBPQFhCAADMQFNAj4BPQFmAj4BPQFm
-        Aj4BPQFmAj4BPQFmAj4BPQFmAj4BPQFmAj4BPQFmAj4BPQFmAj4BPQFmAj4BPQFmAj4BPQFmAj4BPQFm
-        Aj4BPQFmAj4BPQFmAzEBTQI3ATQBTQJHAUABZgJHAUABZgJHAUABZgJHAUABZgJHAUABZgJHAUABZgJH
-        AUABZgJHAUABZgJHAUABZgJHAUABZgJHAUABZgJHAUABZgJHAUABZgJHAUABZgI3ATQBTQMxAU0CPgE9
-        AWYCPgE9AWYCPgE9AWYCPgE9AWYCPgE9AWYCPgE9AWYCPgE9AWYCPgE9AWYCPgE9AWYCPgE9AWYCPgE9
-        AWYCPgE9AWYCPgE9AWYCPgE9AWYDMQFNAUIBTQE+BwABPgMAASgDAAFAAwABIAMAAQEBAAEBBgABARYA
-        A/8RAAGAAf8BgAEBBQABfwEAAQEFAAE/AQABAQUAAR8BAAEBBAABgAEPAYABAQQAAcABBwHAAQMEAAHg
-        AQMB4AEDBAAB8AEBAfABAQQAAfgBAAH4BQAB/AEAAfwFAAH+AQgB/gEIBAAB/wEAAf8FAAH/AYAB/wGA
-        BAAB/wHAAf8BwAQAAfgBfwYAAeABPxYAAcABAQYAAcABAQYAAcABAQYAAcABAQYAAcABAQYAAcABAQYA
-        AcABAwYAAcABAwYAAcABAwYAAcABAwYAAcABAwYAAcABAwYACw==
-</value>
-  </data>
-  <metadata name="toolStripMain.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
-    <value>211, 17</value>
-  </metadata>
-  <assembly alias="System.Drawing" name="System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-  <data name="toolbuttonOpenMib.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
-    <value>
-        iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8
-        YQUAAAAJcEhZcwAADsIAAA7CARUoSoAAAAK6SURBVDhPjZNbSNNRHMfPU9DtwR71oZf5IgkF0YMEEYb2
-        EGgG5YNgGQmGSUoYimbel5KKmlM0u3jJSpv3ad7WnGkzb2yO4bByF3WuuTnnnLv47Zw/9YclQQc+/L//
-        P+d8/r/f+Z8/Ib/HjJDcmhaS3P+Bzf2zjr8qiki+QyuE6dNNbIzFw6F8DJ++AVh97c9GK9jcA4LJAlKI
-        rQ7sW9/DpauGZSoFg6JwfJSU+TE0XIXOgqCaAwJ5ASn2bb6F19TM4bO+w4z4HgwWC9YcDugpK3Y7umQy
-        FOZEDMRkZQX7SWS5pMRrboVn9RUHy1/aEqDSajGn0WDZbIZ6bQ0t/f1gIzojI8lPMvaIPPWsN2FP/5yD
-        ZdmLWLwUi/FhZASSqSlOUtXczBMcGZnFVzGUTSr2jI1wfq/lYHms4Tqkc3MYnZ2F0mDAqs3GV8LaiUhN
-        TeYFA5mkenelHg5tNQfLw3UxaOrpQZdUiu7xca5/Mc0do6PQb28jPDk5hRf0PiQi5zcR7JoKDpYHaqIg
-        VyohW1jg+lcZjVwlCzod1p1OXEhMvM8LOtNJvWOpEjZVKQfL/ZVX0NrXh165HP2Tk5hQqzGuUmFQocCm
-        y4XzCQlpvKA9jTTa1WWwzBdzsNxdfhmfFxcxQRct0Q3UmEzY2t2FdWcHdrcb5+LiHvCC1hTSbFOWwDyT
-        x8GyuDQCbRIJ3tBPp6CfU0pbcdA3M4mDCs7ExqYzwWHKibo7pNs6T4+yIofDSqtof3IJBtqzTq+Hx+uF
-        y+OBky5kkh2aT0VFZTNBAEWQFEFqhyvO2pclSe6f03nYnC1EW9FFGOnGGSi+/X14KW6fD3tUtkdzYFiY
-        0O801iWSaNFtUteWGST92nL1R/q1Q7ojAkHV0ZCQkuOhocV/c0wguHvgn2APyuPJ6dI4kpV/gzyjtycp
-        gf8g4Begs1B6Kbj3cQAAAABJRU5ErkJggg==
-</value>
-  </data>
-  <metadata name="dialogOpenMib.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
-    <value>337, 17</value>
-  </metadata>
-</root>
\ No newline at end of file
diff --git a/contrib/apps/LwipMibCompiler/MibViewer/MibViewer.csproj b/contrib/apps/LwipMibCompiler/MibViewer/MibViewer.csproj
deleted file mode 100644
index 957c058c..00000000
--- a/contrib/apps/LwipMibCompiler/MibViewer/MibViewer.csproj
+++ /dev/null
@@ -1,94 +0,0 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <PropertyGroup>
-    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
-    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
-    <ProductVersion>8.0.30703</ProductVersion>
-    <SchemaVersion>2.0</SchemaVersion>
-    <ProjectGuid>{86CC0B65-7985-4017-A252-0A7A18DCAEF3}</ProjectGuid>
-    <OutputType>WinExe</OutputType>
-    <AppDesignerFolder>Properties</AppDesignerFolder>
-    <RootNamespace>LwipMibViewer</RootNamespace>
-    <AssemblyName>MibViewer</AssemblyName>
-    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
-    <FileAlignment>512</FileAlignment>
-    <TargetFrameworkProfile />
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|AnyCPU'">
-    <DebugSymbols>true</DebugSymbols>
-    <OutputPath>bin\Debug\</OutputPath>
-    <DefineConstants>DEBUG;TRACE</DefineConstants>
-    <DebugType>full</DebugType>
-    <ErrorReport>prompt</ErrorReport>
-    <CodeAnalysisIgnoreBuiltInRuleSets>true</CodeAnalysisIgnoreBuiltInRuleSets>
-    <CodeAnalysisIgnoreBuiltInRules>true</CodeAnalysisIgnoreBuiltInRules>
-    <WarningLevel>4</WarningLevel>
-    <Optimize>false</Optimize>
-    <UseVSHostingProcess>false</UseVSHostingProcess>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|AnyCPU'">
-    <OutputPath>bin\Release\</OutputPath>
-    <DefineConstants>TRACE</DefineConstants>
-    <Optimize>true</Optimize>
-    <DebugType>pdbonly</DebugType>
-    <PlatformTarget>AnyCPU</PlatformTarget>
-    <ErrorReport>prompt</ErrorReport>
-    <CodeAnalysisIgnoreBuiltInRuleSets>true</CodeAnalysisIgnoreBuiltInRuleSets>
-    <CodeAnalysisIgnoreBuiltInRules>true</CodeAnalysisIgnoreBuiltInRules>
-    <WarningLevel>4</WarningLevel>
-    <UseVSHostingProcess>false</UseVSHostingProcess>
-  </PropertyGroup>
-  <ItemGroup>
-    <Reference Include="System" />
-    <Reference Include="System.Drawing" />
-    <Reference Include="System.Windows.Forms" />
-  </ItemGroup>
-  <ItemGroup>
-    <Compile Include="FormMain.cs">
-      <SubType>Form</SubType>
-    </Compile>
-    <Compile Include="FormMain.Designer.cs">
-      <DependentUpon>FormMain.cs</DependentUpon>
-    </Compile>
-    <Compile Include="Program.cs" />
-    <Compile Include="Properties\AssemblyInfo.cs" />
-    <EmbeddedResource Include="FormMain.resx">
-      <DependentUpon>FormMain.cs</DependentUpon>
-    </EmbeddedResource>
-    <EmbeddedResource Include="Properties\Resources.resx">
-      <Generator>ResXFileCodeGenerator</Generator>
-      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
-      <SubType>Designer</SubType>
-    </EmbeddedResource>
-    <Compile Include="Properties\Resources.Designer.cs">
-      <AutoGen>True</AutoGen>
-      <DependentUpon>Resources.resx</DependentUpon>
-      <DesignTime>True</DesignTime>
-    </Compile>
-    <None Include="app.config" />
-    <None Include="Properties\Settings.settings">
-      <Generator>SettingsSingleFileGenerator</Generator>
-      <LastGenOutput>Settings.Designer.cs</LastGenOutput>
-    </None>
-    <Compile Include="Properties\Settings.Designer.cs">
-      <AutoGen>True</AutoGen>
-      <DependentUpon>Settings.settings</DependentUpon>
-      <DesignTimeSharedInput>True</DesignTimeSharedInput>
-    </Compile>
-  </ItemGroup>
-  <ItemGroup>
-    <ProjectReference Include="..\SharpSnmpLib\SharpSnmpLib.Mib.csproj">
-      <Project>{CBE20411-5DB7-487D-825D-7694267BB6F5}</Project>
-      <Name>SharpSnmpLib.Mib</Name>
-    </ProjectReference>
-  </ItemGroup>
-  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
-  <PropertyGroup />
-  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
-       Other similar extension points exist, see Microsoft.Common.targets.
-  <Target Name="BeforeBuild">
-  </Target>
-  <Target Name="AfterBuild">
-  </Target>
-  -->
-</Project>
\ No newline at end of file
diff --git a/contrib/apps/LwipMibCompiler/MibViewer/Program.cs b/contrib/apps/LwipMibCompiler/MibViewer/Program.cs
deleted file mode 100644
index cd3ef314..00000000
--- a/contrib/apps/LwipMibCompiler/MibViewer/Program.cs
+++ /dev/null
@@ -1,51 +0,0 @@
-﻿/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Martin Hentschel <info@cl-soft.de>
- *
- */
-
-using System;
-using System.Windows.Forms;
-
-namespace LwipMibViewer
-{
-	static class Program
-	{
-		/// <summary>
-		/// Der Haupteinstiegspunkt für die Anwendung.
-		/// </summary>
-		[STAThread]
-		static void Main()
-		{
-			Application.EnableVisualStyles();
-			Application.SetCompatibleTextRenderingDefault(false);
-			Application.Run(new FormMain());
-		}
-	}
-}
diff --git a/contrib/apps/LwipMibCompiler/MibViewer/Properties/AssemblyInfo.cs b/contrib/apps/LwipMibCompiler/MibViewer/Properties/AssemblyInfo.cs
deleted file mode 100644
index 06e7286c..00000000
--- a/contrib/apps/LwipMibCompiler/MibViewer/Properties/AssemblyInfo.cs
+++ /dev/null
@@ -1,36 +0,0 @@
-﻿using System.Reflection;
-using System.Runtime.CompilerServices;
-using System.Runtime.InteropServices;
-
-// Allgemeine Informationen über eine Assembly werden über die folgenden 
-// Attribute gesteuert. Ändern Sie diese Attributwerte, um die Informationen zu ändern,
-// die mit einer Assembly verknüpft sind.
-[assembly: AssemblyTitle("LwipMibViewer")]
-[assembly: AssemblyDescription("")]
-[assembly: AssemblyConfiguration("")]
-[assembly: AssemblyCompany("")]
-[assembly: AssemblyProduct("LwipMibViewer")]
-[assembly: AssemblyCopyright("Copyright ©  2015")]
-[assembly: AssemblyTrademark("")]
-[assembly: AssemblyCulture("")]
-
-// Durch Festlegen von ComVisible auf "false" werden die Typen in dieser Assembly unsichtbar 
-// für COM-Komponenten. Wenn Sie auf einen Typ in dieser Assembly von 
-// COM zugreifen müssen, legen Sie das ComVisible-Attribut für diesen Typ auf "true" fest.
-[assembly: ComVisible(false)]
-
-// Die folgende GUID bestimmt die ID der Typbibliothek, wenn dieses Projekt für COM verfügbar gemacht wird
-[assembly: Guid("7ffbd1c1-1c64-45bb-b243-2400446c649d")]
-
-// Versionsinformationen für eine Assembly bestehen aus den folgenden vier Werten:
-//
-//      Hauptversion
-//      Nebenversion 
-//      Buildnummer
-//      Revision
-//
-// Sie können alle Werte angeben oder die standardmäßigen Build- und Revisionsnummern 
-// übernehmen, indem Sie "*" eingeben:
-// [assembly: AssemblyVersion("1.0.*")]
-[assembly: AssemblyVersion("1.0.0.0")]
-[assembly: AssemblyFileVersion("1.0.0.0")]
diff --git a/contrib/apps/LwipMibCompiler/MibViewer/Properties/Resources.Designer.cs b/contrib/apps/LwipMibCompiler/MibViewer/Properties/Resources.Designer.cs
deleted file mode 100644
index bf157177..00000000
--- a/contrib/apps/LwipMibCompiler/MibViewer/Properties/Resources.Designer.cs
+++ /dev/null
@@ -1,63 +0,0 @@
-﻿//------------------------------------------------------------------------------
-// <auto-generated>
-//     Dieser Code wurde von einem Tool generiert.
-//     Laufzeitversion:4.0.30319.225
-//
-//     Änderungen an dieser Datei können falsches Verhalten verursachen und gehen verloren, wenn
-//     der Code erneut generiert wird.
-// </auto-generated>
-//------------------------------------------------------------------------------
-
-namespace LwipMibViewer.Properties {
-    using System;
-    
-    
-    /// <summary>
-    ///   Eine stark typisierte Ressourcenklasse zum Suchen von lokalisierten Zeichenfolgen usw.
-    /// </summary>
-    // Diese Klasse wurde von der StronglyTypedResourceBuilder automatisch generiert
-    // -Klasse über ein Tool wie ResGen oder Visual Studio automatisch generiert.
-    // Um einen Member hinzuzufügen oder zu entfernen, bearbeiten Sie die .ResX-Datei und führen dann ResGen
-    // mit der /str-Option erneut aus, oder Sie erstellen Ihr VS-Projekt neu.
-    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
-    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
-    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
-    internal class Resources {
-        
-        private static global::System.Resources.ResourceManager resourceMan;
-        
-        private static global::System.Globalization.CultureInfo resourceCulture;
-        
-        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
-        internal Resources() {
-        }
-        
-        /// <summary>
-        ///   Gibt die zwischengespeicherte ResourceManager-Instanz zurück, die von dieser Klasse verwendet wird.
-        /// </summary>
-        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
-        internal static global::System.Resources.ResourceManager ResourceManager {
-            get {
-                if (object.ReferenceEquals(resourceMan, null)) {
-                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("LwipMibViewer.Properties.Resources", typeof(Resources).Assembly);
-                    resourceMan = temp;
-                }
-                return resourceMan;
-            }
-        }
-        
-        /// <summary>
-        ///   Überschreibt die CurrentUICulture-Eigenschaft des aktuellen Threads für alle
-        ///   Ressourcenzuordnungen, die diese stark typisierte Ressourcenklasse verwenden.
-        /// </summary>
-        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
-        internal static global::System.Globalization.CultureInfo Culture {
-            get {
-                return resourceCulture;
-            }
-            set {
-                resourceCulture = value;
-            }
-        }
-    }
-}
diff --git a/contrib/apps/LwipMibCompiler/MibViewer/Properties/Resources.resx b/contrib/apps/LwipMibCompiler/MibViewer/Properties/Resources.resx
deleted file mode 100644
index af7dbebb..00000000
--- a/contrib/apps/LwipMibCompiler/MibViewer/Properties/Resources.resx
+++ /dev/null
@@ -1,117 +0,0 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<root>
-  <!-- 
-    Microsoft ResX Schema 
-    
-    Version 2.0
-    
-    The primary goals of this format is to allow a simple XML format 
-    that is mostly human readable. The generation and parsing of the 
-    various data types are done through the TypeConverter classes 
-    associated with the data types.
-    
-    Example:
-    
-    ... ado.net/XML headers & schema ...
-    <resheader name="resmimetype">text/microsoft-resx</resheader>
-    <resheader name="version">2.0</resheader>
-    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
-    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
-    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
-    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
-    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
-        <value>[base64 mime encoded serialized .NET Framework object]</value>
-    </data>
-    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
-        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
-        <comment>This is a comment</comment>
-    </data>
-                
-    There are any number of "resheader" rows that contain simple 
-    name/value pairs.
-    
-    Each data row contains a name, and value. The row also contains a 
-    type or mimetype. Type corresponds to a .NET class that support 
-    text/value conversion through the TypeConverter architecture. 
-    Classes that don't support this are serialized and stored with the 
-    mimetype set.
-    
-    The mimetype is used for serialized objects, and tells the 
-    ResXResourceReader how to depersist the object. This is currently not 
-    extensible. For a given mimetype the value must be set accordingly:
-    
-    Note - application/x-microsoft.net.object.binary.base64 is the format 
-    that the ResXResourceWriter will generate, however the reader can 
-    read any of the formats listed below.
-    
-    mimetype: application/x-microsoft.net.object.binary.base64
-    value   : The object must be serialized with 
-            : System.Serialization.Formatters.Binary.BinaryFormatter
-            : and then encoded with base64 encoding.
-    
-    mimetype: application/x-microsoft.net.object.soap.base64
-    value   : The object must be serialized with 
-            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
-            : and then encoded with base64 encoding.
-
-    mimetype: application/x-microsoft.net.object.bytearray.base64
-    value   : The object must be serialized into a byte array 
-            : using a System.ComponentModel.TypeConverter
-            : and then encoded with base64 encoding.
-    -->
-  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
-    <xsd:element name="root" msdata:IsDataSet="true">
-      <xsd:complexType>
-        <xsd:choice maxOccurs="unbounded">
-          <xsd:element name="metadata">
-            <xsd:complexType>
-              <xsd:sequence>
-                <xsd:element name="value" type="xsd:string" minOccurs="0" />
-              </xsd:sequence>
-              <xsd:attribute name="name" type="xsd:string" />
-              <xsd:attribute name="type" type="xsd:string" />
-              <xsd:attribute name="mimetype" type="xsd:string" />
-            </xsd:complexType>
-          </xsd:element>
-          <xsd:element name="assembly">
-            <xsd:complexType>
-              <xsd:attribute name="alias" type="xsd:string" />
-              <xsd:attribute name="name" type="xsd:string" />
-            </xsd:complexType>
-          </xsd:element>
-          <xsd:element name="data">
-            <xsd:complexType>
-              <xsd:sequence>
-                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
-                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
-              </xsd:sequence>
-              <xsd:attribute name="name" type="xsd:string" msdata:Ordinal="1" />
-              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
-              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
-            </xsd:complexType>
-          </xsd:element>
-          <xsd:element name="resheader">
-            <xsd:complexType>
-              <xsd:sequence>
-                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
-              </xsd:sequence>
-              <xsd:attribute name="name" type="xsd:string" use="required" />
-            </xsd:complexType>
-          </xsd:element>
-        </xsd:choice>
-      </xsd:complexType>
-    </xsd:element>
-  </xsd:schema>
-  <resheader name="resmimetype">
-    <value>text/microsoft-resx</value>
-  </resheader>
-  <resheader name="version">
-    <value>2.0</value>
-  </resheader>
-  <resheader name="reader">
-    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
-  </resheader>
-  <resheader name="writer">
-    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
-  </resheader>
-</root>
\ No newline at end of file
diff --git a/contrib/apps/LwipMibCompiler/MibViewer/Properties/Settings.Designer.cs b/contrib/apps/LwipMibCompiler/MibViewer/Properties/Settings.Designer.cs
deleted file mode 100644
index 9831b20f..00000000
--- a/contrib/apps/LwipMibCompiler/MibViewer/Properties/Settings.Designer.cs
+++ /dev/null
@@ -1,26 +0,0 @@
-﻿//------------------------------------------------------------------------------
-// <auto-generated>
-//     Dieser Code wurde von einem Tool generiert.
-//     Laufzeitversion:4.0.30319.225
-//
-//     Änderungen an dieser Datei können falsches Verhalten verursachen und gehen verloren, wenn
-//     der Code erneut generiert wird.
-// </auto-generated>
-//------------------------------------------------------------------------------
-
-namespace LwipMibViewer.Properties {
-    
-    
-    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
-    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "10.0.0.0")]
-    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
-        
-        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
-        
-        public static Settings Default {
-            get {
-                return defaultInstance;
-            }
-        }
-    }
-}
diff --git a/contrib/apps/LwipMibCompiler/MibViewer/Properties/Settings.settings b/contrib/apps/LwipMibCompiler/MibViewer/Properties/Settings.settings
deleted file mode 100644
index 39645652..00000000
--- a/contrib/apps/LwipMibCompiler/MibViewer/Properties/Settings.settings
+++ /dev/null
@@ -1,7 +0,0 @@
-﻿<?xml version='1.0' encoding='utf-8'?>
-<SettingsFile xmlns="http://schemas.microsoft.com/VisualStudio/2004/01/settings" CurrentProfile="(Default)">
-  <Profiles>
-    <Profile Name="(Default)" />
-  </Profiles>
-  <Settings />
-</SettingsFile>
diff --git a/contrib/apps/LwipMibCompiler/MibViewer/app.config b/contrib/apps/LwipMibCompiler/MibViewer/app.config
deleted file mode 100644
index e3656033..00000000
--- a/contrib/apps/LwipMibCompiler/MibViewer/app.config
+++ /dev/null
@@ -1,3 +0,0 @@
-<?xml version="1.0"?>
-<configuration>
-<startup><supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.0"/></startup></configuration>
diff --git a/contrib/apps/LwipMibCompiler/Mibs/IANA-ADDRESS-FAMILY-NUMBERS-MIB b/contrib/apps/LwipMibCompiler/Mibs/IANA-ADDRESS-FAMILY-NUMBERS-MIB
deleted file mode 100644
index 10107955..00000000
--- a/contrib/apps/LwipMibCompiler/Mibs/IANA-ADDRESS-FAMILY-NUMBERS-MIB
+++ /dev/null
@@ -1,131 +0,0 @@
-
-
-  IANA-ADDRESS-FAMILY-NUMBERS-MIB DEFINITIONS ::= BEGIN
-
-  IMPORTS
-      MODULE-IDENTITY,
-      mib-2                               FROM SNMPv2-SMI
-      TEXTUAL-CONVENTION                  FROM SNMPv2-TC;
-
-  ianaAddressFamilyNumbers MODULE-IDENTITY
-      LAST-UPDATED "200203140000Z"  -- March 14, 2002
-      ORGANIZATION "IANA"
-      CONTACT-INFO
-          "Postal:    Internet Assigned Numbers Authority
-                      Internet Corporation for Assigned Names
-		      and Numbers
-                      4676 Admiralty Way, Suite 330
-                      Marina del Rey, CA 90292-6601
-                      USA
-
-          Tel:    +1  310-823-9358
-          E-Mail: iana&iana.org"
-      DESCRIPTION
-          "The MIB module defines the AddressFamilyNumbers
-          textual convention."
-
-      -- revision history
-
-      REVISION     "200203140000Z"  -- March 14, 2002
-      DESCRIPTION  "AddressFamilyNumbers assignment 22 to 
-                   fibreChannelWWPN. AddressFamilyNumbers 
-                   assignment 23 to fibreChannelWWNN.
-                   AddressFamilyNumers assignment 24 to gwid."
-
-      REVISION     "200009080000Z"  -- September 8, 2000
-      DESCRIPTION  "AddressFamilyNumbers assignment 19 to xtpOverIpv4.  
-                   AddressFamilyNumbers assignment 20 to xtpOverIpv6.  
-                   AddressFamilyNumbers assignment 21 to xtpNativeModeXTP."
-
-      REVISION     "200003010000Z"  -- March 1, 2000
-      DESCRIPTION  "AddressFamilyNumbers assignment 17 to distinguishedName. 
-                   AddressFamilyNumbers assignment 18 to asNumber."
-
-      REVISION     "200002040000Z"  -- February 4, 2000
-      DESCRIPTION  "AddressFamilyNumbers assignment 16 to dns."
-
-      REVISION     "9908260000Z"  -- August 26, 1999
-      DESCRIPTION  "Initial version, published as RFC 2677."
-
-      ::= { mib-2 72 }
-
-
-  AddressFamilyNumbers ::= TEXTUAL-CONVENTION
-
-      STATUS       current
-      DESCRIPTION
-          "The definition of this textual convention with the
-          addition of newly assigned values is published
-          periodically by the IANA, in either the Assigned
-          Numbers RFC, or some derivative of it specific to
-          Internet Network Management number assignments.
-          (The latest arrangements can be obtained by
-          contacting the IANA.)
-
-          The enumerations are described as:
-
-          other(0),    -- none of the following
-          ipV4(1),     -- IP Version 4
-          ipV6(2),     -- IP Version 6
-          nsap(3),     -- NSAP
-          hdlc(4),     -- (8-bit multidrop)
-          bbn1822(5),
-          all802(6),   -- (includes all 802 media
-                       --   plus Ethernet 'canonical format')
-          e163(7),
-          e164(8),     -- (SMDS, Frame Relay, ATM)
-          f69(9),      -- (Telex)
-          x121(10),    -- (X.25, Frame Relay)
-          ipx(11),     -- IPX (Internet Protocol Exchange)
-          appleTalk(12),  -- Apple Talk
-          decnetIV(13),   -- DEC Net Phase IV
-          banyanVines(14),  -- Banyan Vines
-          e164withNsap(15),
-                       -- (E.164 with NSAP format subaddress)
-          dns(16),     -- (Domain Name System)
-          distinguishedName(17), -- (Distinguished Name, per X.500)
-          asNumber(18), -- (16-bit quantity, per the AS number space)
-          xtpOverIpv4(19),  -- XTP over IP version 4
-          xtpOverIpv6(20),  -- XTP over IP version 6
-          xtpNativeModeXTP(21),  -- XTP native mode XTP
-          fibreChannelWWPN(22),  -- Fibre Channel World-Wide Port Name 
-          fibreChannelWWNN(23),  -- Fibre Channel World-Wide Node Name
-          gwid(24),    -- Gateway Identifier 
-          afi(25),  -- AFI for L2VPN information
-          reserved(65535)
-
-
-
-          Requests for new values should be made to IANA via
-          email (iana&iana.org)."
-
-      SYNTAX  INTEGER {
-                  other(0),
-                  ipV4(1),
-                  ipV6(2),
-                  nsap(3),
-                  hdlc(4),
-                  bbn1822(5),
-                  all802(6),
-                  e163(7),
-                  e164(8),
-                  f69(9),
-                  x121(10),
-                  ipx(11),
-                  appleTalk(12),
-                  decnetIV(13),
-                  banyanVines(14),
-                  e164withNsap(15),
-                  dns(16),
-                  distinguishedName(17), -- (Distinguished Name, per X.500)
-                  asNumber(18), -- (16-bit quantity, per the AS number space)
-                  xtpOverIpv4(19),
-                  xtpOverIpv6(20),
-                  xtpNativeModeXTP(21),
-                  fibreChannelWWPN(22),
-                  fibreChannelWWNN(23),
-                  gwid(24),
-                  afi(25),
-                  reserved(65535)
-              }
-      END
diff --git a/contrib/apps/LwipMibCompiler/Mibs/IANA-CHARSET-MIB b/contrib/apps/LwipMibCompiler/Mibs/IANA-CHARSET-MIB
deleted file mode 100644
index 499d54e4..00000000
--- a/contrib/apps/LwipMibCompiler/Mibs/IANA-CHARSET-MIB
+++ /dev/null
@@ -1,345 +0,0 @@
-IANA-CHARSET-MIB DEFINITIONS ::= BEGIN
---  http://www.iana.org/assignments/ianacharset-mib
-
-IMPORTS
-    MODULE-IDENTITY,
-        mib-2
-            FROM SNMPv2-SMI                              -- [RFC2578]
-    TEXTUAL-CONVENTION
-            FROM SNMPv2-TC;                              -- [RFC2579]
-
-ianaCharsetMIB MODULE-IDENTITY
-    LAST-UPDATED    "200705140000Z"
-    ORGANIZATION    "IANA"
-    CONTACT-INFO    "       Internet Assigned Numbers Authority
-
-                    Postal: ICANN
-                            4676 Admiralty Way, Suite 330
-                            Marina del Rey, CA 90292
-
-                    Tel:    +1 310 823 9358
-                    E-Mail: iana&iana.org"
-
-    DESCRIPTION     "This MIB module defines the IANACharset
-                    TEXTUAL-CONVENTION.  The IANACharset TC is used to
-                    specify the encoding of string objects defined in
-                    a MIB.
-
-                    Each version of this MIB will be released based on
-                    the IANA Charset Registry file (see RFC 2978) at
-                    http://www.iana.org/assignments/character-sets.
-
-                    Note:  The IANACharset TC, originally defined in
-                    RFC 1759, was inaccurately named CodedCharSet.
-
-                    Note:  Best practice is to define new MIB string
-                    objects with invariant UTF-8 (RFC 3629) syntax
-                    using the SnmpAdminString TC (defined in RFC 3411)
-                    in accordance with IETF Policy on Character Sets and
-                    Languages (RFC 2277).
-
-                    Copyright (C) The Internet Society (2004).  The
-                    initial version of this MIB module was published
-                    in RFC 3808; for full legal notices see the RFC
-                    itself.  Supplementary information may be
-                    available on
-                    http://www.ietf.org/copyrights/ianamib.html."
-
-    --  revision history
-    
-    REVISION        "200705140000Z"
-    DESCRIPTION     "Registration of new charset 2107."
-
-    REVISION        "200612070000Z"
-    DESCRIPTION     "Registration of new charsets numbered 118, 119, 
-                    and 2106."
-
-    REVISION        "200406080000Z"
-    DESCRIPTION     "Original version transferred from Printer MIB,
-                    generated from the IANA maintained assignments
-                    http://www.iana.org/assignments/character-sets."
-
-    ::= { mib-2 106 }
-
-IANACharset ::= TEXTUAL-CONVENTION
-    STATUS  current
-    DESCRIPTION
-        "Specifies an IANA registered 'charset' - coded character set
-        (CCS) plus optional character encoding scheme (CES) - terms
-        defined in 'IANA Charset Registration Procedures' (RFC 2978).
-
-        Objects of this syntax are used to specify the encoding for
-        string objects defined in one or more MIBs.  For example, the
-        prtLocalizationCharacterSet, prtInterpreterDefaultCharSetIn, and
-        prtInterpreterDefaultCharSetOut objects defined in Printer MIB.
-
-        The current list of 'charset' names and enumerated values
-        is contained in the IANA Character Set Registry at:
-
-           http://www.iana.org/assignments/character-sets
-
-        Enum names are derived from the IANA Charset Registry 'Alias'
-        fields that begin with 'cs' (for character set).
-        Enum values are derived from the parallel 'MIBenum' fields."
-    SYNTAX  INTEGER {
-        other(1),   -- used if the designated
-                    -- character set is not currently
-                    -- registered by IANA
-        unknown(2), -- used as a default value
-        csASCII(3),
-        csISOLatin1(4),
-        csISOLatin2(5),
-        csISOLatin3(6),
-        csISOLatin4(7),
-        csISOLatinCyrillic(8),
-        csISOLatinArabic(9),
-        csISOLatinGreek(10),
-        csISOLatinHebrew(11),
-        csISOLatin5(12),
-        csISOLatin6(13),
-        csISOTextComm(14),
-        csHalfWidthKatakana(15),
-        csJISEncoding(16),
-        csShiftJIS(17),
-        csEUCPkdFmtJapanese(18),
-        csEUCFixWidJapanese(19),
-        csISO4UnitedKingdom(20),
-        csISO11SwedishForNames(21),
-        csISO15Italian(22),
-        csISO17Spanish(23),
-        csISO21German(24),
-        csISO60DanishNorwegian(25),
-        csISO69French(26),
-        csISO10646UTF1(27),
-        csISO646basic1983(28),
-        csINVARIANT(29),
-        csISO2IntlRefVersion(30),
-        csNATSSEFI(31),
-        csNATSSEFIADD(32),
-        csNATSDANO(33),
-        csNATSDANOADD(34),
-        csISO10Swedish(35),
-        csKSC56011987(36),
-        csISO2022KR(37),
-        csEUCKR(38),
-        csISO2022JP(39),
-        csISO2022JP2(40),
-        csISO13JISC6220jp(41),
-        csISO14JISC6220ro(42),
-        csISO16Portuguese(43),
-        csISO18Greek7Old(44),
-        csISO19LatinGreek(45),
-        csISO25French(46),
-        csISO27LatinGreek1(47),
-        csISO5427Cyrillic(48),
-        csISO42JISC62261978(49),
-        csISO47BSViewdata(50),
-        csISO49INIS(51),
-        csISO50INIS8(52),
-        csISO51INISCyrillic(53),
-        csISO54271981(54),
-        csISO5428Greek(55),
-        csISO57GB1988(56),
-        csISO58GB231280(57),
-        csISO61Norwegian2(58),
-        csISO70VideotexSupp1(59),
-        csISO84Portuguese2(60),
-        csISO85Spanish2(61),
-        csISO86Hungarian(62),
-        csISO87JISX0208(63),
-        csISO88Greek7(64),
-        csISO89ASMO449(65),
-        csISO90(66),
-        csISO91JISC62291984a(67),
-        csISO92JISC62991984b(68),
-        csISO93JIS62291984badd(69),
-        csISO94JIS62291984hand(70),
-        csISO95JIS62291984handadd(71),
-        csISO96JISC62291984kana(72),
-        csISO2033(73),
-        csISO99NAPLPS(74),
-        csISO102T617bit(75),
-        csISO103T618bit(76),
-        csISO111ECMACyrillic(77),
-        csa71(78),
-        csa72(79),
-        csISO123CSAZ24341985gr(80),
-        csISO88596E(81),
-        csISO88596I(82),
-        csISO128T101G2(83),
-        csISO88598E(84),
-        csISO88598I(85),
-        csISO139CSN369103(86),
-        csISO141JUSIB1002(87),
-        csISO143IECP271(88),
-        csISO146Serbian(89),
-        csISO147Macedonian(90),
-        csISO150(91),
-        csISO151Cuba(92),
-        csISO6937Add(93),
-        csISO153GOST1976874(94),
-        csISO8859Supp(95),
-        csISO10367Box(96),
-        csISO158Lap(97),
-        csISO159JISX02121990(98),
-        csISO646Danish(99),
-        csUSDK(100),
-        csDKUS(101),
-        csKSC5636(102),
-        csUnicode11UTF7(103),
-        csISO2022CN(104),
-        csISO2022CNEXT(105),
-        csUTF8(106),
-        csISO885913(109),
-        csISO885914(110),
-        csISO885915(111),
-        csISO885916(112),
-        csGBK(113),
-        csGB18030(114),
-        csOSDEBCDICDF0415(115),
-        csOSDEBCDICDF03IRV(116),
-        csOSDEBCDICDF041(117),
-        csISO115481(118),
-        csKZ1048(119),
-        csUnicode(1000),
-        csUCS4(1001),
-        csUnicodeASCII(1002),
-        csUnicodeLatin1(1003),
-        csUnicodeIBM1261(1005),
-        csUnicodeIBM1268(1006),
-        csUnicodeIBM1276(1007),
-        csUnicodeIBM1264(1008),
-        csUnicodeIBM1265(1009),
-        csUnicode11(1010),
-        csSCSU(1011),
-        csUTF7(1012),
-        csUTF16BE(1013),
-        csUTF16LE(1014),
-        csUTF16(1015),
-        csCESU8(1016),
-        csUTF32(1017),
-        csUTF32BE(1018),
-        csUTF32LE(1019),
-        csBOCU1(1020),
-        csWindows30Latin1(2000),
-        csWindows31Latin1(2001),
-        csWindows31Latin2(2002),
-        csWindows31Latin5(2003),
-        csHPRoman8(2004),
-        csAdobeStandardEncoding(2005),
-        csVenturaUS(2006),
-        csVenturaInternational(2007),
-        csDECMCS(2008),
-        csPC850Multilingual(2009),
-        csPCp852(2010),
-        csPC8CodePage437(2011),
-        csPC8DanishNorwegian(2012),
-        csPC862LatinHebrew(2013),
-        csPC8Turkish(2014),
-        csIBMSymbols(2015),
-        csIBMThai(2016),
-        csHPLegal(2017),
-        csHPPiFont(2018),
-        csHPMath8(2019),
-        csHPPSMath(2020),
-        csHPDesktop(2021),
-        csVenturaMath(2022),
-        csMicrosoftPublishing(2023),
-        csWindows31J(2024),
-        csGB2312(2025),
-        csBig5(2026),
-        csMacintosh(2027),
-        csIBM037(2028),
-        csIBM038(2029),
-        csIBM273(2030),
-        csIBM274(2031),
-        csIBM275(2032),
-        csIBM277(2033),
-        csIBM278(2034),
-        csIBM280(2035),
-        csIBM281(2036),
-        csIBM284(2037),
-        csIBM285(2038),
-        csIBM290(2039),
-        csIBM297(2040),
-        csIBM420(2041),
-        csIBM423(2042),
-        csIBM424(2043),
-        csIBM500(2044),
-        csIBM851(2045),
-        csIBM855(2046),
-        csIBM857(2047),
-        csIBM860(2048),
-        csIBM861(2049),
-        csIBM863(2050),
-        csIBM864(2051),
-        csIBM865(2052),
-        csIBM868(2053),
-        csIBM869(2054),
-        csIBM870(2055),
-        csIBM871(2056),
-        csIBM880(2057),
-        csIBM891(2058),
-        csIBM903(2059),
-        csIBBM904(2060),
-        csIBM905(2061),
-        csIBM918(2062),
-        csIBM1026(2063),
-        csIBMEBCDICATDE(2064),
-        csEBCDICATDEA(2065),
-        csEBCDICCAFR(2066),
-        csEBCDICDKNO(2067),
-        csEBCDICDKNOA(2068),
-        csEBCDICFISE(2069),
-        csEBCDICFISEA(2070),
-        csEBCDICFR(2071),
-        csEBCDICIT(2072),
-        csEBCDICPT(2073),
-        csEBCDICES(2074),
-        csEBCDICESA(2075),
-        csEBCDICESS(2076),
-        csEBCDICUK(2077),
-        csEBCDICUS(2078),
-        csUnknown8BiT(2079),
-        csMnemonic(2080),
-        csMnem(2081),
-        csVISCII(2082),
-        csVIQR(2083),
-        csKOI8R(2084),
-        csHZGB2312(2085),
-        csIBM866(2086),
-        csPC775Baltic(2087),
-        csKOI8U(2088),
-        csIBM00858(2089),
-        csIBM00924(2090),
-        csIBM01140(2091),
-        csIBM01141(2092),
-        csIBM01142(2093),
-        csIBM01143(2094),
-        csIBM01144(2095),
-        csIBM01145(2096),
-        csIBM01146(2097),
-        csIBM01147(2098),
-        csIBM01148(2099),
-        csIBM01149(2100),
-        csBig5HKSCS(2101),
-        csIBM1047(2102),
-        csPTCP154(2103),
-        csAmiga1251(2104),
-        csKOI7switched(2105),
-        csBRF(2106),
-        csTSCII(2107),
-        cswindows1250(2250),
-        cswindows1251(2251),
-        cswindows1252(2252),
-        cswindows1253(2253),
-        cswindows1254(2254),
-        cswindows1255(2255),
-        cswindows1256(2256),
-        cswindows1257(2257),
-        cswindows1258(2258),
-        csTIS620(2259),
-        reserved(3000)
-    }
-END
-
diff --git a/contrib/apps/LwipMibCompiler/Mibs/IANA/IANA-ITU-ALARM-TC-MIB b/contrib/apps/LwipMibCompiler/Mibs/IANA/IANA-ITU-ALARM-TC-MIB
deleted file mode 100644
index 8579485c..00000000
--- a/contrib/apps/LwipMibCompiler/Mibs/IANA/IANA-ITU-ALARM-TC-MIB
+++ /dev/null
@@ -1,333 +0,0 @@
-IANA-ITU-ALARM-TC-MIB DEFINITIONS ::= BEGIN
-
-   IMPORTS
-      MODULE-IDENTITY, mib-2       FROM SNMPv2-SMI
-      TEXTUAL-CONVENTION           FROM SNMPv2-TC;
-
-    ianaItuAlarmNumbers MODULE-IDENTITY
-        LAST-UPDATED "200409090000Z"  -- September 09, 2004
-        ORGANIZATION "IANA"
-        CONTACT-INFO
-            "Postal:    Internet Assigned Numbers Authority
-                        Internet Corporation for Assigned Names
-                        and Numbers
-                        4676 Admiralty Way, Suite 330
-                        Marina del Rey, CA 90292-6601
-                        USA
-
-            Tel:    +1  310-823-9358
-            E-Mail: iana&iana.org"
-        DESCRIPTION
-            "The MIB module defines the ITU Alarm
-            textual convention for objects expected to require
-            regular extension.
-
-            Copyright (C) The Internet Society (2004).  The
-            initial version of this MIB module was published
-            in RFC 3877. For full legal notices see the RFC
-            itself. Supplementary information may be available on:
-                 http://www.ietf.org/copyrights/ianamib.html"
-         REVISION    "200409090000Z"
-         DESCRIPTION
-             "Initial version, published as RFC 3877."
-        ::= { mib-2 119 } 
-
-
-   IANAItuProbableCause ::= TEXTUAL-CONVENTION
-       STATUS current
-       DESCRIPTION
-           "ITU-T probable cause values. Duplicate values defined in
-            X.733 are appended with X733 to ensure syntactic uniqueness.
-            Probable cause value 0 is reserved for special purposes.
-
-            The Internet Assigned Number Authority (IANA) is responsible
-            for the assignment of the enumerations in this TC.
-            IANAItuProbableCause value of 0 is reserved for special
-            purposes and MUST NOT be assigned.
-
-            Values of IANAItuProbableCause in the range 1 to 1023 are
-            reserved for causes that correspond to ITU-T probable cause.
-
-            All other requests for new causes will be handled on a
-            first-come, first served basis and will be assigned
-            enumeration values starting with 1025.
-
-            Request should  come in the form of well-formed
-            SMI [RFC2578] for enumeration names that are unique and
-            sufficiently descriptive.
-
-            While some effort will be taken to ensure that new probable
-            causes do not conceptually duplicate existing probable
-            causes it is acknowledged that the existence of conceptual
-            duplicates in the starting probable cause list is an known
-            industry reality.
-
-            To aid IANA in the administration of probable cause names
-            and values, the OPS Area Director will appoint one or more
-            experts to help review requests.
-
-            See http://www.iana.org"
-       REFERENCE
-           "ITU Recommendation M.3100, 'Generic Network Information
-               Model', 1995
-            ITU Recommendation X.733, 'Information Technology - Open
-               Systems Interconnection - System Management: Alarm
-               Reporting Function', 1992
-            ITU Recommendation X.736, 'Information Technology - Open
-               Systems Interconnection - System Management: Security
-               Alarm Reporting Function', 1992"
-
-       SYNTAX         INTEGER
-               {
-               -- The following probable causes were defined in M.3100
-                aIS  (1),
-                callSetUpFailure  (2),
-                degradedSignal  (3),
-                farEndReceiverFailure  (4),
-                framingError  (5),
-                lossOfFrame (6),
-                lossOfPointer  (7),
-                lossOfSignal  (8),
-                payloadTypeMismatch (9),
-                transmissionError (10),
-                remoteAlarmInterface (11),
-                excessiveBER  (12),
-                pathTraceMismatch  (13),
-                unavailable  (14),
-                signalLabelMismatch (15),
-                lossOfMultiFrame (16),
-                receiveFailure (17),
-                transmitFailure (18),
-                modulationFailure (19),
-                demodulationFailure (20),
-                broadcastChannelFailure (21),
-                connectionEstablishmentError (22),
-                invalidMessageReceived (23),
-                localNodeTransmissionError (24),
-                remoteNodeTransmissionError (25),
-                routingFailure (26),
-    --Values 27-50 are reserved for communications alarm related
-    --probable causes
-    -- The following are used with equipment alarm.
-                backplaneFailure (51),
-                dataSetProblem  (52),
-                equipmentIdentifierDuplication  (53),
-                externalIFDeviceProblem  (54),
-                lineCardProblem (55),
-                multiplexerProblem  (56),
-                nEIdentifierDuplication  (57),
-                powerProblem  (58),
-                processorProblem  (59),
-                protectionPathFailure  (60),
-                receiverFailure  (61),
-                replaceableUnitMissing  (62),
-                replaceableUnitTypeMismatch (63),
-                synchronizationSourceMismatch  (64),
-                terminalProblem   (65),
-                timingProblem   (66),
-                transmitterFailure  (67),
-                trunkCardProblem  (68),
-                replaceableUnitProblem  (69),
-                realTimeClockFailure (70),
-    --An equipment alarm to be issued if the system detects that the
-    --real time clock has failed
-                antennaFailure (71),
-                batteryChargingFailure (72),
-                diskFailure (73),
-                frequencyHoppingFailure (74),
-                iODeviceError (75),
-                lossOfSynchronisation (76),
-                lossOfRedundancy (77),
-                powerSupplyFailure (78),
-                signalQualityEvaluationFailure (79),
-                tranceiverFailure (80),
-                protectionMechanismFailure (81),
-                protectingResourceFailure (82),
-    -- Values 83-100 are reserved for equipment alarm related probable
-    -- causes
-    -- The following are used with environmental alarm.
-                airCompressorFailure  (101),
-                airConditioningFailure  (102),
-                airDryerFailure   (103),
-                batteryDischarging  (104),
-                batteryFailure   (105),
-                commercialPowerFailure  (106),
-                coolingFanFailure  (107),
-                engineFailure  (108),
-                fireDetectorFailure  (109),
-                fuseFailure  (110),
-                generatorFailure  (111),
-                lowBatteryThreshold (112),
-                pumpFailure  (113),
-                rectifierFailure  (114),
-                rectifierHighVoltage  (115),
-                rectifierLowFVoltage  (116),
-                ventilationsSystemFailure  (117),
-                enclosureDoorOpen  (118),
-                explosiveGas  (119),
-                fire (120),
-                flood   (121),
-                highHumidity  (122),
-                highTemperature  (123),
-                highWind  (124),
-                iceBuildUp  (125),
-                intrusionDetection  (126),
-                lowFuel  (127),
-                lowHumidity  (128),
-                lowCablePressure  (129),
-                lowTemperatue  (130),
-                lowWater  (131),
-                smoke  (132),
-                toxicGas  (133),
-                coolingSystemFailure (134),
-                externalEquipmentFailure (135),
-                externalPointFailure (136),
-    -- Values 137-150 are reserved for environmental alarm related
-    -- probable causes
-    -- The following are used with Processing error alarm.
-                storageCapacityProblem (151),
-                memoryMismatch  (152),
-                corruptData  (153),
-                outOfCPUCycles   (154),
-                sfwrEnvironmentProblem  (155),
-                sfwrDownloadFailure  (156),
-                lossOfRealTimel (157),
-    --A processing error alarm to be issued after the system has
-    --reinitialised. This will indicate
-    --to the management systems that the view they have of the managed
-    --system may no longer
-    --be valid. Usage example: The managed
-    --system issues this alarm after a reinitialization with severity
-    --warning to inform the
-    --management system about the event. No clearing notification will
-    --be sent.
-                applicationSubsystemFailure (158),
-                configurationOrCustomisationError (159),
-                databaseInconsistency (160),
-                fileError (161),
-                outOfMemory (162),
-                softwareError (163),
-                timeoutExpired (164),
-                underlayingResourceUnavailable (165),
-                versionMismatch (166),
-    --Values 168-200 are reserved for processing error alarm related
-    -- probable causes.
-                bandwidthReduced (201),
-                congestion (202),
-                excessiveErrorRate (203),
-                excessiveResponseTime (204),
-                excessiveRetransmissionRate (205),
-                reducedLoggingCapability (206),
-                systemResourcesOverload (207 ),
-                -- The following were defined X.733
-                adapterError (500),
-                applicationSubsystemFailture (501),
-                bandwidthReducedX733 (502),
-                callEstablishmentError (503),
-                communicationsProtocolError (504),
-                communicationsSubsystemFailure (505),
-                configurationOrCustomizationError (506),
-                congestionX733 (507),
-                coruptData (508),
-                cpuCyclesLimitExceeded (509),
-                dataSetOrModemError (510),
-                degradedSignalX733 (511),
-                dteDceInterfaceError (512),
-                enclosureDoorOpenX733 (513),
-                equipmentMalfunction (514),
-                excessiveVibration (515),
-                fileErrorX733 (516),
-                fireDetected (517),
-                framingErrorX733 (518),
-                heatingVentCoolingSystemProblem (519),
-                humidityUnacceptable (520),
-                inputOutputDeviceError (521),
-                inputDeviceError (522),
-                lanError (523),
-                leakDetected (524),
-                localNodeTransmissionErrorX733 (525),
-                lossOfFrameX733 (526),
-                lossOfSignalX733 (527),
-                materialSupplyExhausted (528),
-                multiplexerProblemX733 (529),
-                outOfMemoryX733 (530),
-                ouputDeviceError (531),
-                performanceDegraded (532),
-                powerProblems (533),
-                pressureUnacceptable (534),
-                processorProblems (535),
-                pumpFailureX733 (536),
-                queueSizeExceeded (537),
-                receiveFailureX733 (538),
-                receiverFailureX733 (539),
-                remoteNodeTransmissionErrorX733 (540),
-                resourceAtOrNearingCapacity (541),
-                responseTimeExecessive (542),
-                retransmissionRateExcessive (543),
-                softwareErrorX733 (544),
-                softwareProgramAbnormallyTerminated (545),
-                softwareProgramError (546),
-                storageCapacityProblemX733 (547),
-                temperatureUnacceptable (548),
-                thresholdCrossed (549),
-                timingProblemX733 (550),
-                toxicLeakDetected (551),
-                transmitFailureX733 (552),
-                transmiterFailure (553),
-                underlyingResourceUnavailable (554),
-                versionMismatchX733 (555),
-                -- The following are defined in X.736
-                authenticationFailure (600),
-                breachOfConfidentiality (601),
-                cableTamper (602),
-                delayedInformation (603),
-                denialOfService (604),
-                duplicateInformation (605),
-                informationMissing (606),
-                informationModificationDetected (607),
-                informationOutOfSequence (608),
-                keyExpired (609),
-                nonRepudiationFailure (610),
-                outOfHoursActivity (611),
-                outOfService (612),
-                proceduralError (613),
-                unauthorizedAccessAttempt (614),
-                unexpectedInformation (615),
-
-                other (1024)
-                }
-
-   IANAItuEventType ::= TEXTUAL-CONVENTION
-       STATUS current
-       DESCRIPTION
-               "The ITU event Type values.
-
-               The Internet Assigned Number Authority (IANA) is
-               responsible for the assignment of the enumerations
-               in this TC.
-
-               Request should  come in the form of well-formed
-               SMI [RFC2578] for enumeration names that are unique
-               and sufficiently descriptive.
-
-               See http://www.iana.org "
-       REFERENCE
-              "ITU Recommendation X.736, 'Information Technology - Open
-               Systems Interconnection - System Management: Security
-               Alarm Reporting Function', 1992"
-       SYNTAX         INTEGER
-              {
-              other (1),
-              communicationsAlarm (2),
-              qualityOfServiceAlarm (3),
-              processingErrorAlarm (4),
-              equipmentAlarm (5),
-              environmentalAlarm (6),
-              integrityViolation (7),
-              operationalViolation (8),
-              physicalViolation (9),
-              securityServiceOrMechanismViolation (10),
-              timeDomainViolation (11)
-              }
-
-   END
diff --git a/contrib/apps/LwipMibCompiler/Mibs/IANA/IANA-LANGUAGE-MIB b/contrib/apps/LwipMibCompiler/Mibs/IANA/IANA-LANGUAGE-MIB
deleted file mode 100644
index 6210f723..00000000
--- a/contrib/apps/LwipMibCompiler/Mibs/IANA/IANA-LANGUAGE-MIB
+++ /dev/null
@@ -1,127 +0,0 @@
-
-   IANA-LANGUAGE-MIB DEFINITIONS ::= BEGIN
-
-   IMPORTS
-       MODULE-IDENTITY, OBJECT-IDENTITY, mib-2
-           FROM SNMPv2-SMI;
-
-   ianaLanguages MODULE-IDENTITY
-       LAST-UPDATED "200005100000Z"  -- May 10, 2000
-       ORGANIZATION "IANA"
-       CONTACT-INFO
-           "Internet Assigned Numbers Authority (IANA)
-
-            Postal: ICANN
-                    4676 Admiralty Way, Suite 330
-                    Marina del Rey, CA 90292
-
-            Tel:    +1 310 823 9358 x20
-            E-Mail: iana&iana.org"
-       DESCRIPTION
-           "The MIB module registers object identifier values for
-            well-known programming and scripting languages. Every
-            language registration MUST describe the format used
-            when transferring scripts written in this language.
-
-            Any additions or changes to the contents of this MIB
-            module require Designated Expert Review as defined in
-            the Guidelines for Writing IANA Considerations Section
-            document. The Designated Expert will be selected by
-            the IESG Area Director of the OPS Area.
-
-            Note, this module does not have to register all possible
-            languages since languages are identified by object
-            identifier values. It is therefore possible to registered 
-            languages in private OID trees. The references given below are not
-            normative with regard to the language version. Other
-            references might be better suited to describe some newer 
-            versions of this language. The references are only
-            provided as `a pointer into the right direction'."
-
-    -- Revision log, in reverse chronological order
-
-       REVISION    "200005100000Z" -- May 10, 2000
-       DESCRIPTION "Import mib-2 instead of experimental, so that
-                    this module compiles"
-
-       REVISION    "199909090900Z" -- September 9, 1999
-       DESCRIPTION "Initial version as published at time of
-                    publication of RFC 2591."
-
-       ::= { mib-2 73 }
-
-
-   ianaLangJavaByteCode OBJECT-IDENTITY
-       STATUS  current
-       DESCRIPTION
-           "Java byte code to be processed by a Java virtual machine.
-            A script written in Java byte code is transferred by using
-            the Java archive file format (JAR)."
-       REFERENCE
-           "The Java Virtual Machine Specification.
-            ISBN 0-201-63452-X"
-       ::= { ianaLanguages 1 }
-
-   ianaLangTcl OBJECT-IDENTITY
-       STATUS  current
-       DESCRIPTION
-           "The Tool Command Language (Tcl). A script written in the
-            Tcl language is transferred in Tcl source code format."
-       REFERENCE
-           "Tcl and the Tk Toolkit.
-            ISBN 0-201-63337-X"
-       ::= { ianaLanguages 2 }
-
-   ianaLangPerl OBJECT-IDENTITY
-       STATUS  current
-       DESCRIPTION
-           "The Perl language. A script written in the Perl language
-            is transferred in Perl source code format."
-       REFERENCE
-           "Programming Perl.
-            ISBN 1-56592-149-6"
-       ::= { ianaLanguages 3 }
-
-   ianaLangScheme OBJECT-IDENTITY
-       STATUS  current
-       DESCRIPTION
-           "The Scheme language. A script written in the Scheme
-            language is transferred in Scheme source code format."
-       REFERENCE
-           "The Revised^4 Report on the Algorithmic Language Scheme.
-            MIT Press"
-       ::= { ianaLanguages 4 }
-
-   ianaLangSRSL OBJECT-IDENTITY
-       STATUS  current
-       DESCRIPTION
-           "The SNMP Script Language defined by SNMP Research. A
-            script written in the SNMP Script Language is transferred
-            in the SNMP Script Language source code format."
-       ::= { ianaLanguages 5 }
-
-   ianaLangPSL OBJECT-IDENTITY
-       STATUS  current
-       DESCRIPTION
-           "The Patrol Script Language defined by BMC Software. A script
-            written in the Patrol Script Language is transferred in the
-            Patrol Script Language source code format."
-       REFERENCE
-           "PATROL Script Language Reference Manual, Version 3.0,
-            November 30, 1995. BMC Software, Inc. 2101 City West Blvd.,
-            Houston, Texas 77042."
-       ::= { ianaLanguages 6 }
-
-   ianaLangSMSL OBJECT-IDENTITY
-       STATUS  current
-       DESCRIPTION
-           "The Systems Management Scripting Language. A script written
-            in the SMSL language is transferred in the SMSL source code
-            format."
-       REFERENCE
-           "ISO/ITU Command Sequencer.
-            ISO 10164-21 or ITU X.753"
-       ::= { ianaLanguages 7 }
-
-   END
-
diff --git a/contrib/apps/LwipMibCompiler/Mibs/IANA/IANA-MALLOC-MIB b/contrib/apps/LwipMibCompiler/Mibs/IANA/IANA-MALLOC-MIB
deleted file mode 100644
index 5869a363..00000000
--- a/contrib/apps/LwipMibCompiler/Mibs/IANA/IANA-MALLOC-MIB
+++ /dev/null
@@ -1,67 +0,0 @@
-
-IANA-MALLOC-MIB DEFINITIONS ::= BEGIN
-
-IMPORTS
-    MODULE-IDENTITY, mib-2           FROM SNMPv2-SMI
-    TEXTUAL-CONVENTION               FROM SNMPv2-TC;
-
-ianaMallocMIB MODULE-IDENTITY
-    LAST-UPDATED "200301271200Z" -- January 27, 2003
-    ORGANIZATION "IANA"
-    CONTACT-INFO
-            " Internet Assigned Numbers Authority
-              Internet Corporation for Assigned Names and Numbers
-              4676 Admiralty Way, Suite 330
-              Marina del Rey, CA 90292-6601
-
-              Phone: +1 310 823 9358
-              EMail: iana&iana.org"
-    DESCRIPTION
-            "This MIB module defines the IANAscopeSource and
-            IANAmallocRangeSource textual conventions for use in MIBs
-            which need to identify ways of learning multicast scope and
-            range information.
-
-            Any additions or changes to the contents of this MIB module
-            require either publication of an RFC, or Designated Expert
-            Review as defined in the Guidelines for Writing IANA
-            Considerations Section document.  The Designated Expert will
-            be selected by the IESG Area Director(s) of the Transport
-            Area."
-
-    -- revision log
-
-    REVISION     "200301271200Z" -- January 27, 2003
-    DESCRIPTION
-            "Initial version."
-    ::= { mib-2 102 } 
-
-IANAscopeSource ::= TEXTUAL-CONVENTION
-   STATUS  current
-   DESCRIPTION
-            "The source of multicast scope information."
-   SYNTAX  INTEGER {
-              other(1),  -- none of the following
-              manual(2), -- statically configured
-              local(3),  -- automatically added by the system,
-                         -- such as a Source-Specific Multicast
-                         -- scope
-              mzap(4),   -- MZAP
-              madcap(5)  -- MADCAP
-           }
-
-IANAmallocRangeSource ::= TEXTUAL-CONVENTION
-   STATUS  current
-   DESCRIPTION
-            "The source of multicast address allocation range
-            information."
-   SYNTAX  INTEGER {
-              other(1),  -- none of the following
-              manual(2), -- statically configured
-              local(3)   -- automatically added by the system,
-                         -- such as a Source-Specific Multicast
-                         -- range
-           }
-
-END
-
diff --git a/contrib/apps/LwipMibCompiler/Mibs/IANA/IANA-MAU-MIB b/contrib/apps/LwipMibCompiler/Mibs/IANA/IANA-MAU-MIB
deleted file mode 100644
index 35c3f4a8..00000000
--- a/contrib/apps/LwipMibCompiler/Mibs/IANA/IANA-MAU-MIB
+++ /dev/null
@@ -1,770 +0,0 @@
-IANA-MAU-MIB DEFINITIONS ::= BEGIN
-
-     IMPORTS
-       MODULE-IDENTITY, OBJECT-IDENTITY, mib-2
-         FROM SNMPv2-SMI
-       TEXTUAL-CONVENTION
-         FROM SNMPv2-TC
-       ;
-
-     ianaMauMIB MODULE-IDENTITY
-       LAST-UPDATED "200704210000Z"  -- April 21, 2007
-       ORGANIZATION "IANA"
-       CONTACT-INFO "        Internet Assigned Numbers Authority
-
-                     Postal: ICANN
-                             4676 Admiralty Way, Suite 330
-                             Marina del Rey, CA 90292
-
-                        Tel: +1-310-823-9358
-                      EMail: iana&iana.org"
-
-       DESCRIPTION
-         "This MIB module defines dot3MauType OBJECT-IDENTITIES and
-         IANAifMauListBits, IANAifMauMediaAvailable,
-         IANAifMauAutoNegCapBits, and IANAifJackType
-
-         TEXTUAL-CONVENTIONs, specifying enumerated values of the
-         ifMauTypeListBits, ifMauMediaAvailable / rpMauMediaAvailable,
-         ifMauAutoNegCapabilityBits / ifMauAutoNegCapAdvertisedBits /
-         ifMauAutoNegCapReceivedBits and ifJackType / rpJackType objects
-         respectively, defined in the MAU-MIB.
-
-         It is intended that each new MAU type, Media Availability
-         state, Auto Negotiation capability and/or Jack type defined by
-         the IEEE 802.3 working group and approved for publication in a
-         revision of IEEE Std 802.3 will be added to this MIB module,
-         provided that it is suitable for being managed by the base
-         objects in the MAU-MIB.  An Expert Review, as defined in
-         RFC 2434 [RFC2434], is REQUIRED for such additions.
-
-         The following reference is used throughout this MIB module:
-
-         [IEEE802.3] refers to:
-            IEEE Std 802.3, 2005 Edition: 'IEEE Standard for
-            Information technology - Telecommunications and information
-            exchange between systems - Local and metropolitan area
-            networks - Specific requirements -
-            Part 3: Carrier sense multiple access with collision
-            detection (CSMA/CD) access method and physical layer
-            specifications'.
-
-         This reference should be updated as appropriate when new
-         MAU types, Media Availability states, Auto Negotiation
-         capabilities, and/or Jack types are added to this MIB module.
-
-         Copyright (C) The IETF Trust (2007).
-         The initial version of this MIB module was published in
-         RFC 4836; for full legal notices see the RFC itself.
-         Supplementary information may be available at:
-         http://www.ietf.org/copyrights/ianamib.html"
-
-       REVISION     "200704210000Z"  -- April 21, 2007
-       DESCRIPTION  "Initial version of this MIB as published in
-                     RFC 4836."
-       ::= { mib-2 154 }
-
-     -- Textual Conventions
-
-     IANAifMauTypeListBits ::= TEXTUAL-CONVENTION
-       STATUS       current
-       DESCRIPTION
-         "This data type is used as the syntax of the ifMauTypeListBits
-         object in the (updated) definition of MAU-MIB's ifMauTable.
-
-         The most recent version of this textual convention is available
-         in the online version of this MIB module on the IANA web site.
-
-         Requests for new values should be made to IANA via email
-         (iana&iana.org).
-
-         Note that changes in this textual convention SHALL be
-         synchronized with relevant changes in the dot3MauType
-         OBJECT-IDENTITIES."
-       REFERENCE
-         "[IEEE802.3], Section 30.5.1.1.2"
-       SYNTAX       BITS {
-              bOther(0),          -- other or unknown
-              bAUI(1),            -- AUI
-              b10base5(2),        -- 10BASE-5
-              bFoirl(3),          -- FOIRL
-
-              b10base2(4),        -- 10BASE-2
-              b10baseT(5),        -- 10BASE-T duplex mode unknown
-              b10baseFP(6),       -- 10BASE-FP
-              b10baseFB(7),       -- 10BASE-FB
-              b10baseFL(8),       -- 10BASE-FL duplex mode unknown
-              b10broad36(9),      -- 10BROAD36
-              b10baseTHD(10),     -- 10BASE-T  half duplex mode
-              b10baseTFD(11),     -- 10BASE-T  full duplex mode
-              b10baseFLHD(12),    -- 10BASE-FL half duplex mode
-              b10baseFLFD(13),    -- 10BASE-FL full duplex mode
-              b100baseT4(14),     -- 100BASE-T4
-              b100baseTXHD(15),   -- 100BASE-TX half duplex mode
-              b100baseTXFD(16),   -- 100BASE-TX full duplex mode
-              b100baseFXHD(17),   -- 100BASE-FX half duplex mode
-              b100baseFXFD(18),   -- 100BASE-FX full duplex mode
-              b100baseT2HD(19),   -- 100BASE-T2 half duplex mode
-              b100baseT2FD(20),   -- 100BASE-T2 full duplex mode
-
-              b1000baseXHD(21),   -- 1000BASE-X half duplex mode
-              b1000baseXFD(22),   -- 1000BASE-X full duplex mode
-              b1000baseLXHD(23),  -- 1000BASE-LX half duplex mode
-              b1000baseLXFD(24),  -- 1000BASE-LX full duplex mode
-              b1000baseSXHD(25),  -- 1000BASE-SX half duplex mode
-              b1000baseSXFD(26),  -- 1000BASE-SX full duplex mode
-              b1000baseCXHD(27),  -- 1000BASE-CX half duplex mode
-              b1000baseCXFD(28),  -- 1000BASE-CX full duplex mode
-              b1000baseTHD(29),   -- 1000BASE-T half duplex mode
-              b1000baseTFD(30),   -- 1000BASE-T full duplex mode
-
-              b10GbaseX(31),      -- 10GBASE-X
-              b10GbaseLX4(32),    -- 10GBASE-LX4
-
-              b10GbaseR(33),      -- 10GBASE-R
-              b10GbaseER(34),     -- 10GBASE-ER
-              b10GbaseLR(35),     -- 10GBASE-LR
-              b10GbaseSR(36),     -- 10GBASE-SR
-              b10GbaseW(37),      -- 10GBASE-W
-              b10GbaseEW(38),     -- 10GBASE-EW
-              b10GbaseLW(39),     -- 10GBASE-LW
-              b10GbaseSW(40),     -- 10GBASE-SW
-              -- new since RFC 3636
-              b10GbaseCX4(41),    -- 10GBASE-CX4
-              b2BaseTL(42),       -- 2BASE-TL
-              b10PassTS(43),      -- 10PASS-TS
-              b100BaseBX10D(44),  -- 100BASE-BX10D
-              b100BaseBX10U(45),  -- 100BASE-BX10U
-              b100BaseLX10(46),   -- 100BASE-LX10
-              b1000BaseBX10D(47), -- 1000BASE-BX10D
-              b1000BaseBX10U(48), -- 1000BASE-BX10U
-              b1000BaseLX10(49),  -- 1000BASE-LX10
-              b1000BasePX10D(50), -- 1000BASE-PX10D
-              b1000BasePX10U(51), -- 1000BASE-PX10U
-              b1000BasePX20D(52), -- 1000BASE-PX20D
-              b1000BasePX20U(53)  -- 1000BASE-PX20U
-         }
-
-     IANAifMauMediaAvailable ::= TEXTUAL-CONVENTION
-       STATUS       current
-       DESCRIPTION
-         "This data type is used as the syntax of the
-         ifMauMediaAvailable and rpMauMediaAvailable objects in the
-         (updated) definition of MAU-MIB's ifMauTable and rpMauTable
-         respectively.
-
-         Possible values are:
-           other(1)             - undefined (not listed below)
-           unknown(2)           - MAU's true state is unknown; e.g.,
-                                  during initialization
-           available(3)         - link, light, or loopback is normal
-           notAvailable(4)      - link loss, low light, or no loopback
-           remoteFault(5)       - a fault has been detected at the
-                                  remote end of the link.  This value
-                                  applies to 10BASE-FB, 100BASE-T4 Far
-                                  End Fault Indication and non-specified
-                                  remote faults from a system running
-                                  auto-negotiation
-           invalidSignal(6)     - invalid signal has been received from
-                                  the other end of the link, 10BASE-FB
-                                  only
-           remoteJabber(7)      - remote fault, due to jabber
-
-           remoteLinkLoss(8)    - remote fault, due to link loss
-           remoteTest(9)        - remote fault, due to test
-           offline(10)          - offline, Clause 37 Auto-Negotiation
-                                  only
-           autoNegError(11)     - Auto-Negotiation Error, Clause 37
-                                  Auto-Negotiation only
-           pmdLinkFault(12)     - PMA/PMD receive link fault.  In case
-                                  of PAF (2BASE-TL / 10PASS-TS PHYs),
-                                  all PMEs in the aggregation group have
-                                  detected a link fault
-           wisFrameLoss(13)     - WIS loss of frame, 10GBASE-W only
-           wisSignalLoss(14)    - WIS loss of signal, 10GBASE-W only
-           pcsLinkFault(15)     - PCS receive link fault
-           excessiveBER(16)     - PCS Bit Error Ratio monitor
-                                  reporting excessive error ratio
-           dxsLinkFault(17)     - DTE XGXS receive link fault, XAUI only
-           pxsLinkFault(18)     - PHY XGXS receive link fault, XAUI only
-           availableReduced(19) - link normal, reduced bandwidth,
-                                  2BASE-TL / 10PASS-TS only
-           ready(20)            - at least one PME in the aggregation
-                                  group is detecting handshake tones,
-                                  2BASE-TL / 10PASS-TS only
-
-         If the MAU is a 10M b/s link or fiber type (FOIRL, 10BASE-T,
-         10BASE-F), then this is equivalent to the link test fail
-         state/low light function.  For an AUI, 10BASE2, 10BASE5, or
-         10BROAD36 MAU, this indicates whether loopback is detected on
-         the DI circuit.  The value of this attribute persists between
-         packets for MAU types AUI, 10BASE5, 10BASE2, 10BROAD36, and
-         10BASEFP.
-
-         At power-up or following a reset, the Media Available state
-         will be unknown(2) for AUI, 10BASE5, 10BASE2, 10BROAD36, and
-         10BASE-FP MAUs.  For these MAUs loopback will be tested on each
-         transmission during which no collision is detected.
-         If DI is receiving input when DO returns to IDL after a
-         transmission and there has been no collision during the
-         transmission, then loopback will be detected.  The Media
-         Available state will only change during noncollided
-         transmissions for AUI, 10BASE2, 10BASE5, 10BROAD36, and
-         10BASE-FP MAUs.
-
-         For 100BASE-T2, 100BASE-T4, 100BASE-TX, 100BASE-FX,
-         100BASE-LX10, and 100BASE-BX10 PHYs the enumerations match the
-         states within the link integrity state diagram.
-         Any MAU that implements management of [IEEE802.3] Clause
-         28 Auto-Negotiation, will map remote fault indication to
-         remoteFault(5).
-
-         Any MAU that implements management of Clause 37
-         Auto-Negotiation, will map the received RF1 and RF2 bits as
-         follows: Offline maps to offline(10), Link_Failure maps to
-         remoteFault(5), and Auto-Negotiation Error maps to
-         autoNegError(11).
-
-         The value remoteFault(5) applies to 10BASE-FB remote
-         fault indication, the 100BASE-X far-end fault indication, and
-         nonspecified remote faults from a system running Clause 28
-         Auto-Negotiation.
-
-         The value remoteJabber(7), remoteLink loss(8), or remoteTest(9)
-         SHOULD be used instead of remoteFault(5) where the reason for
-         remote fault is identified in the remote signaling protocol.
-         Where a Clause 22 MII or Clause 35 GMII is present, a logic
-         one in the remote fault bit maps to the value remoteFault(5),
-         a logic zero in the link status bit maps to the enumeration
-         notAvailable(4).  The value notAvailable(4) takes precedence
-         over remoteFault(5).
-
-         For 2BASE-TL and 10PASS-TS PHYs, the value unknown(2) maps to
-         the condition where the PHY (PCS with connected PMEs) is
-         initializing, the value ready(20) maps to the condition where
-         the interface is down and at least one PME in the aggregation
-         group is ready for handshake, the value available(3) maps to
-         the condition where all the PMEs in the aggregation group are
-         up, the value notAvailable(4) maps to the condition where all
-         the PMEs in the aggregation group are down and no handshake
-         tones are detected, the value availableReduced(19) maps to the
-         condition where the interface is up, a link fault is detected
-         at the receive direction by one or more PMEs in the
-         aggregation group, but at least one PME is up and the
-         enumeration pmdLinkFault(12) maps to the condition where a link
-         fault is detected at the receive direction by all of the PMEs
-         in the aggregation group.
-
-         For 10 Gb/s the enumerations map to value of the link_fault
-         variable within the Link Fault Signaling state diagram
-         as follows: the value OK maps to the value available(3),
-         the value Local Fault maps to the value notAvailable(4),
-         and the value Remote Fault maps to the value remoteFault(5).
-         The value pmdLinkFault(12), wisFrameLoss(13),
-         wisSignalLoss(14), pcsLinkFault(15), excessiveBER(16), or
-         dxsLinkFault(17) SHOULD be used instead of the value
-         notAvailable(4), where the reason for the Local Fault state can
-         be identified through the use of the Clause 45 MDIO Interface.
-         Where multiple reasons for the Local Fault state can be
-         identified, only the highest precedence error SHOULD be
-
-         reported.  This precedence in descending order is as follows:
-
-           pxsLinkFault
-           pmdLinkFault
-           wisFrameLoss
-           wisSignalLoss
-           pcsLinkFault
-           excessiveBER
-           dxsLinkFault.
-
-         Where a Clause 45 MDIO interface is present a logic zero in
-         the PMA/PMD Receive link status bit ([IEEE802.3]
-         Section 45.2.1.2.2) maps to the value pmdLinkFault(12),
-         logic one in the LOF status bit (Section 45.2.2.10.4) maps
-         to the value wisFrameLoss(13), a logic one in the LOS
-         status bit (Section 45.2.2.10.5) maps to the value
-         wisSignalLoss, a logic zero in the PCS Receive
-         link status bit (Section 45.2.3.2.2) maps to the value
-         pcsLinkFault(15), a logic one in the 10GBASE-R PCS Latched
-         high BER status bit (Section 45.2.3.12.2) maps to the value
-         excessiveBER, a logic zero in the DTE XS receive link status
-         bit (Section 45.2.5.2.2) maps to the value dxsLinkFault(17)
-         and a logic zero in the PHY XS transmit link status bit
-         (Section 45.2.4.2.2) maps to the value pxsLinkFault(18).
-
-         The most recent version of this textual convention is available
-         in the online version of this MIB module on the IANA web site.
-
-         Requests for new values should be made to IANA via email
-         (iana&iana.org)."
-       REFERENCE
-         "[IEEE802.3], Section 30.5.1.1.4"
-       SYNTAX       INTEGER {
-              other(1),
-              unknown(2),
-              available(3),
-              notAvailable(4),
-              remoteFault(5),
-              invalidSignal(6),
-              remoteJabber(7),
-              remoteLinkLoss(8),
-              remoteTest(9),
-              offline(10),
-              autoNegError(11),
-              pmdLinkFault(12),
-              wisFrameLoss(13),
-              wisSignalLoss(14),
-              pcsLinkFault(15),
-
-              excessiveBER(16),
-              dxsLinkFault(17),
-              pxsLinkFault(18),
-              availableReduced(19),
-              ready(20)
-         }
-
-     IANAifMauAutoNegCapBits ::= TEXTUAL-CONVENTION
-       STATUS       current
-       DESCRIPTION
-         "This data type is used as the syntax of the
-         ifMauAutoNegCapabilityBits, ifMauAutoNegCapAdvertisedBits, and
-         ifMauAutoNegCapReceivedBits objects in the (updated) definition
-         of MAU-MIB's ifMauAutoNegTable.
-
-         The most recent version of this textual convention is available
-         in the online version of this MIB module on the IANA web site.
-
-         Requests for new values should be made to IANA via email
-         (iana&iana.org)."
-       REFERENCE
-         "[IEEE802.3], Section 30.6.1.1.5"
-       SYNTAX       BITS {
-              bOther(0),          -- other or unknown
-              b10baseT(1),        -- 10BASE-T  half duplex mode
-              b10baseTFD(2),      -- 10BASE-T  full duplex mode
-              b100baseT4(3),      -- 100BASE-T4
-              b100baseTX(4),      -- 100BASE-TX half duplex mode
-              b100baseTXFD(5),    -- 100BASE-TX full duplex mode
-              b100baseT2(6),      -- 100BASE-T2 half duplex mode
-              b100baseT2FD(7),    -- 100BASE-T2 full duplex mode
-              bFdxPause(8),       -- PAUSE for full-duplex links
-              bFdxAPause(9),      -- Asymmetric PAUSE for full-duplex
-                                  --     links
-              bFdxSPause(10),     -- Symmetric PAUSE for full-duplex
-                                  --     links
-              bFdxBPause(11),     -- Asymmetric and Symmetric PAUSE for
-                                  --     full-duplex links
-              b1000baseX(12),     -- 1000BASE-X, -LX, -SX, -CX half
-                                  --     duplex mode
-              b1000baseXFD(13),   -- 1000BASE-X, -LX, -SX, -CX full
-                                  --     duplex mode
-              b1000baseT(14),     -- 1000BASE-T half duplex mode
-              b1000baseTFD(15)    -- 1000BASE-T full duplex mode
-         }
-
-     IANAifJackType ::= TEXTUAL-CONVENTION
-       STATUS       current
-
-       DESCRIPTION
-         "Common enumeration values for repeater and interface MAU
-         jack types.  This data type is used as the syntax of the
-         ifJackType and rpJackType objects in the (updated) definition
-         of MAU-MIB's ifJackTable and rpJackTable respectively.
-
-         Possible values are:
-              other(1)          - undefined or unknown
-              rj45(2)           - RJ45
-              rj45S(3)          - RJ45 shielded
-              db9(4)            - DB9
-              bnc(5)            - BNC
-              fAUI(6)           - AUI female
-              mAUI(7)           - AUI male
-              fiberSC(8)        - SC fiber
-              fiberMIC(9)       - MIC fiber
-              fiberST(10)       - ST fiber
-              telco(11)         - Telco
-              mtrj(12)          - MT-RJ fiber
-              hssdc(13)         - fiber channel style-2
-              fiberLC(14)       - LC fiber
-              cx4(15)           - IB4X for 10GBASE-CX4
-
-         The most recent version of this textual convention is available
-         in the online version of this MIB module on the IANA web site.
-
-         Requests for new values should be made to IANA via email
-         (iana&iana.org)."
-       SYNTAX       INTEGER {
-              other(1),
-              rj45(2),
-              rj45S(3),
-              db9(4),
-              bnc(5),
-              fAUI(6),
-              mAUI(7),
-              fiberSC(8),
-              fiberMIC(9),
-              fiberST(10),
-              telco(11),
-              mtrj(12),
-              hssdc(13),
-              fiberLC(14),
-              -- new since RFC 3636
-              cx4(15)
-         }
-
-     -- OBJECT IDENTITIES for MAU types
-
-     --  (see rpMauType and ifMauType of MAU-MIB for usage)
-     -- The following definitions has been moved from RFC 3636 and
-     -- no longer appear in its revision.
-
-     dot3MauType OBJECT IDENTIFIER ::= { mib-2 snmpDot3MauMgt(26) 4 }
-
-     dot3MauTypeAUI OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "no internal MAU, view from AUI"
-       REFERENCE   "[IEEE802.3], Section 7"
-       ::= { dot3MauType 1 }
-
-     dot3MauType10Base5 OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "thick coax MAU"
-       REFERENCE   "[IEEE802.3], Section 7"
-       ::= { dot3MauType 2 }
-
-     dot3MauTypeFoirl OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "FOIRL MAU"
-       REFERENCE   "[IEEE802.3], Section 9.9"
-       ::= { dot3MauType 3 }
-
-     dot3MauType10Base2 OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "thin coax MAU"
-       REFERENCE   "[IEEE802.3], Section 10"
-       ::= { dot3MauType 4 }
-
-     dot3MauType10BaseT OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "UTP MAU.
-                   Note that it is strongly recommended that
-                   agents return either dot3MauType10BaseTHD or
-                   dot3MauType10BaseTFD if the duplex mode is
-                   known.  However, management applications should
-                   be prepared to receive this MAU type value from
-                   older agent implementations."
-       REFERENCE   "[IEEE802.3], Section 14"
-       ::= { dot3MauType 5 }
-
-     dot3MauType10BaseFP OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "passive fiber MAU"
-       REFERENCE   "[IEEE802.3], Section 16"
-       ::= { dot3MauType 6 }
-
-     dot3MauType10BaseFB OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "sync fiber MAU"
-       REFERENCE   "[IEEE802.3], Section 17"
-       ::= { dot3MauType 7 }
-
-     dot3MauType10BaseFL OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "async fiber MAU.
-                   Note that it is strongly recommended that
-                   agents return either dot3MauType10BaseFLHD or
-                   dot3MauType10BaseFLFD if the duplex mode is
-                   known.  However, management applications should
-                   be prepared to receive this MAU type value from
-                   older agent implementations."
-       REFERENCE   "[IEEE802.3], Section 18"
-       ::= { dot3MauType 8 }
-
-     dot3MauType10Broad36 OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "broadband DTE MAU.
-                   Note that 10BROAD36 MAUs can be attached to
-                   interfaces but not to repeaters."
-       REFERENCE   "[IEEE802.3], Section 11"
-       ::= { dot3MauType 9 }
-
-     ------ new since RFC 1515:
-     dot3MauType10BaseTHD OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "UTP MAU, half duplex mode"
-       REFERENCE   "[IEEE802.3], Section 14"
-       ::= { dot3MauType 10 }
-
-     dot3MauType10BaseTFD OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "UTP MAU, full duplex mode"
-       REFERENCE   "[IEEE802.3], Section 14"
-       ::= { dot3MauType 11 }
-
-     dot3MauType10BaseFLHD OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "async fiber MAU, half duplex mode"
-       REFERENCE   "[IEEE802.3], Section 18"
-       ::= { dot3MauType 12 }
-
-     dot3MauType10BaseFLFD OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "async fiber MAU, full duplex mode"
-
-       REFERENCE   "[IEEE802.3], Section 18"
-       ::= { dot3MauType 13 }
-
-     dot3MauType100BaseT4 OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "4 pair category 3 UTP"
-       REFERENCE   "[IEEE802.3], Section 23"
-       ::= { dot3MauType 14 }
-
-     dot3MauType100BaseTXHD OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "2 pair category 5 UTP, half duplex mode"
-       REFERENCE   "[IEEE802.3], Section 25"
-       ::= { dot3MauType 15 }
-
-     dot3MauType100BaseTXFD OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "2 pair category 5 UTP, full duplex mode"
-       REFERENCE   "[IEEE802.3], Section 25"
-       ::= { dot3MauType 16 }
-
-     dot3MauType100BaseFXHD OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "X fiber over PMT, half duplex mode"
-       REFERENCE   "[IEEE802.3], Section 26"
-       ::= { dot3MauType 17 }
-
-     dot3MauType100BaseFXFD OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "X fiber over PMT, full duplex mode"
-       REFERENCE   "[IEEE802.3], Section 26"
-       ::= { dot3MauType 18 }
-
-     dot3MauType100BaseT2HD OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "2 pair category 3 UTP, half duplex mode"
-       REFERENCE   "[IEEE802.3], Section 32"
-       ::= { dot3MauType 19 }
-
-     dot3MauType100BaseT2FD OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "2 pair category 3 UTP, full duplex mode"
-       REFERENCE   "[IEEE802.3], Section 32"
-       ::= { dot3MauType 20 }
-
-     ------ new since RFC 2239:
-     dot3MauType1000BaseXHD OBJECT-IDENTITY
-       STATUS      current
-
-       DESCRIPTION "PCS/PMA, unknown PMD, half duplex mode"
-       REFERENCE   "[IEEE802.3], Section 36"
-       ::= { dot3MauType 21 }
-
-     dot3MauType1000BaseXFD OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "PCS/PMA, unknown PMD, full duplex mode"
-       REFERENCE   "[IEEE802.3], Section 36"
-       ::= { dot3MauType 22 }
-
-     dot3MauType1000BaseLXHD OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "Fiber over long-wavelength laser, half duplex
-                   mode"
-       REFERENCE   "[IEEE802.3], Section 38"
-       ::= { dot3MauType 23 }
-
-     dot3MauType1000BaseLXFD OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "Fiber over long-wavelength laser, full duplex
-                   mode"
-       REFERENCE   "[IEEE802.3], Section 38"
-       ::= { dot3MauType 24 }
-
-     dot3MauType1000BaseSXHD OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "Fiber over short-wavelength laser, half
-                   duplex mode"
-       REFERENCE   "[IEEE802.3], Section 38"
-       ::= { dot3MauType 25 }
-
-     dot3MauType1000BaseSXFD OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "Fiber over short-wavelength laser, full
-                   duplex mode"
-       REFERENCE   "[IEEE802.3], Section 38"
-       ::= { dot3MauType 26 }
-
-     dot3MauType1000BaseCXHD OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "Copper over 150-Ohm balanced cable, half
-                   duplex mode"
-       REFERENCE   "[IEEE802.3], Section 39"
-       ::= { dot3MauType 27 }
-
-     dot3MauType1000BaseCXFD OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "Copper over 150-Ohm balanced cable, full
-
-                   duplex mode"
-       REFERENCE   "[IEEE802.3], Section 39"
-       ::= { dot3MauType 28 }
-
-     dot3MauType1000BaseTHD OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "Four-pair Category 5 UTP, half duplex mode"
-       REFERENCE   "[IEEE802.3], Section 40"
-       ::= { dot3MauType 29 }
-
-     dot3MauType1000BaseTFD OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "Four-pair Category 5 UTP, full duplex mode"
-       REFERENCE   "[IEEE802.3], Section 40"
-       ::= { dot3MauType 30 }
-
-     ------ new since RFC 2668:
-     dot3MauType10GigBaseX OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "X PCS/PMA, unknown PMD."
-       REFERENCE   "[IEEE802.3], Section 48"
-       ::= { dot3MauType 31 }
-
-     dot3MauType10GigBaseLX4 OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "X fiber over WWDM optics"
-       REFERENCE   "[IEEE802.3], Section 53"
-       ::= { dot3MauType 32 }
-
-     dot3MauType10GigBaseR OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "R PCS/PMA, unknown PMD."
-       REFERENCE   "[IEEE802.3], Section 49"
-       ::= { dot3MauType 33 }
-
-     dot3MauType10GigBaseER OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "R fiber over 1550 nm optics"
-       REFERENCE   "[IEEE802.3], Section 52"
-       ::= { dot3MauType 34 }
-
-     dot3MauType10GigBaseLR OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "R fiber over 1310 nm optics"
-       REFERENCE   "[IEEE802.3], Section 52"
-       ::= { dot3MauType 35 }
-
-     dot3MauType10GigBaseSR OBJECT-IDENTITY
-
-       STATUS      current
-       DESCRIPTION "R fiber over 850 nm optics"
-       REFERENCE   "[IEEE802.3], Section 52"
-       ::= { dot3MauType 36 }
-
-     dot3MauType10GigBaseW OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "W PCS/PMA, unknown PMD."
-       REFERENCE   "[IEEE802.3], Section 49 and 50"
-       ::= { dot3MauType 37 }
-
-     dot3MauType10GigBaseEW OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "W fiber over 1550 nm optics"
-       REFERENCE   "[IEEE802.3], Section 52"
-       ::= { dot3MauType 38 }
-
-     dot3MauType10GigBaseLW OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "W fiber over 1310 nm optics"
-       REFERENCE   "[IEEE802.3], Section 52"
-       ::= { dot3MauType 39 }
-
-     dot3MauType10GigBaseSW OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "W fiber over 850 nm optics"
-       REFERENCE   "[IEEE802.3], Section 52"
-       ::= { dot3MauType 40 }
-
-     ------ new since RFC 3636:
-     dot3MauType10GigBaseCX4 OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "X copper over 8 pair 100-Ohm balanced cable"
-       REFERENCE   "[IEEE802.3], Section 54"
-       ::= { dot3MauType 41 }
-
-     dot3MauType2BaseTL OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "Voice grade UTP copper, up to 2700m, optional PAF"
-       REFERENCE   "[IEEE802.3], Sections 61 and 63"
-       ::= { dot3MauType 42 }
-
-     dot3MauType10PassTS OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "Voice grade UTP copper, up to 750m, optional PAF"
-       REFERENCE   "[IEEE802.3], Sections 61 and 62"
-       ::= { dot3MauType 43 }
-
-     dot3MauType100BaseBX10D OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "One single-mode fiber OLT, long wavelength, 10km"
-       REFERENCE   "[IEEE802.3], Section 58"
-       ::= { dot3MauType 44 }
-
-     dot3MauType100BaseBX10U OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "One single-mode fiber ONU, long wavelength, 10km"
-       REFERENCE   "[IEEE802.3], Section 58"
-       ::= { dot3MauType 45 }
-
-     dot3MauType100BaseLX10 OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "Two single-mode fibers, long wavelength, 10km"
-       REFERENCE   "[IEEE802.3], Section 58"
-       ::= { dot3MauType 46 }
-
-     dot3MauType1000BaseBX10D OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "One single-mode fiber OLT, long wavelength, 10km"
-       REFERENCE   "[IEEE802.3], Section 59"
-       ::= { dot3MauType 47 }
-
-     dot3MauType1000BaseBX10U OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "One single-mode fiber ONU, long wavelength, 10km"
-       REFERENCE   "[IEEE802.3], Section 59"
-       ::= { dot3MauType 48 }
-
-     dot3MauType1000BaseLX10 OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "Two sigle-mode fiber, long wavelength, 10km"
-       REFERENCE   "[IEEE802.3], Section 59"
-       ::= { dot3MauType 49 }
-
-     dot3MauType1000BasePX10D OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "One single-mode fiber EPON OLT, 10km"
-       REFERENCE   "[IEEE802.3], Section 60"
-       ::= { dot3MauType 50 }
-
-     dot3MauType1000BasePX10U OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "One single-mode fiber EPON ONU, 10km"
-       REFERENCE   "[IEEE802.3], Section 60"
-       ::= { dot3MauType 51 }
-
-     dot3MauType1000BasePX20D OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "One single-mode fiber EPON OLT, 20km"
-       REFERENCE   "[IEEE802.3], Section 60"
-       ::= { dot3MauType 52 }
-
-     dot3MauType1000BasePX20U OBJECT-IDENTITY
-       STATUS      current
-       DESCRIPTION "One single-mode fiber EPON ONU, 20km"
-       REFERENCE   "[IEEE802.3], Section 60"
-       ::= { dot3MauType 53 }
-
-END
diff --git a/contrib/apps/LwipMibCompiler/Mibs/IANA/IANA-PRINTER-MIB b/contrib/apps/LwipMibCompiler/Mibs/IANA/IANA-PRINTER-MIB
deleted file mode 100644
index 856ed5f8..00000000
--- a/contrib/apps/LwipMibCompiler/Mibs/IANA/IANA-PRINTER-MIB
+++ /dev/null
@@ -1,1319 +0,0 @@
-IANA-PRINTER-MIB DEFINITIONS ::= BEGIN
- -- http://www.iana.org/assignments/ianaprinter-mib
-
-IMPORTS
-    MODULE-IDENTITY,
-        mib-2
-            FROM SNMPv2-SMI                              -- [RFC2578]
-    TEXTUAL-CONVENTION
-            FROM SNMPv2-TC;                              -- [RFC2579]
-
-ianaPrinterMIB MODULE-IDENTITY
-    LAST-UPDATED  "200509140000Z" -- September 14, 2005
-
-    ORGANIZATION  "IANA"
-    CONTACT-INFO  "Internet Assigned Numbers Authority
-                  Postal: ICANN
-                          4676 Admiralty Way, Suite 330
-                          Marina del Rey, CA 90292
-
-                  Tel:    +1 310 823 9358
-                  E-Mail: iana&iana.org"
-
-    DESCRIPTION   "This MIB module defines a set of printing-related
-                  TEXTUAL-CONVENTIONs for use in Printer MIB (RFC 3805),
-                  Finisher MIB (RFC 3806), and other MIBs which need to
-                  specify printing mechanism details.
-
-                  Any additions or changes to the contents of this MIB
-                  module require either publication of an RFC, or
-                  Designated Expert Review as defined in RFC 2434,
-                  Guidelines for Writing an IANA Considerations Section
-                  in RFCs.  The Designated Expert will be selected by
-                  the IESG Area Director(s) of the Applications Area.
-
-                  Copyright (C) The Internet Society (2004). The
-                  initial version of this MIB module was published
-                  in RFC 3805.  For full legal notices see the RFC
-                  itself or see:
-                  http://www.ietf.org/copyrights/ianamib.html"
-
-    REVISION      "200509140000Z"  -- September 14, 2005
-    DESCRIPTION   "Updates to include missing 'unknown' values
-	               for PrtCoverStatusTC, PrtChannelTypeTC, 
-                   PrtAlertGroupTC and removal of comment for
-                   for PrtAlertGroupTC."
-
-    REVISION      "200406020000Z"  -- June 2, 2004
-    DESCRIPTION   "Original version, published in coordination
-                  with Printer MIB (RFC 3805)."
-    ::= { mib-2 109 }
-
---
--- Generic TEXTUAL-CONVENTIONs
---
-
-PrtCoverStatusTC ::= TEXTUAL-CONVENTION
-    -- This TC was extracted from prtCoverStatus in RFC 1759.
-    STATUS    current
-    DESCRIPTION
-        "Values for encoding the state of a particular cover or
-        access panel on the printer case or enclosure."
-    SYNTAX    INTEGER {
-                  other(1),
-                  unknown(2),
-                  coverOpen(3),
-                  coverClosed(4),
-                  interlockOpen(5),
-                  interlockClosed(6)
-
-                  }
-
---
--- General Group TEXTUAL-CONVENTIONs
---
-
-PrtGeneralResetTC ::= TEXTUAL-CONVENTION
-    -- This TC was extracted from prtGeneralReset in RFC 1759.
-    STATUS    current
-    DESCRIPTION
-        "Values for reading and writing the prtGeneralReset object.
-
-        If a device does not have NVRAM, the device shall none the
-        less respond to a SET with the value resetToNVRAM(5) with a
-        sort of warm reset that resets the device to implementation-
-        defined state that is preferably under control of the system
-        administrator by some means outside the scope of the Printer
-        MIB specification."
-
-    SYNTAX    INTEGER {
-                  notResetting(3),
-                  powerCycleReset(4), -- Cold Start
-                  resetToNVRAM(5), -- Warm Start
-                  resetToFactoryDefaults(6) -- Reset contents of
-                                            -- NVRAM to factory
-                                            -- defaults
-                  }
---
--- Channel Group TEXTUAL-CONVENTIONs
---
-
-PrtChannelTypeTC ::= TEXTUAL-CONVENTION
-    -- This TC was extracted from prtChannelType in RFC 1759.
-    STATUS    current
-    DESCRIPTION
-        "This enumeration indicates the type of channel that is
-        receiving jobs."
-    SYNTAX    INTEGER {
-                  other(1),
-                  unknown(2),
-                  chSerialPort(3),
-                  chParallelPort(4),
-                  chIEEE1284Port(5),
-                  chSCSIPort(6),
-                  chAppleTalkPAP(7),
-                      -- AppleTalk Printer
-                      -- Access Protocol (PAP)
-                      --
-                      -- prtChannelInformation entry:
-
-                      --
-                      -- Printer Name
-                      --   Keyword:      Name
-                      --   Syntax:       Name
-                      --   Status:       Optional
-                      --   Multiplicity: Single
-                      --   Description:  The name of the printer
-                      --     within the AppleTalk naming scope
-                  chLPDServer(8),
-                      -- prtChannelInformation entry:
-                      --
-                      -- Printer queue name
-                      --   Keyword:      Queue
-                      --   Syntax:       Name
-                      --   Status:       Mandatory
-                      --   Multiplicity: Single
-                      --   Description: queue name as
-                      --     defined in [RFC1179].
-                  chNetwareRPrinter(9),
-                      -- Novell, Inc.
-                      -- For each entry of this type, the
-                      -- prtChannelInformation must have a pair of
-                      -- keywords.  For Netware 3.x channels this must
-                      -- be a (PServer, Printer) pair.  For Netware
-                      -- 4.x channels and for IntranetWare channels
-                      -- this must be a (NDSTree, NDSPrinter) pair.
-                      --
-                      -- prtChannelInformation entries:
-
-                      -- Print Server Name
-                      --   Keyword:      PServer
-                      --   Syntax:       Name
-                      --   Status:       Mandatory
-                      --   Multiplicity: Single
-                      --   Description:  The Pserver's SAP name
-                      --
-                      -- Printer Number
-                      --   Keyword:      Printer
-                      --   Syntax:       Integer
-                      --   Status:       Mandatory
-                      --   Multiplicity: Single
-                      --   Description:  The printer number
-                      --
-                      -- NDSTree
-                      --   Keyword:      NDSTree
-                      --   Syntax:       Name
-                      --   Multiplicity: Single
-                      --   Description:  The tree's SAP name
-
-                      --
-                      -- NDS Printer object
-                      --   Keyword:      NDSPrinter
-                      --   Syntax:       Text (Unicode)
-                      --   Status:       Mandatory
-                      --   Multiplicity: Single
-                      --   Description:  The fully qualified
-                      --                 name of the Printer
-                      --
-                      -- In the Netware 3.x environment, the
-                      -- client checks the Bindery object
-                      -- representing the named PServer.  The
-                      -- client then checks for queues which
-                      -- are associated with the numbered
-                      -- printer.  In the 4.x and IntraNetware
-                      -- environment, the client looks up the
-                      -- queues which are associated with the
-                      -- NDS Printer Object in the named Tree.
-                      -- Depending on client access rights to
-                      -- those queues, the client submits jobs
-                      -- to the appropriate queue.
-                  chNetwarePServer(10),
-                      -- Novell,Inc.
-                      -- For each entry of this type, the
-                      -- prtChannelInformation must have a pair
-                      -- of keywords.  For Netware 3.x channels
-                      -- this must be a (Server, PServer) pair.
-                      -- For Netware 4.x and IntranetWare
-                      -- channels, this must be a
-                      -- (NDSTree, NDSPServer) pair.
-                      --
-                      -- prtChannelInformation entries:
-                      --
-                      -- Server Name
-                      --   Keyword:      Server
-                      --   Syntax:       Name
-                      --   Status:       Mandatory
-                      --   Multiplicity: Single
-                      --   Description:  The SAP name of the
-                      --   server for which the PServer is defined.
-                      --
-                      -- PServer
-                      --   Keyword:      PServer
-                      --   Syntax:       Name
-                      --   Status:       Mandatory
-                      --   Multiplicity: Single
-                      --   Description:  The bindery name of
-                      --                 the PServer
-
-                      --
-                      -- NDS Tree
-                      --   Keyword:      NDSTree
-                      --   Syntax:       Name
-                      --   Status:       Mandatory
-                      --   Multiplicity: Single
-                      --   Description:  The NDS Tree name
-                      --
-                      -- PServer
-                      --   Keyword:      NDSPServer
-                      --   Syntax:       Text (Unicode)
-                      --   Status:       Mandatory
-                      --   Multiplicity: Single
-                      --   Description:  The fully qualified
-                      --     name of the PServer object in the tree.
-                      --
-                      -- In the 3.x environment, the client
-                      -- checks the bindery object
-                      -- representing the named PServer on the
-                      -- named Server.  In the 4.x and
-                      -- IntranetWare environment,
-                      -- the client checks the NDS object
-                      -- representing the named PServer in the
-                      -- named Tree.  In either case, the
-                      -- client then checks for all queues
-                      -- associated with the Pserver object.
-                      -- Depending on client access rights
-                      -- to those queues, the client submits
-                      -- jobs to the appropriate queue.
-                  chPort9100(11),
-                      -- DEPRECATED
-                      -- (see chPortTCP - 37; chBidirPortTCP - 38)
-                  chAppSocket(12),
-                      -- A bi-directional, LPD-like, protocol using
-                      -- 9101 for control and 9100 for data.
-                      -- Adobe Systems, Inc.
-                  chFTP(13),         -- [RFC959]
-                  chTFTP(14),        -- [RFC1350]
-                  chDLCLLCPort(15),
-                  chIBM3270(16),     -- IBM Coax
-                  chIBM5250(17),     -- IBM Twinax
-                  chFax(18),
-                  chIEEE1394(19),
-                  chTransport1(20),
-                      -- TCP port 35, for reserved TCP port list see
-                      -- [RFC3232].  This RFC should also be
-                      -- referenced for other channel
-                      -- enumerations utilizing TCP port
-
-                      -- numbers 0 through 1024.
-                  chCPAP(21),      -- TCP port 170
-                      -- Digital Equipment Corp.
-                  chDCERemoteProcCall(22), -- OSF
-                      -- DEPRECATED
-                  chONCRemoteProcCall(23), -- SUN Microsystems
-                      -- DEPRECATED
-                  chOLE(24),         -- Microsoft
-                      -- DEPRECATED
-                  chNamedPipe(25),
-                  chPCPrint(26),   -- Banyan
-                  chServerMessageBlock(27),
-                      -- File/Print sharing protocol used by
-                      -- various network operating systems
-                      -- from IBM 3Com, Microsoft and others
-                      --
-                      -- prtChannelInformation entry:
-                      --
-                      -- Service Name
-                      --   Keyword:      Name
-                      --   Syntax:       Name
-                      --   Status:       Optional
-                      --   Multiplicity: Single
-                      --   Description:  The service name of
-                      --                 the printer
-                  chDPMF(28),   -- IBM Infoprint
-                  chDLLAPI(29), -- Microsoft
-                      -- DEPRECATED
-                  chVxDAPI(30), -- Microsoft
-                      -- DEPRECATED
-                  chSystemObjectManager(31), -- IBM
-                  chDECLAT(32),
-                      -- Digital Equipment Corp.
-                      --
-                      -- prtChannelInformation entries:
-                      --
-                      -- Port Name
-                      --   Keyword:      Port
-                      --   Syntax:       Name
-                      --   Status:       Conditionally
-                      --                 Mandatory
-                      --                 (see note below)
-                      --   Multiplicity: Single
-                      --   Description:  LAT port name
-                      --
-                      -- Service Name
-                      --   Keyword:      Service
-                      --   Syntax:       Name
-
-                      --   Status:       Conditionally
-                      --                 Mandatory
-                      --   Multiplicity: Single
-                      --   Description:  LAT service name
-                      --
-                      -- The LAT channel may be
-                      -- identified by either a port or
-                      -- service, so either a
-                      -- Port or Service entry must be
-                      -- specified, but not both.
-                  chNPAP(33),
-                  chUSB(34), -- Not in RFC 1759
-                             -- Universal Serial Bus
-                  chIRDA(35), -- Not in RFC 1759
-                              -- Infrared Data Assoc. Prot.
-                  chPrintXChange(36),  -- Not in RFC 1759
-                                       -- PrintXChange Protocol
-                  chPortTCP(37),  -- Not in RFC 1759
-                      -- A unidirectional "raw" TCP
-                      -- channel that uses an administratively
-                      -- assigned TCP port address.
-                      --
-                      -- prtChannelInformation entry:
-                      --
-                      -- Port Number
-                      --   Keyword:      Port
-                      --   Syntax:       decimal number
-                      --   Status:       Mandatory
-                      --   Multiplicity: Single
-                      --   Description:  TCP port number
-                  chBidirPortTCP(38),  -- Not in RFC 1759
-                      -- A bi-directional version of chPortTCP
-                      --
-                      -- prtChannelInformation entries:
-                      -- (See chPortTCP)
-                  chUNPP(39),  -- Not in RFC 1759
-                      -- Universal Network Printing
-                      -- Protocol(UNPP). A bi-directional,
-                      -- multiport network printing
-                      -- application protocol available on
-                      -- multiple transport protocols.
-                      -- Underscore, Inc.
-                      -- Contact: info&underscore.com
-                  chAppleTalkADSP(40),  -- Not in RFC 1759
-                      -- AppleTalk Data Stream Protocol.
-                      -- ADSP is part of the AppleTalk
-                      -- suite of protocols.
-                      -- It is a symmetric, connection-
-
-                      -- oriented protocol that makes
-                      -- possible the establishment
-                      -- and maintenance of full-duplex
-                      -- streams of data bytes between
-                      -- two sockets in an AppleTalk
-                      -- internet.
-                      -- See [APPLEMAC].
-                  chPortSPX(41),  -- Not in RFC 1759
-                      -- Sequenced Packet Exchange (SPX)
-                      -- socket.
-                      -- Novell, Inc. Similar to TCP, a
-                      -- bi-directional data pipe using
-                      -- Novell SPX as a transport.
-                      --
-                      -- prtChannelInformation entries:
-                      --
-                      -- Network Number
-                      --   Keyword:      Net
-                      --   Syntax:       HexString
-                      --   Status:       Mandatory
-                      --   Multiplicity: Single
-                      --   Description:  The network number
-                      --
-                      -- Node Number
-                      --   Keyword:      Node
-                      --   Syntax:       HexString
-                      --   Status:       Mandatory
-                      --   Multiplicity: Single
-                      --   Description:  The node number
-                      --
-                      -- Socket Number
-                      --   Keyword:      Socket
-                      --   Syntax:       HexString
-                      --   Status:       Mandatory
-                      --   Multiplicity: Single
-                      --   Description:  The SPX socket number
-                      --
-                      -- There must be exactly one "Net" and
-                      -- one "Node" and one "Socket" entry.  A
-                      -- HexString is a binary value
-                      -- represented as a string of
-                      -- ASCII characters using hexadecimal
-                      -- notation.
-                  chPortHTTP(42),  -- Not in RFC 1759
-                      -- Hypertext Transfer Protocol. See [RFC1945]
-                      -- and [RFC2616].
-                  chNDPS(43),  -- Not in RFC 1759
-                      -- Novell, Inc.
-
-                      --
-                      -- prtChannelInformation entry:
-                      --
-                      -- Printer Agent Name
-                      --   Keyword:      PA
-                      --   Syntax:       Name
-                      --   Status:       Mandatory
-                      --   Multiplicity: Single
-                      --   Description:  The NDPS Printer
-                      --                 Agent Name
-                  chIPP(44),  -- Not in RFC 1759
-                      -- Internet Printing Protocol (IPP),
-                      -- (IPP/1.1 - see [RFC2910] and [RFC2911])
-                      -- also applies to all future versions of IPP.
-                      --
-                      -- IPP Printer URI
-                      --   Keyword:      URI
-                      --   Syntax:       URI (Unicode UTF-8 per
-                      --                 [RFC2396])
-                      --   Status:       Mandatory
-                      --   Multiplicity: Single
-                      --   Default:      not applicable
-                      --   Description:  URI of this IPP Printer
-                      --     within Internet naming scope.  Unicode
-                      --     UTF-8 [RFC3629] string with
-                      --     hexadecimal escapes for any non-ASCII
-                      --     characters (per [RFC2396]).
-                      --   Conformance: An IPP Printer shall list all
-                      --     IPP URI it supports (one per IPP Channel
-                      --     entry).  If a URI contains the 'http:'
-                      --     scheme it must have an explicit port.
-                      --   See: [RFC3629], [RFC2396], [RFC2910],
-                     --     [RFC2911].
-                      --
-                      -- IPP Printer Client Authentication
-                      --   Keyword:      Auth
-                      --   Syntax:       Keyword
-                      --   Status:       Optional
-                      --   Multiplicity: Single
-                      --   Default:      'none'
-                      --   Description:  A client authentication
-                      --     mechanism supported for this IPP Printer
-                      --     URI:
-                      --       'none'
-                      --         no client authentication mechanism
-                      --       'requesting-user-name'
-                      --         authenticated user in 'requesting-
-                      --         user-name'
-
-                      --       'basic'
-                      --         authenticated user via HTTP Basic
-                      --         mechanism
-                      --       'digest'
-                      --         authenticated user via HTTP Digest
-                      --         mechanism
-                      --       'certificate'
-                      --         authenticated user via certificate
-                      --         mechanism
-                      --   Conformance: An IPP Printer should list
-                      --     all IPP client authentication mechanisms
-                      --     it supports (one per IPP Channel entry).
-                      --     See: [RFC2911] and [RFC2910].
-                      --
-                      -- IPP Printer Security
-                      --   Keyword:      Security
-                      --   Syntax:       Keyword
-                      --   Status:       Optional
-                      --   Multiplicity: Single
-                      --   Default:      'none'
-                      --   Description:  A security mechanism
-                      --     supported for this IPP Printer URI:
-                      --     'none'
-                      --       no security mechanism
-                      --     'ssl3'
-                      --       SSL3 secure communications channel
-                      --       protocol
-                      --     'tls'
-                      --       TLS secure communications channel
-                      --       protocol
-                      --   Conformance: An IPP Printer should list
-                      --     all IPP security mechanisms it supports
-                      --     (one per IPP Channel entry).
-                      --   See: [RFC2246], [RFC2911].
-                      --
-                      -- IPP Printer Protocol Version
-                      --   Keyword:      Version
-                      --   Syntax:       Keyword
-                      --   Status:       Optional
-                      --   Multiplicity: Multiple
-                      --   Default:      '1.1'
-                      --   Description:  All of the IPP protocol
-                      --     versions (major.minor) supported for
-                      --     this IPP Printer URI:
-                      --     '1.0'
-                      --       IPP/1.0 conforming Printer
-                      --     '1.1'
-                      --       IPP/1.1 conforming Printer
-
-                      --   Conformance:  An IPP Printer should list
-                      --     all IPP versions it supports (all listed
-                      --     in each IPP Channel entry).  An IPP
-                      --     Client should select the highest
-                      --     numbered version the IPP Client supports
-                      --     for use in all IPP Requests (for optimum
-                      --     interworking).
-                      --   See: [RFC2911].
-                  chSMTP(45)
-                      -- Print Job submission via Simple Mail
-                      -- Transfer Protocol (SMTP) - see [RFC2821]
-                      --
-                      -- prtChannelInformation entry:
-                      --
-                      --   Keyword:      Mailto
-                      --   Syntax:       Name
-                      --   Status:       Mandatory
-                      --   Multiplicity: Single
-                      --   Default:      not applicable
-                      --   Description:  The SMTP URL of the printer.
-}
-
---
--- Interpreter Group TEXTUAL-CONVENTIONs
---
-
-PrtInterpreterLangFamilyTC ::= TEXTUAL-CONVENTION
-    -- This TC was extracted from prtInterpreterLangFamily in RFC 1759.
-    STATUS    current
-    DESCRIPTION
-        "This enumeration indicates the type of interpreter that is
-        receiving jobs."
-    SYNTAX    INTEGER {
-        other(1),
-        unknown(2),          -- Not in RFC 1759
-        langPCL(3),          -- PCL.  Starting with PCL version 5,
-                             -- HP-GL/2 is included as part of the
-                             -- PCL language.
-                             -- PCL and HP-GL/2 are registered
-                             -- trademarks of Hewlett-Packard
-                             -- Company.
-        langHPGL(4),         -- Hewlett-Packard Graphics Language.
-                             -- HP-GL is a registered trademark of
-                             -- Hewlett-Packard Company.
-        langPJL(5),          -- Peripheral Job Language.  Appears in
-                             -- the data stream between data intended
-                             -- for a page description language.
-                             -- Hewlett-Packard Co.
-
-        langPS(6),           -- PostScript (tm) Language
-                             -- Postscript - a trademark of Adobe
-                             -- Systems Incorporated which may be
-                             -- registered in certain jurisdictions
-        langIPDS(7),         -- Intelligent Printer Data Stream
-                             -- Bi-directional print data stream for
-                             -- documents consisting of data objects
-                             -- (text, image, graphics, bar codes),
-                             -- resources (fonts, overlays) and page,
-                             -- form and finishing instructions.
-                             -- Facilitates system level device
-                             -- control, document tracking and error
-                             -- recovery throughout the print
-                             -- process.
-                             -- IBM Corporation.
-        langPPDS(8),         -- IBM Personal Printer Data Stream.
-                             -- Originally called IBM ASCII, the name
-                             -- was changed to PPDS when the Laser
-                             -- Printer was introduced in 1989.
-                             -- Lexmark International, Inc.
-        langEscapeP(9),      -- Epson Corp.
-        langEpson(10),
-        langDDIF(11),        -- Digital Document Interchange Format
-                             -- Digital Equipment Corp., Maynard MA
-        langInterpress(12),
-                             -- Xerox Corp.
-        langISO6429(13),     -- ISO 6429.  Control functions for
-                             -- Coded Character Sets (has ASCII
-                             -- control characters, plus additional
-                             -- controls for
-                             -- character imaging devices.)
-        langLineData(14),    -- line-data:  Lines of data as
-                             -- separate ASCII or EBCDIC records
-                             -- and containing no control functions
-                             -- (no CR, LF, HT, FF, etc.)
-                             -- For use with traditional line
-                             -- printers.  May use CR and/or LF to
-                             -- delimit lines, instead of records.
-                             -- See ISO 10175 Document Printing
-                             -- Application (DPA) [ISO10175].
-        langMODCA(15),       -- Mixed Object Document Content
-                             -- Architecture
-                             -- Definitions that allow the
-                             -- composition, interchange, and
-                             -- presentation of final form
-                             -- documents as a collection of data
-                             -- objects (text, image, graphics, bar
-                             -- codes), resources (fonts, overlays)
-
-                             -- and page, form and finishing
-                             -- instructions.
-                             -- IBM Corporation.
-        langREGIS(16),       -- Remote Graphics Instruction Set,
-                             -- Digital Equipment Corp., Maynard MA
-        langSCS(17),         -- SNA Character String
-                             -- Bi-directional print data stream for
-                             -- SNA LU-1 mode of communication.
-                             -- IBM
-        langSPDL(18),        -- ISO 10180 Standard Page Description
-                             -- Language
-                             -- ISO Standard
-        langTEK4014(19),     -- Tektronix Corp.
-        langPDS(20),
-        langIGP(21),         -- Printronix Corp.
-        langCodeV(22),       -- Magnum Code-V, Image and printer
-                             -- control language used to control
-                             -- impact/dot-matrix printers.
-                             -- QMS, Inc., Mobile AL
-        langDSCDSE(23),      -- DSC-DSE:  Data Stream Compatible and
-                             -- Emulation Bi-directional print data
-                             -- stream for non-SNA (DSC) and SNA LU-3
-                             -- 3270 controller (DSE) communications
-                             -- IBM
-        langWPS(24),         -- Windows Printing System, Resource
-                             -- based command/data stream used by
-                             -- Microsoft At Work Peripherals.
-                             -- Developed by the Microsoft
-                             -- Corporation.
-        langLN03(25),        -- Early DEC-PPL3, Digital Equipment
-                             -- Corp.
-        langCCITT(26),
-        langQUIC(27),        -- QUIC (Quality Information Code), Page
-                             -- Description Language for laser
-                             -- printers.  Included graphics, printer
-                             -- control capability and emulation of
-                             -- other well-known printer.
-                             -- QMS, Inc.
-        langCPAP(28),        -- Common Printer Access Protocol
-                             -- Digital Equipment Corp.
-        langDecPPL(29),      -- Digital ANSI-Compliant Printing
-                             -- Protocol
-                             -- (DEC-PPL)
-                             -- Digital Equipment Corp.
-        langSimpleText(30),
-                             -- simple-text:  character coded data,
-                             -- including NUL, CR , LF, HT, and FF
-                             -- control characters.  See ISO 10175
-
-                             -- Document Printing Application (DPA)
-                             -- [ISO10175].
-        langNPAP(31),        -- Network Printer Alliance Protocol
-                             -- (NPAP).  This protocol has been
-                             -- superseded by the IEEE 1284.1 TIPSI
-                             -- Std (ref. LangTIPSI(49)).
-        langDOC(32),         -- Document Option Commands, Appears in
-                             -- the data stream between data
-                             -- intended for a page description.
-                             -- QMS, Inc.
-        langimPress(33),     -- imPRESS, Page description language
-                             -- originally developed for the
-                             -- ImageServer product line. A binary
-                             -- language providing representations
-                             -- of text, simple graphics, and some
-                             -- large forms (simple
-                             -- bit-map and CCITT group 3/4
-                             -- encoded).The
-                             -- language was intended to be sent over
-                             -- an 8-bit channel and supported early
-                             -- document preparation languages (e.g.,
-                             -- TeX and TROFF).
-                             -- QMS, Inc.
-        langPinwriter(34),
-                             -- 24 wire dot matrix printer  for
-                             -- USA, Europe, and Asia except
-                             -- Japan.
-                             -- More widely used in Germany, and
-                             -- some Asian countries than in US.
-                             -- NEC
-        langNPDL(35),        -- Page printer  for Japanese market.
-                             -- NEC
-        langNEC201PL(36),    -- Serial printer language used in
-                             -- the Japanese market.
-                             -- NEC
-        langAutomatic(37),
-                             -- Automatic PDL sensing.  Automatic
-                             -- sensing of the interpreter
-                             -- language family by the printer
-                             -- examining the document content.
-                             -- Which actual interpreter language
-                             -- families are sensed depends on
-                             -- the printer implementation.
-        langPages(38),       -- Page printer Advanced Graphic
-                             -- Escape Set
-                             -- IBM Japan
-        langLIPS(39),        -- LBP Image Processing System
-        langTIFF(40),        -- Tagged Image File Format (Aldus)
-
-        langDiagnostic(41),
-                             -- A hex dump of the input to the
-                             -- interpreter
-        langPSPrinter(42),
-                             -- The PostScript Language used for
-                             -- control (with any PDLs)
-                             -- Adobe Systems Incorporated
-        langCaPSL(43),       -- Canon Print Systems Language
-        langEXCL(44),        -- Extended Command Language
-                             -- Talaris Systems Inc.
-        langLCDS(45),        -- Line Conditioned Data Stream
-                             -- Xerox Corporation
-        langXES(46),         -- Xerox Escape Sequences
-                             -- Xerox Corporation
-        langPCLXL(47),       -- Not in RFC 1759
-                             -- Printer Control Language. Extended
-                             -- language features for printing, and
-                             -- printer control.
-                             -- Hewlett-Packard Co.
-        langART(48),         -- Not in RFC 1759
-                             -- Advanced Rendering Tools (ART).
-                             -- Page Description language
-                             -- originally developed for the Laser
-                             -- Press printers.
-                             -- Technical reference manual: "ART IV
-                             -- Reference Manual", No F33M.
-                             -- Fuji Xerox Co., Ltd.
-        langTIPSI(49),       -- Not in RFC 1759
-                             -- Transport Independent Printer
-                             -- System Interface (ref. IEEE Std.
-                             -- 1284.1)
-        langPrescribe(50),   -- Not in RFC 1759
-                             -- Page description and printer
-                             -- control language. It can be
-                             -- described with ordinary ASCII
-                             -- Technical reference manual:
-                             -- "PRESCRIBE II Programming Manual"
-        langLinePrinter(51), -- Not in RFC 1759
-                             -- A simple-text character stream which
-                             -- supports the control codes LF, VT,
-                             -- FF, and plus Centronics or
-                             -- Dataproducts Vertical Format Unit
-                             -- (VFU) language is commonly used on
-                             -- many older model line and matrix
-                             -- printers.
-        langIDP(52),         -- Not in RFC 1759
-                             -- Imaging Device Protocol
-                             -- Apple Computer.
-
-        langXJCL(53),        -- Not in RFC 1759
-                             -- Xerox Job Control Language (JCL).
-                             -- A Job Control language originally
-                             -- developed for the LaserPress printers
-                             -- and is capable of switching PDLs.
-                             -- Technical reference manual:
-                             -- "ART IV Reference Manual", No F33M.
-                             -- Fuji Xerox Co., Ltd.
-        langPDF(54),         -- Not in RFC 1759
-                             -- Adobe Portable Document Format
-                             -- Adobe Systems, Inc.
-        langRPDL(55),        -- Not in RFC 1759
-                             -- Ricoh Page Description Language for
-                             -- printers.
-                             -- Technical manual "RPDL command
-                             -- reference" No.307029
-                             -- RICOH, Co. LTD
-        langIntermecIPL(56), -- Not in RFC 1759
-                             -- Intermec Printer Language for label
-                             -- printers.
-                             -- Technical Manual: "IPL Programmers
-                             -- Reference Manual"
-                             -- Intermec Corporation
-        langUBIFingerprint(57),  -- Not in RFC 1759
-                             -- An intelligent basic-like programming
-                             -- language for label printers.
-                             -- Reference Manual: "UBI Fingerprint
-                             -- 7.1", No. 1-960434-00
-                             -- United Barcode Industries
-        langUBIDirectProtocol(58),  -- Not in RFC 1759
-                             -- An intelligent control language for
-                             -- label printers.
-                             -- Programmers guide: " UBI Direct
-                             -- Protocol", No. 1-960419-00
-                             -- United Barcode Industries
-        langFujitsu(59),     -- Not in RFC 1759
-                             -- Fujitsu Printer Language
-                             -- Reference Manual:
-                             -- "FM Printer Sequence" No. 80HP-0770
-                             -- FUJITSU LIMITED
-        langCGM(60),         -- Not in RFC 1759
-                             -- Computer Graphics Metafile
-                             -- MIME type 'image/cgm'
-        langJPEG(61),        -- Not in RFC 1759
-                             -- Joint Photographic Experts Group
-                             -- MIME type 'image/jpeg'
-        langCALS1(62),       -- Not in RFC 1759
-                             -- US DOD CALS1 (see MIL-STD-1840)
-
-                             -- MIME type 'application/cals-1840'
-        langCALS2(63),       -- Not in RFC 1759
-                             -- US DOD CALS2 (see MIL-STD-1840)
-                             -- MIME type 'application/cals-1840'
-        langNIRS(64),        -- Not in RFC 1759
-                             -- US DOD NIRS (see MIL-STD-1840)
-                             -- MIME type 'application/cals-1840'
-        langC4(65)           -- Not in RFC 1759
-                             -- US DOD C4 (see MIL-STD-1840)
-                             -- MIME type 'application/cals-1840'
-}
-
---
--- Input/Output Group TEXTUAL-CONVENTIONs
---
-
-PrtInputTypeTC ::= TEXTUAL-CONVENTION
-    -- This TC was extracted from prtInputType in RFC 1759.
-    STATUS    current
-    DESCRIPTION
-        "The type of technology (discriminated primarily according to
-        feeder mechanism type) employed by a specific component or
-        components."
-    SYNTAX    INTEGER {
-                  other(1),
-                  unknown(2),
-                  sheetFeedAutoRemovableTray(3),
-                  sheetFeedAutoNonRemovableTray(4),
-                  sheetFeedManual(5),
-                  continuousRoll(6),
-                  continuousFanFold(7)
-                  }
-
-PrtOutputTypeTC ::= TEXTUAL-CONVENTION
-    -- This TC was extracted from prtOutputType in RFC 1759.
-    STATUS    current
-    DESCRIPTION
-        "The Type of technology supported by this output subunit."
-    SYNTAX    INTEGER {
-                  other(1),
-                  unknown(2),
-                  removableBin(3),
-                  unRemovableBin(4),
-                  continuousRollDevice(5),
-                  mailBox(6),
-                  continuousFanFold(7)
-                  }
-
---
--- Marker Group TEXTUAL-CONVENTIONs
---
-
-PrtMarkerMarkTechTC ::= TEXTUAL-CONVENTION
-    -- This TC was extracted from prtMarkerMarkTech in RFC 1759.
-    STATUS    current
-    DESCRIPTION
-        "The type of marking technology used for this marking
-        subunit."
-    SYNTAX    INTEGER {
-                  other(1),
-                  unknown(2),
-                  electrophotographicLED(3),
-                  electrophotographicLaser(4),
-                  electrophotographicOther(5),
-                  impactMovingHeadDotMatrix9pin(6),
-                  impactMovingHeadDotMatrix24pin(7),
-                  impactMovingHeadDotMatrixOther(8),
-                  impactMovingHeadFullyFormed(9),
-                  impactBand(10),
-                  impactOther(11),
-                  inkjetAqueous(12),
-                  inkjetSolid(13),
-                  inkjetOther(14),
-                  pen(15),
-                  thermalTransfer(16),
-                  thermalSensitive(17),
-                  thermalDiffusion(18),
-                  thermalOther(19),
-                  electroerosion(20),
-                  electrostatic(21),
-                  photographicMicrofiche(22),
-                  photographicImagesetter(23),
-                  photographicOther(24),
-                  ionDeposition(25),
-                  eBeam(26),
-                  typesetter(27)
-                  }
-
-PrtMarkerSuppliesTypeTC ::= TEXTUAL-CONVENTION
-    -- This TC was extracted from prtMarkerSuppliesType in RFC 1759.
-    STATUS    current
-    DESCRIPTION
-        "The type of this supply."
-    SYNTAX    INTEGER {
-                  other(1),
-                  unknown(2),
-
-                -- Values for Printer MIB
-                  toner(3),
-                  wasteToner(4),
-                  ink(5),
-                  inkCartridge(6),
-                  inkRibbon(7),
-                  wasteInk(8),
-                  opc(9),               -- photo conductor
-                  developer(10),
-                  fuserOil(11),
-                  solidWax(12),
-                  ribbonWax(13),
-                  wasteWax(14),
-                  fuser(15),            -- Not in RFC 1759
-                  coronaWire(16),       -- Not in RFC 1759
-                  fuserOilWick(17),     -- Not in RFC 1759
-                  cleanerUnit(18),      -- Not in RFC 1759
-                  fuserCleaningPad(19), -- Not in RFC 1759
-                  transferUnit(20),     -- Not in RFC 1759
-                  tonerCartridge(21),   -- Not in RFC 1759
-                  fuserOiler(22),       -- Not in RFC 1759
-                -- End of values for Printer MIB
-                -- Values for Finisher MIB
-                  water(23),            -- Not in RFC 1759
-                  wasteWater(24),       -- Not in RFC 1759
-                  glueWaterAdditive(25),-- Not in RFC 1759
-                  wastePaper(26),       -- Not in RFC 1759
-                  bindingSupply(27),    -- Not in RFC 1759
-                  bandingSupply(28),    -- Not in RFC 1759
-                  stitchingWire(29),    -- Not in RFC 1759
-                  shrinkWrap(30),       -- Not in RFC 1759
-                  paperWrap(31),        -- Not in RFC 1759
-                  staples(32),          -- Not in RFC 1759
-                  inserts(33),          -- Not in RFC 1759
-                  covers(34)            -- Not in RFC 1759
-                -- End of values for Finisher MIB
-                  }
-
---
--- Media Path TEXTUAL-CONVENTIONs
---
-
-PrtMediaPathTypeTC ::= TEXTUAL-CONVENTION
-    -- This TC was extracted from prtMediaPathType in RFC 1759.
-    STATUS    current
-    DESCRIPTION
-        "The type of the media path for this media path."
-    SYNTAX    INTEGER {
-
-                  other(1),
-                  unknown(2),
-                  longEdgeBindingDuplex(3),
-                  shortEdgeBindingDuplex(4),
-                  simplex(5)
-                  }
-
---
--- Console Group TEXTUAL-CONVENTIONs
---
-
-PrtConsoleColorTC ::= TEXTUAL-CONVENTION
-    -- This TC was extracted from prtConsoleColor in RFC 1759.
-    STATUS     current
-    DESCRIPTION
-        "The color of this light."
-    SYNTAX    INTEGER {
-                  other(1),
-                  unknown(2),
-                  white(3),
-                  red(4),
-                  green(5),
-                  blue(6),
-                  cyan(7),
-                  magenta(8),
-                  yellow(9),
-                  orange(10)        -- Not in RFC 1759
-                  }
-
-PrtConsoleDisableTC ::= TEXTUAL-CONVENTION
-    -- This TC was extracted from prtConsoleDisable in RFC 1759.
-    STATUS     current
-    DESCRIPTION
-        "This value indicates whether or not input is accepted from
-        the operator console.  A value of 'enabled' indicates that
-        input is accepted from the console, and a value of 'disabled'
-        indicates that input is not accepted from the console. "
-    SYNTAX    INTEGER {
-                  enabled(3),
-                  disabled(4)
-                  }
-
---
--- Alert Group TEXTUAL-CONVENTIONs
---
-
-PrtAlertTrainingLevelTC ::= TEXTUAL-CONVENTION
-    -- This TC was extracted from prtAlertTrainingLevel in RFC 1759.
-
-    STATUS    current
-    DESCRIPTION
-        "The level of training required to handle this alert, if
-        human intervention is required.  The noInterventionRequired
-        value should be used if the event does not require any human
-        intervention.  The training level is an enumeration that is
-        determined and assigned by the printer manufacturer based on
-        the information or training required to handle this alert.
-        The printer will break alerts into these different training
-        levels.  It is the responsibility of a management application
-        in the system to determine how a particular alert is handled
-        and how and to whom that alert is routed.  The following are
-        the four training levels of alerts:
-
-        Field Service - Alerts that typically require advanced
-            training and technical knowledge of the printer and its
-            subunits.  An example of a technical person would be a
-            manufacturer's Field Service representative, or other
-            person formally trained by the manufacturer or similar
-            representative.
-        Trained - Alerts that require an intermediate or moderate
-            knowledge of the printer and its subunits.  A typical
-            example of such an alert is replacing a toner cartridge.
-        Untrained -     Alerts that can be fixed without prior
-            training either because the action to correct the alert
-            is obvious or the printer can help the untrained person
-            fix the problem.  A typical example of such an alert is
-            reloading paper trays or emptying output bins on a low
-            end printer.
-        Management -    Alerts that have to do with overall operation
-            of and configuration of the printer.  Examples of such
-            management events are configuration change of subunits."
-    SYNTAX    INTEGER {
-                  other(1),
-                  unknown(2),
-                  untrained(3),
-                  trained(4),
-                  fieldService(5),
-                  management(6),
-                  noInterventionRequired(7)  -- Not in RFC 1759
-                 }
-
-PrtAlertGroupTC ::= TEXTUAL-CONVENTION
-    -- Values in the range 1 to 29 must not be IANA-assigned without
-    -- re-publishing Printer MIB.
-    -- Values of 30 and greater are for use in MIBs that augment
-    -- the Printer MIB, such as the Finisher MIB.
-    -- This TC extracted from prtAlertGroup in RFC 1759.
-
-    STATUS    current
-    DESCRIPTION
-        "The type of subunit within the printer model that this alert
-        is related.  Input, output, and markers are examples of
-        printer model groups, i.e., examples of types of subunits.
-        Wherever possible, the enumerations match the sub-identifier
-        that identifies the relevant table in the Printer MIB.
-
-        NOTE: Alert type codes have been added for the Host Resources
-        MIB storage table and device table.  These additional types
-        are for situations in which the printer's storage and device
-        objects must generate alerts (and possibly traps for critical
-        alerts)."
-    SYNTAX    INTEGER {
-                  other(1),
-                  unknown(2),
-                -- Values for Host Resources MIB
-                  hostResourcesMIBStorageTable(3),
-                  hostResourcesMIBDeviceTable(4),
-                -- Values for Printer MIB
-                  generalPrinter(5),
-                  cover(6),
-                  localization(7),
-                  input(8),
-                  output(9),
-                  marker(10),
-                  markerSupplies(11),
-                  markerColorant(12),
-                  mediaPath(13),
-                  channel(14),
-                  interpreter(15),
-                  consoleDisplayBuffer(16),
-                  consoleLights(17),
-                  alert(18),                   -- Not in RFC 1759
-                -- Values (5) to (29) reserved for Printer MIB
-                -- Values for Finisher MIB
-                  finDevice(30),               -- Not in RFC 1759
-                  finSupply(31),               -- Not in RFC 1759
-                  finSupplyMediaInput(32),     -- Not in RFC 1759
-                  finAttribute(33)             -- Not in RFC 1759
-                -- Values (30) to (39) reserved for Finisher MIB
-                  }
-
-PrtAlertCodeTC ::= TEXTUAL-CONVENTION
-    -- This TC was extracted from prtAlertCode in RFC 1759.
-    STATUS    current
-    DESCRIPTION
-        "The code that describes the type of alert for this entry in
-
-        the table.  Binary change event alerts describe states of the
-        subunit while unary change event alerts describe a single
-        event.  The same alert code can be used for a binary change
-        event or a unary change event, depending on implementation.
-        Also, the same alert code can be used to indicate a critical
-        or non-critical (warning) alert, depending on implementation.
-        The value of prtAlertSeverityLevel specifies binary vs. unary
-        and critical vs. non-critical for each event for the
-        implementation.
-
-        While there are some specific codes for many subunits, the
-        generic codes should be used for most subunit alerts.  The
-        network management station can then query the subunit
-        specified by prtAlertGroup to determine further subunit
-        status and other subunit information.
-
-        An agent shall not add two entries to the alert table for the
-        same event, one containing a generic event code and the other
-        containing a specific event code; the agent shall add only
-        one entry in the alert table for each event; either generic
-        (preferred) or specific, not both.
-
-        Implementation of the unary change event
-        alertRemovalOfBinaryChangeEntry(1801) is optional.  When
-        implemented, this alert code shall indicate to network
-        management stations that the trailing edge of a binary change
-        event has occurred and the corresponding alert entry has been
-        removed from the alert table.  As with all events, the
-        alertRemovalOfBinaryChangeEntry(1801) alert shall be placed
-        at the end of the alert table.  Such an alert table entry
-        shall specify the following information:
-
-        prtAlertSeverityLevel   warningUnaryChangeEvent(4)
-        prtAlertTrainingLevel   noInterventionRequired(7)
-        prtAlertGroup           alert(18)
-        prtAlertGroupIndex      the index of the row in the
-                                alert table of the binary
-                                change event that this event
-                                has removed.
-        prtAlertLocation        unknown (-2)
-        prtAlertCode            alertRemovalOfBinaryChangeEntry(1801)
-        prtAlertDescription     <description or null string>
-        prtAlertTime            the value of sysUpTime at
-                                the time of the removal of the
-                                binary change event from the
-                                alert table.
-
-        Optionally, the agent may generate a trap coincident with
-
-        removing the binary change event and placing the unary change
-        event alertRemovalOfBinaryChangeEntry(1801) in the alert
-        table.  For such a trap, the prtAlertIndex sent with the above
-        trap parameters shall be the index of the
-        alertRemovalOfBinaryChangeEvent row that was added to the
-        prtAlertTable; not the index of the row that was removed from
-        the prtAlertTable."
-    SYNTAX    INTEGER {
-                  other(1),
-                      -- an event that is not represented
-                      -- by one of the alert codes
-                      -- specified below.
-                  unknown(2),
-                      -- The following generic codes are common to
-                      -- multiple groups.  The NMS may examine the
-                      -- prtAlertGroup object to determine what group
-                      -- to query for further information.
-                  coverOpen(3),
-                  coverClosed(4),
-                  interlockOpen(5),
-                  interlockClosed(6),
-                  configurationChange(7),
-                  jam(8),
-                  subunitMissing(9),           -- Not in RFC 1759
-                      -- The subunit tray, bin, etc.
-                      -- has been removed.
-                  subunitLifeAlmostOver(10),   -- Not in RFC 1759
-                  subunitLifeOver(11),         -- Not in RFC 1759
-                  subunitAlmostEmpty(12),      -- Not in RFC 1759
-                  subunitEmpty(13),            -- Not in RFC 1759
-                  subunitAlmostFull(14),       -- Not in RFC 1759
-                  subunitFull(15),             -- Not in RFC 1759
-                  subunitNearLimit(16),        -- Not in RFC 1759
-                  subunitAtLimit(17),          -- Not in RFC 1759
-                  subunitOpened(18),           -- Not in RFC 1759
-                  subunitClosed(19),           -- Not in RFC 1759
-                  subunitTurnedOn(20),         -- Not in RFC 1759
-                  subunitTurnedOff(21),        -- Not in RFC 1759
-                  subunitOffline(22),          -- Not in RFC 1759
-                  subunitPowerSaver(23),       -- Not in RFC 1759
-                  subunitWarmingUp(24),        -- Not in RFC 1759
-                  subunitAdded(25),            -- Not in RFC 1759
-                  subunitRemoved(26),          -- Not in RFC 1759
-                  subunitResourceAdded(27),    -- Not in RFC 1759
-                  subunitResourceRemoved(28),  -- Not in RFC 1759
-                  subunitRecoverableFailure(29),
-                                               -- Not in RFC 1759
-                  subunitUnrecoverableFailure(30),
-
-                                               -- Not in RFC 1759
-                  subunitRecoverableStorageError(31),
-                                               -- Not in RFC 1759
-                  subunitUnrecoverableStorageError(32),
-                                               -- Not in RFC 1759
-                  subunitMotorFailure(33),     -- Not in RFC 1759
-                  subunitMemoryExhausted(34),  -- Not in RFC 1759
-                  subunitUnderTemperature(35), -- Not in RFC 1759
-                  subunitOverTemperature(36),  -- Not in RFC 1759
-                  subunitTimingFailure(37),    -- Not in RFC 1759
-                  subunitThermistorFailure(38), -- Not in RFC 1759
-
-                -- General Printer group
-                  doorOpen(501),    -- DEPRECATED
-                                    -- Use coverOpened(3)
-                  doorClosed(502),  -- DEPRECATED
-                                    -- Use coverClosed(4)
-                  powerUp(503),
-                  powerDown(504),
-                  printerNMSReset(505),        -- Not in RFC 1759
-                      -- The printer has been reset by some
-                      -- network management station(NMS)
-                      -- writing into 'prtGeneralReset'.
-                  printerManualReset(506),     -- Not in RFC 1759
-                      -- The printer has been reset manually.
-                  printerReadyToPrint(507),    -- Not in RFC 1759
-                      -- The printer is ready to print. (i.e.,
-                      -- not warming up, not in power save
-                      -- state, not adjusting print quality,
-                      -- etc.).
-
-                -- Input Group
-                  inputMediaTrayMissing(801),
-                  inputMediaSizeChange(802),
-                  inputMediaWeightChange(803),
-                  inputMediaTypeChange(804),
-                  inputMediaColorChange(805),
-                  inputMediaFormPartsChange(806),
-                  inputMediaSupplyLow(807),
-                  inputMediaSupplyEmpty(808),
-                  inputMediaChangeRequest(809), -- Not in RFC 1759
-                      -- An interpreter has detected that a
-                      -- different medium is need in this input
-                      -- tray subunit.  The prtAlertDescription may
-                      -- be used to convey a human readable
-                      -- description of the medium required to
-                      -- satisfy the request.
-                  inputManualInputRequest(810), -- Not in RFC 1759
-
-                      -- An interpreter has detected that manual
-                      -- input is required in this subunit.  The
-                      -- prtAlertDescription may be used to convey
-                      -- a human readable description of the medium
-                      -- required to satisfy the request.
-                  inputTrayPositionFailure(811), -- Not in RFC 1759
-                      -- The input tray failed to position correctly.
-                  inputTrayElevationFailure(812),
-                                        -- Not in RFC 1759
-                  inputCannotFeedSizeSelected(813),
-                                        -- Not in RFC 1759
-                -- Output Group
-                  outputMediaTrayMissing(901),
-                  outputMediaTrayAlmostFull(902),
-                  outputMediaTrayFull(903),
-                  outputMailboxSelectFailure(904),
-                                        -- Not in RFC 1759
-                -- Marker group
-                  markerFuserUnderTemperature(1001),
-                  markerFuserOverTemperature(1002),
-                  markerFuserTimingFailure(1003),
-                                        -- Not in RFC 1759
-                  markerFuserThermistorFailure(1004),
-                                        -- Not in RFC 1759
-                  markerAdjustingPrintQuality(1005),
-                                        -- Not in RFC 1759
-                -- Marker Supplies group
-                  markerTonerEmpty(1101),
-                  markerInkEmpty(1102),
-                  markerPrintRibbonEmpty(1103),
-                  markerTonerAlmostEmpty(1104),
-                  markerInkAlmostEmpty(1105),
-                  markerPrintRibbonAlmostEmpty(1106),
-                  markerWasteTonerReceptacleAlmostFull(1107),
-                  markerWasteInkReceptacleAlmostFull(1108),
-                  markerWasteTonerReceptacleFull(1109),
-                  markerWasteInkReceptacleFull(1110),
-                  markerOpcLifeAlmostOver(1111),
-                  markerOpcLifeOver(1112),
-                  markerDeveloperAlmostEmpty(1113),
-                  markerDeveloperEmpty(1114),
-                  markerTonerCartridgeMissing(1115),
-                                        -- Not in RFC 1759
-                -- Media Path Device Group
-                  mediaPathMediaTrayMissing(1301),
-                  mediaPathMediaTrayAlmostFull(1302),
-                  mediaPathMediaTrayFull(1303),
-                  mediaPathCannotDuplexMediaSelected(1304),
-
-                                        -- Not in RFC 1759
-                -- Interpreter Group
-                  interpreterMemoryIncrease(1501),
-                  interpreterMemoryDecrease(1502),
-                  interpreterCartridgeAdded(1503),
-                  interpreterCartridgeDeleted(1504),
-                  interpreterResourceAdded(1505),
-                  interpreterResourceDeleted(1506),
-                  interpreterResourceUnavailable(1507),
-                  interpreterComplexPageEncountered(1509),
-                                        -- Not in RFC 1759
-                      -- The interpreter has encountered a page
-                      -- that is too complex for the resources that
-                      -- are available.
-                -- Alert Group
-                  alertRemovalOfBinaryChangeEntry(1801)
-                                        -- Not in RFC 1759
-                      -- A binary change event entry has been
-                      -- removed from the alert table.  This unary
-                      -- change alert table entry is added to the
-                      -- end of the alert table.
-                  }
-END
-
-
diff --git a/contrib/apps/LwipMibCompiler/Mibs/IANA/IANA-RTPROTO-MIB b/contrib/apps/LwipMibCompiler/Mibs/IANA/IANA-RTPROTO-MIB
deleted file mode 100644
index 952c84e2..00000000
--- a/contrib/apps/LwipMibCompiler/Mibs/IANA/IANA-RTPROTO-MIB
+++ /dev/null
@@ -1,92 +0,0 @@
-
-IANA-RTPROTO-MIB DEFINITIONS ::= BEGIN
-
-IMPORTS
-    MODULE-IDENTITY, mib-2           FROM SNMPv2-SMI
-    TEXTUAL-CONVENTION               FROM SNMPv2-TC;
-
-ianaRtProtoMIB  MODULE-IDENTITY
-    LAST-UPDATED "200009260000Z" -- September 26, 2000
-    ORGANIZATION "IANA"
-    CONTACT-INFO
-            " Internet Assigned Numbers Authority
-              Internet Corporation for Assigned Names and Numbers
-              4676 Admiralty Way, Suite 330
-              Marina del Rey, CA 90292-6601
-
-              Phone: +1 310 823 9358
-              EMail: iana&iana.org"
-    DESCRIPTION
-            "This MIB module defines the IANAipRouteProtocol and
-            IANAipMRouteProtocol textual conventions for use in MIBs
-            which need to identify unicast or multicast routing
-            mechanisms.
-
-            Any additions or changes to the contents of this MIB module
-            require either publication of an RFC, or Designated Expert
-            Review as defined in RFC 2434, Guidelines for Writing an
-            IANA Considerations Section in RFCs.  The Designated Expert 
-            will be selected by the IESG Area Director(s) of the Routing
-            Area."
-
-    REVISION     "200009260000Z"  -- September 26, 2000 
-    DESCRIPTION  "Original version, published in coordination
-                 with RFC 2932."
-
-    ::= { mib-2 84 }
-
-IANAipRouteProtocol ::= TEXTUAL-CONVENTION
-   STATUS      current
-
-   DESCRIPTION
-            "A mechanism for learning routes.  Inclusion of values for
-            routing protocols is not intended to imply that those
-            protocols need be supported."
-   SYNTAX      INTEGER {
-                other     (1),  -- not specified
-                local     (2),  -- local interface
-                netmgmt   (3),  -- static route
-                icmp      (4),  -- result of ICMP Redirect
-
-                        -- the following are all dynamic
-                        -- routing protocols
-
-                egp        (5),  -- Exterior Gateway Protocol
-                ggp        (6),  -- Gateway-Gateway Protocol
-                hello      (7),  -- FuzzBall HelloSpeak
-                rip        (8),  -- Berkeley RIP or RIP-II
-                isIs       (9),  -- Dual IS-IS
-                esIs       (10), -- ISO 9542
-                ciscoIgrp  (11), -- Cisco IGRP
-                bbnSpfIgp  (12), -- BBN SPF IGP
-                ospf       (13), -- Open Shortest Path First
-                bgp        (14), -- Border Gateway Protocol
-                idpr       (15), -- InterDomain Policy Routing
-                ciscoEigrp (16), -- Cisco EIGRP
-                dvmrp      (17)  -- DVMRP
-               }
-
-IANAipMRouteProtocol ::= TEXTUAL-CONVENTION
-   STATUS      current
-   DESCRIPTION
-            "The multicast routing protocol.  Inclusion of values for
-            multicast routing protocols is not intended to imply that
-            those protocols need be supported."
-   SYNTAX      INTEGER {
-                   other(1),          -- none of the following
-                   local(2),          -- e.g., manually configured
-                   netmgmt(3),        -- set via net.mgmt protocol
-                   dvmrp(4),
-                   mospf(5),
-                   pimSparseDense(6), -- PIMv1, both DM and SM
-                   cbt(7),
-                   pimSparseMode(8),  -- PIM-SM
-                   pimDenseMode(9),   -- PIM-DM
-                   igmpOnly(10),
-                   bgmp(11),
-                   msdp(12)
-               }
-
-END
-
-
diff --git a/contrib/apps/LwipMibCompiler/Mibs/IANA/IANATn3270eTC-MIB b/contrib/apps/LwipMibCompiler/Mibs/IANA/IANATn3270eTC-MIB
deleted file mode 100644
index e774ac00..00000000
--- a/contrib/apps/LwipMibCompiler/Mibs/IANA/IANATn3270eTC-MIB
+++ /dev/null
@@ -1,306 +0,0 @@
-
-  IANATn3270eTC-MIB DEFINITIONS ::= BEGIN
-
- IMPORTS
-      MODULE-IDENTITY, mib-2
-          FROM SNMPv2-SMI
-      TEXTUAL-CONVENTION
-          FROM SNMPv2-TC;
-
-    ianaTn3270eTcMib MODULE-IDENTITY
-        LAST-UPDATED "200005100000Z"  -- May 10, 2000
-        ORGANIZATION "IANA"
-        CONTACT-INFO
-            "Internet Assigned Numbers Authority
-
-             Postal: ICANN
-                     4676 Admiralty Way, Suite 330
-                     Marina del Rey, CA 90292
-
-             Tel:    +1  310 823 9358 x20
-             E-Mail: iana&iana.org"
-        DESCRIPTION
-            "This module defines a set of textual conventions
-            for use by the TN3270E-MIB and the TN3270E-RT-MIB.
-
-            Any additions or changes to the contents of this
-            MIB module must first be discussed on the tn3270e
-            working group list at: tn3270e&list.nih.gov
-            and approved by one of the following TN3270E
-            working group contacts:
-
-                Ed Bailey (co-chair) - elbailey&us.ibm.com
-                Michael Boe (co-chair) - mboe&cisco.com
-                Ken White - kennethw&vnet.ibm.com
-                Robert Moore - remoore&us.ibm.com
-
-            The above list of contacts can be altered with
-            the approval of the two co-chairs.
-
-            The Textual Conventions defined within this MIB have
-            no security issues associated with them unless
-            explicitly stated in their corresponding
-            DESCRIPTION clause."
-
-     -- revision log, in reverse chronological order
-
-        REVISION    "200005100000Z"  -- May 10, 2000
-        DESCRIPTION "Fix to import mib-2 instead of experimental."
-
-        REVISION    "199909011000Z"  -- September 1, 1999
-        DESCRIPTION
-            "Initial version transferred from the TN3270E
-            working group to IANA."
-
-        ::= { mib-2 61 }
-
-
-  -- Textual Conventions
-
-  IANATn3270eAddrType ::= TEXTUAL-CONVENTION
-      STATUS current
-      DESCRIPTION
-          "The textual convention for defining the type of a
-          client address.  The enumeration value unknown(0) is
-          also used to indicate that no actual address is present."
-      SYNTAX INTEGER {
-                      unknown(0),
-                      ipv4(1),
-                      ipv6(2)
-                     }
-
-  IANATn3270eAddress ::= TEXTUAL-CONVENTION
-      STATUS current
-      DESCRIPTION
-          "Denotes a client address.  The type of client address is
-          determined by use of the IANATn3270eAddrType textual
-convention.
-          The length in octets of a IANATn3270eAddress object is:
-
-            IANATn3270eAddrType   Address Length
-            +++++++++++++++++++   ++++++++++++++
-                     unknown(0)   not specified or unknown; the
-                                  actual length of the
-                                  IANATn3270eAddress octet string
-                                  indicates if an address
-                                  is present
-                        ipv4(1)   4 OCTETS
-                        ipv6(2)   16 OCTETS
-
-          This textual convention is similar to the TAddress
-          TC defined by RFC1903 except that it allows a
-          zero-length octet string and is not a full transport
-          layer address."
-      SYNTAX OCTET STRING (SIZE (0..255))
-
-  IANATn3270eClientType ::= TEXTUAL-CONVENTION
-      STATUS current
-      DESCRIPTION
-          "The textual convention for defining the set of
-           enumerations used by tn3270eTcpConnClientIdFormat
-           in the TN3270E-MIB:
-
-           ENUMERATION        OCTETs  DESCRIPTION
-
-           none(1)              0     Not specified
-           other(2)           1..512  Implementation specific
-           ipv4(3)              6     4-octet IP Address plus
-                                      2-octet TCP Port
-           ipv6(4)              18    16-octet IPv6 Address
-                                      plus 2-octet TCP Port
-           domainName(5)      1..512  The DNS name of a
-                                      client.
-           truncDomainName(6) 1..512  The (truncated) DNS name
-                                      of a client.
-           string(7)          1..512  Unknown Utf8String
-           certificate(8)     1..512  certificate
-           userId(9)          1..8    Client's userid
-           x509dn(10)         1..512  X.509 Distinguished Name
-
-           Representation of a certificate(8) may be lead to
-           a security exposure and is NOT RECOMMENDED without
-           adequate security."
-      SYNTAX INTEGER {
-                      none(1),
-                      other(2),
-                      ipv4(3),
-                      ipv6(4),
-                      domainName(5),
-                      truncDomainName(6),
-                      string(7),
-                      certificate(8),
-                      userId(9),
-                      x509dn(10)
-                     }
-
-  IANATn3270Functions ::= TEXTUAL-CONVENTION
-      STATUS current
-      DESCRIPTION
-          "This textual convention reflects the current set of
-          TN3270 and TN3270E functions that can be negotiated
-          between a server and its client:
-
-          RFC856
-          transmitBinary  The sender of this command REQUESTS
-                          permission to begin transmitting, or
-                          confirms that it will now begin
-                          transmitting characters which are to
-                          be interpreted as 8 bits of binary
-                          data by the receiver of the data.
-          RFC860
-          timingMark      The sender of this command REQUESTS
-                          that the receiver of this command
-                          return a WILL TIMING-MARK in the data
-                          stream at the 'appropriate place'.
-          RFC885
-          endOfRecord     The sender of this command requests
-                          permission to begin transmission of
-                          the Telnet END-OF-RECORD (EOR) code
-                          when transmitting data characters, or
-                          the sender of this command confirms it
-                          will now begin transmission of EORs
-                          with transmitted data characters.
-          RFC1091
-          terminalType    Sender is willing to send terminal
-                          type information in a subsequent
-                          sub-negotiation.
-
-          RFC1041
-          tn3270Regime    Sender is willing to send list of
-                          supported 3270 Regimes in a
-                          subsequent sub-negotiation.
-          RFC2355
-          scsCtlCodes     (Printer sessions only).  Allows the
-                          use of the SNA Character Stream (SCS)
-                          and SCS control codes on the session.
-                          SCS is used with LU type 1 SNA sessions.
-          dataStreamCtl   (Printer sessions only).  Allows the use
-                          of the standard 3270 data stream.  This
-                          corresponds to LU type 3 SNA sessions.
-          responses       Provides support for positive and
-                          negative response handling.  Allows the
-                          server to reflect to the client any and
-                          all definite, exception, and no response
-                          requests sent by the host application.
-          bindImage       Allows the server to send the SNA Bind
-                          image and Unbind notification to the
-                          client.
-          sysreq          Allows the client and server to emulate
-                          some (or all, depending on the server) of
-                          the functions of the SYSREQ key in an SNA
-                          environment."
-      SYNTAX BITS {
-                   transmitBinary(0),-- rfc856
-                   timemark(1),      -- rfc860
-                   endOfRecord(2),   -- rfc885
-                   terminalType(3),  -- rfc1091
-                   tn3270Regime(4),  -- rfc1041
-                   scsCtlCodes(5),   -- rfc2355
-                   dataStreamCtl(6), -- rfc2355
-                   responses(7),     -- rfc2355
-                   bindImage(8),     -- rfc2355
-                   sysreq(9)         -- rfc2355
-                  }
-
-  IANATn3270ResourceType ::= TEXTUAL-CONVENTION
-      STATUS current
-      DESCRIPTION
-          "The type of resource defined by a resource pool.  Refer
-          to tn3270eResPoolTable."
-      SYNTAX INTEGER {
-                      other(1),
-                      terminal(2),
-                      printer(3),
-                      terminalOrPrinter(4)
-                     }
-
-  IANATn3270DeviceType ::= TEXTUAL-CONVENTION
-      STATUS current
-      DESCRIPTION
-          "This textual convention defines the list of device
-          types that can be set, as defined by RFC 2355."
-      SYNTAX INTEGER {
-                   -- terminals
-                      ibm3278d2(1),    -- (24 row x 80 col display)
-                      ibm3278d2E(2),   -- (24 row x 80 col display)
-                      ibm3278d3(3),    -- (32 row x 80 col display)
-                      ibm3278d3E(4),   -- (32 row x 80 col display)
-                      ibm3278d4(5),    -- (43 row x 80 col display)
-                      ibm3278d4E(6),   -- (43 row x 80 col display)
-                      ibm3278d5(7),    -- (27 row x 132 col display)
-                      ibm3278d5E(8),   -- (27 row x 132 col display)
-                      ibmDynamic(9),   -- (no pre-defined display size)
-
-                   -- printers
-                      ibm3287d1(10),
-
-                      unknown(100)
-                     }
-
-  IANATn3270eLogData ::= TEXTUAL-CONVENTION
-      STATUS current
-      DESCRIPTION
-        "An octet string representing log data as pertaining to
-        either a TN3270 or TN3270E Session as reported from a
-        TN3270E Server. Log data is stored in an octet string
-        in time order (from earliest to latest).
-
-        Each log element has the following form:
-
-        +------+----+---------+------------+
-        !length!type!TimeStamp! data       !
-        +------+----+---------+------------+
-
-        where
-
-        length    = one-octet length of the data portion of the
-                    trace element, not including the length,
-                    type, and TimeStamp fields
-        type      = one-octet code point characterizing the data.
-        TimeStamp = A 4-octet field representing the number of
-                    TimeTicks since the TN3270E server was last
-                    activated.  The server's last activation time
-                    is available in the tn3270eSrvrConfLastActTime
-                    object in the TN3270E MIB, which has the
-                    syntax DateAndTime.
-        data      = initial part of a PDU.
-
-        length   type
-
-          0-255  x'00' - unknown
-          0      x'01' - inactivity timer expired
-          0      x'02' - dynamic timer expired
-          0      x'03' - actlu req
-          0      x'04' - bind req
-          0      x'05' - clear req
-          0      x'06' - dactlu req
-          0      x'07' - warm actpu req
-          0      x'08' - sdt req
-          0      x'09' - unbind req
-          0      x'0A' - notify resp
-          0      x'0B' - reply PSID neg rsp
-          0      x'0C' - reply PSID pos rsp
-          0      x'0D' - unbind rsp
-          0      x'0E' - hierarchical reset
-          0      x'0F' - client connect req
-          0      x'10' - client disconnect req
-          0      x'11' - timingmark received
-          0      x'12' - flowControl timer expired
-          0      x'13' - neg rsp to host
-          0      x'14' - neg rsp from host
-          0      x'15' - data contention
-          0      x'16' - no buffer to send SNA data
-          0      x'17' - receive response while inbound
-          0      x'18' - client protocol error
-          0      x'19' - badClientSequenceReceived
-          1-255  x'1A' - utf8String
-          2      x'1B' - hexCode, implementation dependent
-
-          Log element entries have a minimum length of 6 octets.
-          The zero-length string indicates that no log data is
-          available."
-      SYNTAX OCTET STRING (SIZE (0 | 6..2048))
-
-  END
-
-
diff --git a/contrib/apps/LwipMibCompiler/Mibs/IANA/IANAifType-MIB b/contrib/apps/LwipMibCompiler/Mibs/IANA/IANAifType-MIB
deleted file mode 100644
index 39dddf9e..00000000
--- a/contrib/apps/LwipMibCompiler/Mibs/IANA/IANAifType-MIB
+++ /dev/null
@@ -1,572 +0,0 @@
-   IANAifType-MIB DEFINITIONS ::= BEGIN
-
-   IMPORTS
-       MODULE-IDENTITY, mib-2      FROM SNMPv2-SMI
-       TEXTUAL-CONVENTION          FROM SNMPv2-TC;
-
-   ianaifType MODULE-IDENTITY
-       LAST-UPDATED "200709130000Z"  -- September 13, 2007
-       ORGANIZATION "IANA"
-       CONTACT-INFO "        Internet Assigned Numbers Authority
-
-                     Postal: ICANN
-                             4676 Admiralty Way, Suite 330
-                             Marina del Rey, CA 90292
-
-                     Tel:    +1 310 823 9358
-                     E-Mail: iana&iana.org"
-
-       DESCRIPTION  "This MIB module defines the IANAifType Textual
-                     Convention, and thus the enumerated values of
-                     the ifType object defined in MIB-II's ifTable."
-
-       REVISION     "200709130000Z"  -- September 13, 2007
-       DESCRIPTION  "Registration of new IANAifTypes 243 and 244."
-
-       REVISION     "200705290000Z"  -- May 29, 2007
-       DESCRIPTION  "Changed the description for IANAifType 228."
-
-       REVISION     "200703080000Z"  -- March 08, 2007
-       DESCRIPTION  "Registration of new IANAifType 242."
-
-       REVISION     "200701230000Z"  -- January 23, 2007
-       DESCRIPTION  "Registration of new IANAifTypes 239, 240, and 241." 
-
-       REVISION     "200610170000Z"  -- October 17, 2006
-       DESCRIPTION  "Deprecated/Obsoleted IANAifType 230.  Registration of 
-                     IANAifType 238." 
-
-       REVISION     "200609250000Z"  -- September 25, 2006
-       DESCRIPTION  "Changed the description for IANA ifType 
-                     184 and added new IANA ifType 237."  
-
-       REVISION     "200608170000Z"  -- August 17, 2006
-       DESCRIPTION  "Changed the descriptions for IANAifTypes
-                     20 and 21."   
-
-       REVISION     "200608110000Z"  -- August 11, 2006
-       DESCRIPTION  "Changed the descriptions for IANAifTypes
-                     7, 11, 62, 69, and 117."   
-
-       REVISION     "200607250000Z"  -- July 25, 2006
-       DESCRIPTION  "Registration of new IANA ifType 236."
-
-       REVISION     "200606140000Z"  -- June 14, 2006
-       DESCRIPTION  "Registration of new IANA ifType 235."
-
-       REVISION     "200603310000Z"  -- March 31, 2006
-       DESCRIPTION  "Registration of new IANA ifType 234."
-	   
-       REVISION     "200603300000Z"  -- March 30, 2006
-       DESCRIPTION  "Registration of new IANA ifType 233."
-       
-       REVISION     "200512220000Z"  -- December 22, 2005
-       DESCRIPTION  "Registration of new IANA ifTypes 231 and 232."
-	   
-       REVISION     "200510100000Z"  -- October 10, 2005
-       DESCRIPTION  "Registration of new IANA ifType 230."
-
-       REVISION     "200509090000Z"  -- September 09, 2005
-       DESCRIPTION  "Registration of new IANA ifType 229."
-
-       REVISION     "200505270000Z"  -- May 27, 2005
-       DESCRIPTION  "Registration of new IANA ifType 228."
-
-       REVISION     "200503030000Z"  -- March 3, 2005
-       DESCRIPTION  "Added the IANAtunnelType TC and deprecated
-	                 IANAifType sixToFour (215) per RFC4087."
-
-       REVISION     "200411220000Z"  -- November 22, 2004
-       DESCRIPTION  "Registration of new IANA ifType 227 per RFC4631."
-
-       REVISION     "200406170000Z"  -- June 17, 2004
-       DESCRIPTION  "Registration of new IANA ifType 226."
-
-       REVISION     "200405120000Z"  -- May 12, 2004
-       DESCRIPTION  "Added description for IANAifType 6, and 
-	                 changed the descriptions for IANAifTypes
-                     180, 181, and 182."
-
-       REVISION     "200405070000Z"  -- May 7, 2004
-       DESCRIPTION  "Registration of new IANAifType 225."
-
-       REVISION     "200308250000Z"  -- Aug 25, 2003
-       DESCRIPTION  "Deprecated IANAifTypes 7 and 11. Obsoleted
-                     IANAifTypes 62, 69, and 117.  ethernetCsmacd (6)
-                     should be used instead of these values"
-
-       REVISION     "200308180000Z"  -- Aug 18, 2003
-       DESCRIPTION  "Registration of new IANAifType
-                     224."
-
-       REVISION     "200308070000Z"  -- Aug 7, 2003
-       DESCRIPTION  "Registration of new IANAifTypes
-                     222 and 223."
-
-       REVISION     "200303180000Z"  -- Mar 18, 2003
-       DESCRIPTION  "Registration of new IANAifType
-                     221."
-
-       REVISION     "200301130000Z"  -- Jan 13, 2003
-       DESCRIPTION  "Registration of new IANAifType
-                     220."
-
-       REVISION     "200210170000Z"  -- Oct 17, 2002
-       DESCRIPTION  "Registration of new IANAifType
-                     219."
-	   
-       REVISION     "200207160000Z"  -- Jul 16, 2002
-       DESCRIPTION  "Registration of new IANAifTypes
-                     217 and 218."
-
-       REVISION     "200207100000Z"  -- Jul 10, 2002
-       DESCRIPTION  "Registration of new IANAifTypes
-                     215 and 216."
-
-       REVISION     "200206190000Z"  -- Jun 19, 2002
-       DESCRIPTION  "Registration of new IANAifType
-                     214."
-	   
-       REVISION     "200201040000Z"  -- Jan 4, 2002
-       DESCRIPTION  "Registration of new IANAifTypes
-                     211, 212 and 213."
-
-       REVISION     "200112200000Z"  -- Dec 20, 2001
-       DESCRIPTION  "Registration of new IANAifTypes
-                     209 and 210."
-
-       REVISION     "200111150000Z"  -- Nov 15, 2001
-       DESCRIPTION  "Registration of new IANAifTypes
-                     207 and 208."
-
-
-       REVISION     "200111060000Z"  -- Nov 6, 2001
-       DESCRIPTION  "Registration of new IANAifType
-                     206."
-
-
-       REVISION     "200111020000Z"  -- Nov 2, 2001
-       DESCRIPTION  "Registration of new IANAifType
-                     205."
-
-
-       REVISION     "200110160000Z"  -- Oct 16, 2001
-       DESCRIPTION  "Registration of new IANAifTypes
-                     199, 200, 201, 202, 203, and 204."
-
-
-       REVISION     "200109190000Z"  -- Sept 19, 2001
-       DESCRIPTION  "Registration of new IANAifType
-                     198."
-
-       REVISION     "200105110000Z"  -- May 11, 2001
-       DESCRIPTION  "Registration of new IANAifType
-                     197."
-
-       
-       REVISION     "200101120000Z"  -- Jan 12, 2001
-       DESCRIPTION  "Registration of new IANAifTypes
-                     195 and 196."
-
-       REVISION     "200012190000Z"  -- Dec 19, 2000
-       DESCRIPTION  "Registration of new IANAifTypes
-                     193 and 194."
-
-       REVISION     "200012070000Z"  -- Dec 07, 2000
-       DESCRIPTION  "Registration of new IANAifTypes
-                     191 and 192."
-
-       REVISION     "200012040000Z"  -- Dec 04, 2000
-       DESCRIPTION  "Registration of new IANAifType
-                     190."
-
-       REVISION     "200010170000Z"  -- Oct 17, 2000
-       DESCRIPTION  "Registration of new IANAifTypes
-                     188 and 189."  
-
-       REVISION     "200010020000Z"  -- Oct 02, 2000
-       DESCRIPTION  "Registration of new IANAifType 187." 
-
-       REVISION     "200009010000Z"  -- Sept 01, 2000
-       DESCRIPTION  "Registration of new IANAifTypes
-                     184, 185, and 186."			
-
-       REVISION     "200008240000Z"  -- Aug 24, 2000
-       DESCRIPTION  "Registration of new IANAifType 183." 
-
-       REVISION     "200008230000Z"  -- Aug 23, 2000
-       DESCRIPTION  "Registration of new IANAifTypes
-                     174-182."
-
-       REVISION     "200008220000Z"  -- Aug 22, 2000
-       DESCRIPTION  "Registration of new IANAifTypes 170,
-                     171, 172 and 173."
-
-       REVISION     "200004250000Z"  -- Apr 25, 2000
-       DESCRIPTION  "Registration of new IANAifTypes 168 and 169."       
-	
-       REVISION     "200003060000Z"  -- Mar 6, 2000
-       DESCRIPTION  "Fixed a missing semi-colon in the IMPORT.
-                     Also cleaned up the REVISION log a bit.
-                     It is not complete, but from now on it will
-                     be maintained and kept up to date with each
-                     change to this MIB module."
-
-       REVISION     "199910081430Z"  -- Oct 08, 1999
-       DESCRIPTION  "Include new name assignments up to cnr(85).
-                     This is the first version available via the WWW
-                     at: ftp://ftp.isi.edu/mib/ianaiftype.mib"
-
-       REVISION     "199401310000Z"  -- Jan 31, 1994
-       DESCRIPTION  "Initial version of this MIB as published in
-                     RFC 1573."
-
-       ::= { mib-2 30 }
-
-
-   IANAifType ::= TEXTUAL-CONVENTION
-       STATUS       current
-       DESCRIPTION
-               "This data type is used as the syntax of the ifType
-               object in the (updated) definition of MIB-II's
-               ifTable.
-
-               The definition of this textual convention with the
-               addition of newly assigned values is published
-               periodically by the IANA, in either the Assigned
-               Numbers RFC, or some derivative of it specific to
-               Internet Network Management number assignments.  (The
-               latest arrangements can be obtained by contacting the
-               IANA.)
-
-               Requests for new values should be made to IANA via
-               email (iana&iana.org).
-
-               The relationship between the assignment of ifType
-               values and of OIDs to particular media-specific MIBs
-               is solely the purview of IANA and is subject to change
-               without notice.  Quite often, a media-specific MIB's
-               OID-subtree assignment within MIB-II's 'transmission'
-               subtree will be the same as its ifType value.
-               However, in some circumstances this will not be the
-               case, and implementors must not pre-assume any
-               specific relationship between ifType values and
-               transmission subtree OIDs."
-       SYNTAX  INTEGER {
-                   other(1),          -- none of the following
-                   regular1822(2),
-                   hdh1822(3),
-                   ddnX25(4),
-                   rfc877x25(5),
-                   ethernetCsmacd(6), -- for all ethernet-like interfaces,
-                                      -- regardless of speed, as per RFC3635
-                   iso88023Csmacd(7), -- Deprecated via RFC3635
-                                      -- ethernetCsmacd (6) should be used instead
-                   iso88024TokenBus(8),
-                   iso88025TokenRing(9),
-                   iso88026Man(10),
-                   starLan(11), -- Deprecated via RFC3635
-                                -- ethernetCsmacd (6) should be used instead
-                   proteon10Mbit(12),
-                   proteon80Mbit(13),
-                   hyperchannel(14),
-                   fddi(15),
-                   lapb(16),
-                   sdlc(17),
-                   ds1(18),            -- DS1-MIB
-                   e1(19),             -- Obsolete see DS1-MIB
-                   basicISDN(20),              -- no longer used
-                                               -- see also RFC2127
-                   primaryISDN(21),            -- no longer used
-                                               -- see also RFC2127
-                   propPointToPointSerial(22), -- proprietary serial
-                   ppp(23),
-                   softwareLoopback(24),
-                   eon(25),            -- CLNP over IP 
-                   ethernet3Mbit(26),
-                   nsip(27),           -- XNS over IP
-                   slip(28),           -- generic SLIP
-                   ultra(29),          -- ULTRA technologies
-                   ds3(30),            -- DS3-MIB
-                   sip(31),            -- SMDS, coffee
-                   frameRelay(32),     -- DTE only. 
-                   rs232(33),
-                   para(34),           -- parallel-port
-                   arcnet(35),         -- arcnet
-                   arcnetPlus(36),     -- arcnet plus
-                   atm(37),            -- ATM cells
-                   miox25(38),
-                   sonet(39),          -- SONET or SDH 
-                   x25ple(40),
-                   iso88022llc(41),
-                   localTalk(42),
-                   smdsDxi(43),
-                   frameRelayService(44),  -- FRNETSERV-MIB
-                   v35(45),
-                   hssi(46),
-                   hippi(47),
-                   modem(48),          -- Generic modem
-                   aal5(49),           -- AAL5 over ATM
-                   sonetPath(50),
-                   sonetVT(51),
-                   smdsIcip(52),       -- SMDS InterCarrier Interface
-                   propVirtual(53),    -- proprietary virtual/internal
-                   propMultiplexor(54),-- proprietary multiplexing
-                   ieee80212(55),      -- 100BaseVG
-                   fibreChannel(56),   -- Fibre Channel
-                   hippiInterface(57), -- HIPPI interfaces     
-                   frameRelayInterconnect(58), -- Obsolete use either
-                                       -- frameRelay(32) or 
-                                       -- frameRelayService(44).
-                   aflane8023(59),     -- ATM Emulated LAN for 802.3
-                   aflane8025(60),     -- ATM Emulated LAN for 802.5
-                   cctEmul(61),        -- ATM Emulated circuit          
-                   fastEther(62),      -- Obsoleted via RFC3635
-                                       -- ethernetCsmacd (6) should be used instead
-                   isdn(63),           -- ISDN and X.25           
-                   v11(64),            -- CCITT V.11/X.21             
-                   v36(65),            -- CCITT V.36                  
-                   g703at64k(66),      -- CCITT G703 at 64Kbps
-                   g703at2mb(67),      -- Obsolete see DS1-MIB
-                   qllc(68),           -- SNA QLLC                    
-                   fastEtherFX(69),    -- Obsoleted via RFC3635
-                                       -- ethernetCsmacd (6) should be used instead
-                   channel(70),        -- channel                     
-                   ieee80211(71),      -- radio spread spectrum       
-                   ibm370parChan(72),  -- IBM System 360/370 OEMI Channel
-                   escon(73),          -- IBM Enterprise Systems Connection
-                   dlsw(74),           -- Data Link Switching
-                   isdns(75),          -- ISDN S/T interface
-                   isdnu(76),          -- ISDN U interface
-                   lapd(77),           -- Link Access Protocol D
-                   ipSwitch(78),       -- IP Switching Objects
-                   rsrb(79),           -- Remote Source Route Bridging
-                   atmLogical(80),     -- ATM Logical Port
-                   ds0(81),            -- Digital Signal Level 0
-                   ds0Bundle(82),      -- group of ds0s on the same ds1
-                   bsc(83),            -- Bisynchronous Protocol
-                   async(84),          -- Asynchronous Protocol
-                   cnr(85),            -- Combat Net Radio
-                   iso88025Dtr(86),    -- ISO 802.5r DTR
-                   eplrs(87),          -- Ext Pos Loc Report Sys
-                   arap(88),           -- Appletalk Remote Access Protocol
-                   propCnls(89),       -- Proprietary Connectionless Protocol
-                   hostPad(90),        -- CCITT-ITU X.29 PAD Protocol
-                   termPad(91),        -- CCITT-ITU X.3 PAD Facility
-                   frameRelayMPI(92),  -- Multiproto Interconnect over FR
-                   x213(93),           -- CCITT-ITU X213
-                   adsl(94),           -- Asymmetric Digital Subscriber Loop
-                   radsl(95),          -- Rate-Adapt. Digital Subscriber Loop
-                   sdsl(96),           -- Symmetric Digital Subscriber Loop
-                   vdsl(97),           -- Very H-Speed Digital Subscrib. Loop
-                   iso88025CRFPInt(98), -- ISO 802.5 CRFP
-                   myrinet(99),        -- Myricom Myrinet
-                   voiceEM(100),       -- voice recEive and transMit
-                   voiceFXO(101),      -- voice Foreign Exchange Office
-                   voiceFXS(102),      -- voice Foreign Exchange Station
-                   voiceEncap(103),    -- voice encapsulation
-                   voiceOverIp(104),   -- voice over IP encapsulation
-                   atmDxi(105),        -- ATM DXI
-                   atmFuni(106),       -- ATM FUNI
-                   atmIma (107),       -- ATM IMA		   
-                   pppMultilinkBundle(108), -- PPP Multilink Bundle
-                   ipOverCdlc (109),   -- IBM ipOverCdlc
-                   ipOverClaw (110),   -- IBM Common Link Access to Workstn
-                   stackToStack (111), -- IBM stackToStack
-                   virtualIpAddress (112), -- IBM VIPA
-                   mpc (113),          -- IBM multi-protocol channel support
-                   ipOverAtm (114),    -- IBM ipOverAtm
-                   iso88025Fiber (115), -- ISO 802.5j Fiber Token Ring
-                   tdlc (116),	       -- IBM twinaxial data link control
-                   gigabitEthernet (117), -- Obsoleted via RFC3635
-                                          -- ethernetCsmacd (6) should be used instead
-                   hdlc (118),         -- HDLC
-                   lapf (119),	       -- LAP F
-                   v37 (120),	       -- V.37
-                   x25mlp (121),       -- Multi-Link Protocol
-                   x25huntGroup (122), -- X25 Hunt Group
-                   trasnpHdlc (123),   -- Transp HDLC
-                   interleave (124),   -- Interleave channel
-                   fast (125),         -- Fast channel
-                   ip (126),	       -- IP (for APPN HPR in IP networks)
-                   docsCableMaclayer (127),  -- CATV Mac Layer
-                   docsCableDownstream (128), -- CATV Downstream interface
-                   docsCableUpstream (129),  -- CATV Upstream interface
-                   a12MppSwitch (130), -- Avalon Parallel Processor
-                   tunnel (131),       -- Encapsulation interface
-                   coffee (132),       -- coffee pot
-                   ces (133),          -- Circuit Emulation Service
-                   atmSubInterface (134), -- ATM Sub Interface
-                   l2vlan (135),       -- Layer 2 Virtual LAN using 802.1Q
-                   l3ipvlan (136),     -- Layer 3 Virtual LAN using IP
-                   l3ipxvlan (137),    -- Layer 3 Virtual LAN using IPX
-                   digitalPowerline (138), -- IP over Power Lines	
-                   mediaMailOverIp (139), -- Multimedia Mail over IP
-                   dtm (140),        -- Dynamic syncronous Transfer Mode
-                   dcn (141),    -- Data Communications Network
-                   ipForward (142),    -- IP Forwarding Interface
-                   msdsl (143),       -- Multi-rate Symmetric DSL
-                   ieee1394 (144), -- IEEE1394 High Performance Serial Bus
-                   if-gsn (145),       --   HIPPI-6400 
-                   dvbRccMacLayer (146), -- DVB-RCC MAC Layer
-                   dvbRccDownstream (147),  -- DVB-RCC Downstream Channel
-                   dvbRccUpstream (148),  -- DVB-RCC Upstream Channel
-                   atmVirtual (149),   -- ATM Virtual Interface
-                   mplsTunnel (150),   -- MPLS Tunnel Virtual Interface
-                   srp (151),	-- Spatial Reuse Protocol	
-                   voiceOverAtm (152),  -- Voice Over ATM
-                   voiceOverFrameRelay (153),   -- Voice Over Frame Relay 
-                   idsl (154),		-- Digital Subscriber Loop over ISDN
-                   compositeLink (155),  -- Avici Composite Link Interface
-                   ss7SigLink (156),     -- SS7 Signaling Link 
-                   propWirelessP2P (157),  --  Prop. P2P wireless interface
-                   frForward (158),    -- Frame Forward Interface
-                   rfc1483 (159),	-- Multiprotocol over ATM AAL5
-                   usb (160),		-- USB Interface
-                   ieee8023adLag (161),  -- IEEE 802.3ad Link Aggregate
-                   bgppolicyaccounting (162), -- BGP Policy Accounting
-                   frf16MfrBundle (163), -- FRF .16 Multilink Frame Relay 
-                   h323Gatekeeper (164), -- H323 Gatekeeper
-                   h323Proxy (165), -- H323 Voice and Video Proxy
-                   mpls (166), -- MPLS                   
-                   mfSigLink (167), -- Multi-frequency signaling link
-                   hdsl2 (168), -- High Bit-Rate DSL - 2nd generation
-                   shdsl (169), -- Multirate HDSL2
-                   ds1FDL (170), -- Facility Data Link 4Kbps on a DS1
-                   pos (171), -- Packet over SONET/SDH Interface
-                   dvbAsiIn (172), -- DVB-ASI Input
-                   dvbAsiOut (173), -- DVB-ASI Output 
-                   plc (174), -- Power Line Communtications
-                   nfas (175), -- Non Facility Associated Signaling
-                   tr008 (176), -- TR008
-                   gr303RDT (177), -- Remote Digital Terminal
-                   gr303IDT (178), -- Integrated Digital Terminal
-                   isup (179), -- ISUP
-                   propDocsWirelessMaclayer (180), -- Cisco proprietary Maclayer
-                   propDocsWirelessDownstream (181), -- Cisco proprietary Downstream
-                   propDocsWirelessUpstream (182), -- Cisco proprietary Upstream
-                   hiperlan2 (183), -- HIPERLAN Type 2 Radio Interface
-                   propBWAp2Mp (184), -- PropBroadbandWirelessAccesspt2multipt
-                             -- use of this iftype for IEEE 802.16 WMAN
-                             -- interfaces as per IEEE Std 802.16f is
-                             -- deprecated and ifType 237 should be used instead.
-                   sonetOverheadChannel (185), -- SONET Overhead Channel
-                   digitalWrapperOverheadChannel (186), -- Digital Wrapper
-                   aal2 (187), -- ATM adaptation layer 2
-                   radioMAC (188), -- MAC layer over radio links
-                   atmRadio (189), -- ATM over radio links   
-                   imt (190), -- Inter Machine Trunks
-                   mvl (191), -- Multiple Virtual Lines DSL
-                   reachDSL (192), -- Long Reach DSL
-                   frDlciEndPt (193), -- Frame Relay DLCI End Point
-                   atmVciEndPt (194), -- ATM VCI End Point
-                   opticalChannel (195), -- Optical Channel
-                   opticalTransport (196), -- Optical Transport
-                   propAtm (197), --  Proprietary ATM       
-                   voiceOverCable (198), -- Voice Over Cable Interface
-                   infiniband (199), -- Infiniband
-                   teLink (200), -- TE Link
-                   q2931 (201), -- Q.2931
-                   virtualTg (202), -- Virtual Trunk Group
-                   sipTg (203), -- SIP Trunk Group
-                   sipSig (204), -- SIP Signaling   
-                   docsCableUpstreamChannel (205), -- CATV Upstream Channel
-                   econet (206), -- Acorn Econet
-                   pon155 (207), -- FSAN 155Mb Symetrical PON interface
-                   pon622 (208), -- FSAN622Mb Symetrical PON interface
-                   bridge (209), -- Transparent bridge interface
-                   linegroup (210), -- Interface common to multiple lines		   
-                   voiceEMFGD (211), -- voice E&M Feature Group D
-                   voiceFGDEANA (212), -- voice FGD Exchange Access North American
-                   voiceDID (213), -- voice Direct Inward Dialing
-                   mpegTransport (214), -- MPEG transport interface
-                   sixToFour (215), -- 6to4 interface (DEPRECATED)
-                   gtp (216), -- GTP (GPRS Tunneling Protocol)
-                   pdnEtherLoop1 (217), -- Paradyne EtherLoop 1
-                   pdnEtherLoop2 (218), -- Paradyne EtherLoop 2
-                   opticalChannelGroup (219), -- Optical Channel Group
-                   homepna (220), -- HomePNA ITU-T G.989				   
-                   gfp (221), -- Generic Framing Procedure (GFP)
-                   ciscoISLvlan (222), -- Layer 2 Virtual LAN using Cisco ISL
-                   actelisMetaLOOP (223), -- Acteleis proprietary MetaLOOP High Speed Link 
-                   fcipLink (224), -- FCIP Link 
-                   rpr (225), -- Resilient Packet Ring Interface Type
-                   qam (226), -- RF Qam Interface
-                   lmp (227), -- Link Management Protocol
-                   cblVectaStar (228), -- Cambridge Broadband Networks Limited VectaStar
-                   docsCableMCmtsDownstream (229), -- CATV Modular CMTS Downstream Interface
-                   adsl2 (230), -- Asymmetric Digital Subscriber Loop Version 2 
-                                -- (DEPRECATED/OBSOLETED - please use adsl2plus 238 instead)
-                   macSecControlledIF (231), -- MACSecControlled 
-                   macSecUncontrolledIF (232), -- MACSecUncontrolled
-                   aviciOpticalEther (233), -- Avici Optical Ethernet Aggregate
-                   atmbond (234), -- atmbond
-                   voiceFGDOS (235), -- voice FGD Operator Services
-                   mocaVersion1 (236), -- MultiMedia over Coax Alliance (MoCA) Interface
-                             -- as documented in information provided privately to IANA
-                   ieee80216WMAN (237), -- IEEE 802.16 WMAN interface
-                   adsl2plus (238), -- Asymmetric Digital Subscriber Loop Version 2, 
-                                   -- Version 2 Plus and all variants
-                   dvbRcsMacLayer (239), -- DVB-RCS MAC Layer
-                   dvbTdm (240), -- DVB Satellite TDM
-                   dvbRcsTdma (241), -- DVB-RCS TDMA
-                   x86Laps (242), -- LAPS based on ITU-T X.86/Y.1323
-                   wwanPP (243), -- 3GPP WWAN
-                   wwanPP2 (244) -- 3GPP2 WWAN
-                   }
-
-IANAtunnelType ::= TEXTUAL-CONVENTION
-    STATUS     current
-    DESCRIPTION
-            "The encapsulation method used by a tunnel. The value
-            direct indicates that a packet is encapsulated
-            directly within a normal IP header, with no
-            intermediate header, and unicast to the remote tunnel
-            endpoint (e.g., an RFC 2003 IP-in-IP tunnel, or an RFC
-            1933 IPv6-in-IPv4 tunnel). The value minimal indicates
-            that a Minimal Forwarding Header (RFC 2004) is
-            inserted between the outer header and the payload
-            packet. The value UDP indicates that the payload
-            packet is encapsulated within a normal UDP packet
-            (e.g., RFC 1234).
-
-            The values sixToFour, sixOverFour, and isatap
-            indicates that an IPv6 packet is encapsulated directly
-            within an IPv4 header, with no intermediate header,
-            and unicast to the destination determined by the 6to4,
-            6over4, or ISATAP protocol.
-
-            The remaining protocol-specific values indicate that a
-            header of the protocol of that name is inserted
-            between the outer header and the payload header.
-
-            The assignment policy for IANAtunnelType values is
-            identical to the policy for assigning IANAifType
-            values."
-    SYNTAX     INTEGER {
-                   other(1),        -- none of the following
-                   direct(2),       -- no intermediate header
-                   gre(3),          -- GRE encapsulation
-                   minimal(4),      -- Minimal encapsulation
-                   l2tp(5),         -- L2TP encapsulation
-                   pptp(6),         -- PPTP encapsulation
-                   l2f(7),          -- L2F encapsulation
-                   udp(8),          -- UDP encapsulation
-                   atmp(9),         -- ATMP encapsulation
-                   msdp(10),        -- MSDP encapsulation
-                   sixToFour(11),   -- 6to4 encapsulation
-                   sixOverFour(12), -- 6over4 encapsulation
-                   isatap(13),      -- ISATAP encapsulation
-                   teredo(14)       -- Teredo encapsulation
-               }
-
-   END
-
-
-
-
-
-
-
-
-
diff --git a/contrib/apps/LwipMibCompiler/Mibs/IF-MIB b/contrib/apps/LwipMibCompiler/Mibs/IF-MIB
deleted file mode 100644
index 87138943..00000000
--- a/contrib/apps/LwipMibCompiler/Mibs/IF-MIB
+++ /dev/null
@@ -1,1899 +0,0 @@
-IF-MIB DEFINITIONS ::= BEGIN
-
-IMPORTS
-    MODULE-IDENTITY, OBJECT-TYPE, Counter32, Gauge32, Counter64,
-    Integer32, TimeTicks, mib-2,
-    NOTIFICATION-TYPE                        FROM SNMPv2-SMI
-    TEXTUAL-CONVENTION, DisplayString,
-    PhysAddress, TruthValue, RowStatus,
-    TimeStamp, AutonomousType, TestAndIncr   FROM SNMPv2-TC
-    MODULE-COMPLIANCE, OBJECT-GROUP,
-    NOTIFICATION-GROUP                       FROM SNMPv2-CONF
-    snmpTraps                                FROM SNMPv2-MIB
-    IANAifType                               FROM IANAifType-MIB;
-
-
-ifMIB MODULE-IDENTITY
-    LAST-UPDATED "200006140000Z"
-    ORGANIZATION "IETF Interfaces MIB Working Group"
-    CONTACT-INFO
-            "   Keith McCloghrie
-                Cisco Systems, Inc.
-                170 West Tasman Drive
-                San Jose, CA  95134-1706
-                US
-
-                408-526-5260
-                kzm@cisco.com"
-    DESCRIPTION
-            "The MIB module to describe generic objects for network
-            interface sub-layers.  This MIB is an updated version of
-            MIB-II's ifTable, and incorporates the extensions defined in
-            RFC 1229."
-
-
-    REVISION      "200006140000Z"
-    DESCRIPTION
-            "Clarifications agreed upon by the Interfaces MIB WG, and
-            published as RFC 2863."
-    REVISION      "199602282155Z"
-    DESCRIPTION
-            "Revisions made by the Interfaces MIB WG, and published in
-            RFC 2233."
-    REVISION      "199311082155Z"
-    DESCRIPTION
-            "Initial revision, published as part of RFC 1573."
-    ::= { mib-2 31 }
-
-
-ifMIBObjects OBJECT IDENTIFIER ::= { ifMIB 1 }
-
-interfaces   OBJECT IDENTIFIER ::= { mib-2 2 }
-
---
--- Textual Conventions
---
-
-
--- OwnerString has the same semantics as used in RFC 1271
-
-OwnerString ::= TEXTUAL-CONVENTION
-    DISPLAY-HINT "255a"
-    STATUS       deprecated
-    DESCRIPTION
-            "This data type is used to model an administratively
-            assigned name of the owner of a resource.  This information
-            is taken from the NVT ASCII character set.  It is suggested
-            that this name contain one or more of the following: ASCII
-            form of the manager station's transport address, management
-            station name (e.g., domain name), network management
-            personnel's name, location, or phone number.  In some cases
-            the agent itself will be the owner of an entry.  In these
-            cases, this string shall be set to a string starting with
-            'agent'."
-    SYNTAX       OCTET STRING (SIZE(0..255))
-
--- InterfaceIndex contains the semantics of ifIndex and should be used
--- for any objects defined in other MIB modules that need these semantics.
-
-InterfaceIndex ::= TEXTUAL-CONVENTION
-    DISPLAY-HINT "d"
-    STATUS       current
-    DESCRIPTION
-
-
-            "A unique value, greater than zero, for each interface or
-            interface sub-layer in the managed system.  It is
-            recommended that values are assigned contiguously starting
-            from 1.  The value for each interface sub-layer must remain
-            constant at least from one re-initialization of the entity's
-            network management system to the next re-initialization."
-    SYNTAX       Integer32 (1..2147483647)
-
-InterfaceIndexOrZero ::= TEXTUAL-CONVENTION
-    DISPLAY-HINT "d"
-    STATUS       current
-    DESCRIPTION
-            "This textual convention is an extension of the
-            InterfaceIndex convention.  The latter defines a greater
-            than zero value used to identify an interface or interface
-            sub-layer in the managed system.  This extension permits the
-            additional value of zero.  the value zero is object-specific
-            and must therefore be defined as part of the description of
-            any object which uses this syntax.  Examples of the usage of
-            zero might include situations where interface was unknown,
-            or when none or all interfaces need to be referenced."
-    SYNTAX       Integer32 (0..2147483647)
-
-ifNumber  OBJECT-TYPE
-    SYNTAX      Integer32
-    MAX-ACCESS  read-only
-    STATUS      current
-    DESCRIPTION
-            "The number of network interfaces (regardless of their
-            current state) present on this system."
-    ::= { interfaces 1 }
-
-ifTableLastChange  OBJECT-TYPE
-    SYNTAX      TimeTicks
-    MAX-ACCESS  read-only
-    STATUS      current
-    DESCRIPTION
-            "The value of sysUpTime at the time of the last creation or
-            deletion of an entry in the ifTable.  If the number of
-            entries has been unchanged since the last re-initialization
-            of the local network management subsystem, then this object
-            contains a zero value."
-    ::= { ifMIBObjects 5 }
-
-
--- the Interfaces table
-
--- The Interfaces table contains information on the entity's
-
-
--- interfaces.  Each sub-layer below the internetwork-layer
--- of a network interface is considered to be an interface.
-
-ifTable OBJECT-TYPE
-    SYNTAX      SEQUENCE OF IfEntry
-    MAX-ACCESS  not-accessible
-    STATUS      current
-    DESCRIPTION
-            "A list of interface entries.  The number of entries is
-            given by the value of ifNumber."
-    ::= { interfaces 2 }
-
-ifEntry OBJECT-TYPE
-    SYNTAX      IfEntry
-    MAX-ACCESS  not-accessible
-    STATUS      current
-    DESCRIPTION
-            "An entry containing management information applicable to a
-            particular interface."
-    INDEX   { ifIndex }
-    ::= { ifTable 1 }
-
-IfEntry ::=
-    SEQUENCE {
-        ifIndex                 InterfaceIndex,
-        ifDescr                 DisplayString,
-        ifType                  IANAifType,
-        ifMtu                   Integer32,
-        ifSpeed                 Gauge32,
-        ifPhysAddress           PhysAddress,
-        ifAdminStatus           INTEGER,
-        ifOperStatus            INTEGER,
-        ifLastChange            TimeTicks,
-        ifInOctets              Counter32,
-        ifInUcastPkts           Counter32,
-        ifInNUcastPkts          Counter32,  -- deprecated
-        ifInDiscards            Counter32,
-        ifInErrors              Counter32,
-        ifInUnknownProtos       Counter32,
-        ifOutOctets             Counter32,
-        ifOutUcastPkts          Counter32,
-        ifOutNUcastPkts         Counter32,  -- deprecated
-        ifOutDiscards           Counter32,
-        ifOutErrors             Counter32,
-        ifOutQLen               Gauge32,    -- deprecated
-        ifSpecific              OBJECT IDENTIFIER -- deprecated
-    }
-
-
-
-ifIndex OBJECT-TYPE
-    SYNTAX      InterfaceIndex
-    MAX-ACCESS  read-only
-    STATUS      current
-    DESCRIPTION
-            "A unique value, greater than zero, for each interface.  It
-            is recommended that values are assigned contiguously
-            starting from 1.  The value for each interface sub-layer
-            must remain constant at least from one re-initialization of
-            the entity's network management system to the next re-
-            initialization."
-    ::= { ifEntry 1 }
-
-ifDescr OBJECT-TYPE
-    SYNTAX      DisplayString (SIZE (0..255))
-    MAX-ACCESS  read-only
-    STATUS      current
-    DESCRIPTION
-            "A textual string containing information about the
-            interface.  This string should include the name of the
-            manufacturer, the product name and the version of the
-            interface hardware/software."
-    ::= { ifEntry 2 }
-
-ifType OBJECT-TYPE
-    SYNTAX      IANAifType
-    MAX-ACCESS  read-only
-    STATUS      current
-    DESCRIPTION
-            "The type of interface.  Additional values for ifType are
-            assigned by the Internet Assigned Numbers Authority (IANA),
-            through updating the syntax of the IANAifType textual
-            convention."
-    ::= { ifEntry 3 }
-
-ifMtu OBJECT-TYPE
-    SYNTAX      Integer32
-    MAX-ACCESS  read-only
-    STATUS      current
-    DESCRIPTION
-            "The size of the largest packet which can be sent/received
-            on the interface, specified in octets.  For interfaces that
-            are used for transmitting network datagrams, this is the
-            size of the largest network datagram that can be sent on the
-            interface."
-    ::= { ifEntry 4 }
-
-ifSpeed OBJECT-TYPE
-
-
-    SYNTAX      Gauge32
-    MAX-ACCESS  read-only
-    STATUS      current
-    DESCRIPTION
-            "An estimate of the interface's current bandwidth in bits
-            per second.  For interfaces which do not vary in bandwidth
-            or for those where no accurate estimation can be made, this
-            object should contain the nominal bandwidth.  If the
-            bandwidth of the interface is greater than the maximum value
-            reportable by this object then this object should report its
-            maximum value (4,294,967,295) and ifHighSpeed must be used
-            to report the interace's speed.  For a sub-layer which has
-            no concept of bandwidth, this object should be zero."
-    ::= { ifEntry 5 }
-
-ifPhysAddress OBJECT-TYPE
-    SYNTAX      PhysAddress
-    MAX-ACCESS  read-only
-    STATUS      current
-    DESCRIPTION
-            "The interface's address at its protocol sub-layer.  For
-            example, for an 802.x interface, this object normally
-            contains a MAC address.  The interface's media-specific MIB
-            must define the bit and byte ordering and the format of the
-            value of this object.  For interfaces which do not have such
-            an address (e.g., a serial line), this object should contain
-            an octet string of zero length."
-    ::= { ifEntry 6 }
-
-ifAdminStatus OBJECT-TYPE
-    SYNTAX  INTEGER {
-                up(1),       -- ready to pass packets
-                down(2),
-                testing(3)   -- in some test mode
-            }
-    MAX-ACCESS  read-write
-    STATUS      current
-    DESCRIPTION
-            "The desired state of the interface.  The testing(3) state
-            indicates that no operational packets can be passed.  When a
-            managed system initializes, all interfaces start with
-            ifAdminStatus in the down(2) state.  As a result of either
-            explicit management action or per configuration information
-            retained by the managed system, ifAdminStatus is then
-            changed to either the up(1) or testing(3) states (or remains
-            in the down(2) state)."
-    ::= { ifEntry 7 }
-
-
-
-ifOperStatus OBJECT-TYPE
-    SYNTAX  INTEGER {
-                up(1),        -- ready to pass packets
-                down(2),
-                testing(3),   -- in some test mode
-                unknown(4),   -- status can not be determined
-                              -- for some reason.
-                dormant(5),
-                notPresent(6),    -- some component is missing
-                lowerLayerDown(7) -- down due to state of
-                                  -- lower-layer interface(s)
-            }
-    MAX-ACCESS  read-only
-    STATUS      current
-    DESCRIPTION
-            "The current operational state of the interface.  The
-            testing(3) state indicates that no operational packets can
-            be passed.  If ifAdminStatus is down(2) then ifOperStatus
-            should be down(2).  If ifAdminStatus is changed to up(1)
-            then ifOperStatus should change to up(1) if the interface is
-            ready to transmit and receive network traffic; it should
-            change to dormant(5) if the interface is waiting for
-            external actions (such as a serial line waiting for an
-            incoming connection); it should remain in the down(2) state
-            if and only if there is a fault that prevents it from going
-            to the up(1) state; it should remain in the notPresent(6)
-            state if the interface has missing (typically, hardware)
-            components."
-    ::= { ifEntry 8 }
-
-ifLastChange OBJECT-TYPE
-    SYNTAX      TimeTicks
-    MAX-ACCESS  read-only
-    STATUS      current
-    DESCRIPTION
-            "The value of sysUpTime at the time the interface entered
-            its current operational state.  If the current state was
-            entered prior to the last re-initialization of the local
-            network management subsystem, then this object contains a
-            zero value."
-    ::= { ifEntry 9 }
-
-ifInOctets OBJECT-TYPE
-    SYNTAX      Counter32
-    MAX-ACCESS  read-only
-    STATUS      current
-    DESCRIPTION
-            "The total number of octets received on the interface,
-
-
-            including framing characters.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ifCounterDiscontinuityTime."
-    ::= { ifEntry 10 }
-
-ifInUcastPkts OBJECT-TYPE
-    SYNTAX      Counter32
-    MAX-ACCESS  read-only
-    STATUS      current
-    DESCRIPTION
-            "The number of packets, delivered by this sub-layer to a
-            higher (sub-)layer, which were not addressed to a multicast
-            or broadcast address at this sub-layer.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ifCounterDiscontinuityTime."
-    ::= { ifEntry 11 }
-
-ifInNUcastPkts OBJECT-TYPE
-    SYNTAX  Counter32
-    MAX-ACCESS  read-only
-    STATUS      deprecated
-    DESCRIPTION
-            "The number of packets, delivered by this sub-layer to a
-            higher (sub-)layer, which were addressed to a multicast or
-            broadcast address at this sub-layer.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ifCounterDiscontinuityTime.
-
-            This object is deprecated in favour of ifInMulticastPkts and
-            ifInBroadcastPkts."
-    ::= { ifEntry 12 }
-
-ifInDiscards OBJECT-TYPE
-    SYNTAX      Counter32
-    MAX-ACCESS  read-only
-    STATUS      current
-    DESCRIPTION
-            "The number of inbound packets which were chosen to be
-            discarded even though no errors had been detected to prevent
-
-
-            their being deliverable to a higher-layer protocol.  One
-            possible reason for discarding such a packet could be to
-            free up buffer space.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ifCounterDiscontinuityTime."
-    ::= { ifEntry 13 }
-
-ifInErrors OBJECT-TYPE
-    SYNTAX      Counter32
-    MAX-ACCESS  read-only
-    STATUS      current
-    DESCRIPTION
-            "For packet-oriented interfaces, the number of inbound
-            packets that contained errors preventing them from being
-            deliverable to a higher-layer protocol.  For character-
-            oriented or fixed-length interfaces, the number of inbound
-            transmission units that contained errors preventing them
-            from being deliverable to a higher-layer protocol.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ifCounterDiscontinuityTime."
-    ::= { ifEntry 14 }
-
-ifInUnknownProtos OBJECT-TYPE
-    SYNTAX      Counter32
-    MAX-ACCESS  read-only
-    STATUS      current
-    DESCRIPTION
-            "For packet-oriented interfaces, the number of packets
-            received via the interface which were discarded because of
-            an unknown or unsupported protocol.  For character-oriented
-            or fixed-length interfaces that support protocol
-            multiplexing the number of transmission units received via
-            the interface which were discarded because of an unknown or
-            unsupported protocol.  For any interface that does not
-            support protocol multiplexing, this counter will always be
-            0.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ifCounterDiscontinuityTime."
-    ::= { ifEntry 15 }
-
-
-ifOutOctets OBJECT-TYPE
-    SYNTAX      Counter32
-    MAX-ACCESS  read-only
-    STATUS      current
-    DESCRIPTION
-            "The total number of octets transmitted out of the
-            interface, including framing characters.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ifCounterDiscontinuityTime."
-    ::= { ifEntry 16 }
-
-ifOutUcastPkts OBJECT-TYPE
-    SYNTAX      Counter32
-    MAX-ACCESS  read-only
-    STATUS      current
-    DESCRIPTION
-            "The total number of packets that higher-level protocols
-            requested be transmitted, and which were not addressed to a
-            multicast or broadcast address at this sub-layer, including
-            those that were discarded or not sent.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ifCounterDiscontinuityTime."
-    ::= { ifEntry 17 }
-
-ifOutNUcastPkts OBJECT-TYPE
-    SYNTAX      Counter32
-    MAX-ACCESS  read-only
-    STATUS      deprecated
-    DESCRIPTION
-            "The total number of packets that higher-level protocols
-            requested be transmitted, and which were addressed to a
-            multicast or broadcast address at this sub-layer, including
-            those that were discarded or not sent.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ifCounterDiscontinuityTime.
-
-            This object is deprecated in favour of ifOutMulticastPkts
-            and ifOutBroadcastPkts."
-    ::= { ifEntry 18 }
-
-
-ifOutDiscards OBJECT-TYPE
-    SYNTAX      Counter32
-    MAX-ACCESS  read-only
-    STATUS      current
-    DESCRIPTION
-            "The number of outbound packets which were chosen to be
-            discarded even though no errors had been detected to prevent
-            their being transmitted.  One possible reason for discarding
-            such a packet could be to free up buffer space.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ifCounterDiscontinuityTime."
-    ::= { ifEntry 19 }
-
-ifOutErrors OBJECT-TYPE
-    SYNTAX      Counter32
-    MAX-ACCESS  read-only
-    STATUS      current
-    DESCRIPTION
-            "For packet-oriented interfaces, the number of outbound
-            packets that could not be transmitted because of errors.
-            For character-oriented or fixed-length interfaces, the
-            number of outbound transmission units that could not be
-            transmitted because of errors.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ifCounterDiscontinuityTime."
-    ::= { ifEntry 20 }
-
-ifOutQLen OBJECT-TYPE
-    SYNTAX      Gauge32
-    MAX-ACCESS  read-only
-    STATUS      deprecated
-    DESCRIPTION
-            "The length of the output packet queue (in packets)."
-    ::= { ifEntry 21 }
-
-ifSpecific OBJECT-TYPE
-    SYNTAX      OBJECT IDENTIFIER
-    MAX-ACCESS  read-only
-    STATUS      deprecated
-    DESCRIPTION
-            "A reference to MIB definitions specific to the particular
-            media being used to realize the interface.  It is
-
-
-            recommended that this value point to an instance of a MIB
-            object in the media-specific MIB, i.e., that this object
-            have the semantics associated with the InstancePointer
-            textual convention defined in RFC 2579.  In fact, it is
-            recommended that the media-specific MIB specify what value
-            ifSpecific should/can take for values of ifType.  If no MIB
-            definitions specific to the particular media are available,
-            the value should be set to the OBJECT IDENTIFIER { 0 0 }."
-    ::= { ifEntry 22 }
-
-
-
---
---   Extension to the interface table
---
--- This table replaces the ifExtnsTable table.
---
-
-ifXTable        OBJECT-TYPE
-    SYNTAX      SEQUENCE OF IfXEntry
-    MAX-ACCESS  not-accessible
-    STATUS      current
-    DESCRIPTION
-            "A list of interface entries.  The number of entries is
-            given by the value of ifNumber.  This table contains
-            additional objects for the interface table."
-    ::= { ifMIBObjects 1 }
-
-ifXEntry        OBJECT-TYPE
-    SYNTAX      IfXEntry
-    MAX-ACCESS  not-accessible
-    STATUS      current
-    DESCRIPTION
-            "An entry containing additional management information
-            applicable to a particular interface."
-    AUGMENTS    { ifEntry }
-    ::= { ifXTable 1 }
-
-IfXEntry ::=
-    SEQUENCE {
-        ifName                  DisplayString,
-        ifInMulticastPkts       Counter32,
-        ifInBroadcastPkts       Counter32,
-        ifOutMulticastPkts      Counter32,
-        ifOutBroadcastPkts      Counter32,
-        ifHCInOctets            Counter64,
-        ifHCInUcastPkts         Counter64,
-        ifHCInMulticastPkts     Counter64,
-
-
-        ifHCInBroadcastPkts     Counter64,
-        ifHCOutOctets           Counter64,
-        ifHCOutUcastPkts        Counter64,
-        ifHCOutMulticastPkts    Counter64,
-        ifHCOutBroadcastPkts    Counter64,
-        ifLinkUpDownTrapEnable  INTEGER,
-        ifHighSpeed             Gauge32,
-        ifPromiscuousMode       TruthValue,
-        ifConnectorPresent      TruthValue,
-        ifAlias                 DisplayString,
-        ifCounterDiscontinuityTime TimeStamp
-    }
-
-
-ifName OBJECT-TYPE
-    SYNTAX      DisplayString
-    MAX-ACCESS  read-only
-    STATUS      current
-    DESCRIPTION
-            "The textual name of the interface.  The value of this
-            object should be the name of the interface as assigned by
-            the local device and should be suitable for use in commands
-            entered at the device's `console'.  This might be a text
-            name, such as `le0' or a simple port number, such as `1',
-            depending on the interface naming syntax of the device.  If
-            several entries in the ifTable together represent a single
-            interface as named by the device, then each will have the
-            same value of ifName.  Note that for an agent which responds
-            to SNMP queries concerning an interface on some other
-            (proxied) device, then the value of ifName for such an
-            interface is the proxied device's local name for it.
-
-            If there is no local name, or this object is otherwise not
-            applicable, then this object contains a zero-length string."
-    ::= { ifXEntry 1 }
-
-ifInMulticastPkts OBJECT-TYPE
-    SYNTAX      Counter32
-    MAX-ACCESS  read-only
-    STATUS      current
-    DESCRIPTION
-            "The number of packets, delivered by this sub-layer to a
-            higher (sub-)layer, which were addressed to a multicast
-            address at this sub-layer.  For a MAC layer protocol, this
-            includes both Group and Functional addresses.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-
-
-            times as indicated by the value of
-            ifCounterDiscontinuityTime."
-    ::= { ifXEntry 2 }
-
-ifInBroadcastPkts OBJECT-TYPE
-    SYNTAX      Counter32
-    MAX-ACCESS  read-only
-    STATUS      current
-    DESCRIPTION
-            "The number of packets, delivered by this sub-layer to a
-            higher (sub-)layer, which were addressed to a broadcast
-            address at this sub-layer.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ifCounterDiscontinuityTime."
-    ::= { ifXEntry 3 }
-
-ifOutMulticastPkts OBJECT-TYPE
-    SYNTAX      Counter32
-    MAX-ACCESS  read-only
-    STATUS      current
-    DESCRIPTION
-            "The total number of packets that higher-level protocols
-            requested be transmitted, and which were addressed to a
-            multicast address at this sub-layer, including those that
-            were discarded or not sent.  For a MAC layer protocol, this
-            includes both Group and Functional addresses.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ifCounterDiscontinuityTime."
-    ::= { ifXEntry 4 }
-
-ifOutBroadcastPkts OBJECT-TYPE
-    SYNTAX      Counter32
-    MAX-ACCESS  read-only
-    STATUS      current
-    DESCRIPTION
-            "The total number of packets that higher-level protocols
-            requested be transmitted, and which were addressed to a
-            broadcast address at this sub-layer, including those that
-            were discarded or not sent.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-
-
-            times as indicated by the value of
-            ifCounterDiscontinuityTime."
-    ::= { ifXEntry 5 }
-
---
--- High Capacity Counter objects.  These objects are all
--- 64 bit versions of the "basic" ifTable counters.  These
--- objects all have the same basic semantics as their 32-bit
--- counterparts, however, their syntax has been extended
--- to 64 bits.
---
-
-ifHCInOctets OBJECT-TYPE
-    SYNTAX      Counter64
-    MAX-ACCESS  read-only
-    STATUS      current
-    DESCRIPTION
-            "The total number of octets received on the interface,
-            including framing characters.  This object is a 64-bit
-            version of ifInOctets.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ifCounterDiscontinuityTime."
-    ::= { ifXEntry 6 }
-
-ifHCInUcastPkts OBJECT-TYPE
-    SYNTAX      Counter64
-    MAX-ACCESS  read-only
-    STATUS      current
-    DESCRIPTION
-            "The number of packets, delivered by this sub-layer to a
-            higher (sub-)layer, which were not addressed to a multicast
-            or broadcast address at this sub-layer.  This object is a
-            64-bit version of ifInUcastPkts.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ifCounterDiscontinuityTime."
-    ::= { ifXEntry 7 }
-
-ifHCInMulticastPkts OBJECT-TYPE
-    SYNTAX      Counter64
-    MAX-ACCESS  read-only
-    STATUS      current
-    DESCRIPTION
-
-
-            "The number of packets, delivered by this sub-layer to a
-            higher (sub-)layer, which were addressed to a multicast
-            address at this sub-layer.  For a MAC layer protocol, this
-            includes both Group and Functional addresses.  This object
-            is a 64-bit version of ifInMulticastPkts.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ifCounterDiscontinuityTime."
-    ::= { ifXEntry 8 }
-
-ifHCInBroadcastPkts OBJECT-TYPE
-    SYNTAX      Counter64
-    MAX-ACCESS  read-only
-    STATUS      current
-    DESCRIPTION
-            "The number of packets, delivered by this sub-layer to a
-            higher (sub-)layer, which were addressed to a broadcast
-            address at this sub-layer.  This object is a 64-bit version
-            of ifInBroadcastPkts.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ifCounterDiscontinuityTime."
-    ::= { ifXEntry 9 }
-
-ifHCOutOctets OBJECT-TYPE
-    SYNTAX      Counter64
-    MAX-ACCESS  read-only
-    STATUS      current
-    DESCRIPTION
-            "The total number of octets transmitted out of the
-            interface, including framing characters.  This object is a
-            64-bit version of ifOutOctets.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ifCounterDiscontinuityTime."
-    ::= { ifXEntry 10 }
-
-ifHCOutUcastPkts OBJECT-TYPE
-    SYNTAX      Counter64
-    MAX-ACCESS  read-only
-    STATUS      current
-    DESCRIPTION
-
-
-            "The total number of packets that higher-level protocols
-            requested be transmitted, and which were not addressed to a
-            multicast or broadcast address at this sub-layer, including
-            those that were discarded or not sent.  This object is a
-            64-bit version of ifOutUcastPkts.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ifCounterDiscontinuityTime."
-    ::= { ifXEntry 11 }
-
-ifHCOutMulticastPkts OBJECT-TYPE
-    SYNTAX      Counter64
-    MAX-ACCESS  read-only
-    STATUS      current
-    DESCRIPTION
-            "The total number of packets that higher-level protocols
-            requested be transmitted, and which were addressed to a
-            multicast address at this sub-layer, including those that
-            were discarded or not sent.  For a MAC layer protocol, this
-            includes both Group and Functional addresses.  This object
-            is a 64-bit version of ifOutMulticastPkts.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ifCounterDiscontinuityTime."
-    ::= { ifXEntry 12 }
-
-ifHCOutBroadcastPkts OBJECT-TYPE
-    SYNTAX      Counter64
-    MAX-ACCESS  read-only
-    STATUS      current
-    DESCRIPTION
-            "The total number of packets that higher-level protocols
-            requested be transmitted, and which were addressed to a
-            broadcast address at this sub-layer, including those that
-            were discarded or not sent.  This object is a 64-bit version
-            of ifOutBroadcastPkts.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ifCounterDiscontinuityTime."
-    ::= { ifXEntry 13 }
-
-ifLinkUpDownTrapEnable  OBJECT-TYPE
-
-
-    SYNTAX      INTEGER { enabled(1), disabled(2) }
-    MAX-ACCESS  read-write
-    STATUS      current
-    DESCRIPTION
-            "Indicates whether linkUp/linkDown traps should be generated
-            for this interface.
-
-            By default, this object should have the value enabled(1) for
-            interfaces which do not operate on 'top' of any other
-            interface (as defined in the ifStackTable), and disabled(2)
-            otherwise."
-    ::= { ifXEntry 14 }
-
-ifHighSpeed OBJECT-TYPE
-    SYNTAX      Gauge32
-    MAX-ACCESS  read-only
-    STATUS      current
-    DESCRIPTION
-            "An estimate of the interface's current bandwidth in units
-            of 1,000,000 bits per second.  If this object reports a
-            value of `n' then the speed of the interface is somewhere in
-            the range of `n-500,000' to `n+499,999'.  For interfaces
-            which do not vary in bandwidth or for those where no
-            accurate estimation can be made, this object should contain
-            the nominal bandwidth.  For a sub-layer which has no concept
-            of bandwidth, this object should be zero."
-    ::= { ifXEntry 15 }
-
-ifPromiscuousMode  OBJECT-TYPE
-    SYNTAX      TruthValue
-    MAX-ACCESS  read-write
-    STATUS      current
-    DESCRIPTION
-            "This object has a value of false(2) if this interface only
-            accepts packets/frames that are addressed to this station.
-            This object has a value of true(1) when the station accepts
-            all packets/frames transmitted on the media.  The value
-            true(1) is only legal on certain types of media.  If legal,
-            setting this object to a value of true(1) may require the
-            interface to be reset before becoming effective.
-
-            The value of ifPromiscuousMode does not affect the reception
-            of broadcast and multicast packets/frames by the interface."
-    ::= { ifXEntry 16 }
-
-ifConnectorPresent   OBJECT-TYPE
-    SYNTAX      TruthValue
-    MAX-ACCESS  read-only
-
-
-    STATUS      current
-    DESCRIPTION
-            "This object has the value 'true(1)' if the interface
-            sublayer has a physical connector and the value 'false(2)'
-            otherwise."
-    ::= { ifXEntry 17 }
-
-ifAlias   OBJECT-TYPE
-    SYNTAX      DisplayString (SIZE(0..64))
-    MAX-ACCESS  read-write
-    STATUS      current
-    DESCRIPTION
-            "This object is an 'alias' name for the interface as
-            specified by a network manager, and provides a non-volatile
-            'handle' for the interface.
-
-            On the first instantiation of an interface, the value of
-            ifAlias associated with that interface is the zero-length
-            string.  As and when a value is written into an instance of
-            ifAlias through a network management set operation, then the
-            agent must retain the supplied value in the ifAlias instance
-            associated with the same interface for as long as that
-            interface remains instantiated, including across all re-
-            initializations/reboots of the network management system,
-            including those which result in a change of the interface's
-            ifIndex value.
-
-            An example of the value which a network manager might store
-            in this object for a WAN interface is the (Telco's) circuit
-            number/identifier of the interface.
-
-            Some agents may support write-access only for interfaces
-            having particular values of ifType.  An agent which supports
-            write access to this object is required to keep the value in
-            non-volatile storage, but it may limit the length of new
-            values depending on how much storage is already occupied by
-            the current values for other interfaces."
-    ::= { ifXEntry 18 }
-
-ifCounterDiscontinuityTime OBJECT-TYPE
-    SYNTAX      TimeStamp
-    MAX-ACCESS  read-only
-    STATUS      current
-    DESCRIPTION
-            "The value of sysUpTime on the most recent occasion at which
-            any one or more of this interface's counters suffered a
-            discontinuity.  The relevant counters are the specific
-            instances associated with this interface of any Counter32 or
-
-
-            Counter64 object contained in the ifTable or ifXTable.  If
-            no such discontinuities have occurred since the last re-
-            initialization of the local management subsystem, then this
-            object contains a zero value."
-    ::= { ifXEntry 19 }
-
---           The Interface Stack Group
---
--- Implementation of this group is optional, but strongly recommended
--- for all systems
---
-
-ifStackTable  OBJECT-TYPE
-     SYNTAX        SEQUENCE OF IfStackEntry
-     MAX-ACCESS    not-accessible
-     STATUS        current
-     DESCRIPTION
-            "The table containing information on the relationships
-            between the multiple sub-layers of network interfaces.  In
-            particular, it contains information on which sub-layers run
-            'on top of' which other sub-layers, where each sub-layer
-            corresponds to a conceptual row in the ifTable.  For
-            example, when the sub-layer with ifIndex value x runs over
-            the sub-layer with ifIndex value y, then this table
-            contains:
-
-              ifStackStatus.x.y=active
-
-            For each ifIndex value, I, which identifies an active
-            interface, there are always at least two instantiated rows
-            in this table associated with I.  For one of these rows, I
-            is the value of ifStackHigherLayer; for the other, I is the
-            value of ifStackLowerLayer.  (If I is not involved in
-            multiplexing, then these are the only two rows associated
-            with I.)
-
-            For example, two rows exist even for an interface which has
-            no others stacked on top or below it:
-
-              ifStackStatus.0.x=active
-              ifStackStatus.x.0=active "
-     ::= { ifMIBObjects 2 }
-
-
-ifStackEntry  OBJECT-TYPE
-     SYNTAX        IfStackEntry
-     MAX-ACCESS    not-accessible
-     STATUS        current
-
-
-     DESCRIPTION
-            "Information on a particular relationship between two sub-
-            layers, specifying that one sub-layer runs on 'top' of the
-            other sub-layer.  Each sub-layer corresponds to a conceptual
-            row in the ifTable."
-     INDEX { ifStackHigherLayer, ifStackLowerLayer }
-     ::= { ifStackTable 1 }
-
-
-IfStackEntry ::=
-    SEQUENCE {
-        ifStackHigherLayer  InterfaceIndexOrZero,
-        ifStackLowerLayer   InterfaceIndexOrZero,
-        ifStackStatus       RowStatus
-     }
-
-
-ifStackHigherLayer  OBJECT-TYPE
-     SYNTAX        InterfaceIndexOrZero
-     MAX-ACCESS    not-accessible
-     STATUS        current
-     DESCRIPTION
-            "The value of ifIndex corresponding to the higher sub-layer
-            of the relationship, i.e., the sub-layer which runs on 'top'
-            of the sub-layer identified by the corresponding instance of
-            ifStackLowerLayer.  If there is no higher sub-layer (below
-            the internetwork layer), then this object has the value 0."
-     ::= { ifStackEntry 1 }
-
-
-ifStackLowerLayer  OBJECT-TYPE
-     SYNTAX        InterfaceIndexOrZero
-     MAX-ACCESS    not-accessible
-     STATUS        current
-     DESCRIPTION
-            "The value of ifIndex corresponding to the lower sub-layer
-            of the relationship, i.e., the sub-layer which runs 'below'
-            the sub-layer identified by the corresponding instance of
-            ifStackHigherLayer.  If there is no lower sub-layer, then
-            this object has the value 0."
-     ::= { ifStackEntry 2 }
-
-
-ifStackStatus  OBJECT-TYPE
-    SYNTAX         RowStatus
-    MAX-ACCESS     read-create
-    STATUS         current
-    DESCRIPTION
-
-
-            "The status of the relationship between two sub-layers.
-
-            Changing the value of this object from 'active' to
-            'notInService' or 'destroy' will likely have consequences up
-            and down the interface stack.  Thus, write access to this
-            object is likely to be inappropriate for some types of
-            interfaces, and many implementations will choose not to
-            support write-access for any type of interface."
-    ::= { ifStackEntry 3 }
-
-ifStackLastChange OBJECT-TYPE
-    SYNTAX         TimeTicks
-    MAX-ACCESS     read-only
-    STATUS         current
-    DESCRIPTION
-            "The value of sysUpTime at the time of the last change of
-            the (whole) interface stack.  A change of the interface
-            stack is defined to be any creation, deletion, or change in
-            value of any instance of ifStackStatus.  If the interface
-            stack has been unchanged since the last re-initialization of
-            the local network management subsystem, then this object
-            contains a zero value."
-    ::= { ifMIBObjects 6 }
-
-
---   Generic Receive Address Table
---
--- This group of objects is mandatory for all types of
--- interfaces which can receive packets/frames addressed to
--- more than one address.
---
--- This table replaces the ifExtnsRcvAddr table.  The main
--- difference is that this table makes use of the RowStatus
--- textual convention, while ifExtnsRcvAddr did not.
-
-ifRcvAddressTable  OBJECT-TYPE
-    SYNTAX      SEQUENCE OF IfRcvAddressEntry
-    MAX-ACCESS  not-accessible
-    STATUS      current
-    DESCRIPTION
-            "This table contains an entry for each address (broadcast,
-            multicast, or uni-cast) for which the system will receive
-            packets/frames on a particular interface, except as follows:
-
-            - for an interface operating in promiscuous mode, entries
-            are only required for those addresses for which the system
-            would receive frames were it not operating in promiscuous
-            mode.
-
-
-            - for 802.5 functional addresses, only one entry is
-            required, for the address which has the functional address
-            bit ANDed with the bit mask of all functional addresses for
-            which the interface will accept frames.
-
-            A system is normally able to use any unicast address which
-            corresponds to an entry in this table as a source address."
-    ::= { ifMIBObjects 4 }
-
-ifRcvAddressEntry  OBJECT-TYPE
-    SYNTAX      IfRcvAddressEntry
-    MAX-ACCESS  not-accessible
-    STATUS      current
-    DESCRIPTION
-            "A list of objects identifying an address for which the
-            system will accept packets/frames on the particular
-            interface identified by the index value ifIndex."
-    INDEX  { ifIndex, ifRcvAddressAddress }
-    ::= { ifRcvAddressTable 1 }
-
-IfRcvAddressEntry ::=
-    SEQUENCE {
-        ifRcvAddressAddress   PhysAddress,
-        ifRcvAddressStatus    RowStatus,
-        ifRcvAddressType      INTEGER
-    }
-
-ifRcvAddressAddress OBJECT-TYPE
-    SYNTAX      PhysAddress
-    MAX-ACCESS  not-accessible
-    STATUS      current
-    DESCRIPTION
-            "An address for which the system will accept packets/frames
-            on this entry's interface."
-    ::= { ifRcvAddressEntry 1 }
-
-ifRcvAddressStatus OBJECT-TYPE
-    SYNTAX      RowStatus
-    MAX-ACCESS  read-create
-    STATUS      current
-    DESCRIPTION
-            "This object is used to create and delete rows in the
-            ifRcvAddressTable."
-
-    ::= { ifRcvAddressEntry 2 }
-
-ifRcvAddressType OBJECT-TYPE
-    SYNTAX      INTEGER {
-
-
-                    other(1),
-                    volatile(2),
-                    nonVolatile(3)
-                }
-
-    MAX-ACCESS  read-create
-    STATUS      current
-    DESCRIPTION
-            "This object has the value nonVolatile(3) for those entries
-            in the table which are valid and will not be deleted by the
-            next restart of the managed system.  Entries having the
-            value volatile(2) are valid and exist, but have not been
-            saved, so that will not exist after the next restart of the
-            managed system.  Entries having the value other(1) are valid
-            and exist but are not classified as to whether they will
-            continue to exist after the next restart."
-
-    DEFVAL  { volatile }
-    ::= { ifRcvAddressEntry 3 }
-
--- definition of interface-related traps.
-
-linkDown NOTIFICATION-TYPE
-    OBJECTS { ifIndex, ifAdminStatus, ifOperStatus }
-    STATUS  current
-    DESCRIPTION
-            "A linkDown trap signifies that the SNMP entity, acting in
-            an agent role, has detected that the ifOperStatus object for
-            one of its communication links is about to enter the down
-            state from some other state (but not from the notPresent
-            state).  This other state is indicated by the included value
-            of ifOperStatus."
-    ::= { snmpTraps 3 }
-
-linkUp NOTIFICATION-TYPE
-    OBJECTS { ifIndex, ifAdminStatus, ifOperStatus }
-    STATUS  current
-    DESCRIPTION
-            "A linkUp trap signifies that the SNMP entity, acting in an
-            agent role, has detected that the ifOperStatus object for
-            one of its communication links left the down state and
-            transitioned into some other state (but not into the
-            notPresent state).  This other state is indicated by the
-            included value of ifOperStatus."
-    ::= { snmpTraps 4 }
-
--- conformance information
-
-
-
-ifConformance OBJECT IDENTIFIER ::= { ifMIB 2 }
-
-ifGroups      OBJECT IDENTIFIER ::= { ifConformance 1 }
-ifCompliances OBJECT IDENTIFIER ::= { ifConformance 2 }
-
-
--- compliance statements
-
-ifCompliance3 MODULE-COMPLIANCE
-    STATUS  current
-    DESCRIPTION
-            "The compliance statement for SNMP entities which have
-            network interfaces."
-
-    MODULE  -- this module
-        MANDATORY-GROUPS { ifGeneralInformationGroup,
-                           linkUpDownNotificationsGroup }
-
--- The groups:
---        ifFixedLengthGroup
---        ifHCFixedLengthGroup
---        ifPacketGroup
---        ifHCPacketGroup
---        ifVHCPacketGroup
--- are mutually exclusive; at most one of these groups is implemented
--- for a particular interface.  When any of these groups is implemented
--- for a particular interface, then ifCounterDiscontinuityGroup must
--- also be implemented for that interface.
-
-
-        GROUP       ifFixedLengthGroup
-        DESCRIPTION
-            "This group is mandatory for those network interfaces which
-            are character-oriented or transmit data in fixed-length
-            transmission units, and for which the value of the
-            corresponding instance of ifSpeed is less than or equal to
-            20,000,000 bits/second."
-
-        GROUP       ifHCFixedLengthGroup
-        DESCRIPTION
-            "This group is mandatory for those network interfaces which
-            are character-oriented or transmit data in fixed-length
-            transmission units, and for which the value of the
-            corresponding instance of ifSpeed is greater than 20,000,000
-            bits/second."
-
-        GROUP       ifPacketGroup
-        DESCRIPTION
-
-
-            "This group is mandatory for those network interfaces which
-            are packet-oriented, and for which the value of the
-            corresponding instance of ifSpeed is less than or equal to
-            20,000,000 bits/second."
-
-        GROUP       ifHCPacketGroup
-        DESCRIPTION
-            "This group is mandatory only for those network interfaces
-            which are packet-oriented and for which the value of the
-            corresponding instance of ifSpeed is greater than 20,000,000
-            bits/second but less than or equal to 650,000,000
-            bits/second."
-
-        GROUP       ifVHCPacketGroup
-        DESCRIPTION
-            "This group is mandatory only for those network interfaces
-            which are packet-oriented and for which the value of the
-            corresponding instance of ifSpeed is greater than
-            650,000,000 bits/second."
-
-
-        GROUP       ifCounterDiscontinuityGroup
-        DESCRIPTION
-            "This group is mandatory for those network interfaces that
-            are required to maintain counters (i.e., those for which one
-            of the ifFixedLengthGroup, ifHCFixedLengthGroup,
-            ifPacketGroup, ifHCPacketGroup, or ifVHCPacketGroup is
-            mandatory)."
-
-
-        GROUP       ifRcvAddressGroup
-        DESCRIPTION
-            "The applicability of this group MUST be defined by the
-            media-specific MIBs.  Media-specific MIBs must define the
-            exact meaning, use, and semantics of the addresses in this
-            group."
-
-        OBJECT      ifLinkUpDownTrapEnable
-        MIN-ACCESS  read-only
-        DESCRIPTION
-            "Write access is not required."
-
-        OBJECT      ifPromiscuousMode
-        MIN-ACCESS  read-only
-        DESCRIPTION
-            "Write access is not required."
-
-        OBJECT       ifAdminStatus
-
-
-        SYNTAX       INTEGER { up(1), down(2) }
-        MIN-ACCESS   read-only
-        DESCRIPTION
-            "Write access is not required, nor is support for the value
-            testing(3)."
-
-        OBJECT       ifAlias
-        MIN-ACCESS   read-only
-        DESCRIPTION
-            "Write access is not required."
-
-    ::= { ifCompliances 3 }
-
--- units of conformance
-
-ifGeneralInformationGroup    OBJECT-GROUP
-    OBJECTS { ifIndex, ifDescr, ifType, ifSpeed, ifPhysAddress,
-              ifAdminStatus, ifOperStatus, ifLastChange,
-              ifLinkUpDownTrapEnable, ifConnectorPresent,
-              ifHighSpeed, ifName, ifNumber, ifAlias,
-              ifTableLastChange }
-    STATUS  current
-    DESCRIPTION
-            "A collection of objects providing information applicable to
-            all network interfaces."
-    ::= { ifGroups 10 }
-
--- the following five groups are mutually exclusive; at most
--- one of these groups is implemented for any interface
-
-ifFixedLengthGroup    OBJECT-GROUP
-    OBJECTS { ifInOctets, ifOutOctets, ifInUnknownProtos,
-              ifInErrors, ifOutErrors }
-    STATUS  current
-    DESCRIPTION
-            "A collection of objects providing information specific to
-            non-high speed (non-high speed interfaces transmit and
-            receive at speeds less than or equal to 20,000,000
-            bits/second) character-oriented or fixed-length-transmission
-            network interfaces."
-    ::= { ifGroups 2 }
-
-ifHCFixedLengthGroup    OBJECT-GROUP
-    OBJECTS { ifHCInOctets, ifHCOutOctets,
-              ifInOctets, ifOutOctets, ifInUnknownProtos,
-              ifInErrors, ifOutErrors }
-    STATUS  current
-    DESCRIPTION
-
-
-            "A collection of objects providing information specific to
-            high speed (greater than 20,000,000 bits/second) character-
-            oriented or fixed-length-transmission network interfaces."
-    ::= { ifGroups 3 }
-
-ifPacketGroup    OBJECT-GROUP
-    OBJECTS { ifInOctets, ifOutOctets, ifInUnknownProtos,
-              ifInErrors, ifOutErrors,
-              ifMtu, ifInUcastPkts, ifInMulticastPkts,
-              ifInBroadcastPkts, ifInDiscards,
-              ifOutUcastPkts, ifOutMulticastPkts,
-              ifOutBroadcastPkts, ifOutDiscards,
-              ifPromiscuousMode }
-    STATUS  current
-    DESCRIPTION
-            "A collection of objects providing information specific to
-            non-high speed (non-high speed interfaces transmit and
-            receive at speeds less than or equal to 20,000,000
-            bits/second) packet-oriented network interfaces."
-    ::= { ifGroups 4 }
-
-ifHCPacketGroup    OBJECT-GROUP
-    OBJECTS { ifHCInOctets, ifHCOutOctets,
-              ifInOctets, ifOutOctets, ifInUnknownProtos,
-              ifInErrors, ifOutErrors,
-              ifMtu, ifInUcastPkts, ifInMulticastPkts,
-              ifInBroadcastPkts, ifInDiscards,
-              ifOutUcastPkts, ifOutMulticastPkts,
-              ifOutBroadcastPkts, ifOutDiscards,
-              ifPromiscuousMode }
-    STATUS  current
-    DESCRIPTION
-            "A collection of objects providing information specific to
-            high speed (greater than 20,000,000 bits/second but less
-            than or equal to 650,000,000 bits/second) packet-oriented
-            network interfaces."
-    ::= { ifGroups 5 }
-
-ifVHCPacketGroup    OBJECT-GROUP
-    OBJECTS { ifHCInUcastPkts, ifHCInMulticastPkts,
-              ifHCInBroadcastPkts, ifHCOutUcastPkts,
-              ifHCOutMulticastPkts, ifHCOutBroadcastPkts,
-              ifHCInOctets, ifHCOutOctets,
-              ifInOctets, ifOutOctets, ifInUnknownProtos,
-              ifInErrors, ifOutErrors,
-              ifMtu, ifInUcastPkts, ifInMulticastPkts,
-              ifInBroadcastPkts, ifInDiscards,
-              ifOutUcastPkts, ifOutMulticastPkts,
-
-
-              ifOutBroadcastPkts, ifOutDiscards,
-              ifPromiscuousMode }
-    STATUS  current
-    DESCRIPTION
-            "A collection of objects providing information specific to
-            higher speed (greater than 650,000,000 bits/second) packet-
-            oriented network interfaces."
-    ::= { ifGroups 6 }
-
-ifRcvAddressGroup    OBJECT-GROUP
-    OBJECTS { ifRcvAddressStatus, ifRcvAddressType }
-    STATUS  current
-    DESCRIPTION
-            "A collection of objects providing information on the
-            multiple addresses which an interface receives."
-    ::= { ifGroups 7 }
-
-ifStackGroup2    OBJECT-GROUP
-    OBJECTS { ifStackStatus, ifStackLastChange }
-    STATUS  current
-    DESCRIPTION
-            "A collection of objects providing information on the
-            layering of MIB-II interfaces."
-    ::= { ifGroups 11 }
-
-ifCounterDiscontinuityGroup  OBJECT-GROUP
-    OBJECTS { ifCounterDiscontinuityTime }
-    STATUS  current
-    DESCRIPTION
-            "A collection of objects providing information specific to
-            interface counter discontinuities."
-    ::= { ifGroups 13 }
-
-linkUpDownNotificationsGroup  NOTIFICATION-GROUP
-    NOTIFICATIONS { linkUp, linkDown }
-    STATUS  current
-    DESCRIPTION
-            "The notifications which indicate specific changes in the
-            value of ifOperStatus."
-    ::= { ifGroups 14 }
-
--- Deprecated Definitions - Objects
-
-
---
---    The Interface Test Table
---
--- This group of objects is optional.  However, a media-specific
-
-
--- MIB may make implementation of this group mandatory.
---
--- This table replaces the ifExtnsTestTable
---
-
-ifTestTable   OBJECT-TYPE
-    SYNTAX      SEQUENCE OF IfTestEntry
-    MAX-ACCESS  not-accessible
-    STATUS      deprecated
-    DESCRIPTION
-            "This table contains one entry per interface.  It defines
-            objects which allow a network manager to instruct an agent
-            to test an interface for various faults.  Tests for an
-            interface are defined in the media-specific MIB for that
-            interface.  After invoking a test, the object ifTestResult
-            can be read to determine the outcome.  If an agent can not
-            perform the test, ifTestResult is set to so indicate.  The
-            object ifTestCode can be used to provide further test-
-            specific or interface-specific (or even enterprise-specific)
-            information concerning the outcome of the test.  Only one
-            test can be in progress on each interface at any one time.
-            If one test is in progress when another test is invoked, the
-            second test is rejected.  Some agents may reject a test when
-            a prior test is active on another interface.
-
-            Before starting a test, a manager-station must first obtain
-            'ownership' of the entry in the ifTestTable for the
-            interface to be tested.  This is accomplished with the
-            ifTestId and ifTestStatus objects as follows:
-
-          try_again:
-              get (ifTestId, ifTestStatus)
-              while (ifTestStatus != notInUse)
-                  /*
-                   * Loop while a test is running or some other
-                   * manager is configuring a test.
-                   */
-                  short delay
-                  get (ifTestId, ifTestStatus)
-              }
-
-              /*
-               * Is not being used right now -- let's compete
-               * to see who gets it.
-               */
-              lock_value = ifTestId
-
-              if ( set(ifTestId = lock_value, ifTestStatus = inUse,
-
-
-                       ifTestOwner = 'my-IP-address') == FAILURE)
-                  /*
-                   * Another manager got the ifTestEntry -- go
-                   * try again
-                   */
-                  goto try_again;
-
-              /*
-               * I have the lock
-               */
-              set up any test parameters.
-
-              /*
-               * This starts the test
-               */
-              set(ifTestType = test_to_run);
-
-              wait for test completion by polling ifTestResult
-
-              when test completes, agent sets ifTestResult
-                   agent also sets ifTestStatus = 'notInUse'
-
-              retrieve any additional test results, and ifTestId
-
-              if (ifTestId == lock_value+1) results are valid
-
-            A manager station first retrieves the value of the
-            appropriate ifTestId and ifTestStatus objects, periodically
-            repeating the retrieval if necessary, until the value of
-            ifTestStatus is 'notInUse'.  The manager station then tries
-            to set the same ifTestId object to the value it just
-            retrieved, the same ifTestStatus object to 'inUse', and the
-            corresponding ifTestOwner object to a value indicating
-            itself.  If the set operation succeeds then the manager has
-            obtained ownership of the ifTestEntry, and the value of the
-            ifTestId object is incremented by the agent (per the
-            semantics of TestAndIncr).  Failure of the set operation
-            indicates that some other manager has obtained ownership of
-            the ifTestEntry.
-
-            Once ownership is obtained, any test parameters can be
-            setup, and then the test is initiated by setting ifTestType.
-            On completion of the test, the agent sets ifTestStatus to
-            'notInUse'.  Once this occurs, the manager can retrieve the
-            results.  In the (rare) event that the invocation of tests
-            by two network managers were to overlap, then there would be
-            a possibility that the first test's results might be
-            overwritten by the second test's results prior to the first
-
-
-            results being read.  This unlikely circumstance can be
-            detected by a network manager retrieving ifTestId at the
-            same time as retrieving the test results, and ensuring that
-            the results are for the desired request.
-
-            If ifTestType is not set within an abnormally long period of
-            time after ownership is obtained, the agent should time-out
-            the manager, and reset the value of the ifTestStatus object
-            back to 'notInUse'.  It is suggested that this time-out
-            period be 5 minutes.
-
-            In general, a management station must not retransmit a
-            request to invoke a test for which it does not receive a
-            response; instead, it properly inspects an agent's MIB to
-            determine if the invocation was successful.  Only if the
-            invocation was unsuccessful, is the invocation request
-            retransmitted.
-
-            Some tests may require the interface to be taken off-line in
-            order to execute them, or may even require the agent to
-            reboot after completion of the test.  In these
-            circumstances, communication with the management station
-            invoking the test may be lost until after completion of the
-            test.  An agent is not required to support such tests.
-            However, if such tests are supported, then the agent should
-            make every effort to transmit a response to the request
-            which invoked the test prior to losing communication.  When
-            the agent is restored to normal service, the results of the
-            test are properly made available in the appropriate objects.
-            Note that this requires that the ifIndex value assigned to
-            an interface must be unchanged even if the test causes a
-            reboot.  An agent must reject any test for which it cannot,
-            perhaps due to resource constraints, make available at least
-            the minimum amount of information after that test
-            completes."
-    ::= { ifMIBObjects 3 }
-
-ifTestEntry OBJECT-TYPE
-    SYNTAX       IfTestEntry
-    MAX-ACCESS   not-accessible
-    STATUS       deprecated
-    DESCRIPTION
-            "An entry containing objects for invoking tests on an
-            interface."
-    AUGMENTS  { ifEntry }
-    ::= { ifTestTable 1 }
-
-IfTestEntry ::=
-
-
-    SEQUENCE {
-        ifTestId           TestAndIncr,
-        ifTestStatus       INTEGER,
-        ifTestType         AutonomousType,
-        ifTestResult       INTEGER,
-        ifTestCode         OBJECT IDENTIFIER,
-        ifTestOwner        OwnerString
-    }
-
-ifTestId         OBJECT-TYPE
-    SYNTAX       TestAndIncr
-    MAX-ACCESS   read-write
-    STATUS       deprecated
-    DESCRIPTION
-            "This object identifies the current invocation of the
-            interface's test."
-    ::= { ifTestEntry 1 }
-
-ifTestStatus     OBJECT-TYPE
-    SYNTAX       INTEGER { notInUse(1), inUse(2) }
-    MAX-ACCESS   read-write
-    STATUS       deprecated
-    DESCRIPTION
-            "This object indicates whether or not some manager currently
-            has the necessary 'ownership' required to invoke a test on
-            this interface.  A write to this object is only successful
-            when it changes its value from 'notInUse(1)' to 'inUse(2)'.
-            After completion of a test, the agent resets the value back
-            to 'notInUse(1)'."
-    ::= { ifTestEntry 2 }
-
-ifTestType       OBJECT-TYPE
-    SYNTAX       AutonomousType
-    MAX-ACCESS   read-write
-    STATUS       deprecated
-    DESCRIPTION
-            "A control variable used to start and stop operator-
-            initiated interface tests.  Most OBJECT IDENTIFIER values
-            assigned to tests are defined elsewhere, in association with
-            specific types of interface.  However, this document assigns
-            a value for a full-duplex loopback test, and defines the
-            special meanings of the subject identifier:
-
-                noTest  OBJECT IDENTIFIER ::= { 0 0 }
-
-            When the value noTest is written to this object, no action
-            is taken unless a test is in progress, in which case the
-            test is aborted.  Writing any other value to this object is
-
-
-            only valid when no test is currently in progress, in which
-            case the indicated test is initiated.
-
-            When read, this object always returns the most recent value
-            that ifTestType was set to.  If it has not been set since
-            the last initialization of the network management subsystem
-            on the agent, a value of noTest is returned."
-    ::= { ifTestEntry 3 }
-
-ifTestResult  OBJECT-TYPE
-    SYNTAX       INTEGER {
-                     none(1),          -- no test yet requested
-                     success(2),
-                     inProgress(3),
-                     notSupported(4),
-                     unAbleToRun(5),   -- due to state of system
-                     aborted(6),
-                     failed(7)
-                 }
-    MAX-ACCESS   read-only
-    STATUS       deprecated
-    DESCRIPTION
-            "This object contains the result of the most recently
-            requested test, or the value none(1) if no tests have been
-            requested since the last reset.  Note that this facility
-            provides no provision for saving the results of one test
-            when starting another, as could be required if used by
-            multiple managers concurrently."
-    ::= { ifTestEntry 4 }
-
-ifTestCode  OBJECT-TYPE
-    SYNTAX       OBJECT IDENTIFIER
-    MAX-ACCESS   read-only
-    STATUS       deprecated
-    DESCRIPTION
-            "This object contains a code which contains more specific
-            information on the test result, for example an error-code
-            after a failed test.  Error codes and other values this
-            object may take are specific to the type of interface and/or
-            test.  The value may have the semantics of either the
-            AutonomousType or InstancePointer textual conventions as
-            defined in RFC 2579.  The identifier:
-
-                testCodeUnknown  OBJECT IDENTIFIER ::= { 0 0 }
-
-            is defined for use if no additional result code is
-            available."
-    ::= { ifTestEntry 5 }
-
-
-ifTestOwner      OBJECT-TYPE
-    SYNTAX       OwnerString
-    MAX-ACCESS   read-write
-    STATUS       deprecated
-    DESCRIPTION
-            "The entity which currently has the 'ownership' required to
-            invoke a test on this interface."
-    ::= { ifTestEntry 6 }
-
--- Deprecated Definitions - Groups
-
-
-ifGeneralGroup    OBJECT-GROUP
-    OBJECTS { ifDescr, ifType, ifSpeed, ifPhysAddress,
-              ifAdminStatus, ifOperStatus, ifLastChange,
-              ifLinkUpDownTrapEnable, ifConnectorPresent,
-              ifHighSpeed, ifName }
-    STATUS  deprecated
-    DESCRIPTION
-            "A collection of objects deprecated in favour of
-            ifGeneralInformationGroup."
-    ::= { ifGroups 1 }
-
-
-ifTestGroup    OBJECT-GROUP
-    OBJECTS { ifTestId, ifTestStatus, ifTestType,
-              ifTestResult, ifTestCode, ifTestOwner }
-    STATUS  deprecated
-    DESCRIPTION
-            "A collection of objects providing the ability to invoke
-            tests on an interface."
-    ::= { ifGroups 8 }
-
-
-ifStackGroup    OBJECT-GROUP
-    OBJECTS { ifStackStatus }
-    STATUS  deprecated
-    DESCRIPTION
-            "The previous collection of objects providing information on
-            the layering of MIB-II interfaces."
-    ::= { ifGroups 9 }
-
-
-ifOldObjectsGroup    OBJECT-GROUP
-    OBJECTS { ifInNUcastPkts, ifOutNUcastPkts,
-              ifOutQLen, ifSpecific }
-    STATUS  deprecated
-    DESCRIPTION
-
-
-            "The collection of objects deprecated from the original MIB-
-            II interfaces group."
-    ::= { ifGroups 12 }
-
--- Deprecated Definitions - Compliance
-
-ifCompliance MODULE-COMPLIANCE
-    STATUS  deprecated
-    DESCRIPTION
-            "A compliance statement defined in a previous version of
-            this MIB module, for SNMP entities which have network
-            interfaces."
-
-    MODULE  -- this module
-        MANDATORY-GROUPS { ifGeneralGroup, ifStackGroup }
-
-        GROUP       ifFixedLengthGroup
-        DESCRIPTION
-            "This group is mandatory for all network interfaces which
-            are character-oriented or transmit data in fixed-length
-            transmission units."
-
-        GROUP       ifHCFixedLengthGroup
-        DESCRIPTION
-            "This group is mandatory only for those network interfaces
-            which are character-oriented or transmit data in fixed-
-            length transmission units, and for which the value of the
-            corresponding instance of ifSpeed is greater than 20,000,000
-            bits/second."
-
-        GROUP       ifPacketGroup
-        DESCRIPTION
-            "This group is mandatory for all network interfaces which
-            are packet-oriented."
-
-        GROUP       ifHCPacketGroup
-        DESCRIPTION
-            "This group is mandatory only for those network interfaces
-            which are packet-oriented and for which the value of the
-            corresponding instance of ifSpeed is greater than
-            650,000,000 bits/second."
-
-        GROUP       ifTestGroup
-        DESCRIPTION
-            "This group is optional.  Media-specific MIBs which require
-            interface tests are strongly encouraged to use this group
-            for invoking tests and reporting results.  A medium specific
-            MIB which has mandatory tests may make implementation of
-
-
-            this group mandatory."
-
-        GROUP       ifRcvAddressGroup
-        DESCRIPTION
-            "The applicability of this group MUST be defined by the
-            media-specific MIBs.  Media-specific MIBs must define the
-            exact meaning, use, and semantics of the addresses in this
-            group."
-
-        OBJECT      ifLinkUpDownTrapEnable
-        MIN-ACCESS  read-only
-        DESCRIPTION
-            "Write access is not required."
-
-        OBJECT      ifPromiscuousMode
-        MIN-ACCESS  read-only
-        DESCRIPTION
-            "Write access is not required."
-
-        OBJECT      ifStackStatus
-        SYNTAX      INTEGER { active(1) } -- subset of RowStatus
-        MIN-ACCESS  read-only
-        DESCRIPTION
-            "Write access is not required, and only one of the six
-            enumerated values for the RowStatus textual convention need
-            be supported, specifically: active(1)."
-
-        OBJECT       ifAdminStatus
-        SYNTAX       INTEGER { up(1), down(2) }
-        MIN-ACCESS   read-only
-        DESCRIPTION
-            "Write access is not required, nor is support for the value
-            testing(3)."
-    ::= { ifCompliances 1 }
-
-ifCompliance2 MODULE-COMPLIANCE
-    STATUS      deprecated
-    DESCRIPTION
-            "A compliance statement defined in a previous version of
-            this MIB module, for SNMP entities which have network
-            interfaces."
-
-    MODULE  -- this module
-        MANDATORY-GROUPS { ifGeneralInformationGroup, ifStackGroup2,
-                           ifCounterDiscontinuityGroup }
-
-        GROUP       ifFixedLengthGroup
-        DESCRIPTION
-
-
-            "This group is mandatory for all network interfaces which
-            are character-oriented or transmit data in fixed-length
-            transmission units."
-
-        GROUP       ifHCFixedLengthGroup
-        DESCRIPTION
-            "This group is mandatory only for those network interfaces
-            which are character-oriented or transmit data in fixed-
-            length transmission units, and for which the value of the
-            corresponding instance of ifSpeed is greater than 20,000,000
-            bits/second."
-
-        GROUP       ifPacketGroup
-        DESCRIPTION
-            "This group is mandatory for all network interfaces which
-            are packet-oriented."
-
-        GROUP       ifHCPacketGroup
-        DESCRIPTION
-            "This group is mandatory only for those network interfaces
-            which are packet-oriented and for which the value of the
-            corresponding instance of ifSpeed is greater than
-            650,000,000 bits/second."
-
-        GROUP       ifRcvAddressGroup
-        DESCRIPTION
-            "The applicability of this group MUST be defined by the
-            media-specific MIBs.  Media-specific MIBs must define the
-            exact meaning, use, and semantics of the addresses in this
-            group."
-
-        OBJECT      ifLinkUpDownTrapEnable
-        MIN-ACCESS  read-only
-        DESCRIPTION
-            "Write access is not required."
-
-        OBJECT      ifPromiscuousMode
-        MIN-ACCESS  read-only
-        DESCRIPTION
-            "Write access is not required."
-
-        OBJECT      ifStackStatus
-        SYNTAX      INTEGER { active(1) } -- subset of RowStatus
-        MIN-ACCESS  read-only
-        DESCRIPTION
-            "Write access is not required, and only one of the six
-            enumerated values for the RowStatus textual convention need
-            be supported, specifically: active(1)."
-
-
-        OBJECT       ifAdminStatus
-        SYNTAX       INTEGER { up(1), down(2) }
-        MIN-ACCESS   read-only
-        DESCRIPTION
-            "Write access is not required, nor is support for the value
-            testing(3)."
-
-        OBJECT       ifAlias
-        MIN-ACCESS   read-only
-        DESCRIPTION
-            "Write access is not required."
-
-    ::= { ifCompliances 2 }
-
-END
diff --git a/contrib/apps/LwipMibCompiler/Mibs/INET-ADDRESS-MIB b/contrib/apps/LwipMibCompiler/Mibs/INET-ADDRESS-MIB
deleted file mode 100644
index a19b8d22..00000000
--- a/contrib/apps/LwipMibCompiler/Mibs/INET-ADDRESS-MIB
+++ /dev/null
@@ -1,421 +0,0 @@
-INET-ADDRESS-MIB DEFINITIONS ::= BEGIN
-
-IMPORTS
-    MODULE-IDENTITY, mib-2, Unsigned32 FROM SNMPv2-SMI
-    TEXTUAL-CONVENTION                 FROM SNMPv2-TC;
-
-inetAddressMIB MODULE-IDENTITY
-    LAST-UPDATED "200502040000Z"
-    ORGANIZATION
-        "IETF Operations and Management Area"
-    CONTACT-INFO
-        "Juergen Schoenwaelder (Editor)
-         International University Bremen
-         P.O. Box 750 561
-         28725 Bremen, Germany
-
-         Phone: +49 421 200-3587
-         EMail: j.schoenwaelder@iu-bremen.de
-
-         Send comments to <ietfmibs@ops.ietf.org>."
-    DESCRIPTION
-        "This MIB module defines textual conventions for
-         representing Internet addresses.  An Internet
-         address can be an IPv4 address, an IPv6 address,
-         or a DNS domain name.  This module also defines
-         textual conventions for Internet port numbers,
-         autonomous system numbers, and the length of an
-         Internet address prefix.
-
-         Copyright (C) The Internet Society (2005).  This version
-         of this MIB module is part of RFC 4001, see the RFC
-         itself for full legal notices."
-    REVISION     "200502040000Z"
-    DESCRIPTION
-        "Third version, published as RFC 4001.  This revision
-         introduces the InetZoneIndex, InetScopeType, and
-         InetVersion textual conventions."
-    REVISION     "200205090000Z"
-    DESCRIPTION
-        "Second version, published as RFC 3291.  This
-         revision contains several clarifications and
-         introduces several new textual conventions:
-         InetAddressPrefixLength, InetPortNumber,
-         InetAutonomousSystemNumber, InetAddressIPv4z,
-         and InetAddressIPv6z."
-    REVISION     "200006080000Z"
-
-
-
-    DESCRIPTION
-        "Initial version, published as RFC 2851."
-    ::= { mib-2 76 }
-
-InetAddressType ::= TEXTUAL-CONVENTION
-    STATUS      current
-    DESCRIPTION
-        "A value that represents a type of Internet address.
-
-         unknown(0)  An unknown address type.  This value MUST
-                     be used if the value of the corresponding
-                     InetAddress object is a zero-length string.
-                     It may also be used to indicate an IP address
-                     that is not in one of the formats defined
-                     below.
-
-         ipv4(1)     An IPv4 address as defined by the
-                     InetAddressIPv4 textual convention.
-
-         ipv6(2)     An IPv6 address as defined by the
-                     InetAddressIPv6 textual convention.
-
-         ipv4z(3)    A non-global IPv4 address including a zone
-                     index as defined by the InetAddressIPv4z
-                     textual convention.
-
-         ipv6z(4)    A non-global IPv6 address including a zone
-                     index as defined by the InetAddressIPv6z
-                     textual convention.
-
-         dns(16)     A DNS domain name as defined by the
-                     InetAddressDNS textual convention.
-
-         Each definition of a concrete InetAddressType value must be
-         accompanied by a definition of a textual convention for use
-         with that InetAddressType.
-
-         To support future extensions, the InetAddressType textual
-         convention SHOULD NOT be sub-typed in object type definitions.
-         It MAY be sub-typed in compliance statements in order to
-         require only a subset of these address types for a compliant
-         implementation.
-
-         Implementations must ensure that InetAddressType objects
-         and any dependent objects (e.g., InetAddress objects) are
-         consistent.  An inconsistentValue error must be generated
-         if an attempt to change an InetAddressType object would,
-         for example, lead to an undefined InetAddress value.  In
-
-
-
-         particular, InetAddressType/InetAddress pairs must be
-         changed together if the address type changes (e.g., from
-         ipv6(2) to ipv4(1))."
-    SYNTAX       INTEGER {
-                     unknown(0),
-                     ipv4(1),
-                     ipv6(2),
-                     ipv4z(3),
-                     ipv6z(4),
-                     dns(16)
-                 }
-
-InetAddress ::= TEXTUAL-CONVENTION
-    STATUS      current
-    DESCRIPTION
-        "Denotes a generic Internet address.
-
-         An InetAddress value is always interpreted within the context
-         of an InetAddressType value.  Every usage of the InetAddress
-         textual convention is required to specify the InetAddressType
-         object that provides the context.  It is suggested that the
-         InetAddressType object be logically registered before the
-         object(s) that use the InetAddress textual convention, if
-         they appear in the same logical row.
-
-         The value of an InetAddress object must always be
-         consistent with the value of the associated InetAddressType
-         object.  Attempts to set an InetAddress object to a value
-         inconsistent with the associated InetAddressType
-         must fail with an inconsistentValue error.
-
-         When this textual convention is used as the syntax of an
-         index object, there may be issues with the limit of 128
-         sub-identifiers specified in SMIv2, STD 58.  In this case,
-         the object definition MUST include a 'SIZE' clause to
-         limit the number of potential instance sub-identifiers;
-         otherwise the applicable constraints MUST be stated in
-         the appropriate conceptual row DESCRIPTION clauses, or
-         in the surrounding documentation if there is no single
-         DESCRIPTION clause that is appropriate."
-    SYNTAX       OCTET STRING (SIZE (0..255))
-
-InetAddressIPv4 ::= TEXTUAL-CONVENTION
-    DISPLAY-HINT "1d.1d.1d.1d"
-    STATUS       current
-    DESCRIPTION
-        "Represents an IPv4 network address:
-
-
-
-
-           Octets   Contents         Encoding
-            1-4     IPv4 address     network-byte order
-
-         The corresponding InetAddressType value is ipv4(1).
-
-         This textual convention SHOULD NOT be used directly in object
-         definitions, as it restricts addresses to a specific format.
-         However, if it is used, it MAY be used either on its own or in
-         conjunction with InetAddressType, as a pair."
-    SYNTAX       OCTET STRING (SIZE (4))
-
-InetAddressIPv6 ::= TEXTUAL-CONVENTION
-    DISPLAY-HINT "2x:2x:2x:2x:2x:2x:2x:2x"
-    STATUS       current
-    DESCRIPTION
-        "Represents an IPv6 network address:
-
-           Octets   Contents         Encoding
-            1-16    IPv6 address     network-byte order
-
-         The corresponding InetAddressType value is ipv6(2).
-
-         This textual convention SHOULD NOT be used directly in object
-         definitions, as it restricts addresses to a specific format.
-         However, if it is used, it MAY be used either on its own or in
-         conjunction with InetAddressType, as a pair."
-    SYNTAX       OCTET STRING (SIZE (16))
-
-InetAddressIPv4z ::= TEXTUAL-CONVENTION
-    DISPLAY-HINT "1d.1d.1d.1d%4d"
-    STATUS       current
-    DESCRIPTION
-        "Represents a non-global IPv4 network address, together
-         with its zone index:
-
-           Octets   Contents         Encoding
-            1-4     IPv4 address     network-byte order
-            5-8     zone index       network-byte order
-
-         The corresponding InetAddressType value is ipv4z(3).
-
-         The zone index (bytes 5-8) is used to disambiguate identical
-         address values on nodes that have interfaces attached to
-         different zones of the same scope.  The zone index may contain
-         the special value 0, which refers to the default zone for each
-         scope.
-
-         This textual convention SHOULD NOT be used directly in object
-
-
-
-         definitions, as it restricts addresses to a specific format.
-         However, if it is used, it MAY be used either on its own or in
-         conjunction with InetAddressType, as a pair."
-    SYNTAX       OCTET STRING (SIZE (8))
-
-InetAddressIPv6z ::= TEXTUAL-CONVENTION
-    DISPLAY-HINT "2x:2x:2x:2x:2x:2x:2x:2x%4d"
-    STATUS       current
-    DESCRIPTION
-        "Represents a non-global IPv6 network address, together
-         with its zone index:
-
-           Octets   Contents         Encoding
-            1-16    IPv6 address     network-byte order
-           17-20    zone index       network-byte order
-
-         The corresponding InetAddressType value is ipv6z(4).
-
-         The zone index (bytes 17-20) is used to disambiguate
-         identical address values on nodes that have interfaces
-         attached to different zones of the same scope.  The zone index
-         may contain the special value 0, which refers to the default
-         zone for each scope.
-
-         This textual convention SHOULD NOT be used directly in object
-         definitions, as it restricts addresses to a specific format.
-         However, if it is used, it MAY be used either on its own or in
-         conjunction with InetAddressType, as a pair."
-    SYNTAX       OCTET STRING (SIZE (20))
-
-InetAddressDNS ::= TEXTUAL-CONVENTION
-    DISPLAY-HINT "255a"
-    STATUS       current
-    DESCRIPTION
-        "Represents a DNS domain name.  The name SHOULD be fully
-         qualified whenever possible.
-
-         The corresponding InetAddressType is dns(16).
-
-         The DESCRIPTION clause of InetAddress objects that may have
-         InetAddressDNS values MUST fully describe how (and when)
-         these names are to be resolved to IP addresses.
-
-         The resolution of an InetAddressDNS value may require to
-         query multiple DNS records (e.g., A for IPv4 and AAAA for
-         IPv6).  The order of the resolution process and which DNS
-         record takes precedence depends on the configuration of the
-         resolver.
-
-
-
-         This textual convention SHOULD NOT be used directly in object
-         definitions, as it restricts addresses to a specific format.
-         However, if it is used, it MAY be used either on its own or in
-         conjunction with InetAddressType, as a pair."
-    SYNTAX       OCTET STRING (SIZE (1..255))
-
-InetAddressPrefixLength ::= TEXTUAL-CONVENTION
-    DISPLAY-HINT "d"
-    STATUS       current
-    DESCRIPTION
-        "Denotes the length of a generic Internet network address
-         prefix.  A value of n corresponds to an IP address mask
-         that has n contiguous 1-bits from the most significant
-         bit (MSB), with all other bits set to 0.
-
-         An InetAddressPrefixLength value is always interpreted within
-         the context of an InetAddressType value.  Every usage of the
-         InetAddressPrefixLength textual convention is required to
-         specify the InetAddressType object that provides the
-         context.  It is suggested that the InetAddressType object be
-         logically registered before the object(s) that use the
-         InetAddressPrefixLength textual convention, if they appear
-         in the same logical row.
-
-         InetAddressPrefixLength values larger than
-         the maximum length of an IP address for a specific
-         InetAddressType are treated as the maximum significant
-         value applicable for the InetAddressType.  The maximum
-         significant value is 32 for the InetAddressType
-         'ipv4(1)' and 'ipv4z(3)' and 128 for the InetAddressType
-         'ipv6(2)' and 'ipv6z(4)'.  The maximum significant value
-         for the InetAddressType 'dns(16)' is 0.
-
-         The value zero is object-specific and must be defined as
-         part of the description of any object that uses this
-         syntax.  Examples of the usage of zero might include
-         situations where the Internet network address prefix
-         is unknown or does not apply.
-
-         The upper bound of the prefix length has been chosen to
-         be consistent with the maximum size of an InetAddress."
-    SYNTAX       Unsigned32 (0..2040)
-
-InetPortNumber ::= TEXTUAL-CONVENTION
-    DISPLAY-HINT "d"
-    STATUS       current
-    DESCRIPTION
-        "Represents a 16 bit port number of an Internet transport
-
-
-
-         layer protocol.  Port numbers are assigned by IANA.  A
-         current list of all assignments is available from
-         <http://www.iana.org/>.
-
-         The value zero is object-specific and must be defined as
-         part of the description of any object that uses this
-         syntax.  Examples of the usage of zero might include
-         situations where a port number is unknown, or when the
-         value zero is used as a wildcard in a filter."
-    REFERENCE   "STD 6 (RFC 768), STD 7 (RFC 793) and RFC 2960"
-    SYNTAX       Unsigned32 (0..65535)
-
-InetAutonomousSystemNumber ::= TEXTUAL-CONVENTION
-    DISPLAY-HINT "d"
-    STATUS       current
-    DESCRIPTION
-        "Represents an autonomous system number that identifies an
-         Autonomous System (AS).  An AS is a set of routers under a
-         single technical administration, using an interior gateway
-         protocol and common metrics to route packets within the AS,
-         and using an exterior gateway protocol to route packets to
-         other ASes'.  IANA maintains the AS number space and has
-         delegated large parts to the regional registries.
-
-         Autonomous system numbers are currently limited to 16 bits
-         (0..65535).  There is, however, work in progress to enlarge the
-         autonomous system number space to 32 bits.  Therefore, this
-         textual convention uses an Unsigned32 value without a
-         range restriction in order to support a larger autonomous
-         system number space."
-    REFERENCE   "RFC 1771, RFC 1930"
-    SYNTAX       Unsigned32
-
-InetScopeType ::= TEXTUAL-CONVENTION
-    STATUS       current
-    DESCRIPTION
-        "Represents a scope type.  This textual convention can be used
-         in cases where a MIB has to represent different scope types
-         and there is no context information, such as an InetAddress
-         object, that implicitly defines the scope type.
-
-         Note that not all possible values have been assigned yet, but
-         they may be assigned in future revisions of this specification.
-         Applications should therefore be able to deal with values
-         not yet assigned."
-    REFERENCE   "RFC 3513"
-    SYNTAX       INTEGER {
-                     -- reserved(0),
-
-
-
-                     interfaceLocal(1),
-                     linkLocal(2),
-                     subnetLocal(3),
-                     adminLocal(4),
-                     siteLocal(5), -- site-local unicast addresses
-                                   -- have been deprecated by RFC 3879
-                     -- unassigned(6),
-                     -- unassigned(7),
-                     organizationLocal(8),
-                     -- unassigned(9),
-                     -- unassigned(10),
-                     -- unassigned(11),
-                     -- unassigned(12),
-                     -- unassigned(13),
-                     global(14)
-                     -- reserved(15)
-                 }
-
-InetZoneIndex ::= TEXTUAL-CONVENTION
-    DISPLAY-HINT "d"
-    STATUS       current
-    DESCRIPTION
-        "A zone index identifies an instance of a zone of a
-         specific scope.
-
-         The zone index MUST disambiguate identical address
-         values.  For link-local addresses, the zone index will
-         typically be the interface index (ifIndex as defined in the
-         IF-MIB) of the interface on which the address is configured.
-
-         The zone index may contain the special value 0, which refers
-         to the default zone.  The default zone may be used in cases
-         where the valid zone index is not known (e.g., when a
-         management application has to write a link-local IPv6
-         address without knowing the interface index value).  The
-         default zone SHOULD NOT be used as an easy way out in
-         cases where the zone index for a non-global IPv6 address
-         is known."
-    REFERENCE   "RFC4007"
-    SYNTAX       Unsigned32
-
-InetVersion ::= TEXTUAL-CONVENTION
-    STATUS  current
-    DESCRIPTION
-        "A value representing a version of the IP protocol.
-
-         unknown(0)  An unknown or unspecified version of the IP
-                     protocol.
-
-
-
-         ipv4(1)     The IPv4 protocol as defined in RFC 791 (STD 5).
-
-         ipv6(2)     The IPv6 protocol as defined in RFC 2460.
-
-         Note that this textual convention SHOULD NOT be used to
-         distinguish different address types associated with IP
-         protocols.  The InetAddressType has been designed for this
-         purpose."
-    REFERENCE   "RFC 791, RFC 2460"
-    SYNTAX       INTEGER {
-                     unknown(0),
-                     ipv4(1),
-                     ipv6(2)
-                 }
-END
diff --git a/contrib/apps/LwipMibCompiler/Mibs/IP-MIB b/contrib/apps/LwipMibCompiler/Mibs/IP-MIB
deleted file mode 100644
index 0a93501b..00000000
--- a/contrib/apps/LwipMibCompiler/Mibs/IP-MIB
+++ /dev/null
@@ -1,5254 +0,0 @@
-IP-MIB DEFINITIONS ::= BEGIN
-
-IMPORTS
-    MODULE-IDENTITY, OBJECT-TYPE,
-    Integer32, Counter32, IpAddress,
-    mib-2, Unsigned32, Counter64,
-    zeroDotZero                        FROM SNMPv2-SMI
-    PhysAddress, TruthValue,
-    TimeStamp, RowPointer,
-    TEXTUAL-CONVENTION, TestAndIncr,
-    RowStatus, StorageType             FROM SNMPv2-TC
-    MODULE-COMPLIANCE, OBJECT-GROUP    FROM SNMPv2-CONF
-    InetAddress, InetAddressType,
-    InetAddressPrefixLength,
-    InetVersion, InetZoneIndex         FROM INET-ADDRESS-MIB
-    InterfaceIndex                     FROM IF-MIB;
-
-ipMIB MODULE-IDENTITY
-    LAST-UPDATED "200602020000Z"
-    ORGANIZATION "IETF IPv6 MIB Revision Team"
-    CONTACT-INFO
-           "Editor:
-
-
-
-            Shawn A. Routhier
-            Interworking Labs
-            108 Whispering Pines Dr. Suite 235
-            Scotts Valley, CA 95066
-            USA
-            EMail: <sar@iwl.com>"
-    DESCRIPTION
-           "The MIB module for managing IP and ICMP implementations, but
-            excluding their management of IP routes.
-
-            Copyright (C) The Internet Society (2006).  This version of
-            this MIB module is part of RFC 4293; see the RFC itself for
-            full legal notices."
-
-    REVISION      "200602020000Z"
-    DESCRIPTION
-           "The IP version neutral revision with added IPv6 objects for
-            ND, default routers, and router advertisements.  As well as
-            being the successor to RFC 2011, this MIB is also the
-            successor to RFCs 2465 and 2466.  Published as RFC 4293."
-
-    REVISION      "199411010000Z"
-    DESCRIPTION
-           "A separate MIB module (IP-MIB) for IP and ICMP management
-            objects.  Published as RFC 2011."
-
-    REVISION      "199103310000Z"
-    DESCRIPTION
-           "The initial revision of this MIB module was part of MIB-II,
-            which was published as RFC 1213."
-    ::= { mib-2 48}
-
---
--- The textual conventions we define and use in this MIB.
---
-
-IpAddressOriginTC ::= TEXTUAL-CONVENTION
-    STATUS     current
-    DESCRIPTION
-           "The origin of the address.
-
-            manual(2) indicates that the address was manually configured
-            to a specified address, e.g., by user configuration.
-
-            dhcp(4) indicates an address that was assigned to this
-            system by a DHCP server.
-
-            linklayer(5) indicates an address created by IPv6 stateless
-
-
-
-            auto-configuration.
-
-            random(6) indicates an address chosen by the system at
-            random, e.g., an IPv4 address within 169.254/16, or an RFC
-            3041 privacy address."
-    SYNTAX     INTEGER {
-        other(1),
-        manual(2),
-        dhcp(4),
-        linklayer(5),
-        random(6)
-    }
-
-IpAddressStatusTC ::= TEXTUAL-CONVENTION
-    STATUS     current
-    DESCRIPTION
-           "The status of an address.  Most of the states correspond to
-            states from the IPv6 Stateless Address Autoconfiguration
-            protocol.
-
-            The preferred(1) state indicates that this is a valid
-            address that can appear as the destination or source address
-            of a packet.
-
-            The deprecated(2) state indicates that this is a valid but
-            deprecated address that should no longer be used as a source
-            address in new communications, but packets addressed to such
-            an address are processed as expected.
-
-            The invalid(3) state indicates that this isn't a valid
-            address and it shouldn't appear as the destination or source
-            address of a packet.
-
-            The inaccessible(4) state indicates that the address is not
-            accessible because the interface to which this address is
-            assigned is not operational.
-
-            The unknown(5) state indicates that the status cannot be
-            determined for some reason.
-
-            The tentative(6) state indicates that the uniqueness of the
-            address on the link is being verified.  Addresses in this
-            state should not be used for general communication and
-            should only be used to determine the uniqueness of the
-            address.
-
-            The duplicate(7) state indicates the address has been
-            determined to be non-unique on the link and so must not be
-
-
-
-            used.
-
-            The optimistic(8) state indicates the address is available
-            for use, subject to restrictions, while its uniqueness on
-            a link is being verified.
-
-            In the absence of other information, an IPv4 address is
-            always preferred(1)."
-    REFERENCE "RFC 2462"
-    SYNTAX     INTEGER {
-        preferred(1),
-        deprecated(2),
-        invalid(3),
-        inaccessible(4),
-        unknown(5),
-        tentative(6),
-        duplicate(7),
-        optimistic(8)
-    }
-
-IpAddressPrefixOriginTC ::= TEXTUAL-CONVENTION
-    STATUS     current
-    DESCRIPTION
-           "The origin of this prefix.
-
-            manual(2) indicates a prefix that was manually configured.
-
-            wellknown(3) indicates a well-known prefix, e.g., 169.254/16
-            for IPv4 auto-configuration or fe80::/10 for IPv6 link-local
-            addresses.  Well known prefixes may be assigned by IANA,
-            the address registries, or by specification in a standards
-            track RFC.
-
-            dhcp(4) indicates a prefix that was assigned by a DHCP
-            server.
-
-            routeradv(5) indicates a prefix learned from a router
-            advertisement.
-
-            Note: while IpAddressOriginTC and IpAddressPrefixOriginTC
-            are similar, they are not identical.  The first defines how
-            an address was created, while the second defines how a
-            prefix was found."
-    SYNTAX     INTEGER {
-        other(1),
-        manual(2),
-        wellknown(3),
-        dhcp(4),
-
-
-
-        routeradv(5)
-    }
-
-Ipv6AddressIfIdentifierTC ::= TEXTUAL-CONVENTION
-     DISPLAY-HINT "2x:"
-     STATUS       current
-     DESCRIPTION
-       "This data type is used to model IPv6 address
-       interface identifiers.  This is a binary string
-       of up to 8 octets in network byte-order."
-     SYNTAX      OCTET STRING (SIZE (0..8))
-
---
--- the IP general group
--- some objects that affect all of IPv4
---
-
-ip       OBJECT IDENTIFIER ::= { mib-2 4 }
-
-ipForwarding OBJECT-TYPE
-    SYNTAX     INTEGER {
-                    forwarding(1),    -- acting as a router
-                    notForwarding(2)  -- NOT acting as a router
-               }
-    MAX-ACCESS read-write
-    STATUS     current
-    DESCRIPTION
-           "The indication of whether this entity is acting as an IPv4
-            router in respect to the forwarding of datagrams received
-            by, but not addressed to, this entity.  IPv4 routers forward
-            datagrams.  IPv4 hosts do not (except those source-routed
-            via the host).
-
-            When this object is written, the entity should save the
-            change to non-volatile storage and restore the object from
-            non-volatile storage upon re-initialization of the system.
-            Note: a stronger requirement is not used because this object
-            was previously defined."
-    ::= { ip 1 }
-
-ipDefaultTTL OBJECT-TYPE
-    SYNTAX     Integer32 (1..255)
-    MAX-ACCESS read-write
-    STATUS     current
-    DESCRIPTION
-           "The default value inserted into the Time-To-Live field of
-            the IPv4 header of datagrams originated at this entity,
-            whenever a TTL value is not supplied by the transport layer
-
-
-
-            protocol.
-
-            When this object is written, the entity should save the
-            change to non-volatile storage and restore the object from
-            non-volatile storage upon re-initialization of the system.
-            Note: a stronger requirement is not used because this object
-            was previously defined."
-    ::= { ip 2 }
-
-ipReasmTimeout OBJECT-TYPE
-    SYNTAX     Integer32
-    UNITS      "seconds"
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The maximum number of seconds that received fragments are
-            held while they are awaiting reassembly at this entity."
-    ::= { ip 13 }
-
---
--- the IPv6 general group
--- Some objects that affect all of IPv6
---
-
-ipv6IpForwarding OBJECT-TYPE
-    SYNTAX     INTEGER {
-                    forwarding(1),    -- acting as a router
-                    notForwarding(2)  -- NOT acting as a router
-               }
-    MAX-ACCESS read-write
-    STATUS     current
-    DESCRIPTION
-           "The indication of whether this entity is acting as an IPv6
-            router on any interface in respect to the forwarding of
-            datagrams received by, but not addressed to, this entity.
-            IPv6 routers forward datagrams.  IPv6 hosts do not (except
-            those source-routed via the host).
-
-            When this object is written, the entity SHOULD save the
-            change to non-volatile storage and restore the object from
-            non-volatile storage upon re-initialization of the system."
-    ::= { ip 25 }
-
-ipv6IpDefaultHopLimit OBJECT-TYPE
-    SYNTAX     Integer32 (0..255)
-    MAX-ACCESS read-write
-    STATUS     current
-    DESCRIPTION
-
-
-
-           "The default value inserted into the Hop Limit field of the
-            IPv6 header of datagrams originated at this entity whenever
-            a Hop Limit value is not supplied by the transport layer
-            protocol.
-
-            When this object is written, the entity SHOULD save the
-            change to non-volatile storage and restore the object from
-            non-volatile storage upon re-initialization of the system."
-    REFERENCE "RFC 2461 Section 6.3.2"
-    ::= { ip 26 }
-
---
--- IPv4 Interface Table
---
-
-ipv4InterfaceTableLastChange OBJECT-TYPE
-    SYNTAX     TimeStamp
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The value of sysUpTime on the most recent occasion at which
-            a row in the ipv4InterfaceTable was added or deleted, or
-            when an ipv4InterfaceReasmMaxSize or an
-            ipv4InterfaceEnableStatus object was modified.
-
-            If new objects are added to the ipv4InterfaceTable that
-            require the ipv4InterfaceTableLastChange to be updated when
-            they are modified, they must specify that requirement in
-            their description clause."
-    ::= { ip 27 }
-
-ipv4InterfaceTable OBJECT-TYPE
-    SYNTAX     SEQUENCE OF Ipv4InterfaceEntry
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "The table containing per-interface IPv4-specific
-            information."
-    ::= { ip 28 }
-
-ipv4InterfaceEntry OBJECT-TYPE
-    SYNTAX     Ipv4InterfaceEntry
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "An entry containing IPv4-specific information for a specific
-            interface."
-    INDEX { ipv4InterfaceIfIndex }
-
-
-
-    ::= { ipv4InterfaceTable 1 }
-
-Ipv4InterfaceEntry ::= SEQUENCE {
-        ipv4InterfaceIfIndex         InterfaceIndex,
-        ipv4InterfaceReasmMaxSize    Integer32,
-        ipv4InterfaceEnableStatus    INTEGER,
-        ipv4InterfaceRetransmitTime  Unsigned32
-    }
-
-ipv4InterfaceIfIndex OBJECT-TYPE
-    SYNTAX     InterfaceIndex
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "The index value that uniquely identifies the interface to
-            which this entry is applicable.  The interface identified by
-            a particular value of this index is the same interface as
-            identified by the same value of the IF-MIB's ifIndex."
-    ::= { ipv4InterfaceEntry 1 }
-
-ipv4InterfaceReasmMaxSize OBJECT-TYPE
-    SYNTAX     Integer32 (0..65535)
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The size of the largest IPv4 datagram that this entity can
-            re-assemble from incoming IPv4 fragmented datagrams received
-            on this interface."
-    ::= { ipv4InterfaceEntry 2 }
-
-ipv4InterfaceEnableStatus OBJECT-TYPE
-    SYNTAX     INTEGER {
-                 up(1),
-                 down(2)
-    }
-    MAX-ACCESS read-write
-    STATUS     current
-    DESCRIPTION
-           "The indication of whether IPv4 is enabled (up) or disabled
-            (down) on this interface.  This object does not affect the
-            state of the interface itself, only its connection to an
-            IPv4 stack.  The IF-MIB should be used to control the state
-            of the interface."
-    ::= { ipv4InterfaceEntry 3 }
-
-ipv4InterfaceRetransmitTime OBJECT-TYPE
-    SYNTAX     Unsigned32
-    UNITS      "milliseconds"
-
-
-
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The time between retransmissions of ARP requests to a
-            neighbor when resolving the address or when probing the
-            reachability of a neighbor."
-    REFERENCE "RFC 1122"
-    DEFVAL { 1000 }
-    ::= { ipv4InterfaceEntry 4 }
-
---
--- v6 interface table
---
-
-ipv6InterfaceTableLastChange OBJECT-TYPE
-    SYNTAX     TimeStamp
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The value of sysUpTime on the most recent occasion at which
-            a row in the ipv6InterfaceTable was added or deleted or when
-            an ipv6InterfaceReasmMaxSize, ipv6InterfaceIdentifier,
-            ipv6InterfaceEnableStatus, ipv6InterfaceReachableTime,
-            ipv6InterfaceRetransmitTime, or ipv6InterfaceForwarding
-            object was modified.
-
-            If new objects are added to the ipv6InterfaceTable that
-            require the ipv6InterfaceTableLastChange to be updated when
-            they are modified, they must specify that requirement in
-            their description clause."
-    ::= { ip 29 }
-
-ipv6InterfaceTable OBJECT-TYPE
-    SYNTAX     SEQUENCE OF Ipv6InterfaceEntry
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "The table containing per-interface IPv6-specific
-            information."
-    ::= { ip 30 }
-
-ipv6InterfaceEntry OBJECT-TYPE
-    SYNTAX     Ipv6InterfaceEntry
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "An entry containing IPv6-specific information for a given
-            interface."
-
-
-
-    INDEX { ipv6InterfaceIfIndex }
-    ::= { ipv6InterfaceTable 1 }
-
-Ipv6InterfaceEntry ::= SEQUENCE {
-        ipv6InterfaceIfIndex         InterfaceIndex,
-        ipv6InterfaceReasmMaxSize    Unsigned32,
-        ipv6InterfaceIdentifier      Ipv6AddressIfIdentifierTC,
-        ipv6InterfaceEnableStatus    INTEGER,
-        ipv6InterfaceReachableTime   Unsigned32,
-        ipv6InterfaceRetransmitTime  Unsigned32,
-        ipv6InterfaceForwarding      INTEGER
-    }
-
-ipv6InterfaceIfIndex OBJECT-TYPE
-    SYNTAX     InterfaceIndex
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "The index value that uniquely identifies the interface to
-            which this entry is applicable.  The interface identified by
-            a particular value of this index is the same interface as
-            identified by the same value of the IF-MIB's ifIndex."
-    ::= { ipv6InterfaceEntry 1 }
-
-ipv6InterfaceReasmMaxSize OBJECT-TYPE
-    SYNTAX     Unsigned32 (1500..65535)
-    UNITS      "octets"
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The size of the largest IPv6 datagram that this entity can
-            re-assemble from incoming IPv6 fragmented datagrams received
-            on this interface."
-    ::= { ipv6InterfaceEntry 2 }
-
-ipv6InterfaceIdentifier OBJECT-TYPE
-    SYNTAX     Ipv6AddressIfIdentifierTC
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The Interface Identifier for this interface.  The Interface
-            Identifier is combined with an address prefix to form an
-            interface address.
-
-            By default, the Interface Identifier is auto-configured
-            according to the rules of the link type to which this
-            interface is attached.
-
-
-
-
-            A zero length identifier may be used where appropriate.  One
-            possible example is a loopback interface."
-    ::= { ipv6InterfaceEntry 3 }
-
--- This object ID is reserved as it was used in earlier versions of
--- the MIB module.  In theory, OIDs are not assigned until the
--- specification is released as an RFC; however, as some companies
--- may have shipped code based on earlier versions of the MIB, it
--- seems best to reserve this OID.  This OID had been
--- ipv6InterfacePhysicalAddress.
--- ::= { ipv6InterfaceEntry 4}
-
-ipv6InterfaceEnableStatus OBJECT-TYPE
-    SYNTAX     INTEGER {
-                 up(1),
-                 down(2)
-    }
-    MAX-ACCESS read-write
-    STATUS     current
-    DESCRIPTION
-           "The indication of whether IPv6 is enabled (up) or disabled
-            (down) on this interface.  This object does not affect the
-            state of the interface itself, only its connection to an
-            IPv6 stack.  The IF-MIB should be used to control the state
-            of the interface.
-
-            When this object is written, the entity SHOULD save the
-            change to non-volatile storage and restore the object from
-            non-volatile storage upon re-initialization of the system."
-    ::= { ipv6InterfaceEntry 5 }
-
-ipv6InterfaceReachableTime OBJECT-TYPE
-    SYNTAX     Unsigned32
-    UNITS      "milliseconds"
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The time a neighbor is considered reachable after receiving
-            a reachability confirmation."
-    REFERENCE "RFC 2461, Section 6.3.2"
-    ::= { ipv6InterfaceEntry 6 }
-
-ipv6InterfaceRetransmitTime OBJECT-TYPE
-    SYNTAX     Unsigned32
-    UNITS      "milliseconds"
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-
-
-
-           "The time between retransmissions of Neighbor Solicitation
-            messages to a neighbor when resolving the address or when
-            probing the reachability of a neighbor."
-    REFERENCE "RFC 2461, Section 6.3.2"
-    ::= { ipv6InterfaceEntry 7 }
-
-ipv6InterfaceForwarding OBJECT-TYPE
-    SYNTAX     INTEGER {
-                    forwarding(1),    -- acting as a router
-                    notForwarding(2)  -- NOT acting as a router
-               }
-    MAX-ACCESS read-write
-    STATUS     current
-    DESCRIPTION
-           "The indication of whether this entity is acting as an IPv6
-            router on this interface with respect to the forwarding of
-            datagrams received by, but not addressed to, this entity.
-            IPv6 routers forward datagrams.  IPv6 hosts do not (except
-            those source-routed via the host).
-
-            This object is constrained by ipv6IpForwarding and is
-            ignored if ipv6IpForwarding is set to notForwarding.  Those
-            systems that do not provide per-interface control of the
-            forwarding function should set this object to forwarding for
-            all interfaces and allow the ipv6IpForwarding object to
-            control the forwarding capability.
-
-            When this object is written, the entity SHOULD save the
-            change to non-volatile storage and restore the object from
-            non-volatile storage upon re-initialization of the system."
-    ::= { ipv6InterfaceEntry 8 }
-
---
--- Per-Interface or System-Wide IP statistics.
---
--- The following two tables, ipSystemStatsTable and ipIfStatsTable,
--- are intended to provide the same counters at different granularities.
--- The ipSystemStatsTable provides system wide counters aggregating
--- the traffic counters for all interfaces for a given address type.
--- The ipIfStatsTable provides the same counters but for specific
--- interfaces rather than as an aggregate.
---
--- Note well: If a system provides both system-wide and interface-
--- specific values, the system-wide value may not be equal to the sum
--- of the interface-specific values across all interfaces due to e.g.,
--- dynamic interface creation/deletion.
---
--- Note well: Both of these tables contain some items that are
-
-
-
--- represented by two objects, representing the value in either 32
--- or 64 bits.  For those objects, the 32-bit value MUST be the low
--- order 32 bits of the 64-bit value.  Also note that the 32-bit
--- counters must be included when the 64-bit counters are included.
-
-ipTrafficStats OBJECT IDENTIFIER ::= { ip 31 }
-
-ipSystemStatsTable OBJECT-TYPE
-    SYNTAX     SEQUENCE OF IpSystemStatsEntry
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "The table containing system wide, IP version specific
-            traffic statistics.  This table and the ipIfStatsTable
-            contain similar objects whose difference is in their
-            granularity.  Where this table contains system wide traffic
-            statistics, the ipIfStatsTable contains the same statistics
-            but counted on a per-interface basis."
-    ::= { ipTrafficStats 1 }
-
-ipSystemStatsEntry OBJECT-TYPE
-    SYNTAX     IpSystemStatsEntry
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "A statistics entry containing system-wide objects for a
-            particular IP version."
-    INDEX { ipSystemStatsIPVersion }
-    ::= { ipSystemStatsTable 1 }
-
-IpSystemStatsEntry ::= SEQUENCE {
-        ipSystemStatsIPVersion           InetVersion,
-        ipSystemStatsInReceives          Counter32,
-        ipSystemStatsHCInReceives        Counter64,
-        ipSystemStatsInOctets            Counter32,
-        ipSystemStatsHCInOctets          Counter64,
-        ipSystemStatsInHdrErrors         Counter32,
-        ipSystemStatsInNoRoutes          Counter32,
-        ipSystemStatsInAddrErrors        Counter32,
-        ipSystemStatsInUnknownProtos     Counter32,
-        ipSystemStatsInTruncatedPkts     Counter32,
-        ipSystemStatsInForwDatagrams     Counter32,
-        ipSystemStatsHCInForwDatagrams   Counter64,
-        ipSystemStatsReasmReqds          Counter32,
-        ipSystemStatsReasmOKs            Counter32,
-        ipSystemStatsReasmFails          Counter32,
-        ipSystemStatsInDiscards          Counter32,
-        ipSystemStatsInDelivers          Counter32,
-
-
-
-        ipSystemStatsHCInDelivers        Counter64,
-        ipSystemStatsOutRequests         Counter32,
-        ipSystemStatsHCOutRequests       Counter64,
-        ipSystemStatsOutNoRoutes         Counter32,
-        ipSystemStatsOutForwDatagrams    Counter32,
-        ipSystemStatsHCOutForwDatagrams  Counter64,
-        ipSystemStatsOutDiscards         Counter32,
-        ipSystemStatsOutFragReqds        Counter32,
-        ipSystemStatsOutFragOKs          Counter32,
-        ipSystemStatsOutFragFails        Counter32,
-        ipSystemStatsOutFragCreates      Counter32,
-        ipSystemStatsOutTransmits        Counter32,
-        ipSystemStatsHCOutTransmits      Counter64,
-        ipSystemStatsOutOctets           Counter32,
-        ipSystemStatsHCOutOctets         Counter64,
-        ipSystemStatsInMcastPkts         Counter32,
-        ipSystemStatsHCInMcastPkts       Counter64,
-        ipSystemStatsInMcastOctets       Counter32,
-        ipSystemStatsHCInMcastOctets     Counter64,
-        ipSystemStatsOutMcastPkts        Counter32,
-        ipSystemStatsHCOutMcastPkts      Counter64,
-        ipSystemStatsOutMcastOctets      Counter32,
-        ipSystemStatsHCOutMcastOctets    Counter64,
-        ipSystemStatsInBcastPkts         Counter32,
-        ipSystemStatsHCInBcastPkts       Counter64,
-        ipSystemStatsOutBcastPkts        Counter32,
-        ipSystemStatsHCOutBcastPkts      Counter64,
-        ipSystemStatsDiscontinuityTime   TimeStamp,
-        ipSystemStatsRefreshRate         Unsigned32
-    }
-
-ipSystemStatsIPVersion OBJECT-TYPE
-    SYNTAX     InetVersion
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "The IP version of this row."
-    ::= { ipSystemStatsEntry 1 }
-
--- This object ID is reserved to allow the IDs for this table's objects
--- to align with the objects in the ipIfStatsTable.
--- ::= { ipSystemStatsEntry 2 }
-
-ipSystemStatsInReceives OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-
-
-
-           "The total number of input IP datagrams received, including
-            those received in error.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipSystemStatsDiscontinuityTime."
-    ::= { ipSystemStatsEntry 3 }
-
-ipSystemStatsHCInReceives OBJECT-TYPE
-    SYNTAX     Counter64
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of input IP datagrams received, including
-            those received in error.  This object counts the same
-            datagrams as ipSystemStatsInReceives, but allows for larger
-            values.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipSystemStatsDiscontinuityTime."
-    ::= { ipSystemStatsEntry 4 }
-
-ipSystemStatsInOctets OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of octets received in input IP datagrams,
-            including those received in error.  Octets from datagrams
-            counted in ipSystemStatsInReceives MUST be counted here.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipSystemStatsDiscontinuityTime."
-    ::= { ipSystemStatsEntry 5 }
-
-ipSystemStatsHCInOctets OBJECT-TYPE
-    SYNTAX     Counter64
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of octets received in input IP datagrams,
-            including those received in error.  This object counts the
-            same octets as ipSystemStatsInOctets, but allows for larger
-
-
-
-            values.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipSystemStatsDiscontinuityTime."
-    ::= { ipSystemStatsEntry 6 }
-
-ipSystemStatsInHdrErrors OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of input IP datagrams discarded due to errors in
-            their IP headers, including version number mismatch, other
-            format errors, hop count exceeded, errors discovered in
-            processing their IP options, etc.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipSystemStatsDiscontinuityTime."
-    ::= { ipSystemStatsEntry 7 }
-
-ipSystemStatsInNoRoutes OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of input IP datagrams discarded because no route
-            could be found to transmit them to their destination.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipSystemStatsDiscontinuityTime."
-    ::= { ipSystemStatsEntry 8 }
-
-ipSystemStatsInAddrErrors OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of input IP datagrams discarded because the IP
-            address in their IP header's destination field was not a
-            valid address to be received at this entity.  This count
-            includes invalid addresses (e.g., ::0).  For entities
-            that are not IP routers and therefore do not forward
-
-
-
-            datagrams, this counter includes datagrams discarded
-            because the destination address was not a local address.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipSystemStatsDiscontinuityTime."
-    ::= { ipSystemStatsEntry 9 }
-
-ipSystemStatsInUnknownProtos OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of locally-addressed IP datagrams received
-            successfully but discarded because of an unknown or
-            unsupported protocol.
-
-            When tracking interface statistics, the counter of the
-            interface to which these datagrams were addressed is
-            incremented.  This interface might not be the same as the
-            input interface for some of the datagrams.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipSystemStatsDiscontinuityTime."
-    ::= { ipSystemStatsEntry 10 }
-
-ipSystemStatsInTruncatedPkts OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of input IP datagrams discarded because the
-            datagram frame didn't carry enough data.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipSystemStatsDiscontinuityTime."
-    ::= { ipSystemStatsEntry 11 }
-
-ipSystemStatsInForwDatagrams OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-
-
-
-           "The number of input datagrams for which this entity was not
-            their final IP destination and for which this entity
-            attempted to find a route to forward them to that final
-            destination.  In entities that do not act as IP routers,
-            this counter will include only those datagrams that were
-            Source-Routed via this entity, and the Source-Route
-            processing was successful.
-
-            When tracking interface statistics, the counter of the
-            incoming interface is incremented for each datagram.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipSystemStatsDiscontinuityTime."
-    ::= { ipSystemStatsEntry 12 }
-
-ipSystemStatsHCInForwDatagrams OBJECT-TYPE
-    SYNTAX     Counter64
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of input datagrams for which this entity was not
-            their final IP destination and for which this entity
-            attempted to find a route to forward them to that final
-            destination.  This object counts the same packets as
-            ipSystemStatsInForwDatagrams, but allows for larger values.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipSystemStatsDiscontinuityTime."
-    ::= { ipSystemStatsEntry 13 }
-
-ipSystemStatsReasmReqds OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of IP fragments received that needed to be
-            reassembled at this interface.
-
-            When tracking interface statistics, the counter of the
-            interface to which these fragments were addressed is
-            incremented.  This interface might not be the same as the
-            input interface for some of the fragments.
-
-            Discontinuities in the value of this counter can occur at
-
-
-
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipSystemStatsDiscontinuityTime."
-    ::= { ipSystemStatsEntry 14 }
-
-ipSystemStatsReasmOKs OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of IP datagrams successfully reassembled.
-
-            When tracking interface statistics, the counter of the
-            interface to which these datagrams were addressed is
-            incremented.  This interface might not be the same as the
-            input interface for some of the datagrams.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipSystemStatsDiscontinuityTime."
-    ::= { ipSystemStatsEntry 15 }
-
-ipSystemStatsReasmFails OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of failures detected by the IP re-assembly
-            algorithm (for whatever reason: timed out, errors, etc.).
-            Note that this is not necessarily a count of discarded IP
-            fragments since some algorithms (notably the algorithm in
-            RFC 815) can lose track of the number of fragments by
-            combining them as they are received.
-
-            When tracking interface statistics, the counter of the
-            interface to which these fragments were addressed is
-            incremented.  This interface might not be the same as the
-            input interface for some of the fragments.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipSystemStatsDiscontinuityTime."
-    ::= { ipSystemStatsEntry 16 }
-
-ipSystemStatsInDiscards OBJECT-TYPE
-    SYNTAX     Counter32
-
-
-
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of input IP datagrams for which no problems were
-            encountered to prevent their continued processing, but
-            were discarded (e.g., for lack of buffer space).  Note that
-            this counter does not include any datagrams discarded while
-            awaiting re-assembly.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipSystemStatsDiscontinuityTime."
-    ::= { ipSystemStatsEntry 17 }
-
-ipSystemStatsInDelivers OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of datagrams successfully delivered to IP
-            user-protocols (including ICMP).
-
-            When tracking interface statistics, the counter of the
-            interface to which these datagrams were addressed is
-            incremented.  This interface might not be the same as the
-            input interface for some of the datagrams.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipSystemStatsDiscontinuityTime."
-    ::= { ipSystemStatsEntry 18 }
-
-ipSystemStatsHCInDelivers OBJECT-TYPE
-    SYNTAX     Counter64
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of datagrams successfully delivered to IP
-            user-protocols (including ICMP).  This object counts the
-            same packets as ipSystemStatsInDelivers, but allows for
-            larger values.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipSystemStatsDiscontinuityTime."
-
-
-
-    ::= { ipSystemStatsEntry 19 }
-
-ipSystemStatsOutRequests OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of IP datagrams that local IP user-
-            protocols (including ICMP) supplied to IP in requests for
-            transmission.  Note that this counter does not include any
-            datagrams counted in ipSystemStatsOutForwDatagrams.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipSystemStatsDiscontinuityTime."
-    ::= { ipSystemStatsEntry 20 }
-
-ipSystemStatsHCOutRequests OBJECT-TYPE
-    SYNTAX     Counter64
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of IP datagrams that local IP user-
-            protocols (including ICMP) supplied to IP in requests for
-            transmission.  This object counts the same packets as
-            ipSystemStatsOutRequests, but allows for larger values.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipSystemStatsDiscontinuityTime."
-    ::= { ipSystemStatsEntry 21 }
-
-ipSystemStatsOutNoRoutes OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of locally generated IP datagrams discarded
-            because no route could be found to transmit them to their
-            destination.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipSystemStatsDiscontinuityTime."
-    ::= { ipSystemStatsEntry 22 }
-
-
-
-ipSystemStatsOutForwDatagrams OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of datagrams for which this entity was not their
-            final IP destination and for which it was successful in
-            finding a path to their final destination.  In entities
-            that do not act as IP routers, this counter will include
-            only those datagrams that were Source-Routed via this
-            entity, and the Source-Route processing was successful.
-
-            When tracking interface statistics, the counter of the
-            outgoing interface is incremented for a successfully
-            forwarded datagram.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipSystemStatsDiscontinuityTime."
-    ::= { ipSystemStatsEntry 23 }
-
-ipSystemStatsHCOutForwDatagrams OBJECT-TYPE
-    SYNTAX     Counter64
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of datagrams for which this entity was not their
-            final IP destination and for which it was successful in
-            finding a path to their final destination.  This object
-            counts the same packets as ipSystemStatsOutForwDatagrams,
-            but allows for larger values.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipSystemStatsDiscontinuityTime."
-    ::= { ipSystemStatsEntry 24 }
-
-ipSystemStatsOutDiscards OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of output IP datagrams for which no problem was
-            encountered to prevent their transmission to their
-            destination, but were discarded (e.g., for lack of
-            buffer space).  Note that this counter would include
-
-
-
-            datagrams counted in ipSystemStatsOutForwDatagrams if any
-            such datagrams met this (discretionary) discard criterion.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipSystemStatsDiscontinuityTime."
-    ::= { ipSystemStatsEntry 25 }
-
-ipSystemStatsOutFragReqds OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of IP datagrams that would require fragmentation
-            in order to be transmitted.
-
-            When tracking interface statistics, the counter of the
-            outgoing interface is incremented for a successfully
-            fragmented datagram.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipSystemStatsDiscontinuityTime."
-    ::= { ipSystemStatsEntry 26 }
-
-ipSystemStatsOutFragOKs OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of IP datagrams that have been successfully
-            fragmented.
-
-            When tracking interface statistics, the counter of the
-            outgoing interface is incremented for a successfully
-            fragmented datagram.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipSystemStatsDiscontinuityTime."
-    ::= { ipSystemStatsEntry 27 }
-
-ipSystemStatsOutFragFails OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-
-
-
-    STATUS     current
-    DESCRIPTION
-           "The number of IP datagrams that have been discarded because
-            they needed to be fragmented but could not be.  This
-            includes IPv4 packets that have the DF bit set and IPv6
-            packets that are being forwarded and exceed the outgoing
-            link MTU.
-
-            When tracking interface statistics, the counter of the
-            outgoing interface is incremented for an unsuccessfully
-            fragmented datagram.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipSystemStatsDiscontinuityTime."
-    ::= { ipSystemStatsEntry 28 }
-
-ipSystemStatsOutFragCreates OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of output datagram fragments that have been
-            generated as a result of IP fragmentation.
-
-            When tracking interface statistics, the counter of the
-            outgoing interface is incremented for a successfully
-            fragmented datagram.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipSystemStatsDiscontinuityTime."
-    ::= { ipSystemStatsEntry 29 }
-
-ipSystemStatsOutTransmits OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of IP datagrams that this entity supplied
-            to the lower layers for transmission.  This includes
-            datagrams generated locally and those forwarded by this
-            entity.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-
-
-
-            times as indicated by the value of
-            ipSystemStatsDiscontinuityTime."
-    ::= { ipSystemStatsEntry 30 }
-
-ipSystemStatsHCOutTransmits OBJECT-TYPE
-    SYNTAX     Counter64
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of IP datagrams that this entity supplied
-            to the lower layers for transmission.  This object counts
-            the same datagrams as ipSystemStatsOutTransmits, but allows
-            for larger values.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipSystemStatsDiscontinuityTime."
-    ::= { ipSystemStatsEntry 31 }
-
-ipSystemStatsOutOctets OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of octets in IP datagrams delivered to the
-            lower layers for transmission.  Octets from datagrams
-            counted in ipSystemStatsOutTransmits MUST be counted here.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipSystemStatsDiscontinuityTime."
-    ::= { ipSystemStatsEntry 32 }
-
-ipSystemStatsHCOutOctets OBJECT-TYPE
-    SYNTAX     Counter64
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of octets in IP datagrams delivered to the
-            lower layers for transmission.  This objects counts the same
-            octets as ipSystemStatsOutOctets, but allows for larger
-            values.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-
-
-
-            ipSystemStatsDiscontinuityTime."
-    ::= { ipSystemStatsEntry 33 }
-
-ipSystemStatsInMcastPkts OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of IP multicast datagrams received.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipSystemStatsDiscontinuityTime."
-    ::= { ipSystemStatsEntry 34 }
-
-ipSystemStatsHCInMcastPkts OBJECT-TYPE
-    SYNTAX     Counter64
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of IP multicast datagrams received.  This object
-            counts the same datagrams as ipSystemStatsInMcastPkts but
-            allows for larger values.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipSystemStatsDiscontinuityTime."
-    ::= { ipSystemStatsEntry 35 }
-
-ipSystemStatsInMcastOctets OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of octets received in IP multicast
-            datagrams.  Octets from datagrams counted in
-            ipSystemStatsInMcastPkts MUST be counted here.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipSystemStatsDiscontinuityTime."
-    ::= { ipSystemStatsEntry 36 }
-
-ipSystemStatsHCInMcastOctets OBJECT-TYPE
-    SYNTAX     Counter64
-
-
-
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of octets received in IP multicast
-            datagrams.  This object counts the same octets as
-            ipSystemStatsInMcastOctets, but allows for larger values.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipSystemStatsDiscontinuityTime."
-    ::= { ipSystemStatsEntry 37 }
-
-ipSystemStatsOutMcastPkts OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of IP multicast datagrams transmitted.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipSystemStatsDiscontinuityTime."
-    ::= { ipSystemStatsEntry 38 }
-
-ipSystemStatsHCOutMcastPkts OBJECT-TYPE
-    SYNTAX     Counter64
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of IP multicast datagrams transmitted.  This
-            object counts the same datagrams as
-            ipSystemStatsOutMcastPkts, but allows for larger values.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipSystemStatsDiscontinuityTime."
-    ::= { ipSystemStatsEntry 39 }
-
-ipSystemStatsOutMcastOctets OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of octets transmitted in IP multicast
-            datagrams.  Octets from datagrams counted in
-
-
-
-            ipSystemStatsOutMcastPkts MUST be counted here.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipSystemStatsDiscontinuityTime."
-    ::= { ipSystemStatsEntry 40 }
-
-ipSystemStatsHCOutMcastOctets OBJECT-TYPE
-    SYNTAX     Counter64
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of octets transmitted in IP multicast
-            datagrams.  This object counts the same octets as
-            ipSystemStatsOutMcastOctets, but allows for larger values.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipSystemStatsDiscontinuityTime."
-    ::= { ipSystemStatsEntry 41 }
-
-ipSystemStatsInBcastPkts OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of IP broadcast datagrams received.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipSystemStatsDiscontinuityTime."
-    ::= { ipSystemStatsEntry 42 }
-
-ipSystemStatsHCInBcastPkts OBJECT-TYPE
-    SYNTAX     Counter64
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of IP broadcast datagrams received.  This object
-            counts the same datagrams as ipSystemStatsInBcastPkts but
-            allows for larger values.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-
-
-
-            ipSystemStatsDiscontinuityTime."
-    ::= { ipSystemStatsEntry 43 }
-
-ipSystemStatsOutBcastPkts OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of IP broadcast datagrams transmitted.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipSystemStatsDiscontinuityTime."
-    ::= { ipSystemStatsEntry 44 }
-
-ipSystemStatsHCOutBcastPkts OBJECT-TYPE
-    SYNTAX     Counter64
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of IP broadcast datagrams transmitted.  This
-            object counts the same datagrams as
-            ipSystemStatsOutBcastPkts, but allows for larger values.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipSystemStatsDiscontinuityTime."
-    ::= { ipSystemStatsEntry 45 }
-
-ipSystemStatsDiscontinuityTime OBJECT-TYPE
-    SYNTAX     TimeStamp
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The value of sysUpTime on the most recent occasion at which
-            any one or more of this entry's counters suffered a
-            discontinuity.
-
-            If no such discontinuities have occurred since the last re-
-            initialization of the local management subsystem, then this
-            object contains a zero value."
-    ::= { ipSystemStatsEntry 46 }
-
-ipSystemStatsRefreshRate OBJECT-TYPE
-    SYNTAX     Unsigned32
-    UNITS      "milli-seconds"
-
-
-
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The minimum reasonable polling interval for this entry.
-            This object provides an indication of the minimum amount of
-            time required to update the counters in this entry."
-    ::= { ipSystemStatsEntry 47 }
-
-ipIfStatsTableLastChange OBJECT-TYPE
-    SYNTAX     TimeStamp
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The value of sysUpTime on the most recent occasion at which
-            a row in the ipIfStatsTable was added or deleted.
-
-            If new objects are added to the ipIfStatsTable that require
-            the ipIfStatsTableLastChange to be updated when they are
-            modified, they must specify that requirement in their
-            description clause."
-    ::= { ipTrafficStats 2 }
-
-ipIfStatsTable OBJECT-TYPE
-    SYNTAX     SEQUENCE OF IpIfStatsEntry
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "The table containing per-interface traffic statistics.  This
-            table and the ipSystemStatsTable contain similar objects
-            whose difference is in their granularity.  Where this table
-            contains per-interface statistics, the ipSystemStatsTable
-            contains the same statistics, but counted on a system wide
-            basis."
-    ::= { ipTrafficStats 3 }
-
-ipIfStatsEntry OBJECT-TYPE
-    SYNTAX     IpIfStatsEntry
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "An interface statistics entry containing objects for a
-            particular interface and version of IP."
-    INDEX { ipIfStatsIPVersion, ipIfStatsIfIndex }
-    ::= { ipIfStatsTable 1 }
-
-IpIfStatsEntry ::= SEQUENCE {
-        ipIfStatsIPVersion           InetVersion,
-        ipIfStatsIfIndex             InterfaceIndex,
-
-
-
-        ipIfStatsInReceives          Counter32,
-        ipIfStatsHCInReceives        Counter64,
-        ipIfStatsInOctets            Counter32,
-        ipIfStatsHCInOctets          Counter64,
-        ipIfStatsInHdrErrors         Counter32,
-        ipIfStatsInNoRoutes          Counter32,
-        ipIfStatsInAddrErrors        Counter32,
-        ipIfStatsInUnknownProtos     Counter32,
-        ipIfStatsInTruncatedPkts     Counter32,
-        ipIfStatsInForwDatagrams     Counter32,
-        ipIfStatsHCInForwDatagrams   Counter64,
-        ipIfStatsReasmReqds          Counter32,
-        ipIfStatsReasmOKs            Counter32,
-        ipIfStatsReasmFails          Counter32,
-        ipIfStatsInDiscards          Counter32,
-        ipIfStatsInDelivers          Counter32,
-        ipIfStatsHCInDelivers        Counter64,
-        ipIfStatsOutRequests         Counter32,
-        ipIfStatsHCOutRequests       Counter64,
-        ipIfStatsOutForwDatagrams    Counter32,
-        ipIfStatsHCOutForwDatagrams  Counter64,
-        ipIfStatsOutDiscards         Counter32,
-        ipIfStatsOutFragReqds        Counter32,
-        ipIfStatsOutFragOKs          Counter32,
-        ipIfStatsOutFragFails        Counter32,
-        ipIfStatsOutFragCreates      Counter32,
-        ipIfStatsOutTransmits        Counter32,
-        ipIfStatsHCOutTransmits      Counter64,
-        ipIfStatsOutOctets           Counter32,
-        ipIfStatsHCOutOctets         Counter64,
-        ipIfStatsInMcastPkts         Counter32,
-        ipIfStatsHCInMcastPkts       Counter64,
-        ipIfStatsInMcastOctets       Counter32,
-        ipIfStatsHCInMcastOctets     Counter64,
-        ipIfStatsOutMcastPkts        Counter32,
-        ipIfStatsHCOutMcastPkts      Counter64,
-        ipIfStatsOutMcastOctets      Counter32,
-        ipIfStatsHCOutMcastOctets    Counter64,
-        ipIfStatsInBcastPkts         Counter32,
-        ipIfStatsHCInBcastPkts       Counter64,
-        ipIfStatsOutBcastPkts        Counter32,
-        ipIfStatsHCOutBcastPkts      Counter64,
-        ipIfStatsDiscontinuityTime   TimeStamp,
-        ipIfStatsRefreshRate         Unsigned32
-    }
-
-ipIfStatsIPVersion OBJECT-TYPE
-    SYNTAX     InetVersion
-
-
-
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "The IP version of this row."
-    ::= { ipIfStatsEntry 1 }
-
-ipIfStatsIfIndex OBJECT-TYPE
-    SYNTAX     InterfaceIndex
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "The index value that uniquely identifies the interface to
-            which this entry is applicable.  The interface identified by
-            a particular value of this index is the same interface as
-            identified by the same value of the IF-MIB's ifIndex."
-    ::= { ipIfStatsEntry 2 }
-
-ipIfStatsInReceives OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of input IP datagrams received, including
-            those received in error.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipIfStatsDiscontinuityTime."
-    ::= { ipIfStatsEntry 3 }
-
-ipIfStatsHCInReceives OBJECT-TYPE
-    SYNTAX     Counter64
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of input IP datagrams received, including
-            those received in error.  This object counts the same
-            datagrams as ipIfStatsInReceives, but allows for larger
-            values.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipIfStatsDiscontinuityTime."
-    ::= { ipIfStatsEntry 4 }
-
-ipIfStatsInOctets OBJECT-TYPE
-
-
-
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of octets received in input IP datagrams,
-            including those received in error.  Octets from datagrams
-            counted in ipIfStatsInReceives MUST be counted here.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipIfStatsDiscontinuityTime."
-    ::= { ipIfStatsEntry 5 }
-
-ipIfStatsHCInOctets OBJECT-TYPE
-    SYNTAX     Counter64
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of octets received in input IP datagrams,
-            including those received in error.  This object counts the
-            same octets as ipIfStatsInOctets, but allows for larger
-            values.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipIfStatsDiscontinuityTime."
-    ::= { ipIfStatsEntry 6 }
-
-ipIfStatsInHdrErrors OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of input IP datagrams discarded due to errors in
-            their IP headers, including version number mismatch, other
-            format errors, hop count exceeded, errors discovered in
-            processing their IP options, etc.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipIfStatsDiscontinuityTime."
-    ::= { ipIfStatsEntry 7 }
-
-ipIfStatsInNoRoutes OBJECT-TYPE
-    SYNTAX     Counter32
-
-
-
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of input IP datagrams discarded because no route
-            could be found to transmit them to their destination.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipIfStatsDiscontinuityTime."
-    ::= { ipIfStatsEntry 8 }
-
-ipIfStatsInAddrErrors OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of input IP datagrams discarded because the IP
-            address in their IP header's destination field was not a
-            valid address to be received at this entity.  This count
-            includes invalid addresses (e.g., ::0).  For entities that
-            are not IP routers and therefore do not forward datagrams,
-            this counter includes datagrams discarded because the
-            destination address was not a local address.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipIfStatsDiscontinuityTime."
-    ::= { ipIfStatsEntry 9 }
-
-ipIfStatsInUnknownProtos OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of locally-addressed IP datagrams received
-            successfully but discarded because of an unknown or
-            unsupported protocol.
-
-            When tracking interface statistics, the counter of the
-            interface to which these datagrams were addressed is
-            incremented.  This interface might not be the same as the
-            input interface for some of the datagrams.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-
-
-
-            ipIfStatsDiscontinuityTime."
-    ::= { ipIfStatsEntry 10 }
-
-ipIfStatsInTruncatedPkts OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of input IP datagrams discarded because the
-            datagram frame didn't carry enough data.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipIfStatsDiscontinuityTime."
-    ::= { ipIfStatsEntry 11 }
-
-ipIfStatsInForwDatagrams OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of input datagrams for which this entity was not
-            their final IP destination and for which this entity
-            attempted to find a route to forward them to that final
-            destination.  In entities that do not act as IP routers,
-            this counter will include only those datagrams that were
-            Source-Routed via this entity, and the Source-Route
-            processing was successful.
-
-            When tracking interface statistics, the counter of the
-            incoming interface is incremented for each datagram.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipIfStatsDiscontinuityTime."
-    ::= { ipIfStatsEntry 12 }
-
-ipIfStatsHCInForwDatagrams OBJECT-TYPE
-    SYNTAX     Counter64
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of input datagrams for which this entity was not
-            their final IP destination and for which this entity
-            attempted to find a route to forward them to that final
-            destination.  This object counts the same packets as
-
-
-
-            ipIfStatsInForwDatagrams, but allows for larger values.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipIfStatsDiscontinuityTime."
-    ::= { ipIfStatsEntry 13 }
-
-ipIfStatsReasmReqds OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of IP fragments received that needed to be
-            reassembled at this interface.
-
-            When tracking interface statistics, the counter of the
-            interface to which these fragments were addressed is
-            incremented.  This interface might not be the same as the
-            input interface for some of the fragments.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipIfStatsDiscontinuityTime."
-    ::= { ipIfStatsEntry 14 }
-
-ipIfStatsReasmOKs OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of IP datagrams successfully reassembled.
-
-            When tracking interface statistics, the counter of the
-            interface to which these datagrams were addressed is
-            incremented.  This interface might not be the same as the
-            input interface for some of the datagrams.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipIfStatsDiscontinuityTime."
-    ::= { ipIfStatsEntry 15 }
-
-ipIfStatsReasmFails OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-
-
-
-    STATUS     current
-    DESCRIPTION
-           "The number of failures detected by the IP re-assembly
-            algorithm (for whatever reason: timed out, errors, etc.).
-            Note that this is not necessarily a count of discarded IP
-            fragments since some algorithms (notably the algorithm in
-            RFC 815) can lose track of the number of fragments by
-            combining them as they are received.
-
-            When tracking interface statistics, the counter of the
-            interface to which these fragments were addressed is
-            incremented.  This interface might not be the same as the
-            input interface for some of the fragments.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipIfStatsDiscontinuityTime."
-    ::= { ipIfStatsEntry 16 }
-
-ipIfStatsInDiscards OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of input IP datagrams for which no problems were
-            encountered to prevent their continued processing, but
-            were discarded (e.g., for lack of buffer space).  Note that
-            this counter does not include any datagrams discarded while
-            awaiting re-assembly.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipIfStatsDiscontinuityTime."
-    ::= { ipIfStatsEntry 17 }
-
-ipIfStatsInDelivers OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of datagrams successfully delivered to IP
-            user-protocols (including ICMP).
-
-            When tracking interface statistics, the counter of the
-            interface to which these datagrams were addressed is
-            incremented.  This interface might not be the same as the
-
-
-
-            input interface for some of the datagrams.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipIfStatsDiscontinuityTime."
-    ::= { ipIfStatsEntry 18 }
-
-ipIfStatsHCInDelivers OBJECT-TYPE
-    SYNTAX     Counter64
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of datagrams successfully delivered to IP
-            user-protocols (including ICMP).  This object counts the
-            same packets as ipIfStatsInDelivers, but allows for larger
-            values.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipIfStatsDiscontinuityTime."
-    ::= { ipIfStatsEntry 19 }
-
-ipIfStatsOutRequests OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of IP datagrams that local IP user-
-            protocols (including ICMP) supplied to IP in requests for
-            transmission.  Note that this counter does not include any
-            datagrams counted in ipIfStatsOutForwDatagrams.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipIfStatsDiscontinuityTime."
-    ::= { ipIfStatsEntry 20 }
-
-ipIfStatsHCOutRequests OBJECT-TYPE
-    SYNTAX     Counter64
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of IP datagrams that local IP user-
-            protocols (including ICMP) supplied to IP in requests for
-            transmission.  This object counts the same packets as
-
-
-
-            ipIfStatsOutRequests, but allows for larger values.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipIfStatsDiscontinuityTime."
-    ::= { ipIfStatsEntry 21 }
-
--- This object ID is reserved to allow the IDs for this table's objects
--- to align with the objects in the ipSystemStatsTable.
--- ::= {ipIfStatsEntry 22}
-
-ipIfStatsOutForwDatagrams OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of datagrams for which this entity was not their
-            final IP destination and for which it was successful in
-            finding a path to their final destination.  In entities
-            that do not act as IP routers, this counter will include
-            only those datagrams that were Source-Routed via this
-            entity, and the Source-Route processing was successful.
-
-            When tracking interface statistics, the counter of the
-            outgoing interface is incremented for a successfully
-            forwarded datagram.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipIfStatsDiscontinuityTime."
-    ::= { ipIfStatsEntry 23 }
-
-ipIfStatsHCOutForwDatagrams OBJECT-TYPE
-    SYNTAX     Counter64
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of datagrams for which this entity was not their
-            final IP destination and for which it was successful in
-            finding a path to their final destination.  This object
-            counts the same packets as ipIfStatsOutForwDatagrams, but
-            allows for larger values.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-
-
-
-            ipIfStatsDiscontinuityTime."
-    ::= { ipIfStatsEntry 24 }
-
-ipIfStatsOutDiscards OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of output IP datagrams for which no problem was
-            encountered to prevent their transmission to their
-            destination, but were discarded (e.g., for lack of
-            buffer space).  Note that this counter would include
-            datagrams counted in ipIfStatsOutForwDatagrams if any such
-            datagrams met this (discretionary) discard criterion.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipIfStatsDiscontinuityTime."
-    ::= { ipIfStatsEntry 25 }
-
-ipIfStatsOutFragReqds OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of IP datagrams that would require fragmentation
-            in order to be transmitted.
-
-            When tracking interface statistics, the counter of the
-            outgoing interface is incremented for a successfully
-            fragmented datagram.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipIfStatsDiscontinuityTime."
-    ::= { ipIfStatsEntry 26 }
-
-ipIfStatsOutFragOKs OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of IP datagrams that have been successfully
-            fragmented.
-
-            When tracking interface statistics, the counter of the
-
-
-
-            outgoing interface is incremented for a successfully
-            fragmented datagram.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipIfStatsDiscontinuityTime."
-    ::= { ipIfStatsEntry 27 }
-
-ipIfStatsOutFragFails OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of IP datagrams that have been discarded because
-            they needed to be fragmented but could not be.  This
-            includes IPv4 packets that have the DF bit set and IPv6
-            packets that are being forwarded and exceed the outgoing
-            link MTU.
-
-            When tracking interface statistics, the counter of the
-            outgoing interface is incremented for an unsuccessfully
-            fragmented datagram.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipIfStatsDiscontinuityTime."
-    ::= { ipIfStatsEntry 28 }
-
-ipIfStatsOutFragCreates OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of output datagram fragments that have been
-            generated as a result of IP fragmentation.
-
-            When tracking interface statistics, the counter of the
-            outgoing interface is incremented for a successfully
-            fragmented datagram.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipIfStatsDiscontinuityTime."
-    ::= { ipIfStatsEntry 29 }
-
-
-
-
-ipIfStatsOutTransmits OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of IP datagrams that this entity supplied
-            to the lower layers for transmission.  This includes
-            datagrams generated locally and those forwarded by this
-            entity.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipIfStatsDiscontinuityTime."
-    ::= { ipIfStatsEntry 30 }
-
-ipIfStatsHCOutTransmits OBJECT-TYPE
-    SYNTAX     Counter64
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of IP datagrams that this entity supplied
-            to the lower layers for transmission.  This object counts
-            the same datagrams as ipIfStatsOutTransmits, but allows for
-            larger values.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipIfStatsDiscontinuityTime."
-    ::= { ipIfStatsEntry 31 }
-
-ipIfStatsOutOctets OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of octets in IP datagrams delivered to the
-            lower layers for transmission.  Octets from datagrams
-            counted in ipIfStatsOutTransmits MUST be counted here.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipIfStatsDiscontinuityTime."
-    ::= { ipIfStatsEntry 32 }
-
-ipIfStatsHCOutOctets OBJECT-TYPE
-
-
-
-    SYNTAX     Counter64
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of octets in IP datagrams delivered to the
-            lower layers for transmission.  This objects counts the same
-            octets as ipIfStatsOutOctets, but allows for larger values.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipIfStatsDiscontinuityTime."
-    ::= { ipIfStatsEntry 33 }
-
-ipIfStatsInMcastPkts OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of IP multicast datagrams received.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipIfStatsDiscontinuityTime."
-    ::= { ipIfStatsEntry 34 }
-
-ipIfStatsHCInMcastPkts OBJECT-TYPE
-    SYNTAX     Counter64
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of IP multicast datagrams received.  This object
-            counts the same datagrams as ipIfStatsInMcastPkts, but
-            allows for larger values.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipIfStatsDiscontinuityTime."
-    ::= { ipIfStatsEntry 35 }
-
-ipIfStatsInMcastOctets OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of octets received in IP multicast
-
-
-
-            datagrams.  Octets from datagrams counted in
-            ipIfStatsInMcastPkts MUST be counted here.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipIfStatsDiscontinuityTime."
-    ::= { ipIfStatsEntry 36 }
-
-ipIfStatsHCInMcastOctets OBJECT-TYPE
-    SYNTAX     Counter64
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of octets received in IP multicast
-            datagrams.  This object counts the same octets as
-            ipIfStatsInMcastOctets, but allows for larger values.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipIfStatsDiscontinuityTime."
-    ::= { ipIfStatsEntry 37 }
-
-ipIfStatsOutMcastPkts OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of IP multicast datagrams transmitted.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipIfStatsDiscontinuityTime."
-    ::= { ipIfStatsEntry 38 }
-
-ipIfStatsHCOutMcastPkts OBJECT-TYPE
-    SYNTAX     Counter64
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of IP multicast datagrams transmitted.  This
-            object counts the same datagrams as ipIfStatsOutMcastPkts,
-            but allows for larger values.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-
-
-
-            times as indicated by the value of
-            ipIfStatsDiscontinuityTime."
-    ::= { ipIfStatsEntry 39 }
-
-ipIfStatsOutMcastOctets OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of octets transmitted in IP multicast
-            datagrams.  Octets from datagrams counted in
-            ipIfStatsOutMcastPkts MUST be counted here.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipIfStatsDiscontinuityTime."
-    ::= { ipIfStatsEntry 40 }
-
-ipIfStatsHCOutMcastOctets OBJECT-TYPE
-    SYNTAX     Counter64
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of octets transmitted in IP multicast
-            datagrams.  This object counts the same octets as
-            ipIfStatsOutMcastOctets, but allows for larger values.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipIfStatsDiscontinuityTime."
-    ::= { ipIfStatsEntry 41 }
-
-ipIfStatsInBcastPkts OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of IP broadcast datagrams received.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipIfStatsDiscontinuityTime."
-    ::= { ipIfStatsEntry 42 }
-
-ipIfStatsHCInBcastPkts OBJECT-TYPE
-
-
-
-    SYNTAX     Counter64
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of IP broadcast datagrams received.  This object
-            counts the same datagrams as ipIfStatsInBcastPkts, but
-            allows for larger values.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipIfStatsDiscontinuityTime."
-    ::= { ipIfStatsEntry 43 }
-
-ipIfStatsOutBcastPkts OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of IP broadcast datagrams transmitted.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipIfStatsDiscontinuityTime."
-    ::= { ipIfStatsEntry 44 }
-
-ipIfStatsHCOutBcastPkts OBJECT-TYPE
-    SYNTAX     Counter64
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of IP broadcast datagrams transmitted.  This
-            object counts the same datagrams as ipIfStatsOutBcastPkts,
-            but allows for larger values.
-
-            Discontinuities in the value of this counter can occur at
-            re-initialization of the management system, and at other
-            times as indicated by the value of
-            ipIfStatsDiscontinuityTime."
-    ::= { ipIfStatsEntry 45 }
-
-ipIfStatsDiscontinuityTime OBJECT-TYPE
-    SYNTAX     TimeStamp
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The value of sysUpTime on the most recent occasion at which
-
-
-
-            any one or more of this entry's counters suffered a
-            discontinuity.
-
-            If no such discontinuities have occurred since the last re-
-            initialization of the local management subsystem, then this
-            object contains a zero value."
-    ::= { ipIfStatsEntry 46 }
-
-ipIfStatsRefreshRate OBJECT-TYPE
-    SYNTAX     Unsigned32
-    UNITS "milli-seconds"
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The minimum reasonable polling interval for this entry.
-            This object provides an indication of the minimum amount of
-            time required to update the counters in this entry."
-    ::= { ipIfStatsEntry 47 }
-
---
--- Internet Address Prefix table
---
-
-ipAddressPrefixTable OBJECT-TYPE
-    SYNTAX     SEQUENCE OF IpAddressPrefixEntry
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "This table allows the user to determine the source of an IP
-            address or set of IP addresses, and allows other tables to
-            share the information via pointer rather than by copying.
-
-            For example, when the node configures both a unicast and
-            anycast address for a prefix, the ipAddressPrefix objects
-            for those addresses will point to a single row in this
-            table.
-
-            This table primarily provides support for IPv6 prefixes, and
-            several of the objects are less meaningful for IPv4.  The
-            table continues to allow IPv4 addresses to allow future
-            flexibility.  In order to promote a common configuration,
-            this document includes suggestions for default values for
-            IPv4 prefixes.  Each of these values may be overridden if an
-            object is meaningful to the node.
-
-            All prefixes used by this entity should be included in this
-            table independent of how the entity learned the prefix.
-            (This table isn't limited to prefixes learned from router
-
-
-
-            advertisements.)"
-    ::= { ip 32 }
-
-ipAddressPrefixEntry OBJECT-TYPE
-    SYNTAX     IpAddressPrefixEntry
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "An entry in the ipAddressPrefixTable."
-    INDEX    { ipAddressPrefixIfIndex, ipAddressPrefixType,
-               ipAddressPrefixPrefix, ipAddressPrefixLength }
-    ::= { ipAddressPrefixTable 1 }
-
-IpAddressPrefixEntry ::= SEQUENCE {
-        ipAddressPrefixIfIndex               InterfaceIndex,
-        ipAddressPrefixType                  InetAddressType,
-        ipAddressPrefixPrefix                InetAddress,
-        ipAddressPrefixLength                InetAddressPrefixLength,
-        ipAddressPrefixOrigin                IpAddressPrefixOriginTC,
-        ipAddressPrefixOnLinkFlag            TruthValue,
-        ipAddressPrefixAutonomousFlag        TruthValue,
-        ipAddressPrefixAdvPreferredLifetime  Unsigned32,
-        ipAddressPrefixAdvValidLifetime      Unsigned32
-    }
-
-ipAddressPrefixIfIndex OBJECT-TYPE
-    SYNTAX     InterfaceIndex
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "The index value that uniquely identifies the interface on
-            which this prefix is configured.  The interface identified
-            by a particular value of this index is the same interface as
-            identified by the same value of the IF-MIB's ifIndex."
-    ::= { ipAddressPrefixEntry 1 }
-
-ipAddressPrefixType OBJECT-TYPE
-    SYNTAX     InetAddressType
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "The address type of ipAddressPrefix."
-    ::= { ipAddressPrefixEntry 2 }
-
-ipAddressPrefixPrefix OBJECT-TYPE
-    SYNTAX     InetAddress
-    MAX-ACCESS not-accessible
-    STATUS     current
-
-
-
-    DESCRIPTION
-           "The address prefix.  The address type of this object is
-            specified in ipAddressPrefixType.  The length of this object
-            is the standard length for objects of that type (4 or 16
-            bytes).  Any bits after ipAddressPrefixLength must be zero.
-
-            Implementors need to be aware that, if the size of
-            ipAddressPrefixPrefix exceeds 114 octets, then OIDS of
-            instances of columns in this row will have more than 128
-            sub-identifiers and cannot be accessed using SNMPv1,
-            SNMPv2c, or SNMPv3."
-    ::= { ipAddressPrefixEntry 3 }
-
-ipAddressPrefixLength OBJECT-TYPE
-    SYNTAX     InetAddressPrefixLength
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "The prefix length associated with this prefix.
-
-            The value 0 has no special meaning for this object.  It
-            simply refers to address '::/0'."
-    ::= { ipAddressPrefixEntry 4 }
-
-ipAddressPrefixOrigin OBJECT-TYPE
-    SYNTAX     IpAddressPrefixOriginTC
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The origin of this prefix."
-    ::= { ipAddressPrefixEntry 5 }
-
-ipAddressPrefixOnLinkFlag OBJECT-TYPE
-    SYNTAX     TruthValue
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "This object has the value 'true(1)', if this prefix can be
-            used for on-link determination; otherwise, the value is
-            'false(2)'.
-
-            The default for IPv4 prefixes is 'true(1)'."
-    REFERENCE "For IPv6 RFC 2461, especially sections 2 and 4.6.2 and
-               RFC 2462"
-    ::= { ipAddressPrefixEntry 6 }
-
-ipAddressPrefixAutonomousFlag OBJECT-TYPE
-    SYNTAX     TruthValue
-
-
-
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "Autonomous address configuration flag.  When true(1),
-            indicates that this prefix can be used for autonomous
-            address configuration (i.e., can be used to form a local
-            interface address).  If false(2), it is not used to auto-
-            configure a local interface address.
-
-            The default for IPv4 prefixes is 'false(2)'."
-    REFERENCE "For IPv6 RFC 2461, especially sections 2 and 4.6.2 and
-               RFC 2462"
-    ::= { ipAddressPrefixEntry 7 }
-
-ipAddressPrefixAdvPreferredLifetime OBJECT-TYPE
-    SYNTAX     Unsigned32
-    UNITS      "seconds"
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The remaining length of time, in seconds, that this prefix
-            will continue to be preferred, i.e., time until deprecation.
-
-            A value of 4,294,967,295 represents infinity.
-
-            The address generated from a deprecated prefix should no
-            longer be used as a source address in new communications,
-            but packets received on such an interface are processed as
-            expected.
-
-            The default for IPv4 prefixes is 4,294,967,295 (infinity)."
-    REFERENCE "For IPv6 RFC 2461, especially sections 2 and 4.6.2 and
-               RFC 2462"
-    ::= { ipAddressPrefixEntry 8 }
-
-ipAddressPrefixAdvValidLifetime OBJECT-TYPE
-    SYNTAX     Unsigned32
-    UNITS       "seconds"
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The remaining length of time, in seconds, that this prefix
-            will continue to be valid, i.e., time until invalidation.  A
-            value of 4,294,967,295 represents infinity.
-
-            The address generated from an invalidated prefix should not
-            appear as the destination or source address of a packet.
-
-
-
-
-            The default for IPv4 prefixes is 4,294,967,295 (infinity)."
-    REFERENCE "For IPv6 RFC 2461, especially sections 2 and 4.6.2 and
-               RFC 2462"
-    ::= { ipAddressPrefixEntry 9 }
-
---
--- Internet Address Table
---
-
-ipAddressSpinLock OBJECT-TYPE
-    SYNTAX     TestAndIncr
-    MAX-ACCESS read-write
-    STATUS     current
-    DESCRIPTION
-           "An advisory lock used to allow cooperating SNMP managers to
-            coordinate their use of the set operation in creating or
-            modifying rows within this table.
-
-            In order to use this lock to coordinate the use of set
-            operations, managers should first retrieve
-            ipAddressTableSpinLock.  They should then determine the
-            appropriate row to create or modify.  Finally, they should
-            issue the appropriate set command, including the retrieved
-            value of ipAddressSpinLock.  If another manager has altered
-            the table in the meantime, then the value of
-            ipAddressSpinLock will have changed, and the creation will
-            fail as it will be specifying an incorrect value for
-            ipAddressSpinLock.  It is suggested, but not required, that
-            the ipAddressSpinLock be the first var bind for each set of
-            objects representing a 'row' in a PDU."
-    ::= { ip 33 }
-
-ipAddressTable OBJECT-TYPE
-    SYNTAX     SEQUENCE OF IpAddressEntry
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "This table contains addressing information relevant to the
-            entity's interfaces.
-
-            This table does not contain multicast address information.
-            Tables for such information should be contained in multicast
-            specific MIBs, such as RFC 3019.
-
-            While this table is writable, the user will note that
-            several objects, such as ipAddressOrigin, are not.  The
-            intention in allowing a user to write to this table is to
-            allow them to add or remove any entry that isn't
-
-
-
-            permanent.  The user should be allowed to modify objects
-            and entries when that would not cause inconsistencies
-            within the table.  Allowing write access to objects, such
-            as ipAddressOrigin, could allow a user to insert an entry
-            and then label it incorrectly.
-
-            Note well: When including IPv6 link-local addresses in this
-            table, the entry must use an InetAddressType of 'ipv6z' in
-            order to differentiate between the possible interfaces."
-    ::= { ip 34 }
-
-ipAddressEntry OBJECT-TYPE
-    SYNTAX     IpAddressEntry
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "An address mapping for a particular interface."
-    INDEX { ipAddressAddrType, ipAddressAddr }
-    ::= { ipAddressTable 1 }
-
-IpAddressEntry ::= SEQUENCE {
-        ipAddressAddrType     InetAddressType,
-        ipAddressAddr         InetAddress,
-        ipAddressIfIndex      InterfaceIndex,
-        ipAddressType         INTEGER,
-        ipAddressPrefix       RowPointer,
-        ipAddressOrigin       IpAddressOriginTC,
-        ipAddressStatus       IpAddressStatusTC,
-        ipAddressCreated      TimeStamp,
-        ipAddressLastChanged  TimeStamp,
-        ipAddressRowStatus    RowStatus,
-        ipAddressStorageType  StorageType
-    }
-
-ipAddressAddrType OBJECT-TYPE
-    SYNTAX     InetAddressType
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "The address type of ipAddressAddr."
-    ::= { ipAddressEntry 1 }
-
-ipAddressAddr OBJECT-TYPE
-    SYNTAX     InetAddress
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "The IP address to which this entry's addressing information
-
-
-
-            pertains.  The address type of this object is specified in
-            ipAddressAddrType.
-
-            Implementors need to be aware that if the size of
-            ipAddressAddr exceeds 116 octets, then OIDS of instances of
-            columns in this row will have more than 128 sub-identifiers
-            and cannot be accessed using SNMPv1, SNMPv2c, or SNMPv3."
-    ::= { ipAddressEntry 2 }
-
-ipAddressIfIndex OBJECT-TYPE
-    SYNTAX     InterfaceIndex
-    MAX-ACCESS read-create
-    STATUS     current
-    DESCRIPTION
-           "The index value that uniquely identifies the interface to
-            which this entry is applicable.  The interface identified by
-            a particular value of this index is the same interface as
-            identified by the same value of the IF-MIB's ifIndex."
-    ::= { ipAddressEntry 3 }
-
-ipAddressType OBJECT-TYPE
-    SYNTAX     INTEGER {
-                 unicast(1),
-                 anycast(2),
-                 broadcast(3)
-    }
-    MAX-ACCESS read-create
-    STATUS     current
-    DESCRIPTION
-           "The type of address.  broadcast(3) is not a valid value for
-            IPv6 addresses (RFC 3513)."
-    DEFVAL { unicast }
-    ::= { ipAddressEntry 4 }
-
-ipAddressPrefix OBJECT-TYPE
-    SYNTAX     RowPointer
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "A pointer to the row in the prefix table to which this
-            address belongs.  May be { 0 0 } if there is no such row."
-    DEFVAL { zeroDotZero }
-    ::= { ipAddressEntry 5 }
-
-ipAddressOrigin OBJECT-TYPE
-    SYNTAX     IpAddressOriginTC
-    MAX-ACCESS read-only
-    STATUS     current
-
-
-
-    DESCRIPTION
-           "The origin of the address."
-    ::= { ipAddressEntry 6 }
-
-ipAddressStatus OBJECT-TYPE
-    SYNTAX     IpAddressStatusTC
-    MAX-ACCESS read-create
-    STATUS     current
-    DESCRIPTION
-           "The status of the address, describing if the address can be
-            used for communication.
-
-            In the absence of other information, an IPv4 address is
-            always preferred(1)."
-    DEFVAL { preferred }
-    ::= { ipAddressEntry 7 }
-
-ipAddressCreated OBJECT-TYPE
-    SYNTAX     TimeStamp
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The value of sysUpTime at the time this entry was created.
-            If this entry was created prior to the last re-
-            initialization of the local network management subsystem,
-            then this object contains a zero value."
-    ::= { ipAddressEntry 8 }
-
-ipAddressLastChanged OBJECT-TYPE
-    SYNTAX     TimeStamp
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The value of sysUpTime at the time this entry was last
-            updated.  If this entry was updated prior to the last re-
-            initialization of the local network management subsystem,
-            then this object contains a zero value."
-    ::= { ipAddressEntry 9 }
-
-ipAddressRowStatus OBJECT-TYPE
-    SYNTAX     RowStatus
-    MAX-ACCESS read-create
-    STATUS     current
-    DESCRIPTION
-           "The status of this conceptual row.
-
-            The RowStatus TC requires that this DESCRIPTION clause
-            states under which circumstances other objects in this row
-
-
-
-            can be modified.  The value of this object has no effect on
-            whether other objects in this conceptual row can be
-            modified.
-
-            A conceptual row can not be made active until the
-            ipAddressIfIndex has been set to a valid index."
-    ::= { ipAddressEntry 10 }
-
-ipAddressStorageType OBJECT-TYPE
-    SYNTAX     StorageType
-    MAX-ACCESS read-create
-    STATUS     current
-    DESCRIPTION
-           "The storage type for this conceptual row.  If this object
-            has a value of 'permanent', then no other objects are
-            required to be able to be modified."
-    DEFVAL { volatile }
-    ::= { ipAddressEntry 11 }
-
---
--- the Internet Address Translation table
---
-
-ipNetToPhysicalTable OBJECT-TYPE
-    SYNTAX     SEQUENCE OF IpNetToPhysicalEntry
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "The IP Address Translation table used for mapping from IP
-            addresses to physical addresses.
-
-            The Address Translation tables contain the IP address to
-            'physical' address equivalences.  Some interfaces do not use
-            translation tables for determining address equivalences
-            (e.g., DDN-X.25 has an algorithmic method); if all
-            interfaces are of this type, then the Address Translation
-            table is empty, i.e., has zero entries.
-
-            While many protocols may be used to populate this table, ARP
-            and Neighbor Discovery are the most likely
-            options."
-    REFERENCE "RFC 826 and RFC 2461"
-    ::= { ip 35 }
-
-ipNetToPhysicalEntry OBJECT-TYPE
-    SYNTAX     IpNetToPhysicalEntry
-    MAX-ACCESS not-accessible
-    STATUS     current
-
-
-
-    DESCRIPTION
-           "Each entry contains one IP address to `physical' address
-            equivalence."
-    INDEX       { ipNetToPhysicalIfIndex,
-                  ipNetToPhysicalNetAddressType,
-                  ipNetToPhysicalNetAddress }
-    ::= { ipNetToPhysicalTable 1 }
-
-IpNetToPhysicalEntry ::= SEQUENCE {
-        ipNetToPhysicalIfIndex         InterfaceIndex,
-        ipNetToPhysicalNetAddressType  InetAddressType,
-        ipNetToPhysicalNetAddress      InetAddress,
-        ipNetToPhysicalPhysAddress     PhysAddress,
-        ipNetToPhysicalLastUpdated     TimeStamp,
-        ipNetToPhysicalType            INTEGER,
-        ipNetToPhysicalState           INTEGER,
-        ipNetToPhysicalRowStatus       RowStatus
-    }
-
-ipNetToPhysicalIfIndex OBJECT-TYPE
-    SYNTAX     InterfaceIndex
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "The index value that uniquely identifies the interface to
-            which this entry is applicable.  The interface identified by
-            a particular value of this index is the same interface as
-            identified by the same value of the IF-MIB's ifIndex."
-    ::= { ipNetToPhysicalEntry 1 }
-
-ipNetToPhysicalNetAddressType OBJECT-TYPE
-    SYNTAX     InetAddressType
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "The type of ipNetToPhysicalNetAddress."
-    ::= { ipNetToPhysicalEntry 2 }
-
-ipNetToPhysicalNetAddress OBJECT-TYPE
-    SYNTAX     InetAddress
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "The IP Address corresponding to the media-dependent
-            `physical' address.  The address type of this object is
-            specified in ipNetToPhysicalAddressType.
-
-            Implementors need to be aware that if the size of
-
-
-
-            ipNetToPhysicalNetAddress exceeds 115 octets, then OIDS of
-            instances of columns in this row will have more than 128
-            sub-identifiers and cannot be accessed using SNMPv1,
-            SNMPv2c, or SNMPv3."
-    ::= { ipNetToPhysicalEntry 3 }
-
-ipNetToPhysicalPhysAddress OBJECT-TYPE
-    SYNTAX     PhysAddress (SIZE(0..65535))
-    MAX-ACCESS read-create
-    STATUS     current
-    DESCRIPTION
-           "The media-dependent `physical' address.
-
-            As the entries in this table are typically not persistent
-            when this object is written the entity SHOULD NOT save the
-            change to non-volatile storage."
-    ::= { ipNetToPhysicalEntry 4 }
-
-ipNetToPhysicalLastUpdated OBJECT-TYPE
-    SYNTAX     TimeStamp
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The value of sysUpTime at the time this entry was last
-            updated.  If this entry was updated prior to the last re-
-            initialization of the local network management subsystem,
-            then this object contains a zero value."
-    ::= { ipNetToPhysicalEntry 5 }
-
-ipNetToPhysicalType OBJECT-TYPE
-    SYNTAX     INTEGER {
-                other(1),        -- none of the following
-                invalid(2),      -- an invalidated mapping
-                dynamic(3),
-                static(4),
-                local(5)         -- local interface
-            }
-    MAX-ACCESS read-create
-    STATUS     current
-    DESCRIPTION
-           "The type of mapping.
-
-            Setting this object to the value invalid(2) has the effect
-            of invalidating the corresponding entry in the
-            ipNetToPhysicalTable.  That is, it effectively dis-
-            associates the interface identified with said entry from the
-            mapping identified with said entry.  It is an
-            implementation-specific matter as to whether the agent
-
-
-
-            removes an invalidated entry from the table.  Accordingly,
-            management stations must be prepared to receive tabular
-            information from agents that corresponds to entries not
-            currently in use.  Proper interpretation of such entries
-            requires examination of the relevant ipNetToPhysicalType
-            object.
-
-            The 'dynamic(3)' type indicates that the IP address to
-            physical addresses mapping has been dynamically resolved
-            using e.g., IPv4 ARP or the IPv6 Neighbor Discovery
-            protocol.
-
-            The 'static(4)' type indicates that the mapping has been
-            statically configured.  Both of these refer to entries that
-            provide mappings for other entities addresses.
-
-            The 'local(5)' type indicates that the mapping is provided
-            for an entity's own interface address.
-
-            As the entries in this table are typically not persistent
-            when this object is written the entity SHOULD NOT save the
-            change to non-volatile storage."
-    DEFVAL { static }
-    ::= { ipNetToPhysicalEntry 6 }
-
-ipNetToPhysicalState OBJECT-TYPE
-    SYNTAX     INTEGER {
-                     reachable(1), -- confirmed reachability
-
-                     stale(2),     -- unconfirmed reachability
-
-                     delay(3),     -- waiting for reachability
-                                   -- confirmation before entering
-                                   -- the probe state
-
-                     probe(4),     -- actively probing
-
-                     invalid(5),   -- an invalidated mapping
-
-                     unknown(6),   -- state can not be determined
-                                   -- for some reason.
-
-                     incomplete(7) -- address resolution is being
-                                   -- performed.
-                    }
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-
-
-
-           "The Neighbor Unreachability Detection state for the
-            interface when the address mapping in this entry is used.
-            If Neighbor Unreachability Detection is not in use (e.g. for
-            IPv4), this object is always unknown(6)."
-    REFERENCE "RFC 2461"
-    ::= { ipNetToPhysicalEntry 7 }
-
-ipNetToPhysicalRowStatus OBJECT-TYPE
-    SYNTAX     RowStatus
-    MAX-ACCESS read-create
-    STATUS     current
-    DESCRIPTION
-           "The status of this conceptual row.
-
-            The RowStatus TC requires that this DESCRIPTION clause
-            states under which circumstances other objects in this row
-            can be modified.  The value of this object has no effect on
-            whether other objects in this conceptual row can be
-            modified.
-
-            A conceptual row can not be made active until the
-            ipNetToPhysicalPhysAddress object has been set.
-
-            Note that if the ipNetToPhysicalType is set to 'invalid',
-            the managed node may delete the entry independent of the
-            state of this object."
-    ::= { ipNetToPhysicalEntry 8 }
-
---
--- The IPv6 Scope Zone Index Table.
---
-
-ipv6ScopeZoneIndexTable OBJECT-TYPE
-    SYNTAX     SEQUENCE OF Ipv6ScopeZoneIndexEntry
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "The table used to describe IPv6 unicast and multicast scope
-            zones.
-
-            For those objects that have names rather than numbers, the
-            names were chosen to coincide with the names used in the
-            IPv6 address architecture document. "
-    REFERENCE "Section 2.7 of RFC 4291"
-    ::= { ip 36 }
-
-ipv6ScopeZoneIndexEntry OBJECT-TYPE
-    SYNTAX     Ipv6ScopeZoneIndexEntry
-
-
-
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "Each entry contains the list of scope identifiers on a given
-            interface."
-    INDEX { ipv6ScopeZoneIndexIfIndex }
-    ::= { ipv6ScopeZoneIndexTable 1 }
-
-Ipv6ScopeZoneIndexEntry ::= SEQUENCE {
-        ipv6ScopeZoneIndexIfIndex            InterfaceIndex,
-        ipv6ScopeZoneIndexLinkLocal          InetZoneIndex,
-        ipv6ScopeZoneIndex3                  InetZoneIndex,
-        ipv6ScopeZoneIndexAdminLocal         InetZoneIndex,
-        ipv6ScopeZoneIndexSiteLocal          InetZoneIndex,
-        ipv6ScopeZoneIndex6                  InetZoneIndex,
-        ipv6ScopeZoneIndex7                  InetZoneIndex,
-        ipv6ScopeZoneIndexOrganizationLocal  InetZoneIndex,
-        ipv6ScopeZoneIndex9                  InetZoneIndex,
-        ipv6ScopeZoneIndexA                  InetZoneIndex,
-        ipv6ScopeZoneIndexB                  InetZoneIndex,
-        ipv6ScopeZoneIndexC                  InetZoneIndex,
-        ipv6ScopeZoneIndexD                  InetZoneIndex
-    }
-
-ipv6ScopeZoneIndexIfIndex OBJECT-TYPE
-    SYNTAX     InterfaceIndex
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "The index value that uniquely identifies the interface to
-            which these scopes belong.  The interface identified by a
-            particular value of this index is the same interface as
-            identified by the same value of the IF-MIB's ifIndex."
-    ::= { ipv6ScopeZoneIndexEntry 1 }
-
-ipv6ScopeZoneIndexLinkLocal OBJECT-TYPE
-    SYNTAX     InetZoneIndex
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The zone index for the link-local scope on this interface."
-    ::= { ipv6ScopeZoneIndexEntry 2 }
-
-ipv6ScopeZoneIndex3 OBJECT-TYPE
-    SYNTAX     InetZoneIndex
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-
-
-
-           "The zone index for scope 3 on this interface."
-    ::= { ipv6ScopeZoneIndexEntry 3 }
-
-ipv6ScopeZoneIndexAdminLocal OBJECT-TYPE
-    SYNTAX     InetZoneIndex
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The zone index for the admin-local scope on this interface."
-    ::= { ipv6ScopeZoneIndexEntry 4 }
-
-ipv6ScopeZoneIndexSiteLocal OBJECT-TYPE
-    SYNTAX     InetZoneIndex
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The zone index for the site-local scope on this interface."
-    ::= { ipv6ScopeZoneIndexEntry 5 }
-
-ipv6ScopeZoneIndex6 OBJECT-TYPE
-    SYNTAX     InetZoneIndex
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The zone index for scope 6 on this interface."
-    ::= { ipv6ScopeZoneIndexEntry 6 }
-
-ipv6ScopeZoneIndex7 OBJECT-TYPE
-    SYNTAX     InetZoneIndex
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The zone index for scope 7 on this interface."
-    ::= { ipv6ScopeZoneIndexEntry 7 }
-
-ipv6ScopeZoneIndexOrganizationLocal OBJECT-TYPE
-    SYNTAX     InetZoneIndex
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The zone index for the organization-local scope on this
-            interface."
-    ::= { ipv6ScopeZoneIndexEntry 8 }
-
-ipv6ScopeZoneIndex9 OBJECT-TYPE
-    SYNTAX     InetZoneIndex
-    MAX-ACCESS read-only
-    STATUS     current
-
-
-
-    DESCRIPTION
-           "The zone index for scope 9 on this interface."
-    ::= { ipv6ScopeZoneIndexEntry 9 }
-
-ipv6ScopeZoneIndexA OBJECT-TYPE
-    SYNTAX     InetZoneIndex
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The zone index for scope A on this interface."
-    ::= { ipv6ScopeZoneIndexEntry 10 }
-
-ipv6ScopeZoneIndexB OBJECT-TYPE
-    SYNTAX     InetZoneIndex
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The zone index for scope B on this interface."
-    ::= { ipv6ScopeZoneIndexEntry 11 }
-
-ipv6ScopeZoneIndexC OBJECT-TYPE
-    SYNTAX     InetZoneIndex
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The zone index for scope C on this interface."
-    ::= { ipv6ScopeZoneIndexEntry 12 }
-
-ipv6ScopeZoneIndexD OBJECT-TYPE
-    SYNTAX     InetZoneIndex
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The zone index for scope D on this interface."
-    ::= { ipv6ScopeZoneIndexEntry 13 }
-
---
--- The Default Router Table
--- This table simply lists the default routers; for more information
--- about routing tables, see the routing MIBs
---
-
-ipDefaultRouterTable OBJECT-TYPE
-    SYNTAX     SEQUENCE OF IpDefaultRouterEntry
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "The table used to describe the default routers known to this
-
-
-
-            entity."
-    ::= { ip 37 }
-
-ipDefaultRouterEntry OBJECT-TYPE
-    SYNTAX     IpDefaultRouterEntry
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "Each entry contains information about a default router known
-            to this entity."
-    INDEX {ipDefaultRouterAddressType, ipDefaultRouterAddress,
-           ipDefaultRouterIfIndex}
-    ::= { ipDefaultRouterTable 1 }
-
-IpDefaultRouterEntry ::= SEQUENCE {
-        ipDefaultRouterAddressType  InetAddressType,
-        ipDefaultRouterAddress      InetAddress,
-        ipDefaultRouterIfIndex      InterfaceIndex,
-        ipDefaultRouterLifetime     Unsigned32,
-        ipDefaultRouterPreference   INTEGER
-    }
-
-ipDefaultRouterAddressType OBJECT-TYPE
-    SYNTAX     InetAddressType
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "The address type for this row."
-    ::= { ipDefaultRouterEntry 1 }
-
-ipDefaultRouterAddress OBJECT-TYPE
-    SYNTAX     InetAddress
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "The IP address of the default router represented by this
-            row.  The address type of this object is specified in
-            ipDefaultRouterAddressType.
-
-            Implementers need to be aware that if the size of
-            ipDefaultRouterAddress exceeds 115 octets, then OIDS of
-            instances of columns in this row will have more than 128
-            sub-identifiers and cannot be accessed using SNMPv1,
-            SNMPv2c, or SNMPv3."
-    ::= { ipDefaultRouterEntry 2 }
-
-ipDefaultRouterIfIndex OBJECT-TYPE
-    SYNTAX     InterfaceIndex
-
-
-
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "The index value that uniquely identifies the interface by
-            which the router can be reached.  The interface identified
-            by a particular value of this index is the same interface as
-            identified by the same value of the IF-MIB's ifIndex."
-    ::= { ipDefaultRouterEntry 3 }
-
-ipDefaultRouterLifetime OBJECT-TYPE
-    SYNTAX     Unsigned32 (0..65535)
-    UNITS      "seconds"
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The remaining length of time, in seconds, that this router
-            will continue to be useful as a default router.  A value of
-            zero indicates that it is no longer useful as a default
-            router.  It is left to the implementer of the MIB as to
-            whether a router with a lifetime of zero is removed from the
-            list.
-
-            For IPv6, this value should be extracted from the router
-            advertisement messages."
-    REFERENCE "For IPv6 RFC 2462 sections 4.2 and 6.3.4"
-    ::= { ipDefaultRouterEntry 4 }
-
-ipDefaultRouterPreference OBJECT-TYPE
-    SYNTAX     INTEGER {
-                     reserved (-2),
-                     low (-1),
-                     medium (0),
-                     high (1)
-                    }
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "An indication of preference given to this router as a
-            default router as described in he Default Router
-            Preferences document.  Treating the value as a
-            2 bit signed integer allows for simple arithmetic
-            comparisons.
-
-            For IPv4 routers or IPv6 routers that are not using the
-            updated router advertisement format, this object is set to
-            medium (0)."
-    REFERENCE "RFC 4291, section 2.1"
-    ::= { ipDefaultRouterEntry 5 }
-
-
-
---
--- Configuration information for constructing router advertisements
---
-
-ipv6RouterAdvertSpinLock OBJECT-TYPE
-    SYNTAX     TestAndIncr
-    MAX-ACCESS read-write
-    STATUS     current
-    DESCRIPTION
-           "An advisory lock used to allow cooperating SNMP managers to
-            coordinate their use of the set operation in creating or
-            modifying rows within this table.
-
-            In order to use this lock to coordinate the use of set
-            operations, managers should first retrieve
-            ipv6RouterAdvertSpinLock.  They should then determine the
-            appropriate row to create or modify.  Finally, they should
-            issue the appropriate set command including the retrieved
-            value of ipv6RouterAdvertSpinLock.  If another manager has
-            altered the table in the meantime, then the value of
-            ipv6RouterAdvertSpinLock will have changed and the creation
-            will fail as it will be specifying an incorrect value for
-            ipv6RouterAdvertSpinLock.  It is suggested, but not
-            required, that the ipv6RouterAdvertSpinLock be the first var
-            bind for each set of objects representing a 'row' in a PDU."
-    ::= { ip 38 }
-
-ipv6RouterAdvertTable OBJECT-TYPE
-    SYNTAX     SEQUENCE OF Ipv6RouterAdvertEntry
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "The table containing information used to construct router
-            advertisements."
-    ::= { ip 39 }
-
-ipv6RouterAdvertEntry OBJECT-TYPE
-    SYNTAX     Ipv6RouterAdvertEntry
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "An entry containing information used to construct router
-            advertisements.
-
-            Information in this table is persistent, and when this
-            object is written, the entity SHOULD save the change to
-            non-volatile storage."
-    INDEX { ipv6RouterAdvertIfIndex }
-
-
-
-    ::= { ipv6RouterAdvertTable 1 }
-
-Ipv6RouterAdvertEntry ::= SEQUENCE {
-        ipv6RouterAdvertIfIndex          InterfaceIndex,
-        ipv6RouterAdvertSendAdverts      TruthValue,
-        ipv6RouterAdvertMaxInterval      Unsigned32,
-        ipv6RouterAdvertMinInterval      Unsigned32,
-        ipv6RouterAdvertManagedFlag      TruthValue,
-        ipv6RouterAdvertOtherConfigFlag  TruthValue,
-        ipv6RouterAdvertLinkMTU          Unsigned32,
-        ipv6RouterAdvertReachableTime    Unsigned32,
-        ipv6RouterAdvertRetransmitTime   Unsigned32,
-        ipv6RouterAdvertCurHopLimit      Unsigned32,
-        ipv6RouterAdvertDefaultLifetime  Unsigned32,
-        ipv6RouterAdvertRowStatus        RowStatus
-    }
-
-ipv6RouterAdvertIfIndex OBJECT-TYPE
-    SYNTAX     InterfaceIndex
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "The index value that uniquely identifies the interface on
-            which router advertisements constructed with this
-            information will be transmitted.  The interface identified
-            by a particular value of this index is the same interface as
-            identified by the same value of the IF-MIB's ifIndex."
-    ::= { ipv6RouterAdvertEntry 1 }
-
-ipv6RouterAdvertSendAdverts OBJECT-TYPE
-    SYNTAX     TruthValue
-    MAX-ACCESS read-create
-    STATUS     current
-    DESCRIPTION
-           "A flag indicating whether the router sends periodic
-            router advertisements and responds to router solicitations
-            on this interface."
-    REFERENCE "RFC 2461 Section 6.2.1"
-    DEFVAL { false }
-    ::= { ipv6RouterAdvertEntry 2 }
-
-ipv6RouterAdvertMaxInterval OBJECT-TYPE
-    SYNTAX     Unsigned32 (4..1800)
-    UNITS      "seconds"
-    MAX-ACCESS read-create
-    STATUS     current
-    DESCRIPTION
-           "The maximum time allowed between sending unsolicited router
-
-
-
-            advertisements from this interface."
-    REFERENCE "RFC 2461 Section 6.2.1"
-    DEFVAL { 600 }
-    ::= { ipv6RouterAdvertEntry 3 }
-
-ipv6RouterAdvertMinInterval OBJECT-TYPE
-    SYNTAX     Unsigned32 (3..1350)
-    UNITS      "seconds"
-    MAX-ACCESS read-create
-    STATUS     current
-    DESCRIPTION
-           "The minimum time allowed between sending unsolicited router
-            advertisements from this interface.
-
-            The default is 0.33 * ipv6RouterAdvertMaxInterval, however,
-            in the case of a low value for ipv6RouterAdvertMaxInterval,
-            the minimum value for this object is restricted to 3."
-    REFERENCE "RFC 2461 Section 6.2.1"
-    ::= { ipv6RouterAdvertEntry 4 }
-
-ipv6RouterAdvertManagedFlag OBJECT-TYPE
-    SYNTAX     TruthValue
-    MAX-ACCESS read-create
-    STATUS     current
-    DESCRIPTION
-           "The true/false value to be placed into the 'managed address
-            configuration' flag field in router advertisements sent from
-            this interface."
-    REFERENCE "RFC 2461 Section 6.2.1"
-    DEFVAL { false }
-    ::= { ipv6RouterAdvertEntry 5 }
-
-ipv6RouterAdvertOtherConfigFlag OBJECT-TYPE
-    SYNTAX     TruthValue
-    MAX-ACCESS read-create
-    STATUS     current
-    DESCRIPTION
-           "The true/false value to be placed into the 'other stateful
-            configuration' flag field in router advertisements sent from
-            this interface."
-    REFERENCE "RFC 2461 Section 6.2.1"
-    DEFVAL { false }
-    ::= { ipv6RouterAdvertEntry 6 }
-
-ipv6RouterAdvertLinkMTU OBJECT-TYPE
-    SYNTAX     Unsigned32
-    MAX-ACCESS read-create
-    STATUS     current
-
-
-
-    DESCRIPTION
-           "The value to be placed in MTU options sent by the router on
-            this interface.
-
-            A value of zero indicates that no MTU options are sent."
-    REFERENCE "RFC 2461 Section 6.2.1"
-    DEFVAL { 0 }
-    ::= { ipv6RouterAdvertEntry 7 }
-
-ipv6RouterAdvertReachableTime OBJECT-TYPE
-    SYNTAX     Unsigned32 (0..3600000)
-    UNITS      "milliseconds"
-    MAX-ACCESS read-create
-    STATUS     current
-    DESCRIPTION
-           "The value to be placed in the reachable time field in router
-            advertisement messages sent from this interface.
-
-            A value of zero in the router advertisement indicates that
-            the advertisement isn't specifying a value for reachable
-            time."
-    REFERENCE "RFC 2461 Section 6.2.1"
-    DEFVAL { 0 }
-    ::= { ipv6RouterAdvertEntry 8 }
-
-ipv6RouterAdvertRetransmitTime OBJECT-TYPE
-    SYNTAX     Unsigned32
-    UNITS      "milliseconds"
-    MAX-ACCESS read-create
-    STATUS     current
-    DESCRIPTION
-           "The value to be placed in the retransmit timer field in
-            router advertisements sent from this interface.
-
-            A value of zero in the router advertisement indicates that
-            the advertisement isn't specifying a value for retrans
-            time."
-    REFERENCE "RFC 2461 Section 6.2.1"
-    DEFVAL { 0 }
-    ::= { ipv6RouterAdvertEntry 9 }
-
-ipv6RouterAdvertCurHopLimit OBJECT-TYPE
-    SYNTAX     Unsigned32 (0..255)
-    MAX-ACCESS read-create
-    STATUS     current
-    DESCRIPTION
-           "The default value to be placed in the current hop limit
-            field in router advertisements sent from this interface.
-
-
-
-            The value should be set to the current diameter of the
-            Internet.
-
-            A value of zero in the router advertisement indicates that
-            the advertisement isn't specifying a value for curHopLimit.
-
-            The default should be set to the value specified in the IANA
-            web pages (www.iana.org) at the time of implementation."
-    REFERENCE "RFC 2461 Section 6.2.1"
-    ::= { ipv6RouterAdvertEntry 10 }
-
-ipv6RouterAdvertDefaultLifetime OBJECT-TYPE
-    SYNTAX     Unsigned32 (0|4..9000)
-    UNITS      "seconds"
-    MAX-ACCESS read-create
-    STATUS     current
-    DESCRIPTION
-           "The value to be placed in the router lifetime field of
-            router advertisements sent from this interface.  This value
-            MUST be either 0 or between ipv6RouterAdvertMaxInterval and
-            9000 seconds.
-
-            A value of zero indicates that the router is not to be used
-            as a default router.
-
-            The default is 3 * ipv6RouterAdvertMaxInterval."
-    REFERENCE "RFC 2461 Section 6.2.1"
-    ::= { ipv6RouterAdvertEntry 11 }
-
-ipv6RouterAdvertRowStatus OBJECT-TYPE
-    SYNTAX     RowStatus
-    MAX-ACCESS read-create
-    STATUS     current
-    DESCRIPTION
-           "The status of this conceptual row.
-
-            As all objects in this conceptual row have default values, a
-            row can be created and made active by setting this object
-            appropriately.
-
-            The RowStatus TC requires that this DESCRIPTION clause
-            states under which circumstances other objects in this row
-            can be modified.  The value of this object has no effect on
-            whether other objects in this conceptual row can be
-            modified."
-    ::= { ipv6RouterAdvertEntry 12 }
-
---
-
-
-
--- ICMP section
---
-
-icmp     OBJECT IDENTIFIER ::= { mib-2 5 }
-
---
--- ICMP non-message-specific counters
---
-
--- These object IDs are reserved, as they were used in earlier
--- versions of the MIB module.  In theory, OIDs are not assigned
--- until the specification is released as an RFC; however, as some
--- companies may have shipped code based on earlier versions of
--- the MIB, it seems best to reserve these OIDs.
--- ::= { icmp 27 }
--- ::= { icmp 28 }
-
-icmpStatsTable OBJECT-TYPE
-    SYNTAX     SEQUENCE OF IcmpStatsEntry
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "The table of generic system-wide ICMP counters."
-    ::= { icmp 29 }
-
-icmpStatsEntry OBJECT-TYPE
-    SYNTAX     IcmpStatsEntry
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "A conceptual row in the icmpStatsTable."
-    INDEX    { icmpStatsIPVersion }
-    ::= { icmpStatsTable 1 }
-
-IcmpStatsEntry ::= SEQUENCE {
-        icmpStatsIPVersion  InetVersion,
-        icmpStatsInMsgs     Counter32,
-        icmpStatsInErrors   Counter32,
-        icmpStatsOutMsgs    Counter32,
-        icmpStatsOutErrors  Counter32
-    }
-
-icmpStatsIPVersion OBJECT-TYPE
-    SYNTAX     InetVersion
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "The IP version of the statistics."
-
-
-
-    ::= { icmpStatsEntry 1 }
-
-icmpStatsInMsgs OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of ICMP messages that the entity received.
-            Note that this counter includes all those counted by
-            icmpStatsInErrors."
-    ::= { icmpStatsEntry 2 }
-
-icmpStatsInErrors OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of ICMP messages that the entity received but
-            determined as having ICMP-specific errors (bad ICMP
-            checksums, bad length, etc.)."
-    ::= { icmpStatsEntry 3 }
-
-icmpStatsOutMsgs OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of ICMP messages that the entity attempted
-            to send.  Note that this counter includes all those counted
-            by icmpStatsOutErrors."
-    ::= { icmpStatsEntry 4 }
-
-icmpStatsOutErrors OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of ICMP messages that this entity did not send
-            due to problems discovered within ICMP, such as a lack of
-            buffers.  This value should not include errors discovered
-            outside the ICMP layer, such as the inability of IP to route
-            the resultant datagram.  In some implementations, there may
-            be no types of error that contribute to this counter's
-            value."
-    ::= { icmpStatsEntry 5 }
-
---
--- per-version, per-message type ICMP counters
-
-
-
---
-
-icmpMsgStatsTable OBJECT-TYPE
-    SYNTAX     SEQUENCE OF IcmpMsgStatsEntry
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "The table of system-wide per-version, per-message type ICMP
-            counters."
-    ::= { icmp 30 }
-
-icmpMsgStatsEntry OBJECT-TYPE
-    SYNTAX     IcmpMsgStatsEntry
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "A conceptual row in the icmpMsgStatsTable.
-
-            The system should track each ICMP type value, even if that
-            ICMP type is not supported by the system.  However, a
-            given row need not be instantiated unless a message of that
-            type has been processed, i.e., the row for
-            icmpMsgStatsType=X MAY be instantiated before but MUST be
-            instantiated after the first message with Type=X is
-            received or transmitted.  After receiving or transmitting
-            any succeeding messages with Type=X, the relevant counter
-            must be incremented."
-    INDEX { icmpMsgStatsIPVersion, icmpMsgStatsType }
-    ::= { icmpMsgStatsTable 1 }
-
-IcmpMsgStatsEntry ::= SEQUENCE {
-        icmpMsgStatsIPVersion  InetVersion,
-        icmpMsgStatsType       Integer32,
-        icmpMsgStatsInPkts     Counter32,
-        icmpMsgStatsOutPkts    Counter32
-    }
-
-icmpMsgStatsIPVersion OBJECT-TYPE
-    SYNTAX     InetVersion
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "The IP version of the statistics."
-    ::= { icmpMsgStatsEntry 1 }
-
-icmpMsgStatsType OBJECT-TYPE
-    SYNTAX     Integer32 (0..255)
-    MAX-ACCESS not-accessible
-
-
-
-    STATUS     current
-    DESCRIPTION
-           "The ICMP type field of the message type being counted by
-            this row.
-
-            Note that ICMP message types are scoped by the address type
-            in use."
-    REFERENCE "http://www.iana.org/assignments/icmp-parameters and
-               http://www.iana.org/assignments/icmpv6-parameters"
-    ::= { icmpMsgStatsEntry 2 }
-
-icmpMsgStatsInPkts OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of input packets for this AF and type."
-    ::= { icmpMsgStatsEntry 3 }
-
-icmpMsgStatsOutPkts OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of output packets for this AF and type."
-    ::= { icmpMsgStatsEntry 4 }
---
--- conformance information
---
-
-ipMIBConformance OBJECT IDENTIFIER ::= { ipMIB 2 }
-
-ipMIBCompliances OBJECT IDENTIFIER ::= { ipMIBConformance 1 }
-ipMIBGroups      OBJECT IDENTIFIER ::= { ipMIBConformance 2 }
-
--- compliance statements
-ipMIBCompliance2 MODULE-COMPLIANCE
-    STATUS     current
-    DESCRIPTION
-            "The compliance statement for systems that implement IP -
-             either IPv4 or IPv6.
-
-            There are a number of INDEX objects that cannot be
-            represented in the form of OBJECT clauses in SMIv2, but
-            for which we have the following compliance requirements,
-            expressed in OBJECT clause form in this description
-            clause:
-
-
-
-
-            -- OBJECT        ipSystemStatsIPVersion
-            -- SYNTAX        InetVersion {ipv4(1), ipv6(2)}
-            -- DESCRIPTION
-            --     This MIB requires support for only IPv4 and IPv6
-            --     versions.
-            --
-            -- OBJECT        ipIfStatsIPVersion
-            -- SYNTAX        InetVersion {ipv4(1), ipv6(2)}
-            -- DESCRIPTION
-            --     This MIB requires support for only IPv4 and IPv6
-            --     versions.
-            --
-            -- OBJECT        icmpStatsIPVersion
-            -- SYNTAX        InetVersion {ipv4(1), ipv6(2)}
-            -- DESCRIPTION
-            --     This MIB requires support for only IPv4 and IPv6
-            --     versions.
-            --
-            -- OBJECT        icmpMsgStatsIPVersion
-            -- SYNTAX        InetVersion {ipv4(1), ipv6(2)}
-            -- DESCRIPTION
-            --     This MIB requires support for only IPv4 and IPv6
-            --     versions.
-            --
-            -- OBJECT        ipAddressPrefixType
-            -- SYNTAX        InetAddressType {ipv4(1), ipv6(2)}
-            -- DESCRIPTION
-            --     This MIB requires support for only global IPv4 and
-            --     IPv6 address types.
-            --
-            -- OBJECT        ipAddressPrefixPrefix
-            -- SYNTAX        InetAddress (Size(4 | 16))
-            -- DESCRIPTION
-            --     This MIB requires support for only global IPv4 and
-            --     IPv6 addresses and so the size can be either 4 or
-            --     16 bytes.
-            --
-            -- OBJECT        ipAddressAddrType
-            -- SYNTAX        InetAddressType {ipv4(1), ipv6(2),
-            --                                ipv4z(3), ipv6z(4)}
-            -- DESCRIPTION
-            --     This MIB requires support for only global and
-            --     non-global IPv4 and IPv6 address types.
-            --
-            -- OBJECT        ipAddressAddr
-            -- SYNTAX        InetAddress (Size(4 | 8 | 16 | 20))
-            -- DESCRIPTION
-            --     This MIB requires support for only global and
-
-
-
-            --     non-global IPv4 and IPv6 addresses and so the size
-            --     can be 4, 8, 16, or 20 bytes.
-            --
-            -- OBJECT        ipNetToPhysicalNetAddressType
-            -- SYNTAX        InetAddressType {ipv4(1), ipv6(2),
-            --                                ipv4z(3), ipv6z(4)}
-            -- DESCRIPTION
-            --     This MIB requires support for only global and
-            --     non-global IPv4 and IPv6 address types.
-            --
-            -- OBJECT        ipNetToPhysicalNetAddress
-            -- SYNTAX        InetAddress (Size(4 | 8 | 16 | 20))
-            -- DESCRIPTION
-            --     This MIB requires support for only global and
-            --     non-global IPv4 and IPv6 addresses and so the size
-            --     can be 4, 8, 16, or 20 bytes.
-            --
-            -- OBJECT        ipDefaultRouterAddressType
-            -- SYNTAX        InetAddressType {ipv4(1), ipv6(2),
-            --                                ipv4z(3), ipv6z(4)}
-            -- DESCRIPTION
-            --     This MIB requires support for only global and
-            --     non-global IPv4 and IPv6 address types.
-            --
-            -- OBJECT        ipDefaultRouterAddress
-            -- SYNTAX        InetAddress (Size(4 | 8 | 16 | 20))
-            -- DESCRIPTION
-            --     This MIB requires support for only global and
-            --     non-global IPv4 and IPv6 addresses and so the size
-            --     can be 4, 8, 16, or 20 bytes."
-
-    MODULE -- this module
-
-    MANDATORY-GROUPS { ipSystemStatsGroup,   ipAddressGroup,
-                       ipNetToPhysicalGroup, ipDefaultRouterGroup,
-                       icmpStatsGroup }
-
-    GROUP ipSystemStatsHCOctetGroup
-    DESCRIPTION
-           "This group is mandatory for systems that have an aggregate
-            bandwidth of greater than 20MB.  Including this group does
-            not allow an entity to neglect the 32 bit versions of these
-            objects."
-
-    GROUP ipSystemStatsHCPacketGroup
-    DESCRIPTION
-           "This group is mandatory for systems that have an aggregate
-            bandwidth of greater than 650MB.  Including this group
-
-
-
-            does not allow an entity to neglect the 32 bit versions of
-            these objects."
-
-    GROUP ipIfStatsGroup
-    DESCRIPTION
-           "This group is optional for all systems."
-
-    GROUP ipIfStatsHCOctetGroup
-    DESCRIPTION
-           "This group is mandatory for systems that include the
-            ipIfStatsGroup and include links with bandwidths of greater
-            than 20MB.  Including this group does not allow an entity to
-            neglect the 32 bit versions of these objects."
-
-    GROUP ipIfStatsHCPacketGroup
-    DESCRIPTION
-           "This group is mandatory for systems that include the
-            ipIfStatsGroup and include links with bandwidths of greater
-            than 650MB.  Including this group does not allow an entity
-            to neglect the 32 bit versions of these objects."
-
-    GROUP ipv4GeneralGroup
-    DESCRIPTION
-           "This group is mandatory for all systems supporting IPv4."
-
-    GROUP ipv4IfGroup
-    DESCRIPTION
-           "This group is mandatory for all systems supporting IPv4."
-
-    GROUP ipv4SystemStatsGroup
-    DESCRIPTION
-           "This group is mandatory for all systems supporting IPv4."
-
-    GROUP ipv4SystemStatsHCPacketGroup
-    DESCRIPTION
-           "This group is mandatory for all systems supporting IPv4 and
-            that have an aggregate bandwidth of greater than 650MB.
-            Including this group does not allow an entity to neglect the
-            32 bit versions of these objects."
-
-    GROUP ipv4IfStatsGroup
-    DESCRIPTION
-           "This group is mandatory for all systems supporting IPv4 and
-            including the ipIfStatsGroup."
-
-    GROUP ipv4IfStatsHCPacketGroup
-    DESCRIPTION
-           "This group is mandatory for all systems supporting IPv4 and
-
-
-
-            including the ipIfStatsHCPacketGroup.  Including this group
-            does not allow an entity to neglect the 32 bit versions of
-            these objects."
-
-    GROUP ipv6GeneralGroup2
-    DESCRIPTION
-           "This group is mandatory for all systems supporting IPv6."
-
-    GROUP ipv6IfGroup
-    DESCRIPTION
-           "This group is mandatory for all systems supporting IPv6."
-
-    GROUP ipAddressPrefixGroup
-    DESCRIPTION
-           "This group is mandatory for all systems supporting IPv6."
-
-    GROUP ipv6ScopeGroup
-    DESCRIPTION
-           "This group is mandatory for all systems supporting IPv6."
-
-    GROUP ipv6RouterAdvertGroup
-    DESCRIPTION
-           "This group is mandatory for all IPv6 routers."
-
-    GROUP ipLastChangeGroup
-    DESCRIPTION
-           "This group is optional for all agents."
-
-    OBJECT     ipv6IpForwarding
-    MIN-ACCESS read-only
-    DESCRIPTION
-           "An agent is not required to provide write access to this
-            object."
-
-    OBJECT     ipv6IpDefaultHopLimit
-    MIN-ACCESS read-only
-    DESCRIPTION
-           "An agent is not required to provide write access to this
-            object."
-
-    OBJECT     ipv4InterfaceEnableStatus
-    MIN-ACCESS read-only
-    DESCRIPTION
-           "An agent is not required to provide write access to this
-            object."
-
-    OBJECT     ipv6InterfaceEnableStatus
-    MIN-ACCESS read-only
-
-
-
-    DESCRIPTION
-           "An agent is not required to provide write access to this
-            object."
-
-    OBJECT     ipv6InterfaceForwarding
-    MIN-ACCESS read-only
-    DESCRIPTION
-           "An agent is not required to provide write access to this
-            object."
-
-    OBJECT     ipAddressSpinLock
-    MIN-ACCESS not-accessible
-    DESCRIPTION
-           "An agent is not required to provide write access to this
-            object.  However, if an agent provides write access to any
-            of the other objects in the ipAddressGroup, it SHOULD
-            provide write access to this object as well."
-
-    OBJECT     ipAddressIfIndex
-    MIN-ACCESS read-only
-    DESCRIPTION
-           "An agent is not required to provide write or create access
-            to this object."
-
-    OBJECT     ipAddressType
-    MIN-ACCESS read-only
-    DESCRIPTION
-           "An agent is not required to provide write or create access
-            to this object."
-
-    OBJECT     ipAddressStatus
-    MIN-ACCESS read-only
-    DESCRIPTION
-           "An agent is not required to provide write or create access
-            to this object."
-
-    OBJECT     ipAddressRowStatus
-    SYNTAX     RowStatus { active(1) }
-    MIN-ACCESS read-only
-    DESCRIPTION
-           "An agent is not required to provide write or create access
-            to this object."
-
-    OBJECT     ipAddressStorageType
-    MIN-ACCESS read-only
-    DESCRIPTION
-           "An agent is not required to provide write or create access
-            to this object.
-
-
-
-            If an agent allows this object to be written or created, it
-            is not required to allow this object to be set to readOnly,
-            permanent, or nonVolatile."
-
-    OBJECT     ipNetToPhysicalPhysAddress
-    MIN-ACCESS read-only
-    DESCRIPTION
-           "An agent is not required to provide write or create access
-            to this object."
-
-    OBJECT     ipNetToPhysicalType
-    MIN-ACCESS read-only
-    DESCRIPTION
-           "An agent is not required to provide write or create access
-            to this object."
-
-    OBJECT     ipv6RouterAdvertSpinLock
-    MIN-ACCESS read-only
-    DESCRIPTION
-           "An agent is not required to provide write access to this
-            object.  However, if an agent provides write access to
-            any of the other objects in the ipv6RouterAdvertGroup, it
-            SHOULD provide write access to this object as well."
-
-    OBJECT     ipv6RouterAdvertSendAdverts
-    MIN-ACCESS read-only
-    DESCRIPTION
-           "An agent is not required to provide write access to this
-            object."
-
-    OBJECT     ipv6RouterAdvertMaxInterval
-    MIN-ACCESS read-only
-    DESCRIPTION
-           "An agent is not required to provide write access to this
-            object."
-
-    OBJECT     ipv6RouterAdvertMinInterval
-    MIN-ACCESS read-only
-    DESCRIPTION
-           "An agent is not required to provide write access to this
-            object."
-
-    OBJECT     ipv6RouterAdvertManagedFlag
-    MIN-ACCESS read-only
-    DESCRIPTION
-           "An agent is not required to provide write access to this
-            object."
-
-
-
-
-    OBJECT     ipv6RouterAdvertOtherConfigFlag
-    MIN-ACCESS read-only
-    DESCRIPTION
-           "An agent is not required to provide write access to this
-            object."
-
-    OBJECT     ipv6RouterAdvertLinkMTU
-    MIN-ACCESS read-only
-    DESCRIPTION
-           "An agent is not required to provide write access to this
-            object."
-
-    OBJECT     ipv6RouterAdvertReachableTime
-    MIN-ACCESS read-only
-    DESCRIPTION
-           "An agent is not required to provide write access to this
-            object."
-
-    OBJECT     ipv6RouterAdvertRetransmitTime
-    MIN-ACCESS read-only
-    DESCRIPTION
-           "An agent is not required to provide write access to this
-            object."
-
-    OBJECT     ipv6RouterAdvertCurHopLimit
-    MIN-ACCESS read-only
-    DESCRIPTION
-           "An agent is not required to provide write access to this
-            object."
-
-    OBJECT     ipv6RouterAdvertDefaultLifetime
-    MIN-ACCESS read-only
-    DESCRIPTION
-           "An agent is not required to provide write access to this
-            object."
-
-    OBJECT     ipv6RouterAdvertRowStatus
-    MIN-ACCESS read-only
-    DESCRIPTION
-           "An agent is not required to provide write or create access
-            to this object."
-
-    ::= { ipMIBCompliances 2 }
-
--- units of conformance
-
-ipv4GeneralGroup OBJECT-GROUP
-    OBJECTS   { ipForwarding, ipDefaultTTL, ipReasmTimeout }
-
-
-
-    STATUS     current
-    DESCRIPTION
-           "The group of IPv4-specific objects for basic management of
-            IPv4 entities."
-    ::= { ipMIBGroups 3 }
-
-ipv4IfGroup OBJECT-GROUP
-    OBJECTS   { ipv4InterfaceReasmMaxSize, ipv4InterfaceEnableStatus,
-                ipv4InterfaceRetransmitTime }
-    STATUS     current
-    DESCRIPTION
-           "The group of IPv4-specific objects for basic management of
-            IPv4 interfaces."
-    ::= { ipMIBGroups 4 }
-
-ipv6GeneralGroup2 OBJECT-GROUP
-    OBJECTS { ipv6IpForwarding, ipv6IpDefaultHopLimit }
-    STATUS     current
-    DESCRIPTION
-           "The IPv6 group of objects providing for basic management of
-            IPv6 entities."
-    ::= { ipMIBGroups 5 }
-
-ipv6IfGroup OBJECT-GROUP
-    OBJECTS   { ipv6InterfaceReasmMaxSize,   ipv6InterfaceIdentifier,
-                ipv6InterfaceEnableStatus,   ipv6InterfaceReachableTime,
-                ipv6InterfaceRetransmitTime, ipv6InterfaceForwarding }
-    STATUS     current
-    DESCRIPTION
-           "The group of IPv6-specific objects for basic management of
-            IPv6 interfaces."
-    ::= { ipMIBGroups 6 }
-
-ipLastChangeGroup OBJECT-GROUP
-    OBJECTS   { ipv4InterfaceTableLastChange,
-                ipv6InterfaceTableLastChange,
-                ipIfStatsTableLastChange }
-    STATUS     current
-    DESCRIPTION
-           "The last change objects associated with this MIB.  These
-            objects are optional for all agents.  They SHOULD be
-            implemented on agents where it is possible to determine the
-            proper values.  Where it is not possible to determine the
-            proper values, for example when the tables are split amongst
-            several sub-agents using AgentX, the agent MUST NOT
-            implement these objects to return an incorrect or static
-            value."
-    ::= { ipMIBGroups 7 }
-
-
-
-ipSystemStatsGroup OBJECT-GROUP
-    OBJECTS   { ipSystemStatsInReceives,
-                ipSystemStatsInOctets,
-                ipSystemStatsInHdrErrors,
-                ipSystemStatsInNoRoutes,
-                ipSystemStatsInAddrErrors,
-                ipSystemStatsInUnknownProtos,
-                ipSystemStatsInTruncatedPkts,
-                ipSystemStatsInForwDatagrams,
-                ipSystemStatsReasmReqds,
-                ipSystemStatsReasmOKs,
-                ipSystemStatsReasmFails,
-                ipSystemStatsInDiscards,
-                ipSystemStatsInDelivers,
-                ipSystemStatsOutRequests,
-                ipSystemStatsOutNoRoutes,
-                ipSystemStatsOutForwDatagrams,
-                ipSystemStatsOutDiscards,
-                ipSystemStatsOutFragReqds,
-                ipSystemStatsOutFragOKs,
-                ipSystemStatsOutFragFails,
-                ipSystemStatsOutFragCreates,
-                ipSystemStatsOutTransmits,
-                ipSystemStatsOutOctets,
-                ipSystemStatsInMcastPkts,
-                ipSystemStatsInMcastOctets,
-                ipSystemStatsOutMcastPkts,
-                ipSystemStatsOutMcastOctets,
-                ipSystemStatsDiscontinuityTime,
-                ipSystemStatsRefreshRate }
-    STATUS     current
-    DESCRIPTION
-           "IP system wide statistics."
-    ::= { ipMIBGroups 8 }
-
-ipv4SystemStatsGroup OBJECT-GROUP
-    OBJECTS   { ipSystemStatsInBcastPkts, ipSystemStatsOutBcastPkts }
-    STATUS     current
-    DESCRIPTION
-           "IPv4 only system wide statistics."
-    ::= { ipMIBGroups 9 }
-
-ipSystemStatsHCOctetGroup OBJECT-GROUP
-    OBJECTS   { ipSystemStatsHCInOctets,
-                ipSystemStatsHCOutOctets,
-                ipSystemStatsHCInMcastOctets,
-                ipSystemStatsHCOutMcastOctets
-}
-
-
-
-    STATUS     current
-    DESCRIPTION
-           "IP system wide statistics for systems that may overflow the
-            standard octet counters within 1 hour."
-    ::= { ipMIBGroups 10 }
-
-ipSystemStatsHCPacketGroup OBJECT-GROUP
-    OBJECTS   { ipSystemStatsHCInReceives,
-                ipSystemStatsHCInForwDatagrams,
-                ipSystemStatsHCInDelivers,
-                ipSystemStatsHCOutRequests,
-                ipSystemStatsHCOutForwDatagrams,
-                ipSystemStatsHCOutTransmits,
-                ipSystemStatsHCInMcastPkts,
-                ipSystemStatsHCOutMcastPkts
-}
-    STATUS     current
-    DESCRIPTION
-           "IP system wide statistics for systems that may overflow the
-            standard packet counters within 1 hour."
-    ::= { ipMIBGroups 11 }
-
-ipv4SystemStatsHCPacketGroup OBJECT-GROUP
-    OBJECTS   { ipSystemStatsHCInBcastPkts,
-                ipSystemStatsHCOutBcastPkts }
-    STATUS     current
-    DESCRIPTION
-           "IPv4 only system wide statistics for systems that may
-            overflow the standard packet counters within 1 hour."
-    ::= { ipMIBGroups 12 }
-
-ipIfStatsGroup OBJECT-GROUP
-    OBJECTS   { ipIfStatsInReceives,        ipIfStatsInOctets,
-                ipIfStatsInHdrErrors,       ipIfStatsInNoRoutes,
-                ipIfStatsInAddrErrors,      ipIfStatsInUnknownProtos,
-                ipIfStatsInTruncatedPkts,   ipIfStatsInForwDatagrams,
-                ipIfStatsReasmReqds,        ipIfStatsReasmOKs,
-                ipIfStatsReasmFails,        ipIfStatsInDiscards,
-                ipIfStatsInDelivers,        ipIfStatsOutRequests,
-                ipIfStatsOutForwDatagrams,  ipIfStatsOutDiscards,
-                ipIfStatsOutFragReqds,      ipIfStatsOutFragOKs,
-                ipIfStatsOutFragFails,      ipIfStatsOutFragCreates,
-                ipIfStatsOutTransmits,      ipIfStatsOutOctets,
-                ipIfStatsInMcastPkts,       ipIfStatsInMcastOctets,
-                ipIfStatsOutMcastPkts,      ipIfStatsOutMcastOctets,
-                ipIfStatsDiscontinuityTime, ipIfStatsRefreshRate }
-    STATUS     current
-    DESCRIPTION
-
-
-
-           "IP per-interface statistics."
-    ::= { ipMIBGroups 13 }
-
-ipv4IfStatsGroup OBJECT-GROUP
-    OBJECTS   { ipIfStatsInBcastPkts, ipIfStatsOutBcastPkts }
-    STATUS     current
-    DESCRIPTION
-           "IPv4 only per-interface statistics."
-    ::= { ipMIBGroups 14 }
-
-ipIfStatsHCOctetGroup OBJECT-GROUP
-    OBJECTS   { ipIfStatsHCInOctets,      ipIfStatsHCOutOctets,
-                ipIfStatsHCInMcastOctets, ipIfStatsHCOutMcastOctets }
-    STATUS     current
-    DESCRIPTION
-           "IP per-interfaces statistics for systems that include
-            interfaces that may overflow the standard octet
-            counters within 1 hour."
-    ::= { ipMIBGroups 15 }
-
-ipIfStatsHCPacketGroup OBJECT-GROUP
-    OBJECTS   { ipIfStatsHCInReceives,       ipIfStatsHCInForwDatagrams,
-                ipIfStatsHCInDelivers,       ipIfStatsHCOutRequests,
-                ipIfStatsHCOutForwDatagrams, ipIfStatsHCOutTransmits,
-                ipIfStatsHCInMcastPkts,      ipIfStatsHCOutMcastPkts }
-    STATUS     current
-    DESCRIPTION
-           "IP per-interfaces statistics for systems that include
-            interfaces that may overflow the standard packet counters
-            within 1 hour."
-    ::= { ipMIBGroups 16 }
-
-ipv4IfStatsHCPacketGroup OBJECT-GROUP
-    OBJECTS   { ipIfStatsHCInBcastPkts, ipIfStatsHCOutBcastPkts }
-    STATUS     current
-    DESCRIPTION
-           "IPv4 only per-interface statistics for systems that include
-            interfaces that may overflow the standard packet counters
-            within 1 hour."
-    ::= { ipMIBGroups 17 }
-
-ipAddressPrefixGroup OBJECT-GROUP
-    OBJECTS   { ipAddressPrefixOrigin,
-                ipAddressPrefixOnLinkFlag,
-                ipAddressPrefixAutonomousFlag,
-                ipAddressPrefixAdvPreferredLifetime,
-                ipAddressPrefixAdvValidLifetime }
-    STATUS     current
-
-
-
-    DESCRIPTION
-           "The group of objects for providing information about address
-            prefixes used by this node."
-    ::= { ipMIBGroups 18 }
-
-ipAddressGroup OBJECT-GROUP
-    OBJECTS   { ipAddressSpinLock,  ipAddressIfIndex,
-                ipAddressType,      ipAddressPrefix,
-                ipAddressOrigin,    ipAddressStatus,
-                ipAddressCreated,   ipAddressLastChanged,
-                ipAddressRowStatus, ipAddressStorageType }
-    STATUS     current
-    DESCRIPTION
-           "The group of objects for providing information about the
-            addresses relevant to this entity's interfaces."
-    ::= { ipMIBGroups 19 }
-
-ipNetToPhysicalGroup OBJECT-GROUP
-    OBJECTS   { ipNetToPhysicalPhysAddress, ipNetToPhysicalLastUpdated,
-                ipNetToPhysicalType,        ipNetToPhysicalState,
-                ipNetToPhysicalRowStatus }
-    STATUS     current
-    DESCRIPTION
-           "The group of objects for providing information about the
-            mappings of network address to physical address known to
-            this node."
-    ::= { ipMIBGroups 20 }
-
-ipv6ScopeGroup OBJECT-GROUP
-    OBJECTS   { ipv6ScopeZoneIndexLinkLocal,
-                ipv6ScopeZoneIndex3,
-                ipv6ScopeZoneIndexAdminLocal,
-                ipv6ScopeZoneIndexSiteLocal,
-                ipv6ScopeZoneIndex6,
-                ipv6ScopeZoneIndex7,
-                ipv6ScopeZoneIndexOrganizationLocal,
-                ipv6ScopeZoneIndex9,
-                ipv6ScopeZoneIndexA,
-                ipv6ScopeZoneIndexB,
-                ipv6ScopeZoneIndexC,
-                ipv6ScopeZoneIndexD }
-    STATUS     current
-    DESCRIPTION
-           "The group of objects for managing IPv6 scope zones."
-    ::= { ipMIBGroups 21 }
-
-ipDefaultRouterGroup OBJECT-GROUP
-    OBJECTS   { ipDefaultRouterLifetime, ipDefaultRouterPreference }
-
-
-
-    STATUS     current
-    DESCRIPTION
-           "The group of objects for providing information about default
-            routers known to this node."
-    ::= { ipMIBGroups 22 }
-
-ipv6RouterAdvertGroup OBJECT-GROUP
-    OBJECTS   { ipv6RouterAdvertSpinLock,
-                ipv6RouterAdvertSendAdverts,
-                ipv6RouterAdvertMaxInterval,
-                ipv6RouterAdvertMinInterval,
-                ipv6RouterAdvertManagedFlag,
-                ipv6RouterAdvertOtherConfigFlag,
-                ipv6RouterAdvertLinkMTU,
-                ipv6RouterAdvertReachableTime,
-                ipv6RouterAdvertRetransmitTime,
-                ipv6RouterAdvertCurHopLimit,
-                ipv6RouterAdvertDefaultLifetime,
-                ipv6RouterAdvertRowStatus
-}
-    STATUS     current
-    DESCRIPTION
-           "The group of objects for controlling information advertised
-            by IPv6 routers."
-    ::= { ipMIBGroups 23 }
-
-icmpStatsGroup OBJECT-GROUP
-    OBJECTS   {icmpStatsInMsgs,    icmpStatsInErrors,
-               icmpStatsOutMsgs,   icmpStatsOutErrors,
-               icmpMsgStatsInPkts, icmpMsgStatsOutPkts }
-    STATUS     current
-    DESCRIPTION
-           "The group of objects providing ICMP statistics."
-    ::= { ipMIBGroups 24 }
-
---
--- Deprecated objects
---
-
-ipInReceives OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The total number of input datagrams received from
-            interfaces, including those received in error.
-
-            This object has been deprecated, as a new IP version-neutral
-
-
-
-            table has been added.  It is loosely replaced by
-            ipSystemStatsInRecieves."
-    ::= { ip 3 }
-
-ipInHdrErrors OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The number of input datagrams discarded due to errors in
-            their IPv4 headers, including bad checksums, version number
-            mismatch, other format errors, time-to-live exceeded, errors
-            discovered in processing their IPv4 options, etc.
-
-            This object has been deprecated as a new IP version-neutral
-            table has been added.  It is loosely replaced by
-            ipSystemStatsInHdrErrors."
-    ::= { ip 4 }
-
-ipInAddrErrors OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The number of input datagrams discarded because the IPv4
-            address in their IPv4 header's destination field was not a
-            valid address to be received at this entity.  This count
-            includes invalid addresses (e.g., 0.0.0.0) and addresses of
-            unsupported Classes (e.g., Class E).  For entities which are
-            not IPv4 routers, and therefore do not forward datagrams,
-            this counter includes datagrams discarded because the
-            destination address was not a local address.
-
-            This object has been deprecated, as a new IP version-neutral
-            table has been added.  It is loosely replaced by
-            ipSystemStatsInAddrErrors."
-    ::= { ip 5 }
-
-ipForwDatagrams OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The number of input datagrams for which this entity was not
-            their final IPv4 destination, as a result of which an
-            attempt was made to find a route to forward them to that
-            final destination.  In entities which do not act as IPv4
-            routers, this counter will include only those packets which
-
-
-
-            were Source-Routed via this entity, and the Source-Route
-            option processing was successful.
-
-            This object has been deprecated, as a new IP version-neutral
-            table has been added.  It is loosely replaced by
-            ipSystemStatsInForwDatagrams."
-    ::= { ip 6 }
-
-ipInUnknownProtos OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The number of locally-addressed datagrams received
-            successfully but discarded because of an unknown or
-            unsupported protocol.
-
-            This object has been deprecated, as a new IP version-neutral
-            table has been added.  It is loosely replaced by
-            ipSystemStatsInUnknownProtos."
-    ::= { ip 7 }
-
-ipInDiscards OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The number of input IPv4 datagrams for which no problems
-            were encountered to prevent their continued processing, but
-            which were discarded (e.g., for lack of buffer space).  Note
-            that this counter does not include any datagrams discarded
-            while awaiting re-assembly.
-
-            This object has been deprecated, as a new IP version-neutral
-            table has been added.  It is loosely replaced by
-            ipSystemStatsInDiscards."
-    ::= { ip 8 }
-
-ipInDelivers OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The total number of input datagrams successfully delivered
-            to IPv4 user-protocols (including ICMP).
-
-            This object has been deprecated as a new IP version neutral
-            table has been added.  It is loosely replaced by
-
-
-
-            ipSystemStatsIndelivers."
-    ::= { ip 9 }
-
-ipOutRequests OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The total number of IPv4 datagrams which local IPv4 user
-            protocols (including ICMP) supplied to IPv4 in requests for
-            transmission.  Note that this counter does not include any
-            datagrams counted in ipForwDatagrams.
-
-            This object has been deprecated, as a new IP version-neutral
-            table has been added.  It is loosely replaced by
-            ipSystemStatsOutRequests."
-    ::= { ip 10 }
-
-ipOutDiscards OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The number of output IPv4 datagrams for which no problem was
-            encountered to prevent their transmission to their
-            destination, but which were discarded (e.g., for lack of
-            buffer space).  Note that this counter would include
-            datagrams counted in ipForwDatagrams if any such packets met
-            this (discretionary) discard criterion.
-
-            This object has been deprecated, as a new IP version-neutral
-            table has been added.  It is loosely replaced by
-            ipSystemStatsOutDiscards."
-    ::= { ip 11 }
-
-ipOutNoRoutes OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The number of IPv4 datagrams discarded because no route
-            could be found to transmit them to their destination.  Note
-            that this counter includes any packets counted in
-            ipForwDatagrams which meet this `no-route' criterion.  Note
-            that this includes any datagrams which a host cannot route
-            because all of its default routers are down.
-
-            This object has been deprecated, as a new IP version-neutral
-
-
-
-            table has been added.  It is loosely replaced by
-            ipSystemStatsOutNoRoutes."
-    ::= { ip 12 }
-
-ipReasmReqds OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The number of IPv4 fragments received which needed to be
-            reassembled at this entity.
-
-            This object has been deprecated, as a new IP version-neutral
-            table has been added.  It is loosely replaced by
-            ipSystemStatsReasmReqds."
-    ::= { ip 14 }
-
-ipReasmOKs OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The number of IPv4 datagrams successfully re-assembled.
-
-            This object has been deprecated, as a new IP version-neutral
-            table has been added.  It is loosely replaced by
-            ipSystemStatsReasmOKs."
-    ::= { ip 15 }
-
-ipReasmFails OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The number of failures detected by the IPv4 re-assembly
-            algorithm (for whatever reason: timed out, errors, etc).
-            Note that this is not necessarily a count of discarded IPv4
-            fragments since some algorithms (notably the algorithm in
-            RFC 815) can lose track of the number of fragments by
-            combining them as they are received.
-
-            This object has been deprecated, as a new IP version-neutral
-            table has been added.  It is loosely replaced by
-            ipSystemStatsReasmFails."
-    ::= { ip 16 }
-
-ipFragOKs OBJECT-TYPE
-    SYNTAX     Counter32
-
-
-
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The number of IPv4 datagrams that have been successfully
-            fragmented at this entity.
-
-            This object has been deprecated, as a new IP version-neutral
-            table has been added.  It is loosely replaced by
-            ipSystemStatsOutFragOKs."
-    ::= { ip 17 }
-
-ipFragFails OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The number of IPv4 datagrams that have been discarded
-            because they needed to be fragmented at this entity but
-            could not be, e.g., because their Don't Fragment flag was
-            set.
-
-            This object has been deprecated, as a new IP version-neutral
-            table has been added.  It is loosely replaced by
-            ipSystemStatsOutFragFails."
-    ::= { ip 18 }
-
-ipFragCreates OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The number of IPv4 datagram fragments that have been
-            generated as a result of fragmentation at this entity.
-
-            This object has been deprecated as a new IP version neutral
-            table has been added.  It is loosely replaced by
-            ipSystemStatsOutFragCreates."
-    ::= { ip 19 }
-
-ipRoutingDiscards OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The number of routing entries which were chosen to be
-            discarded even though they are valid.  One possible reason
-            for discarding such an entry could be to free-up buffer
-            space for other routing entries.
-
-
-
-            This object was defined in pre-IPv6 versions of the IP MIB.
-            It was implicitly IPv4 only, but the original specifications
-            did not indicate this protocol restriction.  In order to
-            clarify the specifications, this object has been deprecated
-            and a similar, but more thoroughly clarified, object has
-            been added to the IP-FORWARD-MIB."
-    ::= { ip 23 }
-
--- the deprecated IPv4 address table
-
-ipAddrTable OBJECT-TYPE
-    SYNTAX     SEQUENCE OF IpAddrEntry
-    MAX-ACCESS not-accessible
-    STATUS     deprecated
-    DESCRIPTION
-           "The table of addressing information relevant to this
-            entity's IPv4 addresses.
-
-            This table has been deprecated, as a new IP version-neutral
-            table has been added.  It is loosely replaced by the
-            ipAddressTable although several objects that weren't deemed
-            useful weren't carried forward while another
-            (ipAdEntReasmMaxSize) was moved to the ipv4InterfaceTable."
-    ::= { ip 20 }
-
-ipAddrEntry OBJECT-TYPE
-    SYNTAX     IpAddrEntry
-    MAX-ACCESS not-accessible
-    STATUS     deprecated
-    DESCRIPTION
-           "The addressing information for one of this entity's IPv4
-            addresses."
-    INDEX      { ipAdEntAddr }
-    ::= { ipAddrTable 1 }
-
-IpAddrEntry ::= SEQUENCE {
-        ipAdEntAddr          IpAddress,
-        ipAdEntIfIndex       INTEGER,
-        ipAdEntNetMask       IpAddress,
-        ipAdEntBcastAddr     INTEGER,
-        ipAdEntReasmMaxSize  INTEGER
-    }
-
-ipAdEntAddr OBJECT-TYPE
-    SYNTAX     IpAddress
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-
-
-
-           "The IPv4 address to which this entry's addressing
-            information pertains."
-    ::= { ipAddrEntry 1 }
-
-ipAdEntIfIndex OBJECT-TYPE
-    SYNTAX     INTEGER (1..2147483647)
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The index value which uniquely identifies the interface to
-            which this entry is applicable.  The interface identified by
-            a particular value of this index is the same interface as
-            identified by the same value of the IF-MIB's ifIndex."
-    ::= { ipAddrEntry 2 }
-
-ipAdEntNetMask OBJECT-TYPE
-    SYNTAX     IpAddress
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The subnet mask associated with the IPv4 address of this
-            entry.  The value of the mask is an IPv4 address with all
-            the network bits set to 1 and all the hosts bits set to 0."
-    ::= { ipAddrEntry 3 }
-
-ipAdEntBcastAddr OBJECT-TYPE
-    SYNTAX     INTEGER (0..1)
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The value of the least-significant bit in the IPv4 broadcast
-            address used for sending datagrams on the (logical)
-            interface associated with the IPv4 address of this entry.
-            For example, when the Internet standard all-ones broadcast
-            address is used, the value will be 1.  This value applies to
-            both the subnet and network broadcast addresses used by the
-            entity on this (logical) interface."
-    ::= { ipAddrEntry 4 }
-
-ipAdEntReasmMaxSize OBJECT-TYPE
-    SYNTAX     INTEGER (0..65535)
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The size of the largest IPv4 datagram which this entity can
-            re-assemble from incoming IPv4 fragmented datagrams received
-            on this interface."
-    ::= { ipAddrEntry 5 }
-
-
-
--- the deprecated IPv4 Address Translation table
-
--- The Address Translation tables contain the IpAddress to
--- "physical" address equivalences.  Some interfaces do not
--- use translation tables for determining address
--- equivalences (e.g., DDN-X.25 has an algorithmic method);
--- if all interfaces are of this type, then the Address
--- Translation table is empty, i.e., has zero entries.
-
-ipNetToMediaTable OBJECT-TYPE
-    SYNTAX     SEQUENCE OF IpNetToMediaEntry
-    MAX-ACCESS not-accessible
-    STATUS     deprecated
-    DESCRIPTION
-           "The IPv4 Address Translation table used for mapping from
-            IPv4 addresses to physical addresses.
-
-            This table has been deprecated, as a new IP version-neutral
-            table has been added.  It is loosely replaced by the
-            ipNetToPhysicalTable."
-    ::= { ip 22 }
-
-ipNetToMediaEntry OBJECT-TYPE
-    SYNTAX     IpNetToMediaEntry
-    MAX-ACCESS not-accessible
-    STATUS     deprecated
-    DESCRIPTION
-           "Each entry contains one IpAddress to `physical' address
-            equivalence."
-    INDEX       { ipNetToMediaIfIndex,
-                  ipNetToMediaNetAddress }
-    ::= { ipNetToMediaTable 1 }
-
-IpNetToMediaEntry ::= SEQUENCE {
-        ipNetToMediaIfIndex      INTEGER,
-        ipNetToMediaPhysAddress  PhysAddress,
-        ipNetToMediaNetAddress   IpAddress,
-        ipNetToMediaType         INTEGER
-    }
-
-ipNetToMediaIfIndex OBJECT-TYPE
-    SYNTAX     INTEGER (1..2147483647)
-    MAX-ACCESS read-create
-    STATUS     deprecated
-    DESCRIPTION
-           "The interface on which this entry's equivalence is
-            effective.  The interface identified by a particular value
-            of this index is the same interface as identified by the
-
-
-
-            same value of the IF-MIB's ifIndex.
-
-            This object predates the rule limiting index objects to a
-            max access value of 'not-accessible' and so continues to use
-            a value of 'read-create'."
-    ::= { ipNetToMediaEntry 1 }
-
-ipNetToMediaPhysAddress OBJECT-TYPE
-    SYNTAX     PhysAddress (SIZE(0..65535))
-    MAX-ACCESS read-create
-    STATUS     deprecated
-    DESCRIPTION
-           "The media-dependent `physical' address.  This object should
-            return 0 when this entry is in the 'incomplete' state.
-
-            As the entries in this table are typically not persistent
-            when this object is written the entity should not save the
-            change to non-volatile storage.  Note: a stronger
-            requirement is not used because this object was previously
-            defined."
-    ::= { ipNetToMediaEntry 2 }
-
-ipNetToMediaNetAddress OBJECT-TYPE
-    SYNTAX     IpAddress
-    MAX-ACCESS read-create
-    STATUS     deprecated
-    DESCRIPTION
-           "The IpAddress corresponding to the media-dependent
-            `physical' address.
-
-            This object predates the rule limiting index objects to a
-            max access value of 'not-accessible' and so continues to use
-            a value of 'read-create'."
-    ::= { ipNetToMediaEntry 3 }
-
-ipNetToMediaType OBJECT-TYPE
-    SYNTAX     INTEGER {
-                other(1),        -- none of the following
-                invalid(2),      -- an invalidated mapping
-                dynamic(3),
-                static(4)
-            }
-    MAX-ACCESS read-create
-    STATUS     deprecated
-    DESCRIPTION
-           "The type of mapping.
-
-            Setting this object to the value invalid(2) has the effect
-
-
-
-            of invalidating the corresponding entry in the
-            ipNetToMediaTable.  That is, it effectively dis-associates
-            the interface identified with said entry from the mapping
-            identified with said entry.  It is an implementation-
-            specific matter as to whether the agent removes an
-            invalidated entry from the table.  Accordingly, management
-            stations must be prepared to receive tabular information
-            from agents that corresponds to entries not currently in
-            use.  Proper interpretation of such entries requires
-            examination of the relevant ipNetToMediaType object.
-
-            As the entries in this table are typically not persistent
-            when this object is written the entity should not save the
-            change to non-volatile storage.  Note: a stronger
-            requirement is not used because this object was previously
-            defined."
-    ::= { ipNetToMediaEntry 4 }
-
--- the deprecated ICMP group
-
-icmpInMsgs OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The total number of ICMP messages which the entity received.
-            Note that this counter includes all those counted by
-            icmpInErrors.
-
-            This object has been deprecated, as a new IP version-neutral
-            table has been added.  It is loosely replaced by
-            icmpStatsInMsgs."
-    ::= { icmp 1 }
-
-icmpInErrors OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The number of ICMP messages which the entity received but
-            determined as having ICMP-specific errors (bad ICMP
-            checksums, bad length, etc.).
-
-            This object has been deprecated, as a new IP version-neutral
-            table has been added.  It is loosely replaced by
-            icmpStatsInErrors."
-    ::= { icmp 2 }
-
-
-
-
-icmpInDestUnreachs OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The number of ICMP Destination Unreachable messages
-            received.
-
-            This object has been deprecated, as a new IP version-neutral
-            table has been added.  It is loosely replaced by a column in
-            the icmpMsgStatsTable."
-    ::= { icmp 3 }
-
-icmpInTimeExcds OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The number of ICMP Time Exceeded messages received.
-
-            This object has been deprecated, as a new IP version-neutral
-            table has been added.  It is loosely replaced by a column in
-            the icmpMsgStatsTable."
-    ::= { icmp 4 }
-
-icmpInParmProbs OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The number of ICMP Parameter Problem messages received.
-
-            This object has been deprecated, as a new IP version-neutral
-            table has been added.  It is loosely replaced by a column in
-            the icmpMsgStatsTable."
-    ::= { icmp 5 }
-
-icmpInSrcQuenchs OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The number of ICMP Source Quench messages received.
-
-            This object has been deprecated, as a new IP version-neutral
-            table has been added.  It is loosely replaced by a column in
-            the icmpMsgStatsTable."
-    ::= { icmp 6 }
-
-
-
-icmpInRedirects OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The number of ICMP Redirect messages received.
-
-            This object has been deprecated, as a new IP version-neutral
-            table has been added.  It is loosely replaced by a column in
-            the icmpMsgStatsTable."
-    ::= { icmp 7 }
-
-icmpInEchos OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The number of ICMP Echo (request) messages received.
-
-            This object has been deprecated, as a new IP version-neutral
-            table has been added.  It is loosely replaced by a column in
-            the icmpMsgStatsTable."
-    ::= { icmp 8 }
-
-icmpInEchoReps OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The number of ICMP Echo Reply messages received.
-
-            This object has been deprecated, as a new IP version-neutral
-            table has been added.  It is loosely replaced by a column in
-            the icmpMsgStatsTable."
-    ::= { icmp 9 }
-
-icmpInTimestamps OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The number of ICMP Timestamp (request) messages received.
-
-            This object has been deprecated, as a new IP version-neutral
-            table has been added.  It is loosely replaced by a column in
-            the icmpMsgStatsTable."
-    ::= { icmp 10 }
-
-
-
-
-icmpInTimestampReps OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The number of ICMP Timestamp Reply messages received.
-
-            This object has been deprecated, as a new IP version-neutral
-            table has been added.  It is loosely replaced by a column in
-            the icmpMsgStatsTable."
-    ::= { icmp 11 }
-
-icmpInAddrMasks OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The number of ICMP Address Mask Request messages received.
-
-            This object has been deprecated, as a new IP version-neutral
-            table has been added.  It is loosely replaced by a column in
-            the icmpMsgStatsTable."
-    ::= { icmp 12 }
-
-icmpInAddrMaskReps OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The number of ICMP Address Mask Reply messages received.
-
-            This object has been deprecated, as a new IP version-neutral
-            table has been added.  It is loosely replaced by a column in
-            the icmpMsgStatsTable."
-    ::= { icmp 13 }
-
-icmpOutMsgs OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The total number of ICMP messages which this entity
-            attempted to send.  Note that this counter includes all
-            those counted by icmpOutErrors.
-
-            This object has been deprecated, as a new IP version-neutral
-            table has been added.  It is loosely replaced by
-            icmpStatsOutMsgs."
-
-
-
-    ::= { icmp 14 }
-
-icmpOutErrors OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The number of ICMP messages which this entity did not send
-            due to problems discovered within ICMP, such as a lack of
-            buffers.  This value should not include errors discovered
-            outside the ICMP layer, such as the inability of IP to route
-            the resultant datagram.  In some implementations, there may
-            be no types of error which contribute to this counter's
-            value.
-
-            This object has been deprecated, as a new IP version-neutral
-            table has been added.  It is loosely replaced by
-            icmpStatsOutErrors."
-    ::= { icmp 15 }
-
-icmpOutDestUnreachs OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The number of ICMP Destination Unreachable messages sent.
-
-            This object has been deprecated, as a new IP version-neutral
-            table has been added.  It is loosely replaced by a column in
-            the icmpMsgStatsTable."
-    ::= { icmp 16 }
-
-icmpOutTimeExcds OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The number of ICMP Time Exceeded messages sent.
-
-            This object has been deprecated, as a new IP version-neutral
-            table has been added.  It is loosely replaced by a column in
-            the icmpMsgStatsTable."
-    ::= { icmp 17 }
-
-icmpOutParmProbs OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     deprecated
-
-
-
-    DESCRIPTION
-           "The number of ICMP Parameter Problem messages sent.
-
-            This object has been deprecated, as a new IP version-neutral
-            table has been added.  It is loosely replaced by a column in
-            the icmpMsgStatsTable."
-    ::= { icmp 18 }
-
-icmpOutSrcQuenchs OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The number of ICMP Source Quench messages sent.
-
-            This object has been deprecated, as a new IP version-neutral
-            table has been added.  It is loosely replaced by a column in
-            the icmpMsgStatsTable."
-    ::= { icmp 19 }
-
-icmpOutRedirects OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The number of ICMP Redirect messages sent.  For a host, this
-            object will always be zero, since hosts do not send
-            redirects.
-
-            This object has been deprecated, as a new IP version-neutral
-            table has been added.  It is loosely replaced by a column in
-            the icmpMsgStatsTable."
-    ::= { icmp 20 }
-
-icmpOutEchos OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The number of ICMP Echo (request) messages sent.
-
-            This object has been deprecated, as a new IP version-neutral
-            table has been added.  It is loosely replaced by a column in
-            the icmpMsgStatsTable."
-    ::= { icmp 21 }
-
-icmpOutEchoReps OBJECT-TYPE
-    SYNTAX     Counter32
-
-
-
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The number of ICMP Echo Reply messages sent.
-
-            This object has been deprecated, as a new IP version-neutral
-            table has been added.  It is loosely replaced by a column in
-            the icmpMsgStatsTable."
-    ::= { icmp 22 }
-
-icmpOutTimestamps OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The number of ICMP Timestamp (request) messages sent.
-
-            This object has been deprecated, as a new IP version-neutral
-            table has been added.  It is loosely replaced by a column in
-            the icmpMsgStatsTable."
-    ::= { icmp 23 }
-
-icmpOutTimestampReps OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The number of ICMP Timestamp Reply messages sent.
-
-            This object has been deprecated, as a new IP version-neutral
-            table has been added.  It is loosely replaced by a column in
-            the icmpMsgStatsTable."
-    ::= { icmp 24 }
-
-icmpOutAddrMasks OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The number of ICMP Address Mask Request messages sent.
-
-            This object has been deprecated, as a new IP version-neutral
-            table has been added.  It is loosely replaced by a column in
-            the icmpMsgStatsTable."
-    ::= { icmp 25 }
-
-icmpOutAddrMaskReps OBJECT-TYPE
-    SYNTAX     Counter32
-
-
-
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The number of ICMP Address Mask Reply messages sent.
-
-            This object has been deprecated, as a new IP version-neutral
-            table has been added.  It is loosely replaced by a column in
-            the icmpMsgStatsTable."
-    ::= { icmp 26 }
-
--- deprecated conformance information
--- deprecated compliance statements
-
-ipMIBCompliance MODULE-COMPLIANCE
-    STATUS     deprecated
-    DESCRIPTION
-           "The compliance statement for systems that implement only
-            IPv4.  For version-independence, this compliance statement
-            is deprecated in favor of ipMIBCompliance2."
-    MODULE  -- this module
-        MANDATORY-GROUPS { ipGroup,
-                           icmpGroup }
-    ::= { ipMIBCompliances 1 }
-
--- deprecated units of conformance
-
-ipGroup OBJECT-GROUP
-    OBJECTS   { ipForwarding,           ipDefaultTTL,
-                ipInReceives,           ipInHdrErrors,
-                ipInAddrErrors,         ipForwDatagrams,
-                ipInUnknownProtos,      ipInDiscards,
-                ipInDelivers,           ipOutRequests,
-                ipOutDiscards,          ipOutNoRoutes,
-                ipReasmTimeout,         ipReasmReqds,
-                ipReasmOKs,             ipReasmFails,
-                ipFragOKs,              ipFragFails,
-                ipFragCreates,          ipAdEntAddr,
-                ipAdEntIfIndex,         ipAdEntNetMask,
-                ipAdEntBcastAddr,       ipAdEntReasmMaxSize,
-                ipNetToMediaIfIndex,    ipNetToMediaPhysAddress,
-                ipNetToMediaNetAddress, ipNetToMediaType,
-                ipRoutingDiscards
-}
-    STATUS     deprecated
-    DESCRIPTION
-           "The ip group of objects providing for basic management of IP
-            entities, exclusive of the management of IP routes.
-
-
-
-
-            As part of the version independence, this group has been
-            deprecated.  "
-    ::= { ipMIBGroups 1 }
-
-icmpGroup OBJECT-GROUP
-    OBJECTS   { icmpInMsgs,          icmpInErrors,
-                icmpInDestUnreachs,  icmpInTimeExcds,
-                icmpInParmProbs,     icmpInSrcQuenchs,
-                icmpInRedirects,     icmpInEchos,
-                icmpInEchoReps,      icmpInTimestamps,
-                icmpInTimestampReps, icmpInAddrMasks,
-                icmpInAddrMaskReps,  icmpOutMsgs,
-                icmpOutErrors,       icmpOutDestUnreachs,
-                icmpOutTimeExcds,    icmpOutParmProbs,
-                icmpOutSrcQuenchs,   icmpOutRedirects,
-                icmpOutEchos,        icmpOutEchoReps,
-                icmpOutTimestamps,   icmpOutTimestampReps,
-                icmpOutAddrMasks,    icmpOutAddrMaskReps }
-    STATUS     deprecated
-    DESCRIPTION
-           "The icmp group of objects providing ICMP statistics.
-
-            As part of the version independence, this group has been
-            deprecated.  "
-    ::= { ipMIBGroups 2 }
-
-END
diff --git a/contrib/apps/LwipMibCompiler/Mibs/RFC-1212 b/contrib/apps/LwipMibCompiler/Mibs/RFC-1212
deleted file mode 100644
index 4b1bdcfd..00000000
--- a/contrib/apps/LwipMibCompiler/Mibs/RFC-1212
+++ /dev/null
@@ -1,75 +0,0 @@
-RFC-1212 DEFINITIONS ::= BEGIN
-
-          IMPORTS
-              ObjectName
-                  FROM RFC1155-SMI;
---            DisplayString
---                FROM RFC1158-MIB;
-
-          OBJECT-TYPE MACRO ::=
-          BEGIN
-              TYPE NOTATION ::=
-                                          -- must conform to
-                                          -- RFC1155's ObjectSyntax
-                                "SYNTAX" type(ObjectSyntax)
-                                "ACCESS" Access
-                                "STATUS" Status
-                                DescrPart
-                                ReferPart
-                                IndexPart
-                                DefValPart
-              VALUE NOTATION ::= value (VALUE ObjectName)
-
-              Access ::= "read-only"
-                              | "read-write"
-                              | "write-only"
-                              | "not-accessible"
-              Status ::= "mandatory"
-                              | "optional"
-                              | "obsolete"
-                              | "deprecated"
-
-              DescrPart ::=
-                         "DESCRIPTION" value (description DisplayString)
-                              | empty
-
-              ReferPart ::=
-                         "REFERENCE" value (reference DisplayString)
-                              | empty
-
-              IndexPart ::=
-                         "INDEX" "{" IndexTypes "}"
-                              | empty
-              IndexTypes ::=
-                         IndexType | IndexTypes "," IndexType
-              IndexType ::=
-                                  -- if indexobject, use the SYNTAX
-                                  -- value of the correspondent
-                                  -- OBJECT-TYPE invocation
-                         value (indexobject ObjectName)
-                                  -- otherwise use named SMI type
-                                  -- must conform to IndexSyntax below
-                              | type (indextype)
-
-              DefValPart ::=
-                         "DEFVAL" "{" value (defvalue ObjectSyntax) "}"
-                              | empty
-
-          END
-
-          IndexSyntax ::=
-              CHOICE {
-                  number
-                      INTEGER (0..MAX),
-                  string
-                      OCTET STRING,
-                  object
-                      OBJECT IDENTIFIER,
-                  address
-                      NetworkAddress,
-                  ipAddress
-                      IpAddress
-              }
-
-END
-
diff --git a/contrib/apps/LwipMibCompiler/Mibs/RFC-1215 b/contrib/apps/LwipMibCompiler/Mibs/RFC-1215
deleted file mode 100644
index 3cdcfdf3..00000000
--- a/contrib/apps/LwipMibCompiler/Mibs/RFC-1215
+++ /dev/null
@@ -1,34 +0,0 @@
-RFC-1215 DEFINITIONS ::= BEGIN
-
-  IMPORTS
-      ObjectName
-          FROM RFC1155-SMI;
-
-  TRAP-TYPE MACRO ::=
-  BEGIN
-      TYPE NOTATION ::= "ENTERPRISE" value
-                            (enterprise OBJECT IDENTIFIER)
-                        VarPart
-                        DescrPart
-                        ReferPart
-      VALUE NOTATION ::= value (VALUE INTEGER)
-
-      VarPart ::=
-                 "VARIABLES" "{" VarTypes "}"
-                      | empty
-      VarTypes ::=
-                 VarType | VarTypes "," VarType
-      VarType ::=
-                 value (vartype ObjectName)
-
-      DescrPart ::=
-                 "DESCRIPTION" value (description DisplayString)
-                      | empty
-
-      ReferPart ::=
-                 "REFERENCE" value (reference DisplayString)
-                      | empty
-
-  END
-
-END
diff --git a/contrib/apps/LwipMibCompiler/Mibs/RFC1065-SMI b/contrib/apps/LwipMibCompiler/Mibs/RFC1065-SMI
deleted file mode 100644
index 40e55d70..00000000
--- a/contrib/apps/LwipMibCompiler/Mibs/RFC1065-SMI
+++ /dev/null
@@ -1,132 +0,0 @@
-RFC1065-SMI DEFINITIONS ::= BEGIN
-
-EXPORTS -- EVERYTHING
-        internet, directory, mgmt,
-        experimental, private, enterprises,
-        OBJECT-TYPE, ObjectName, ObjectSyntax, SimpleSyntax,
-        ApplicationSyntax, NetworkAddress, IpAddress,
-        Counter, Gauge, TimeTicks, Opaque;
-
- -- the path to the root
-
- internet      OBJECT IDENTIFIER ::= { iso org(3) dod(6) 1 }
-
- directory     OBJECT IDENTIFIER ::= { internet 1 }
-
- mgmt          OBJECT IDENTIFIER ::= { internet 2 }
-
- experimental  OBJECT IDENTIFIER ::= { internet 3 }
-
- private       OBJECT IDENTIFIER ::= { internet 4 }
- enterprises   OBJECT IDENTIFIER ::= { private 1 }
-
-
- -- definition of object types
-
- OBJECT-TYPE MACRO ::=
- BEGIN
-     TYPE NOTATION ::= "SYNTAX" type (TYPE ObjectSyntax)
-                       "ACCESS" Access
-                       "STATUS" Status
-     VALUE NOTATION ::= value (VALUE ObjectName)
-
-     Access ::= "read-only"
-                     | "read-write"
-                     | "write-only"
-                     | "not-accessible"
-     Status ::= "mandatory"
-                     | "optional"
-                     | "obsolete"
- END
-
-    -- names of objects in the MIB
-
-    ObjectName ::=
-        OBJECT IDENTIFIER
-
-
-
-    -- syntax of objects in the MIB
-
-    ObjectSyntax ::=
-        CHOICE {
-            simple
-                SimpleSyntax,
-
-    -- note that simple SEQUENCEs are not directly
-    -- mentioned here to keep things simple (i.e.,
-    -- prevent mis-use).  However, application-wide
-    -- types which are IMPLICITly encoded simple
-    -- SEQUENCEs may appear in the following CHOICE
-
-               application-wide
-                   ApplicationSyntax
-           }
-
-       SimpleSyntax ::=
-           CHOICE {
-               number
-                   INTEGER,
-
-               string
-                   OCTET STRING,
-
-               object
-                   OBJECT IDENTIFIER,
-
-               empty
-                   NULL
-           }
-
-       ApplicationSyntax ::=
-           CHOICE {
-               address
-                   NetworkAddress,
-
-               counter
-                   Counter,
-
-               gauge
-                   Gauge,
-
-               ticks
-                   TimeTicks,
-
-               arbitrary
-                   Opaque
-
-
-       -- other application-wide types, as they are
-       -- defined, will be added here
-           }
-
-
-       -- application-wide types
-
-       NetworkAddress ::=
-           CHOICE {
-               internet
-                   IpAddress
-           }
-
-       IpAddress ::=
-           [APPLICATION 0]          -- in network-byte order
-               IMPLICIT OCTET STRING (SIZE (4))
-
-       Counter ::=
-           [APPLICATION 1]
-               IMPLICIT INTEGER (0..4294967295)
-
-       Gauge ::=
-           [APPLICATION 2]
-               IMPLICIT INTEGER (0..4294967295)
-
-       TimeTicks ::=
-           [APPLICATION 3]
-               IMPLICIT INTEGER
-
-       Opaque ::=
-           [APPLICATION 4]          -- arbitrary ASN.1 value,
-               IMPLICIT OCTET STRING   --   "double-wrapped"
-
-       END
diff --git a/contrib/apps/LwipMibCompiler/Mibs/RFC1155-SMI b/contrib/apps/LwipMibCompiler/Mibs/RFC1155-SMI
deleted file mode 100644
index a6c3bf62..00000000
--- a/contrib/apps/LwipMibCompiler/Mibs/RFC1155-SMI
+++ /dev/null
@@ -1,129 +0,0 @@
-RFC1155-SMI DEFINITIONS ::= BEGIN
-
-EXPORTS -- EVERYTHING
-        internet, directory, mgmt,
-        experimental, private, enterprises,
-        OBJECT-TYPE, ObjectName, ObjectSyntax, SimpleSyntax,
-        ApplicationSyntax, NetworkAddress, IpAddress,
-        Counter, Gauge, TimeTicks, Opaque;
-
- -- the path to the root
-
- internet      OBJECT IDENTIFIER ::= { iso org(3) dod(6) 1 }
-
- directory     OBJECT IDENTIFIER ::= { internet 1 }
-
- mgmt          OBJECT IDENTIFIER ::= { internet 2 }
-
- experimental  OBJECT IDENTIFIER ::= { internet 3 }
-
- private       OBJECT IDENTIFIER ::= { internet 4 }
- enterprises   OBJECT IDENTIFIER ::= { private 1 }
-
-
- -- definition of object types
-
- OBJECT-TYPE MACRO ::=
- BEGIN
-     TYPE NOTATION ::= "SYNTAX" type (TYPE ObjectSyntax)
-                       "ACCESS" Access
-                       "STATUS" Status
-     VALUE NOTATION ::= value (VALUE ObjectName)
-
-     Access ::= "read-only"
-                     | "read-write"
-                     | "write-only"
-                     | "not-accessible"
-     Status ::= "mandatory"
-                     | "optional"
-                     | "obsolete"
- END
-
-    -- names of objects in the MIB
-
-    ObjectName ::=
-        OBJECT IDENTIFIER
-
-    -- syntax of objects in the MIB
-
-    ObjectSyntax ::=
-        CHOICE {
-            simple
-                SimpleSyntax,
-
-    -- note that simple SEQUENCEs are not directly
-    -- mentioned here to keep things simple (i.e.,
-    -- prevent mis-use).  However, application-wide
-    -- types which are IMPLICITly encoded simple
-    -- SEQUENCEs may appear in the following CHOICE
-
-            application-wide
-                ApplicationSyntax
-        }
-
-       SimpleSyntax ::=
-           CHOICE {
-               number
-                   INTEGER,
-
-               string
-                   OCTET STRING,
-
-               object
-                   OBJECT IDENTIFIER,
-
-               empty
-                   NULL
-           }
-
-       ApplicationSyntax ::=
-           CHOICE {
-               address
-                   NetworkAddress,
-
-               counter
-                   Counter,
-
-               gauge
-                   Gauge,
-
-               ticks
-                   TimeTicks,
-
-               arbitrary
-                   Opaque
-
-       -- other application-wide types, as they are
-       -- defined, will be added here
-           }
-
-
-       -- application-wide types
-
-       NetworkAddress ::=
-           CHOICE {
-               internet
-                   IpAddress
-           }
-
-       IpAddress ::=
-           [APPLICATION 0]          -- in network-byte order
-               IMPLICIT OCTET STRING (SIZE (4))
-
-       Counter ::=
-           [APPLICATION 1]
-               IMPLICIT INTEGER (0..4294967295)
-
-       Gauge ::=
-           [APPLICATION 2]
-               IMPLICIT INTEGER (0..4294967295)
-
-       TimeTicks ::=
-           [APPLICATION 3]
-               IMPLICIT INTEGER (0..4294967295)
-
-       Opaque ::=
-           [APPLICATION 4]          -- arbitrary ASN.1 value,
-               IMPLICIT OCTET STRING   --   "double-wrapped"
-
-       END
diff --git a/contrib/apps/LwipMibCompiler/Mibs/RFC1158-MIB b/contrib/apps/LwipMibCompiler/Mibs/RFC1158-MIB
deleted file mode 100644
index 4acf34a0..00000000
--- a/contrib/apps/LwipMibCompiler/Mibs/RFC1158-MIB
+++ /dev/null
@@ -1,1493 +0,0 @@
-RFC1158-MIB DEFINITIONS ::= BEGIN
-
-IMPORTS
-        mgmt, OBJECT-TYPE, NetworkAddress, IpAddress,
-        Counter, Gauge, TimeTicks
-            FROM RFC1155-SMI;
-
-DisplayString ::=
-            OCTET STRING
-
-mib-2      OBJECT IDENTIFIER ::= { mgmt 1 }    -- MIB-II
-           -- (same prefix as MIB-I)
-
-system     OBJECT IDENTIFIER ::= { mib-2 1 }
-interfaces OBJECT IDENTIFIER ::= { mib-2 2 }
-at         OBJECT IDENTIFIER ::= { mib-2 3 }
-ip         OBJECT IDENTIFIER ::= { mib-2 4 }
-icmp       OBJECT IDENTIFIER ::= { mib-2 5 }
-tcp        OBJECT IDENTIFIER ::= { mib-2 6 }
-udp        OBJECT IDENTIFIER ::= { mib-2 7 }
-egp        OBJECT IDENTIFIER ::= { mib-2 8 }
--- cmot    OBJECT IDENTIFIER ::= { mib-2 9 }
-transmission OBJECT IDENTIFIER ::= { mib-2 10 }
-snmp       OBJECT IDENTIFIER ::= { mib-2 11 }
-
-
--- object types
-
--- the System group
-
-sysDescr OBJECT-TYPE
-        SYNTAX  DisplayString (SIZE (0..255))
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { system 1 }
-
-sysObjectID OBJECT-TYPE
-        SYNTAX  OBJECT IDENTIFIER
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { system 2 }
-
-sysUpTime OBJECT-TYPE
-        SYNTAX  TimeTicks
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { system 3 }
-
-sysContact OBJECT-TYPE
-        SYNTAX  DisplayString (SIZE (0..255))
-        ACCESS  read-write
-        STATUS  mandatory
-        ::= { system 4 }
-
-sysName OBJECT-TYPE
-        SYNTAX  DisplayString (SIZE (0..255))
-        ACCESS  read-write
-        STATUS  mandatory
-        ::= { system 5 }
-
-sysLocation OBJECT-TYPE
-        SYNTAX  DisplayString (SIZE (0..255))
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { system 6 }
-
-sysServices OBJECT-TYPE
-        SYNTAX  INTEGER (0..127)
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { system 7 }
-
-
--- the Interfaces group
-
-ifNumber OBJECT-TYPE
-        SYNTAX  INTEGER
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { interfaces 1 }
-
--- the Interfaces table
-
-ifTable OBJECT-TYPE
-        SYNTAX  SEQUENCE OF IfEntry
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { interfaces 2 }
-
-ifEntry OBJECT-TYPE
-        SYNTAX  IfEntry
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { ifTable 1 }
-
-IfEntry ::= SEQUENCE {
-    ifIndex
-        INTEGER,
-    ifDescr
-        DisplayString,
-    ifType
-        INTEGER,
-    ifMtu
-        INTEGER,
-    ifSpeed
-        Gauge,
-    ifPhysAddress
-        OCTET STRING,
-    ifAdminStatus
-        INTEGER,
-    ifOperStatus
-        INTEGER,
-    ifLastChange
-        TimeTicks,
-    ifInOctets
-        Counter,
-    ifInUcastPkts
-        Counter,
-    ifInNUcastPkts
-        Counter,
-    ifInDiscards
-        Counter,
-    ifInErrors
-        Counter,
-    ifInUnknownProtos
-        Counter,
-    ifOutOctets
-        Counter,
-    ifOutUcastPkts
-        Counter,
-    ifOutNUcastPkts
-        Counter,
-    ifOutDiscards
-        Counter,
-    ifOutErrors
-        Counter,
-    ifOutQLen
-        Gauge,
-    ifSpecific
-        OBJECT IDENTIFIER
-}
-
-ifIndex OBJECT-TYPE
-        SYNTAX  INTEGER
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { ifEntry 1 }
-
-ifDescr OBJECT-TYPE
-        SYNTAX  DisplayString (SIZE (0..255))
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { ifEntry 2 }
-
-ifType OBJECT-TYPE
-        SYNTAX  INTEGER {
-                    other(1),             -- none of the
-                                          -- following
-                    regular1822(2),
-                    hdh1822(3),
-                    ddn-x25(4),
-                    rfc877-x25(5),
-                    ethernet-csmacd(6),
-                    iso88023-csmacd(7),
-                    iso88024-tokenBus(8),
-                    iso88025-tokenRing(9),
-                    iso88026-man(10),
-                    starLan(11),
-                    proteon-10Mbit(12),
-                    proteon-80Mbit(13),
-                    hyperchannel(14),
-                    fddi(15),
-                    lapb(16),
-                    sdlc(17),
-                    t1-carrier(18),
-                    cept(19),        -- european
-                                     --equivalent of T-1
-                    basicISDN(20),
-                    primaryISDN(21),
-                                          -- proprietary
-                                          -- serial
-                    propPointToPointSerial(22),
-                    terminalServer-asyncPort(23),
-                    softwareLoopback(24),
-                    eon(25),              -- CLNP over IP
-                    ethernet-3Mbit(26),
-                    nsip(27),             -- XNS over IP
-                    slip(28)              -- generic SLIP
-            }
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { ifEntry 3 }
-
-ifMtu OBJECT-TYPE
-        SYNTAX  INTEGER
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { ifEntry 4 }
-
-ifSpeed OBJECT-TYPE
-        SYNTAX  Gauge
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { ifEntry 5 }
-
-ifPhysAddress OBJECT-TYPE
-        SYNTAX  OCTET STRING
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { ifEntry 6 }
-
-ifAdminStatus OBJECT-TYPE
-        SYNTAX  INTEGER {
-                    up(1),     -- ready to pass packets
-                    down(2),
-                    testing(3) -- in some test mode
-                }
-        ACCESS  read-write
-        STATUS  mandatory
-        ::= { ifEntry 7 }
-
-ifOperStatus OBJECT-TYPE
-        SYNTAX  INTEGER {
-                    up(1),     -- ready to pass packets
-                    down(2),
-                    testing(3) -- in some test mode
-                }
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { ifEntry 8 }
-
-ifLastChange OBJECT-TYPE
-        SYNTAX  TimeTicks
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { ifEntry 9 }
-
-ifInOctets OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { ifEntry 10 }
-
-ifInUcastPkts OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::=  { ifEntry 11 }
-
-ifInNUcastPkts OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { ifEntry 12 }
-
-ifInDiscards OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { ifEntry 13 }
-
-ifInErrors OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { ifEntry 14 }
-
-ifInUnknownProtos OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { ifEntry 15 }
-
-ifOutOctets OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { ifEntry 16 }
-
-ifOutUcastPkts OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { ifEntry 17 }
-
-ifOutNUcastPkts OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { ifEntry 18 }
-
-ifOutDiscards OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { ifEntry 19 }
-
-ifOutErrors OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { ifEntry 20 }
-
-ifOutQLen OBJECT-TYPE
-        SYNTAX  Gauge
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { ifEntry 21 }
-
-ifSpecific OBJECT-TYPE
-        SYNTAX  OBJECT IDENTIFIER
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { ifEntry 22 }
-
-nullSpecific OBJECT IDENTIFIER ::= { 0 0 }
-
--- the Address Translation group (deprecated)
-
-atTable OBJECT-TYPE
-        SYNTAX  SEQUENCE OF AtEntry
-        ACCESS  read-write
-        STATUS  deprecated
-        ::= { at 1 }
-
-atEntry OBJECT-TYPE
-        SYNTAX  AtEntry
-        ACCESS  read-write
-        STATUS  deprecated
-        ::= { atTable 1 }
-
-AtEntry ::= SEQUENCE {
-    atIfIndex
-        INTEGER,
-    atPhysAddress
-        OCTET STRING,
-    atNetAddress
-        NetworkAddress
-}
-
-atIfIndex OBJECT-TYPE
-        SYNTAX  INTEGER
-        ACCESS  read-write
-        STATUS  deprecated
-        ::= { atEntry 1 }
-
-atPhysAddress OBJECT-TYPE
-        SYNTAX  OCTET STRING
-        ACCESS  read-write
-        STATUS  deprecated
-        ::= { atEntry 2 }
-
-atNetAddress OBJECT-TYPE
-        SYNTAX  NetworkAddress
-        ACCESS  read-write
-        STATUS  deprecated
-        ::= { atEntry 3 }
-
-
--- the IP group
-
-ipForwarding OBJECT-TYPE
-        SYNTAX  INTEGER {
-                    gateway(1), -- entity forwards
-                                -- datagrams
-                    host(2)     -- entity does NOT
-                                -- forward datagrams
-                }
-        ACCESS  read-write
-        STATUS  mandatory
-        ::= { ip 1 }
-
-ipDefaultTTL OBJECT-TYPE
-        SYNTAX  INTEGER
-        ACCESS  read-write
-        STATUS  mandatory
-        ::= { ip 2 }
-
-ipInReceives OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { ip 3 }
-
-ipInHdrErrors OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { ip 4 }
-
-ipInAddrErrors OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { ip 5 }
-
-ipForwDatagrams OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { ip 6 }
-
-ipInUnknownProtos OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { ip 7 }
-
-ipInDiscards OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { ip 8 }
-
-ipInDelivers OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { ip 9 }
-
-ipOutRequests OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { ip 10 }
-
-ipOutDiscards OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { ip 11 }
-
-ipOutNoRoutes OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { ip 12 }
-
-ipReasmTimeout OBJECT-TYPE
-        SYNTAX  INTEGER
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { ip 13 }
-
-ipReasmReqds OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { ip 14 }
-
-ipReasmOKs OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { ip 15 }
-
-ipReasmFails OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { ip 16 }
-
-ipFragOKs OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { ip 17 }
-
-ipFragFails OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { ip 18 }
-
-ipFragCreates OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { ip 19 }
-
--- the IP Interface table
-
-ipAddrTable OBJECT-TYPE
-        SYNTAX  SEQUENCE OF IpAddrEntry
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { ip 20 }
-
-ipAddrEntry OBJECT-TYPE
-        SYNTAX  IpAddrEntry
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { ipAddrTable 1 }
-
-IpAddrEntry ::= SEQUENCE {
-    ipAdEntAddr
-        IpAddress,
-    ipAdEntIfIndex
-        INTEGER,
-    ipAdEntNetMask
-        IpAddress,
-    ipAdEntBcastAddr
-        INTEGER,
-    ipAdEntReasmMaxSize
-        INTEGER (0..65535)
-}
-
-ipAdEntAddr OBJECT-TYPE
-        SYNTAX  IpAddress
-        ACCESS  read-only
-        STATUS  mandatory
-        ::=  { ipAddrEntry 1 }
-
-ipAdEntIfIndex OBJECT-TYPE
-        SYNTAX  INTEGER
-        ACCESS  read-only
-        STATUS  mandatory
-        ::=  { ipAddrEntry 2 }
-
-ipAdEntNetMask OBJECT-TYPE
-        SYNTAX  IpAddress
-        ACCESS  read-only
-        STATUS  mandatory
-        ::=  { ipAddrEntry 3 }
-
-ipAdEntBcastAddr OBJECT-TYPE
-        SYNTAX  INTEGER
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { ipAddrEntry 4 }
-
-ipAdEntReasmMaxSize OBJECT-TYPE
-        SYNTAX  INTEGER (0..65535)
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { ipAddrEntry 5 }
-
--- the IP Routing table
-
-ipRoutingTable OBJECT-TYPE
-        SYNTAX  SEQUENCE OF IpRouteEntry
-        ACCESS  read-write
-        STATUS  mandatory
-        ::= { ip 21 }
-
-ipRouteEntry OBJECT-TYPE
-        SYNTAX  IpRouteEntry
-        ACCESS  read-write
-        STATUS  mandatory
-        ::= { ipRoutingTable 1 }
-
-IpRouteEntry ::= SEQUENCE {
-    ipRouteDest
-        IpAddress,
-    ipRouteIfIndex
-        INTEGER,
-    ipRouteMetric1
-        INTEGER,
-    ipRouteMetric2
-        INTEGER,
-    ipRouteMetric3
-        INTEGER,
-    ipRouteMetric4
-        INTEGER,
-    ipRouteNextHop
-        IpAddress,
-    ipRouteType
-        INTEGER,
-    ipRouteProto
-        INTEGER,
-    ipRouteAge
-        INTEGER,
-    ipRouteMask
-        IpAddress
-}
-
-ipRouteDest OBJECT-TYPE
-        SYNTAX  IpAddress
-        ACCESS  read-write
-        STATUS  mandatory
-        ::= { ipRouteEntry 1 }
-
-ipRouteIfIndex  OBJECT-TYPE
-        SYNTAX  INTEGER
-        ACCESS  read-write
-        STATUS  mandatory
-        ::= { ipRouteEntry 2 }
-
-ipRouteMetric1 OBJECT-TYPE
-        SYNTAX  INTEGER
-        ACCESS  read-write
-        STATUS  mandatory
-        ::= { ipRouteEntry 3 }
-
-ipRouteMetric2 OBJECT-TYPE
-        SYNTAX  INTEGER
-        ACCESS  read-write
-        STATUS  mandatory
-        ::= { ipRouteEntry 4 }
-
-ipRouteMetric3 OBJECT-TYPE
-        SYNTAX  INTEGER
-        ACCESS  read-write
-        STATUS  mandatory
-        ::= { ipRouteEntry 5 }
-
-ipRouteMetric4 OBJECT-TYPE
-        SYNTAX  INTEGER
-        ACCESS  read-write
-        STATUS  mandatory
-        ::= { ipRouteEntry 6 }
-
-ipRouteNextHop OBJECT-TYPE
-        SYNTAX  IpAddress
-        ACCESS  read-write
-        STATUS  mandatory
-        ::= { ipRouteEntry 7 }
-
-ipRouteType OBJECT-TYPE
-        SYNTAX  INTEGER {
-                    other(1),    -- none of the following
-
-                    invalid(2),  -- an invalidated route
-
-                                 -- route to directly
-                    direct(3),   -- connected
-                                 -- (sub-)network
-
-                                 -- route to a non-local
-                    remote(4)    -- host/network/
-                                 -- sub-network
-            }
-        ACCESS  read-write
-        STATUS  mandatory
-        ::= { ipRouteEntry 8 }
-
-ipRouteProto OBJECT-TYPE
-        SYNTAX  INTEGER {
-                    other(1),    -- none of the following
-
-                                 -- non-protocol
-                                 -- information
-
-                                 --   e.g., manually
-                    local(2),    --   configured entries
-
-                                 -- set via a network
-                    netmgmt(3),  --   management protocol
-
-                                 -- obtained via ICMP,
-                    icmp(4),     --   e.g., Redirect
-
-                                 -- the following are
-                                 -- gateway routing
-                                 -- protocols
-                    egp(5),
-                    ggp(6),
-                    hello(7),
-                    rip(8),
-                    is-is(9),
-                    es-is(10),
-                    ciscoIgrp(11),
-                    bbnSpfIgp(12),
-                    ospf(13),
-                    bgp(14)
-            }
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { ipRouteEntry 9 }
-
-ipRouteAge OBJECT-TYPE
-        SYNTAX  INTEGER
-        ACCESS  read-write
-        STATUS  mandatory
-        ::= { ipRouteEntry 10 }
-
-ipRouteMask OBJECT-TYPE
-        SYNTAX  IpAddress
-        ACCESS  read-write
-        STATUS  mandatory
-        ::= { ipRouteEntry 11 }
-
--- the IP Address Translation tables
-
-ipNetToMediaTable OBJECT-TYPE
-        SYNTAX  SEQUENCE OF IpNetToMediaEntry
-        ACCESS  read-write
-        STATUS  mandatory
-        ::= { ip 22 }
-
-ipNetToMediaEntry OBJECT-TYPE
-        SYNTAX  IpNetToMediaEntry
-        ACCESS  read-write
-        STATUS  mandatory
-        ::= { ipNetToMediaTable 1 }
-
-IpNetToMediaEntry ::= SEQUENCE {
-    ipNetToMediaIfIndex
-        INTEGER,
-    ipNetToMediaPhysAddress
-        OCTET STRING,
-    ipNetToMediaNetAddress
-        IpAddress,
-    ipNetToMediaType
-        INTEGER
-}
-
-ipNetToMediaIfIndex OBJECT-TYPE
-        SYNTAX  INTEGER
-        ACCESS  read-write
-        STATUS  mandatory
-        ::= { ipNetToMediaEntry 1 }
-
-ipNetToMediaPhysAddress OBJECT-TYPE
-        SYNTAX  OCTET STRING
-        ACCESS  read-write
-        STATUS  mandatory
-        ::= { ipNetToMediaEntry 2 }
-
-ipNetToMediaNetAddress OBJECT-TYPE
-        SYNTAX  IpAddress
-        ACCESS  read-write
-        STATUS  mandatory
-        ::= { ipNetToMediaEntry 3 }
-
-ipNetToMediaType OBJECT-TYPE
-        SYNTAX  INTEGER {
-                    other(1),   -- none of the following
-
-                    invalid(2), -- an invalidated mapping
-                    dynamic(3), -- connected (sub-)network
-
-                    static(4)
-            }
-        ACCESS  read-write
-        STATUS  mandatory
-        ::= { ipNetToMediaEntry 4 }
-
--- the ICMP group
-
-icmpInMsgs OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { icmp 1 }
-
-icmpInErrors OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { icmp 2 }
-
-icmpInDestUnreachs OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { icmp 3 }
-
-icmpInTimeExcds OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { icmp 4 }
-
-icmpInParmProbs OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { icmp 5 }
-
-icmpInSrcQuenchs OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { icmp 6 }
-
-icmpInRedirects OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { icmp 7 }
-
-icmpInEchos OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { icmp 8 }
-
-icmpInEchoReps OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { icmp 9 }
-
-icmpInTimestamps OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { icmp 10 }
-
-icmpInTimestampReps OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { icmp 11 }
-
-icmpInAddrMasks OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { icmp 12 }
-
-icmpInAddrMaskReps OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { icmp 13 }
-
-icmpOutMsgs OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { icmp 14 }
-
-icmpOutErrors OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { icmp 15 }
-
-icmpOutDestUnreachs OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { icmp 16 }
-
-icmpOutTimeExcds OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { icmp 17 }
-
-icmpOutParmProbs OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { icmp 18 }
-
-icmpOutSrcQuenchs OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { icmp 19 }
-
-icmpOutRedirects OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { icmp 20 }
-
-icmpOutEchos OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { icmp 21 }
-
-icmpOutEchoReps OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { icmp 22 }
-
-icmpOutTimestamps OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { icmp 23 }
-
-icmpOutTimestampReps OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { icmp 24 }
-
-icmpOutAddrMasks OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { icmp 25 }
-
-icmpOutAddrMaskReps OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { icmp 26 }
-
-
--- the TCP group
-
-tcpRtoAlgorithm OBJECT-TYPE
-        SYNTAX  INTEGER {
-                    other(1),    -- none of the following
-                    constant(2), -- a constant rto
-                    rsre(3),     -- MIL-STD-1778,
-                                 -- Appendix B
-                    vanj(4)      -- Van Jacobson's
-                                 -- algorithm
-                }
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { tcp 1 }
-
-tcpRtoMin OBJECT-TYPE
-        SYNTAX  INTEGER
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { tcp 2 }
-
-tcpRtoMax OBJECT-TYPE
-        SYNTAX  INTEGER
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { tcp 3 }
-
-tcpMaxConn OBJECT-TYPE
-        SYNTAX  INTEGER
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { tcp 4 }
-
-tcpActiveOpens OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { tcp 5 }
-
-tcpPassiveOpens OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { tcp 6 }
-
-tcpAttemptFails OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { tcp 7 }
-
-tcpEstabResets OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { tcp 8 }
-
-tcpCurrEstab OBJECT-TYPE
-        SYNTAX  Gauge
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { tcp 9 }
-
-tcpInSegs OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { tcp 10 }
-
-tcpOutSegs OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { tcp 11 }
-
-tcpRetransSegs OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { tcp 12 }
-
--- the TCP connections table
-
-tcpConnTable OBJECT-TYPE
-        SYNTAX  SEQUENCE OF TcpConnEntry
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { tcp 13 }
-
-tcpConnEntry OBJECT-TYPE
-        SYNTAX  TcpConnEntry
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { tcpConnTable 1 }
-
-TcpConnEntry ::= SEQUENCE {
-    tcpConnState
-        INTEGER,
-    tcpConnLocalAddress
-        IpAddress,
-    tcpConnLocalPort
-        INTEGER (0..65535),
-    tcpConnRemAddress
-        IpAddress,
-    tcpConnRemPort
-        INTEGER (0..65535)
-}
-
-tcpConnState OBJECT-TYPE
-        SYNTAX  INTEGER {
-                    closed(1),
-                    listen(2),
-                    synSent(3),
-                    synReceived(4),
-                    established(5),
-                    finWait1(6),
-                    finWait2(7),
-                    closeWait(8),
-                    lastAck(9),
-                    closing(10),
-                    timeWait(11)
-                }
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { tcpConnEntry 1 }
-
-tcpConnLocalAddress OBJECT-TYPE
-        SYNTAX  IpAddress
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { tcpConnEntry 2 }
-
-tcpConnLocalPort OBJECT-TYPE
-        SYNTAX  INTEGER (0..65535)
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { tcpConnEntry 3 }
-
-tcpConnRemAddress OBJECT-TYPE
-        SYNTAX  IpAddress
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { tcpConnEntry 4 }
-
-tcpConnRemPort OBJECT-TYPE
-        SYNTAX  INTEGER (0..65535)
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { tcpConnEntry 5 }
-
--- additional TCP variables
-
-tcpInErrs OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { tcp 14 }
-
-tcpOutRsts OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { tcp 15 }
-
-
--- the UDP group
-
-udpInDatagrams OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { udp 1 }
-
-udpNoPorts OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { udp 2 }
-
-udpInErrors OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { udp 3 }
-
-udpOutDatagrams OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { udp 4 }
-
--- the UDP listener table
-
-udpTable OBJECT-TYPE
-        SYNTAX  SEQUENCE OF UdpEntry
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { udp 5 }
-
-udpEntry OBJECT-TYPE
-        SYNTAX  UdpEntry
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { udpTable 1 }
-
-UdpEntry ::= SEQUENCE {
-    udpLocalAddress
-        IpAddress,
-    udpLocalPort
-        INTEGER (0..65535)
-}
-
-udpLocalAddress OBJECT-TYPE
-        SYNTAX  IpAddress
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { udpEntry 1 }
-
-udpLocalPort OBJECT-TYPE
-        SYNTAX  INTEGER (0..65535)
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { udpEntry 2 }
-
--- the EGP group
-
-egpInMsgs OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { egp 1 }
-
-egpInErrors OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { egp 2 }
-
-egpOutMsgs OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { egp 3 }
-
-egpOutErrors OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { egp 4 }
-
--- the EGP Neighbor table
-
-egpNeighTable OBJECT-TYPE
-        SYNTAX  SEQUENCE OF EgpNeighEntry
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { egp 5 }
-
-egpNeighEntry OBJECT-TYPE
-        SYNTAX  EgpNeighEntry
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { egpNeighTable 1 }
-
-EgpNeighEntry ::= SEQUENCE {
-    egpNeighState
-        INTEGER,
-    egpNeighAddr
-        IpAddress,
-    egpNeighAs
-        INTEGER,
-    egpNeighInMsgs
-        Counter,
-    egpNeighInErrs
-        Counter,
-    egpNeighOutMsgs
-        Counter,
-    egpNeighOutErrs
-        Counter,
-    egpNeighInErrMsgs
-        Counter,
-    egpNeighOutErrMsgs
-        Counter,
-    egpNeighStateUps
-        Counter,
-    egpNeighStateDowns
-        Counter,
-    egpNeighIntervalHello
-        INTEGER,
-    egpNeighIntervalPoll
-        INTEGER,
-    egpNeighMode
-        INTEGER,
-    egpNeighEventTrigger
-        INTEGER
-}
-
-egpNeighState OBJECT-TYPE
-        SYNTAX  INTEGER {
-                    idle(1),
-                    acquisition(2),
-                    down(3),
-                    up(4),
-                    cease(5)
-                }
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { egpNeighEntry 1 }
-
-egpNeighAddr OBJECT-TYPE
-        SYNTAX  IpAddress
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { egpNeighEntry 2 }
-
-egpNeighAs OBJECT-TYPE
-        SYNTAX  INTEGER
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { egpNeighEntry 3 }
-
-egpNeighInMsgs OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { egpNeighEntry 4 }
-
-egpNeighInErrs OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { egpNeighEntry 5 }
-
-egpNeighOutMsgs OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { egpNeighEntry 6 }
-
-egpNeighOutErrs OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { egpNeighEntry 7 }
-
-egpNeighInErrMsgs OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { egpNeighEntry 8 }
-
-egpNeighOutErrMsgs OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { egpNeighEntry 9 }
-
-egpNeighStateUps OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { egpNeighEntry 10 }
-
-egpNeighStateDowns OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { egpNeighEntry 11 }
-
-egpNeighIntervalHello OBJECT-TYPE
-        SYNTAX  INTEGER
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { egpNeighEntry 12 }
-
-egpNeighIntervalPoll OBJECT-TYPE
-        SYNTAX  INTEGER
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { egpNeighEntry 13 }
-
-egpNeighMode OBJECT-TYPE
-        SYNTAX  INTEGER {
-                    active(1),
-                    passive(2)
-                }
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { egpNeighEntry 14 }
-
-egpNeighEventTrigger OBJECT-TYPE
-        SYNTAX  INTEGER {
-                    start(1),
-                    stop(2)
-                }
-        ACCESS  read-write
-        STATUS  mandatory
-        ::= { egpNeighEntry 15 }
-
--- additional EGP variables
-
-egpAs OBJECT-TYPE
-        SYNTAX  INTEGER
-        ACCESS  read-only
-        STATUS  mandatory
-        ::= { egp 6 }
-
-
--- the Transmission group (empty at present)
-
--- the SNMP group
-
-snmpInPkts OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::=  { snmp 1 }
-
-snmpOutPkts OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::=  { snmp 2 }
-
-snmpInBadVersions OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::=  { snmp 3 }
-
-snmpInBadCommunityNames OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::=  { snmp 4 }
-
-snmpInBadCommunityUses OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::=  { snmp 5 }
-
-snmpInASNParseErrs OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::=  { snmp 6 }
-
-snmpInBadTypes OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::=  { snmp 7 }
-
-snmpInTooBigs OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::=  { snmp 8 }
-
-snmpInNoSuchNames OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::=  { snmp 9 }
-
-snmpInBadValues OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::=  { snmp 10 }
-
-snmpInReadOnlys OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::=  { snmp 11 }
-
-snmpInGenErrs OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::=  { snmp 12 }
-
-snmpInTotalReqVars OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::=  { snmp 13 }
-
-snmpInTotalSetVars OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::=  { snmp 14 }
-
-snmpInGetRequests OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::=  { snmp 15 }
-
-snmpInGetNexts OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::=  { snmp 16 }
-
-snmpInSetRequests OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::=  { snmp 17 }
-
-snmpInGetResponses OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::=  { snmp 18 }
-
-snmpInTraps OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::=  { snmp 19 }
-
-snmpOutTooBigs OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::=  { snmp 20 }
-
-snmpOutNoSuchNames OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::=  { snmp 21 }
-
-snmpOutBadValues OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::=  { snmp 22 }
-
-snmpOutReadOnlys OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::=  { snmp 23 }
-
-snmpOutGenErrs OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::=  { snmp 24 }
-
-snmpOutGetRequests OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::=  { snmp 25 }
-
-snmpOutGetNexts OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::=  { snmp 26 }
-
-snmpOutSetRequests OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::=  { snmp 27 }
-
-snmpOutGetResponses OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::=  { snmp 28 }
-
-snmpOutTraps OBJECT-TYPE
-        SYNTAX  Counter
-        ACCESS  read-only
-        STATUS  mandatory
-        ::=  { snmp 29 }
-
-snmpEnableAuthTraps OBJECT-TYPE
-        SYNTAX  INTEGER {
-                    enabled(1),
-                    disabled(2)
-                }
-        ACCESS  read-write
-        STATUS  mandatory
-        ::=  { snmp 30 }
-
-END
diff --git a/contrib/apps/LwipMibCompiler/Mibs/RFC1213-MIB b/contrib/apps/LwipMibCompiler/Mibs/RFC1213-MIB
deleted file mode 100644
index 2a849ded..00000000
--- a/contrib/apps/LwipMibCompiler/Mibs/RFC1213-MIB
+++ /dev/null
@@ -1,2621 +0,0 @@
-RFC1213-MIB DEFINITIONS ::= BEGIN
-
-IMPORTS
-        mgmt, NetworkAddress, IpAddress, Counter, Gauge,
-                TimeTicks
-            FROM RFC1155-SMI
-        OBJECT-TYPE
-                FROM RFC-1212;
-
---  This MIB module uses the extended OBJECT-TYPE macro as
---  defined in [14];
-
-
---  MIB-II (same prefix as MIB-I)
-
-mib-2      OBJECT IDENTIFIER ::= { mgmt 1 }
-
--- textual conventions
-
-DisplayString ::=
-    OCTET STRING
--- This data type is used to model textual information taken
--- from the NVT ASCII character set.  By convention, objects
--- with this syntax are declared as having
-
---
---      SIZE (0..255)
-
-PhysAddress ::=
-    OCTET STRING
--- This data type is used to model media addresses.  For many
--- types of media, this will be in a binary representation.
--- For example, an ethernet address would be represented as
--- a string of 6 octets.
-
-
--- groups in MIB-II
-
-system       OBJECT IDENTIFIER ::= { mib-2 1 }
-
-interfaces   OBJECT IDENTIFIER ::= { mib-2 2 }
-
-at           OBJECT IDENTIFIER ::= { mib-2 3 }
-
-ip           OBJECT IDENTIFIER ::= { mib-2 4 }
-
-icmp         OBJECT IDENTIFIER ::= { mib-2 5 }
-
-tcp          OBJECT IDENTIFIER ::= { mib-2 6 }
-
-udp          OBJECT IDENTIFIER ::= { mib-2 7 }
-
-egp          OBJECT IDENTIFIER ::= { mib-2 8 }
-
--- historical (some say hysterical)
--- cmot      OBJECT IDENTIFIER ::= { mib-2 9 }
-
-transmission OBJECT IDENTIFIER ::= { mib-2 10 }
-
-snmp         OBJECT IDENTIFIER ::= { mib-2 11 }
-
-
--- the System group
-
--- Implementation of the System group is mandatory for all
--- systems.  If an agent is not configured to have a value
--- for any of these variables, a string of length 0 is
--- returned.
-
-sysDescr OBJECT-TYPE
-    SYNTAX  DisplayString (SIZE (0..255))
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "A textual description of the entity.  This value
-            should include the full name and version
-            identification of the system's hardware type,
-            software operating-system, and networking
-            software.  It is mandatory that this only contain
-            printable ASCII characters."
-    ::= { system 1 }
-
-sysObjectID OBJECT-TYPE
-    SYNTAX  OBJECT IDENTIFIER
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The vendor's authoritative identification of the
-            network management subsystem contained in the
-            entity.  This value is allocated within the SMI
-            enterprises subtree (1.3.6.1.4.1) and provides an
-            easy and unambiguous means for determining `what
-            kind of box' is being managed.  For example, if
-            vendor `Flintstones, Inc.' was assigned the
-            subtree 1.3.6.1.4.1.4242, it could assign the
-            identifier 1.3.6.1.4.1.4242.1.1 to its `Fred
-            Router'."
-    ::= { system 2 }
-
-sysUpTime OBJECT-TYPE
-    SYNTAX  TimeTicks
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The time (in hundredths of a second) since the
-            network management portion of the system was last
-            re-initialized."
-    ::= { system 3 }
-
-sysContact OBJECT-TYPE
-    SYNTAX  DisplayString (SIZE (0..255))
-    ACCESS  read-write
-    STATUS  mandatory
-    DESCRIPTION
-            "The textual identification of the contact person
-            for this managed node, together with information
-            on how to contact this person."
-    ::= { system 4 }
-
-sysName OBJECT-TYPE
-    SYNTAX  DisplayString (SIZE (0..255))
-    ACCESS  read-write
-    STATUS  mandatory
-    DESCRIPTION
-            "An administratively-assigned name for this
-            managed node.  By convention, this is the node's
-            fully-qualified domain name."
-    ::= { system 5 }
-
-sysLocation OBJECT-TYPE
-    SYNTAX  DisplayString (SIZE (0..255))
-    ACCESS  read-write
-    STATUS  mandatory
-    DESCRIPTION
-            "The physical location of this node (e.g.,
-            `telephone closet, 3rd floor')."
-    ::= { system 6 }
-
-sysServices OBJECT-TYPE
-    SYNTAX  INTEGER (0..127)
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "A value which indicates the set of services that
-            this entity primarily offers.
-
-            The value is a sum.  This sum initially takes the
-            value zero, Then, for each layer, L, in the range
-            1 through 7, that this node performs transactions
-            for, 2 raised to (L - 1) is added to the sum.  For
-            example, a node which performs primarily routing
-            functions would have a value of 4 (2^(3-1)).  In
-            contrast, a node which is a host offering
-            application services would have a value of 72
-            (2^(4-1) + 2^(7-1)).  Note that in the context of
-            the Internet suite of protocols, values should be
-            calculated accordingly:
-
-                 layer  functionality
-                     1  physical (e.g., repeaters)
-                     2  datalink/subnetwork (e.g., bridges)
-                     3  internet (e.g., IP gateways)
-                     4  end-to-end  (e.g., IP hosts)
-                     7  applications (e.g., mail relays)
-
-            For systems including OSI protocols, layers 5 and
-            6 may also be counted."
-    ::= { system 7 }
-
--- the Interfaces group
-
--- Implementation of the Interfaces group is mandatory for
--- all systems.
-
-ifNumber OBJECT-TYPE
-    SYNTAX  INTEGER
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of network interfaces (regardless of
-            their current state) present on this system."
-    ::= { interfaces 1 }
-
-
--- the Interfaces table
-
--- The Interfaces table contains information on the entity's
--- interfaces.  Each interface is thought of as being
--- attached to a `subnetwork'.  Note that this term should
--- not be confused with `subnet' which refers to an
--- addressing partitioning scheme used in the Internet suite
--- of protocols.
-
-ifTable OBJECT-TYPE
-    SYNTAX  SEQUENCE OF IfEntry
-    ACCESS  not-accessible
-    STATUS  mandatory
-    DESCRIPTION
-            "A list of interface entries.  The number of
-            entries is given by the value of ifNumber."
-    ::= { interfaces 2 }
-
-ifEntry OBJECT-TYPE
-    SYNTAX  IfEntry
-    ACCESS  not-accessible
-    STATUS  mandatory
-    DESCRIPTION
-            "An interface entry containing objects at the
-            subnetwork layer and below for a particular
-            interface."
-    INDEX   { ifIndex }
-    ::= { ifTable 1 }
-
-IfEntry ::=
-    SEQUENCE {
-        ifIndex
-            INTEGER,
-        ifDescr
-            DisplayString,
-        ifType
-            INTEGER,
-        ifMtu
-            INTEGER,
-        ifSpeed
-            Gauge,
-        ifPhysAddress
-            PhysAddress,
-        ifAdminStatus
-            INTEGER,
-        ifOperStatus
-            INTEGER,
-        ifLastChange
-            TimeTicks,
-        ifInOctets
-            Counter,
-        ifInUcastPkts
-            Counter,
-        ifInNUcastPkts
-            Counter,
-        ifInDiscards
-            Counter,
-        ifInErrors
-            Counter,
-        ifInUnknownProtos
-            Counter,
-        ifOutOctets
-            Counter,
-        ifOutUcastPkts
-            Counter,
-        ifOutNUcastPkts
-            Counter,
-        ifOutDiscards
-            Counter,
-        ifOutErrors
-            Counter,
-        ifOutQLen
-            Gauge,
-        ifSpecific
-            OBJECT IDENTIFIER
-    }
-
-ifIndex OBJECT-TYPE
-    SYNTAX  INTEGER
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "A unique value for each interface.  Its value
-            ranges between 1 and the value of ifNumber.  The
-            value for each interface must remain constant at
-            least from one re-initialization of the entity's
-            network management system to the next re-
-            initialization."
-    ::= { ifEntry 1 }
-
-ifDescr OBJECT-TYPE
-    SYNTAX  DisplayString (SIZE (0..255))
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "A textual string containing information about the
-            interface.  This string should include the name of
-            the manufacturer, the product name and the version
-            of the hardware interface."
-    ::= { ifEntry 2 }
-
-ifType OBJECT-TYPE
-    SYNTAX  INTEGER {
-                other(1),          -- none of the following
-                regular1822(2),
-                hdh1822(3),
-                ddn-x25(4),
-                rfc877-x25(5),
-                ethernet-csmacd(6),
-                iso88023-csmacd(7),
-                iso88024-tokenBus(8),
-                iso88025-tokenRing(9),
-                iso88026-man(10),
-                starLan(11),
-                proteon-10Mbit(12),
-                proteon-80Mbit(13),
-                hyperchannel(14),
-                fddi(15),
-                lapb(16),
-                sdlc(17),
-                ds1(18),           -- T-1
-                e1(19),            -- european equiv. of T-1
-                basicISDN(20),
-                primaryISDN(21),   -- proprietary serial
-                propPointToPointSerial(22),
-                ppp(23),
-                softwareLoopback(24),
-                eon(25),            -- CLNP over IP [11]
-                ethernet-3Mbit(26),
-                nsip(27),           -- XNS over IP
-                slip(28),           -- generic SLIP
-                ultra(29),          -- ULTRA technologies
-                ds3(30),            -- T-3
-                sip(31),            -- SMDS
-                frame-relay(32)
-            }
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The type of interface, distinguished according to
-            the physical/link protocol(s) immediately `below'
-            the network layer in the protocol stack."
-    ::= { ifEntry 3 }
-
-ifMtu OBJECT-TYPE
-    SYNTAX  INTEGER
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The size of the largest datagram which can be
-            sent/received on the interface, specified in
-            octets.  For interfaces that are used for
-            transmitting network datagrams, this is the size
-            of the largest network datagram that can be sent
-            on the interface."
-    ::= { ifEntry 4 }
-
-ifSpeed OBJECT-TYPE
-    SYNTAX  Gauge
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "An estimate of the interface's current bandwidth
-            in bits per second.  For interfaces which do not
-            vary in bandwidth or for those where no accurate
-            estimation can be made, this object should contain
-            the nominal bandwidth."
-    ::= { ifEntry 5 }
-
-ifPhysAddress OBJECT-TYPE
-    SYNTAX  PhysAddress
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The interface's address at the protocol layer
-            immediately `below' the network layer in the
-            protocol stack.  For interfaces which do not have
-            such an address (e.g., a serial line), this object
-            should contain an octet string of zero length."
-    ::= { ifEntry 6 }
-
-ifAdminStatus OBJECT-TYPE
-    SYNTAX  INTEGER {
-                up(1),       -- ready to pass packets
-                down(2),
-                testing(3)   -- in some test mode
-            }
-    ACCESS  read-write
-    STATUS  mandatory
-    DESCRIPTION
-            "The desired state of the interface.  The
-            testing(3) state indicates that no operational
-            packets can be passed."
-    ::= { ifEntry 7 }
-
-ifOperStatus OBJECT-TYPE
-    SYNTAX  INTEGER {
-                up(1),       -- ready to pass packets
-                down(2),
-                testing(3)   -- in some test mode
-            }
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The current operational state of the interface.
-            The testing(3) state indicates that no operational
-            packets can be passed."
-    ::= { ifEntry 8 }
-
-ifLastChange OBJECT-TYPE
-    SYNTAX  TimeTicks
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The value of sysUpTime at the time the interface
-            entered its current operational state.  If the
-            current state was entered prior to the last re-
-            initialization of the local network management
-            subsystem, then this object contains a zero
-            value."
-    ::= { ifEntry 9 }
-
-ifInOctets OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The total number of octets received on the
-            interface, including framing characters."
-    ::= { ifEntry 10 }
-
-ifInUcastPkts OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of subnetwork-unicast packets
-            delivered to a higher-layer protocol."
-    ::= { ifEntry 11 }
-
-ifInNUcastPkts OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of non-unicast (i.e., subnetwork-
-            broadcast or subnetwork-multicast) packets
-            delivered to a higher-layer protocol."
-    ::= { ifEntry 12 }
-
-ifInDiscards OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of inbound packets which were chosen
-            to be discarded even though no errors had been
-            detected to prevent their being deliverable to a
-            higher-layer protocol.  One possible reason for
-            discarding such a packet could be to free up
-            buffer space."
-    ::= { ifEntry 13 }
-
-ifInErrors OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of inbound packets that contained
-            errors preventing them from being deliverable to a
-            higher-layer protocol."
-    ::= { ifEntry 14 }
-
-ifInUnknownProtos OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of packets received via the interface
-            which were discarded because of an unknown or
-            unsupported protocol."
-    ::= { ifEntry 15 }
-
-ifOutOctets OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The total number of octets transmitted out of the
-            interface, including framing characters."
-    ::= { ifEntry 16 }
-
-ifOutUcastPkts OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The total number of packets that higher-level
-            protocols requested be transmitted to a
-            subnetwork-unicast address, including those that
-            were discarded or not sent."
-    ::= { ifEntry 17 }
-
-ifOutNUcastPkts OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The total number of packets that higher-level
-            protocols requested be transmitted to a non-
-            unicast (i.e., a subnetwork-broadcast or
-            subnetwork-multicast) address, including those
-            that were discarded or not sent."
-    ::= { ifEntry 18 }
-
-ifOutDiscards OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of outbound packets which were chosen
-            to be discarded even though no errors had been
-            detected to prevent their being transmitted.  One
-            possible reason for discarding such a packet could
-            be to free up buffer space."
-    ::= { ifEntry 19 }
-
-ifOutErrors OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of outbound packets that could not be
-            transmitted because of errors."
-    ::= { ifEntry 20 }
-
-ifOutQLen OBJECT-TYPE
-    SYNTAX  Gauge
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The length of the output packet queue (in
-            packets)."
-    ::= { ifEntry 21 }
-
-ifSpecific OBJECT-TYPE
-    SYNTAX  OBJECT IDENTIFIER
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "A reference to MIB definitions specific to the
-            particular media being used to realize the
-            interface.  For example, if the interface is
-            realized by an ethernet, then the value of this
-            object refers to a document defining objects
-            specific to ethernet.  If this information is not
-            present, its value should be set to the OBJECT
-            IDENTIFIER { 0 0 }, which is a syntatically valid
-            object identifier, and any conformant
-            implementation of ASN.1 and BER must be able to
-            generate and recognize this value."
-    ::= { ifEntry 22 }
-
-
--- the Address Translation group
-
--- Implementation of the Address Translation group is
--- mandatory for all systems.  Note however that this group
--- is deprecated by MIB-II. That is, it is being included
-
--- solely for compatibility with MIB-I nodes, and will most
--- likely be excluded from MIB-III nodes.  From MIB-II and
--- onwards, each network protocol group contains its own
--- address translation tables.
-
--- The Address Translation group contains one table which is
--- the union across all interfaces of the translation tables
--- for converting a NetworkAddress (e.g., an IP address) into
--- a subnetwork-specific address.  For lack of a better term,
--- this document refers to such a subnetwork-specific address
--- as a `physical' address.
-
--- Examples of such translation tables are: for broadcast
--- media where ARP is in use, the translation table is
--- equivalent to the ARP cache; or, on an X.25 network where
--- non-algorithmic translation to X.121 addresses is
--- required, the translation table contains the
--- NetworkAddress to X.121 address equivalences.
-
-atTable OBJECT-TYPE
-    SYNTAX  SEQUENCE OF AtEntry
-    ACCESS  not-accessible
-    STATUS  deprecated
-    DESCRIPTION
-            "The Address Translation tables contain the
-            NetworkAddress to `physical' address equivalences.
-            Some interfaces do not use translation tables for
-            determining address equivalences (e.g., DDN-X.25
-            has an algorithmic method); if all interfaces are
-            of this type, then the Address Translation table
-            is empty, i.e., has zero entries."
-    ::= { at 1 }
-
-atEntry OBJECT-TYPE
-    SYNTAX  AtEntry
-    ACCESS  not-accessible
-    STATUS  deprecated
-    DESCRIPTION
-            "Each entry contains one NetworkAddress to
-            `physical' address equivalence."
-    INDEX   { atIfIndex,
-              atNetAddress }
-    ::= { atTable 1 }
-
-AtEntry ::=
-    SEQUENCE {
-        atIfIndex
-            INTEGER,
-        atPhysAddress
-            PhysAddress,
-        atNetAddress
-            NetworkAddress
-    }
-
-atIfIndex OBJECT-TYPE
-    SYNTAX  INTEGER
-    ACCESS  read-write
-    STATUS  deprecated
-    DESCRIPTION
-            "The interface on which this entry's equivalence
-            is effective.  The interface identified by a
-            particular value of this index is the same
-            interface as identified by the same value of
-            ifIndex."
-    ::= { atEntry 1 }
-
-atPhysAddress OBJECT-TYPE
-    SYNTAX  PhysAddress
-    ACCESS  read-write
-    STATUS  deprecated
-    DESCRIPTION
-            "The media-dependent `physical' address.
-
-            Setting this object to a null string (one of zero
-            length) has the effect of invaliding the
-            corresponding entry in the atTable object.  That
-            is, it effectively dissasociates the interface
-            identified with said entry from the mapping
-            identified with said entry.  It is an
-            implementation-specific matter as to whether the
-            agent removes an invalidated entry from the table.
-            Accordingly, management stations must be prepared
-            to receive tabular information from agents that
-            corresponds to entries not currently in use.
-            Proper interpretation of such entries requires
-            examination of the relevant atPhysAddress object."
-    ::= { atEntry 2 }
-
-atNetAddress OBJECT-TYPE
-    SYNTAX  NetworkAddress
-    ACCESS  read-write
-    STATUS  deprecated
-    DESCRIPTION
-            "The NetworkAddress (e.g., the IP address)
-            corresponding to the media-dependent `physical'
-            address."
-    ::= { atEntry 3 }
-
-
--- the IP group
-
--- Implementation of the IP group is mandatory for all
--- systems.
-
-ipForwarding OBJECT-TYPE
-    SYNTAX  INTEGER {
-                forwarding(1),    -- acting as a gateway
-                not-forwarding(2) -- NOT acting as a gateway
-            }
-    ACCESS  read-write
-    STATUS  mandatory
-    DESCRIPTION
-            "The indication of whether this entity is acting
-            as an IP gateway in respect to the forwarding of
-            datagrams received by, but not addressed to, this
-            entity.  IP gateways forward datagrams.  IP hosts
-            do not (except those source-routed via the host).
-
-            Note that for some managed nodes, this object may
-            take on only a subset of the values possible.
-            Accordingly, it is appropriate for an agent to
-            return a `badValue' response if a management
-            station attempts to change this object to an
-            inappropriate value."
-    ::= { ip 1 }
-
-ipDefaultTTL OBJECT-TYPE
-    SYNTAX  INTEGER
-    ACCESS  read-write
-    STATUS  mandatory
-    DESCRIPTION
-            "The default value inserted into the Time-To-Live
-            field of the IP header of datagrams originated at
-            this entity, whenever a TTL value is not supplied
-            by the transport layer protocol."
-    ::= { ip 2 }
-
-ipInReceives OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The total number of input datagrams received from
-            interfaces, including those received in error."
-    ::= { ip 3 }
-
-ipInHdrErrors OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of input datagrams discarded due to
-            errors in their IP headers, including bad
-            checksums, version number mismatch, other format
-            errors, time-to-live exceeded, errors discovered
-            in processing their IP options, etc."
-    ::= { ip 4 }
-
-ipInAddrErrors OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of input datagrams discarded because
-            the IP address in their IP header's destination
-            field was not a valid address to be received at
-            this entity.  This count includes invalid
-            addresses (e.g., 0.0.0.0) and addresses of
-            unsupported Classes (e.g., Class E).  For entities
-            which are not IP Gateways and therefore do not
-            forward datagrams, this counter includes datagrams
-            discarded because the destination address was not
-            a local address."
-    ::= { ip 5 }
-
-ipForwDatagrams OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of input datagrams for which this
-            entity was not their final IP destination, as a
-            result of which an attempt was made to find a
-            route to forward them to that final destination.
-            In entities which do not act as IP Gateways, this
-            counter will include only those packets which were
-            Source-Routed via this entity, and the Source-
-            Route option processing was successful."
-    ::= { ip 6 }
-
-ipInUnknownProtos OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of locally-addressed datagrams
-            received successfully but discarded because of an
-            unknown or unsupported protocol."
-    ::= { ip 7 }
-
-ipInDiscards OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of input IP datagrams for which no
-            problems were encountered to prevent their
-            continued processing, but which were discarded
-            (e.g., for lack of buffer space).  Note that this
-            counter does not include any datagrams discarded
-            while awaiting re-assembly."
-    ::= { ip 8 }
-
-ipInDelivers OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The total number of input datagrams successfully
-            delivered to IP user-protocols (including ICMP)."
-    ::= { ip 9 }
-
-ipOutRequests OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The total number of IP datagrams which local IP
-            user-protocols (including ICMP) supplied to IP in
-            requests for transmission.  Note that this counter
-            does not include any datagrams counted in
-            ipForwDatagrams."
-    ::= { ip 10 }
-
-ipOutDiscards OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of output IP datagrams for which no
-            problem was encountered to prevent their
-            transmission to their destination, but which were
-            discarded (e.g., for lack of buffer space).  Note
-            that this counter would include datagrams counted
-            in ipForwDatagrams if any such packets met this
-            (discretionary) discard criterion."
-    ::= { ip 11 }
-
-ipOutNoRoutes OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of IP datagrams discarded because no
-            route could be found to transmit them to their
-            destination.  Note that this counter includes any
-            packets counted in ipForwDatagrams which meet this
-            `no-route' criterion.  Note that this includes any
-            datagarms which a host cannot route because all of
-            its default gateways are down."
-    ::= { ip 12 }
-
-ipReasmTimeout OBJECT-TYPE
-    SYNTAX  INTEGER
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The maximum number of seconds which received
-            fragments are held while they are awaiting
-            reassembly at this entity."
-    ::= { ip 13 }
-
-ipReasmReqds OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of IP fragments received which needed
-            to be reassembled at this entity."
-    ::= { ip 14 }
-
-ipReasmOKs OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of IP datagrams successfully re-
-            assembled."
-    ::= { ip 15 }
-
-ipReasmFails OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of failures detected by the IP re-
-            assembly algorithm (for whatever reason: timed
-            out, errors, etc).  Note that this is not
-            necessarily a count of discarded IP fragments
-            since some algorithms (notably the algorithm in
-            RFC 815) can lose track of the number of fragments
-            by combining them as they are received."
-    ::= { ip 16 }
-
-ipFragOKs OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of IP datagrams that have been
-            successfully fragmented at this entity."
-    ::= { ip 17 }
-
-ipFragFails OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of IP datagrams that have been
-            discarded because they needed to be fragmented at
-            this entity but could not be, e.g., because their
-            Don't Fragment flag was set."
-    ::= { ip 18 }
-
-ipFragCreates OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of IP datagram fragments that have
-            been generated as a result of fragmentation at
-            this entity."
-    ::= { ip 19 }
-
--- the IP address table
-
--- The IP address table contains this entity's IP addressing
--- information.
-
-ipAddrTable OBJECT-TYPE
-    SYNTAX  SEQUENCE OF IpAddrEntry
-    ACCESS  not-accessible
-    STATUS  mandatory
-    DESCRIPTION
-            "The table of addressing information relevant to
-            this entity's IP addresses."
-    ::= { ip 20 }
-
-ipAddrEntry OBJECT-TYPE
-    SYNTAX  IpAddrEntry
-    ACCESS  not-accessible
-    STATUS  mandatory
-    DESCRIPTION
-            "The addressing information for one of this
-            entity's IP addresses."
-    INDEX   { ipAdEntAddr }
-    ::= { ipAddrTable 1 }
-
-IpAddrEntry ::=
-    SEQUENCE {
-        ipAdEntAddr
-            IpAddress,
-        ipAdEntIfIndex
-            INTEGER,
-        ipAdEntNetMask
-            IpAddress,
-        ipAdEntBcastAddr
-            INTEGER,
-        ipAdEntReasmMaxSize
-            INTEGER (0..65535)
-    }
-
-ipAdEntAddr OBJECT-TYPE
-    SYNTAX  IpAddress
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The IP address to which this entry's addressing
-            information pertains."
-    ::= { ipAddrEntry 1 }
-
-ipAdEntIfIndex OBJECT-TYPE
-    SYNTAX  INTEGER
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The index value which uniquely identifies the
-            interface to which this entry is applicable.  The
-            interface identified by a particular value of this
-            index is the same interface as identified by the
-            same value of ifIndex."
-    ::= { ipAddrEntry 2 }
-
-ipAdEntNetMask OBJECT-TYPE
-    SYNTAX  IpAddress
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The subnet mask associated with the IP address of
-            this entry.  The value of the mask is an IP
-            address with all the network bits set to 1 and all
-            the hosts bits set to 0."
-    ::= { ipAddrEntry 3 }
-
-ipAdEntBcastAddr OBJECT-TYPE
-    SYNTAX  INTEGER
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The value of the least-significant bit in the IP
-            broadcast address used for sending datagrams on
-            the (logical) interface associated with the IP
-            address of this entry.  For example, when the
-            Internet standard all-ones broadcast address is
-            used, the value will be 1.  This value applies to
-            both the subnet and network broadcasts addresses
-            used by the entity on this (logical) interface."
-    ::= { ipAddrEntry 4 }
-
-ipAdEntReasmMaxSize OBJECT-TYPE
-    SYNTAX  INTEGER (0..65535)
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The size of the largest IP datagram which this
-            entity can re-assemble from incoming IP fragmented
-            datagrams received on this interface."
-    ::= { ipAddrEntry 5 }
-
--- the IP routing table
-
--- The IP routing table contains an entry for each route
--- presently known to this entity.
-
-ipRouteTable OBJECT-TYPE
-    SYNTAX  SEQUENCE OF IpRouteEntry
-    ACCESS  not-accessible
-    STATUS  mandatory
-    DESCRIPTION
-            "This entity's IP Routing table."
-    ::= { ip 21 }
-
-ipRouteEntry OBJECT-TYPE
-    SYNTAX  IpRouteEntry
-    ACCESS  not-accessible
-    STATUS  mandatory
-    DESCRIPTION
-            "A route to a particular destination."
-    INDEX   { ipRouteDest }
-    ::= { ipRouteTable 1 }
-
-IpRouteEntry ::=
-    SEQUENCE {
-        ipRouteDest
-            IpAddress,
-        ipRouteIfIndex
-            INTEGER,
-        ipRouteMetric1
-            INTEGER,
-        ipRouteMetric2
-            INTEGER,
-        ipRouteMetric3
-            INTEGER,
-        ipRouteMetric4
-            INTEGER,
-        ipRouteNextHop
-            IpAddress,
-        ipRouteType
-            INTEGER,
-        ipRouteProto
-            INTEGER,
-        ipRouteAge
-            INTEGER,
-        ipRouteMask
-            IpAddress,
-        ipRouteMetric5
-            INTEGER,
-        ipRouteInfo
-            OBJECT IDENTIFIER
-    }
-
-ipRouteDest OBJECT-TYPE
-    SYNTAX  IpAddress
-    ACCESS  read-write
-    STATUS  mandatory
-    DESCRIPTION
-            "The destination IP address of this route.  An
-            entry with a value of 0.0.0.0 is considered a
-            default route.  Multiple routes to a single
-            destination can appear in the table, but access to
-            such multiple entries is dependent on the table-
-            access mechanisms defined by the network
-            management protocol in use."
-    ::= { ipRouteEntry 1 }
-
-ipRouteIfIndex OBJECT-TYPE
-    SYNTAX  INTEGER
-    ACCESS  read-write
-    STATUS  mandatory
-    DESCRIPTION
-            "The index value which uniquely identifies the
-            local interface through which the next hop of this
-            route should be reached.  The interface identified
-            by a particular value of this index is the same
-            interface as identified by the same value of
-            ifIndex."
-    ::= { ipRouteEntry 2 }
-
-ipRouteMetric1 OBJECT-TYPE
-    SYNTAX  INTEGER
-    ACCESS  read-write
-    STATUS  mandatory
-    DESCRIPTION
-            "The primary routing metric for this route.  The
-            semantics of this metric are determined by the
-            routing-protocol specified in the route's
-            ipRouteProto value.  If this metric is not used,
-            its value should be set to -1."
-    ::= { ipRouteEntry 3 }
-
-ipRouteMetric2 OBJECT-TYPE
-    SYNTAX  INTEGER
-    ACCESS  read-write
-    STATUS  mandatory
-    DESCRIPTION
-            "An alternate routing metric for this route.  The
-            semantics of this metric are determined by the
-            routing-protocol specified in the route's
-            ipRouteProto value.  If this metric is not used,
-            its value should be set to -1."
-    ::= { ipRouteEntry 4 }
-
-ipRouteMetric3 OBJECT-TYPE
-    SYNTAX  INTEGER
-    ACCESS  read-write
-    STATUS  mandatory
-    DESCRIPTION
-            "An alternate routing metric for this route.  The
-            semantics of this metric are determined by the
-            routing-protocol specified in the route's
-            ipRouteProto value.  If this metric is not used,
-            its value should be set to -1."
-    ::= { ipRouteEntry 5 }
-
-ipRouteMetric4 OBJECT-TYPE
-    SYNTAX  INTEGER
-    ACCESS  read-write
-    STATUS  mandatory
-    DESCRIPTION
-            "An alternate routing metric for this route.  The
-            semantics of this metric are determined by the
-            routing-protocol specified in the route's
-            ipRouteProto value.  If this metric is not used,
-            its value should be set to -1."
-    ::= { ipRouteEntry 6 }
-
-ipRouteNextHop OBJECT-TYPE
-    SYNTAX  IpAddress
-    ACCESS  read-write
-    STATUS  mandatory
-    DESCRIPTION
-            "The IP address of the next hop of this route.
-            (In the case of a route bound to an interface
-            which is realized via a broadcast media, the value
-            of this field is the agent's IP address on that
-            interface.)"
-    ::= { ipRouteEntry 7 }
-
-ipRouteType OBJECT-TYPE
-    SYNTAX  INTEGER {
-                other(1),        -- none of the following
-
-                invalid(2),      -- an invalidated route
-
-                                 -- route to directly
-                direct(3),       -- connected (sub-)network
-
-                                 -- route to a non-local
-                indirect(4)      -- host/network/sub-network
-            }
-    ACCESS  read-write
-    STATUS  mandatory
-    DESCRIPTION
-            "The type of route.  Note that the values
-            direct(3) and indirect(4) refer to the notion of
-            direct and indirect routing in the IP
-            architecture.
-
-            Setting this object to the value invalid(2) has
-            the effect of invalidating the corresponding entry
-            in the ipRouteTable object.  That is, it
-            effectively dissasociates the destination
-            identified with said entry from the route
-            identified with said entry.  It is an
-            implementation-specific matter as to whether the
-            agent removes an invalidated entry from the table.
-            Accordingly, management stations must be prepared
-            to receive tabular information from agents that
-            corresponds to entries not currently in use.
-            Proper interpretation of such entries requires
-            examination of the relevant ipRouteType object."
-    ::= { ipRouteEntry 8 }
-
-ipRouteProto OBJECT-TYPE
-    SYNTAX  INTEGER {
-                other(1),       -- none of the following
-
-                                -- non-protocol information,
-                                -- e.g., manually configured
-                local(2),       -- entries
-
-                                -- set via a network
-                netmgmt(3),     -- management protocol
-
-                                -- obtained via ICMP,
-                icmp(4),        -- e.g., Redirect
-
-                                -- the remaining values are
-                                -- all gateway routing
-                                -- protocols
-                egp(5),
-                ggp(6),
-                hello(7),
-                rip(8),
-                is-is(9),
-                es-is(10),
-                ciscoIgrp(11),
-                bbnSpfIgp(12),
-                ospf(13),
-                bgp(14)
-            }
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The routing mechanism via which this route was
-            learned.  Inclusion of values for gateway routing
-            protocols is not intended to imply that hosts
-            should support those protocols."
-    ::= { ipRouteEntry 9 }
-
-ipRouteAge OBJECT-TYPE
-    SYNTAX  INTEGER
-    ACCESS  read-write
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of seconds since this route was last
-            updated or otherwise determined to be correct.
-            Note that no semantics of `too old' can be implied
-            except through knowledge of the routing protocol
-            by which the route was learned."
-    ::= { ipRouteEntry 10 }
-
-ipRouteMask OBJECT-TYPE
-    SYNTAX  IpAddress
-    ACCESS  read-write
-    STATUS  mandatory
-    DESCRIPTION
-            "Indicate the mask to be logical-ANDed with the
-            destination address before being compared to the
-            value in the ipRouteDest field.  For those systems
-            that do not support arbitrary subnet masks, an
-            agent constructs the value of the ipRouteMask by
-            determining whether the value of the correspondent
-            ipRouteDest field belong to a class-A, B, or C
-            network, and then using one of:
-
-                 mask           network
-                 255.0.0.0      class-A
-                 255.255.0.0    class-B
-                 255.255.255.0  class-C
-            If the value of the ipRouteDest is 0.0.0.0 (a
-            default route), then the mask value is also
-            0.0.0.0.  It should be noted that all IP routing
-            subsystems implicitly use this mechanism."
-    ::= { ipRouteEntry 11 }
-
-ipRouteMetric5 OBJECT-TYPE
-    SYNTAX  INTEGER
-    ACCESS  read-write
-    STATUS  mandatory
-    DESCRIPTION
-            "An alternate routing metric for this route.  The
-            semantics of this metric are determined by the
-            routing-protocol specified in the route's
-            ipRouteProto value.  If this metric is not used,
-            its value should be set to -1."
-    ::= { ipRouteEntry 12 }
-
-ipRouteInfo OBJECT-TYPE
-    SYNTAX  OBJECT IDENTIFIER
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "A reference to MIB definitions specific to the
-            particular routing protocol which is responsible
-            for this route, as determined by the value
-            specified in the route's ipRouteProto value.  If
-            this information is not present, its value should
-            be set to the OBJECT IDENTIFIER { 0 0 }, which is
-            a syntatically valid object identifier, and any
-            conformant implementation of ASN.1 and BER must be
-            able to generate and recognize this value."
-    ::= { ipRouteEntry 13 }
-
-
--- the IP Address Translation table
-
--- The IP address translation table contain the IpAddress to
--- `physical' address equivalences.  Some interfaces do not
--- use translation tables for determining address
--- equivalences (e.g., DDN-X.25 has an algorithmic method);
--- if all interfaces are of this type, then the Address
--- Translation table is empty, i.e., has zero entries.
-
-ipNetToMediaTable OBJECT-TYPE
-    SYNTAX  SEQUENCE OF IpNetToMediaEntry
-    ACCESS  not-accessible
-    STATUS  mandatory
-    DESCRIPTION
-            "The IP Address Translation table used for mapping
-            from IP addresses to physical addresses."
-    ::= { ip 22 }
-
-ipNetToMediaEntry OBJECT-TYPE
-    SYNTAX  IpNetToMediaEntry
-    ACCESS  not-accessible
-    STATUS  mandatory
-    DESCRIPTION
-            "Each entry contains one IpAddress to `physical'
-            address equivalence."
-    INDEX   { ipNetToMediaIfIndex,
-              ipNetToMediaNetAddress }
-    ::= { ipNetToMediaTable 1 }
-
-IpNetToMediaEntry ::=
-    SEQUENCE {
-        ipNetToMediaIfIndex
-            INTEGER,
-        ipNetToMediaPhysAddress
-            PhysAddress,
-        ipNetToMediaNetAddress
-            IpAddress,
-        ipNetToMediaType
-            INTEGER
-    }
-
-ipNetToMediaIfIndex OBJECT-TYPE
-    SYNTAX  INTEGER
-    ACCESS  read-write
-    STATUS  mandatory
-    DESCRIPTION
-            "The interface on which this entry's equivalence
-            is effective.  The interface identified by a
-            particular value of this index is the same
-            interface as identified by the same value of
-            ifIndex."
-    ::= { ipNetToMediaEntry 1 }
-
-ipNetToMediaPhysAddress OBJECT-TYPE
-    SYNTAX  PhysAddress
-    ACCESS  read-write
-    STATUS  mandatory
-    DESCRIPTION
-            "The media-dependent `physical' address."
-    ::= { ipNetToMediaEntry 2 }
-
-ipNetToMediaNetAddress OBJECT-TYPE
-    SYNTAX  IpAddress
-    ACCESS  read-write
-    STATUS  mandatory
-    DESCRIPTION
-            "The IpAddress corresponding to the media-
-            dependent `physical' address."
-    ::= { ipNetToMediaEntry 3 }
-
-ipNetToMediaType OBJECT-TYPE
-    SYNTAX  INTEGER {
-                other(1),        -- none of the following
-                invalid(2),      -- an invalidated mapping
-                dynamic(3),
-                static(4)
-            }
-    ACCESS  read-write
-    STATUS  mandatory
-    DESCRIPTION
-            "The type of mapping.
-
-            Setting this object to the value invalid(2) has
-            the effect of invalidating the corresponding entry
-            in the ipNetToMediaTable.  That is, it effectively
-            dissasociates the interface identified with said
-            entry from the mapping identified with said entry.
-            It is an implementation-specific matter as to
-            whether the agent removes an invalidated entry
-            from the table.  Accordingly, management stations
-            must be prepared to receive tabular information
-            from agents that corresponds to entries not
-            currently in use.  Proper interpretation of such
-            entries requires examination of the relevant
-            ipNetToMediaType object."
-    ::= { ipNetToMediaEntry 4 }
-
-
--- additional IP objects
-
-ipRoutingDiscards OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of routing entries which were chosen
-            to be discarded even though they are valid.  One
-            possible reason for discarding such an entry could
-            be to free-up buffer space for other routing
-            entries."
-    ::= { ip 23 }
-
-
--- the ICMP group
-
--- Implementation of the ICMP group is mandatory for all
--- systems.
-
-icmpInMsgs OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The total number of ICMP messages which the
-            entity received.  Note that this counter includes
-            all those counted by icmpInErrors."
-    ::= { icmp 1 }
-
-icmpInErrors OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of ICMP messages which the entity
-            received but determined as having ICMP-specific
-            errors (bad ICMP checksums, bad length, etc.)."
-    ::= { icmp 2 }
-
-icmpInDestUnreachs OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of ICMP Destination Unreachable
-            messages received."
-    ::= { icmp 3 }
-
-icmpInTimeExcds OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of ICMP Time Exceeded messages
-            received."
-    ::= { icmp 4 }
-
-icmpInParmProbs OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of ICMP Parameter Problem messages
-            received."
-    ::= { icmp 5 }
-
-icmpInSrcQuenchs OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of ICMP Source Quench messages
-            received."
-    ::= { icmp 6 }
-
-icmpInRedirects OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of ICMP Redirect messages received."
-    ::= { icmp 7 }
-
-icmpInEchos OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of ICMP Echo (request) messages
-            received."
-    ::= { icmp 8 }
-
-icmpInEchoReps OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of ICMP Echo Reply messages received."
-    ::= { icmp 9 }
-
-icmpInTimestamps OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of ICMP Timestamp (request) messages
-            received."
-    ::= { icmp 10 }
-
-icmpInTimestampReps OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of ICMP Timestamp Reply messages
-            received."
-    ::= { icmp 11 }
-
-icmpInAddrMasks OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of ICMP Address Mask Request messages
-            received."
-    ::= { icmp 12 }
-
-icmpInAddrMaskReps OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of ICMP Address Mask Reply messages
-            received."
-    ::= { icmp 13 }
-
-icmpOutMsgs OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The total number of ICMP messages which this
-            entity attempted to send.  Note that this counter
-            includes all those counted by icmpOutErrors."
-    ::= { icmp 14 }
-
-icmpOutErrors OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of ICMP messages which this entity did
-            not send due to problems discovered within ICMP
-            such as a lack of buffers.  This value should not
-            include errors discovered outside the ICMP layer
-            such as the inability of IP to route the resultant
-            datagram.  In some implementations there may be no
-            types of error which contribute to this counter's
-            value."
-    ::= { icmp 15 }
-
-icmpOutDestUnreachs OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of ICMP Destination Unreachable
-            messages sent."
-    ::= { icmp 16 }
-
-icmpOutTimeExcds OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of ICMP Time Exceeded messages sent."
-    ::= { icmp 17 }
-
-icmpOutParmProbs OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of ICMP Parameter Problem messages
-            sent."
-    ::= { icmp 18 }
-
-icmpOutSrcQuenchs OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of ICMP Source Quench messages sent."
-    ::= { icmp 19 }
-
-icmpOutRedirects OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of ICMP Redirect messages sent.  For a
-            host, this object will always be zero, since hosts
-            do not send redirects."
-    ::= { icmp 20 }
-
-icmpOutEchos OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of ICMP Echo (request) messages sent."
-    ::= { icmp 21 }
-
-icmpOutEchoReps OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of ICMP Echo Reply messages sent."
-    ::= { icmp 22 }
-
-icmpOutTimestamps OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of ICMP Timestamp (request) messages
-            sent."
-    ::= { icmp 23 }
-
-icmpOutTimestampReps OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of ICMP Timestamp Reply messages
-            sent."
-    ::= { icmp 24 }
-
-icmpOutAddrMasks OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of ICMP Address Mask Request messages
-            sent."
-    ::= { icmp 25 }
-
-icmpOutAddrMaskReps OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of ICMP Address Mask Reply messages
-            sent."
-    ::= { icmp 26 }
-
-
--- the TCP group
-
--- Implementation of the TCP group is mandatory for all
--- systems that implement the TCP.
-
--- Note that instances of object types that represent
--- information about a particular TCP connection are
--- transient; they persist only as long as the connection
--- in question.
-
-tcpRtoAlgorithm OBJECT-TYPE
-    SYNTAX  INTEGER {
-                other(1),    -- none of the following
-
-                constant(2), -- a constant rto
-                rsre(3),     -- MIL-STD-1778, Appendix B
-                vanj(4)      -- Van Jacobson's algorithm [10]
-            }
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The algorithm used to determine the timeout value
-            used for retransmitting unacknowledged octets."
-    ::= { tcp 1 }
-
-tcpRtoMin OBJECT-TYPE
-    SYNTAX  INTEGER
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The minimum value permitted by a TCP
-            implementation for the retransmission timeout,
-            measured in milliseconds.  More refined semantics
-            for objects of this type depend upon the algorithm
-            used to determine the retransmission timeout.  In
-            particular, when the timeout algorithm is rsre(3),
-            an object of this type has the semantics of the
-            LBOUND quantity described in RFC 793."
-    ::= { tcp 2 }
-
-
-tcpRtoMax OBJECT-TYPE
-    SYNTAX  INTEGER
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The maximum value permitted by a TCP
-            implementation for the retransmission timeout,
-            measured in milliseconds.  More refined semantics
-            for objects of this type depend upon the algorithm
-            used to determine the retransmission timeout.  In
-            particular, when the timeout algorithm is rsre(3),
-            an object of this type has the semantics of the
-            UBOUND quantity described in RFC 793."
-    ::= { tcp 3 }
-
-tcpMaxConn OBJECT-TYPE
-    SYNTAX  INTEGER
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The limit on the total number of TCP connections
-            the entity can support.  In entities where the
-            maximum number of connections is dynamic, this
-            object should contain the value -1."
-    ::= { tcp 4 }
-
-tcpActiveOpens OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of times TCP connections have made a
-            direct transition to the SYN-SENT state from the
-            CLOSED state."
-    ::= { tcp 5 }
-
-tcpPassiveOpens OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of times TCP connections have made a
-            direct transition to the SYN-RCVD state from the
-            LISTEN state."
-    ::= { tcp 6 }
-
-tcpAttemptFails OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of times TCP connections have made a
-            direct transition to the CLOSED state from either
-            the SYN-SENT state or the SYN-RCVD state, plus the
-            number of times TCP connections have made a direct
-            transition to the LISTEN state from the SYN-RCVD
-            state."
-    ::= { tcp 7 }
-
-tcpEstabResets OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of times TCP connections have made a
-            direct transition to the CLOSED state from either
-            the ESTABLISHED state or the CLOSE-WAIT state."
-    ::= { tcp 8 }
-
-tcpCurrEstab OBJECT-TYPE
-    SYNTAX  Gauge
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of TCP connections for which the
-            current state is either ESTABLISHED or CLOSE-
-            WAIT."
-    ::= { tcp 9 }
-
-tcpInSegs OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The total number of segments received, including
-            those received in error.  This count includes
-            segments received on currently established
-            connections."
-    ::= { tcp 10 }
-
-tcpOutSegs OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The total number of segments sent, including
-            those on current connections but excluding those
-            containing only retransmitted octets."
-    ::= { tcp 11 }
-
-tcpRetransSegs OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The total number of segments retransmitted - that
-            is, the number of TCP segments transmitted
-            containing one or more previously transmitted
-            octets."
-    ::= { tcp 12 }
-
-
--- the TCP Connection table
-
--- The TCP connection table contains information about this
--- entity's existing TCP connections.
-
-tcpConnTable OBJECT-TYPE
-    SYNTAX  SEQUENCE OF TcpConnEntry
-    ACCESS  not-accessible
-    STATUS  mandatory
-    DESCRIPTION
-            "A table containing TCP connection-specific
-            information."
-    ::= { tcp 13 }
-
-tcpConnEntry OBJECT-TYPE
-    SYNTAX  TcpConnEntry
-    ACCESS  not-accessible
-    STATUS  mandatory
-    DESCRIPTION
-            "Information about a particular current TCP
-            connection.  An object of this type is transient,
-            in that it ceases to exist when (or soon after)
-            the connection makes the transition to the CLOSED
-            state."
-    INDEX   { tcpConnLocalAddress,
-              tcpConnLocalPort,
-              tcpConnRemAddress,
-              tcpConnRemPort }
-    ::= { tcpConnTable 1 }
-
-TcpConnEntry ::=
-    SEQUENCE {
-        tcpConnState
-            INTEGER,
-        tcpConnLocalAddress
-            IpAddress,
-        tcpConnLocalPort
-            INTEGER (0..65535),
-        tcpConnRemAddress
-            IpAddress,
-        tcpConnRemPort
-            INTEGER (0..65535)
-    }
-
-tcpConnState OBJECT-TYPE
-    SYNTAX  INTEGER {
-                closed(1),
-                listen(2),
-                synSent(3),
-                synReceived(4),
-                established(5),
-                finWait1(6),
-                finWait2(7),
-                closeWait(8),
-                lastAck(9),
-                closing(10),
-                timeWait(11),
-                deleteTCB(12)
-            }
-    ACCESS  read-write
-    STATUS  mandatory
-    DESCRIPTION
-            "The state of this TCP connection.
-
-            The only value which may be set by a management
-            station is deleteTCB(12).  Accordingly, it is
-            appropriate for an agent to return a `badValue'
-            response if a management station attempts to set
-            this object to any other value.
-
-            If a management station sets this object to the
-            value deleteTCB(12), then this has the effect of
-            deleting the TCB (as defined in RFC 793) of the
-            corresponding connection on the managed node,
-            resulting in immediate termination of the
-            connection.
-
-            As an implementation-specific option, a RST
-            segment may be sent from the managed node to the
-            other TCP endpoint (note however that RST segments
-            are not sent reliably)."
-    ::= { tcpConnEntry 1 }
-
-tcpConnLocalAddress OBJECT-TYPE
-    SYNTAX  IpAddress
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The local IP address for this TCP connection.  In
-            the case of a connection in the listen state which
-            is willing to accept connections for any IP
-            interface associated with the node, the value
-            0.0.0.0 is used."
-    ::= { tcpConnEntry 2 }
-
-tcpConnLocalPort OBJECT-TYPE
-    SYNTAX  INTEGER (0..65535)
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The local port number for this TCP connection."
-    ::= { tcpConnEntry 3 }
-
-tcpConnRemAddress OBJECT-TYPE
-    SYNTAX  IpAddress
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The remote IP address for this TCP connection."
-    ::= { tcpConnEntry 4 }
-
-tcpConnRemPort OBJECT-TYPE
-    SYNTAX  INTEGER (0..65535)
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The remote port number for this TCP connection."
-    ::= { tcpConnEntry 5 }
-
-
--- additional TCP objects
-
-tcpInErrs OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The total number of segments received in error
-            (e.g., bad TCP checksums)."
-    ::= { tcp 14 }
-
-tcpOutRsts OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of TCP segments sent containing the
-            RST flag."
-    ::= { tcp 15 }
-
-
--- the UDP group
-
--- Implementation of the UDP group is mandatory for all
--- systems which implement the UDP.
-
-udpInDatagrams OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The total number of UDP datagrams delivered to
-            UDP users."
-    ::= { udp 1 }
-
-udpNoPorts OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The total number of received UDP datagrams for
-            which there was no application at the destination
-            port."
-    ::= { udp 2 }
-
-udpInErrors OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of received UDP datagrams that could
-            not be delivered for reasons other than the lack
-            of an application at the destination port."
-    ::= { udp 3 }
-
-udpOutDatagrams OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The total number of UDP datagrams sent from this
-            entity."
-    ::= { udp 4 }
-
-
--- the UDP Listener table
-
--- The UDP listener table contains information about this
--- entity's UDP end-points on which a local application is
--- currently accepting datagrams.
-
-udpTable OBJECT-TYPE
-    SYNTAX  SEQUENCE OF UdpEntry
-    ACCESS  not-accessible
-    STATUS  mandatory
-    DESCRIPTION
-            "A table containing UDP listener information."
-    ::= { udp 5 }
-
-udpEntry OBJECT-TYPE
-    SYNTAX  UdpEntry
-    ACCESS  not-accessible
-    STATUS  mandatory
-    DESCRIPTION
-            "Information about a particular current UDP
-            listener."
-    INDEX   { udpLocalAddress, udpLocalPort }
-    ::= { udpTable 1 }
-
-UdpEntry ::=
-    SEQUENCE {
-        udpLocalAddress
-            IpAddress,
-        udpLocalPort
-            INTEGER (0..65535)
-    }
-
-udpLocalAddress OBJECT-TYPE
-    SYNTAX  IpAddress
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The local IP address for this UDP listener.  In
-            the case of a UDP listener which is willing to
-            accept datagrams for any IP interface associated
-            with the node, the value 0.0.0.0 is used."
-    ::= { udpEntry 1 }
-
-udpLocalPort OBJECT-TYPE
-    SYNTAX  INTEGER (0..65535)
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The local port number for this UDP listener."
-    ::= { udpEntry 2 }
-
-
--- the EGP group
-
--- Implementation of the EGP group is mandatory for all
--- systems which implement the EGP.
-
-egpInMsgs OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of EGP messages received without
-            error."
-    ::= { egp 1 }
-
-egpInErrors OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of EGP messages received that proved
-            to be in error."
-    ::= { egp 2 }
-
-egpOutMsgs OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The total number of locally generated EGP
-            messages."
-    ::= { egp 3 }
-
-egpOutErrors OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of locally generated EGP messages not
-            sent due to resource limitations within an EGP
-            entity."
-    ::= { egp 4 }
-
-
--- the EGP Neighbor table
-
--- The EGP neighbor table contains information about this
--- entity's EGP neighbors.
-
-egpNeighTable OBJECT-TYPE
-    SYNTAX  SEQUENCE OF EgpNeighEntry
-    ACCESS  not-accessible
-    STATUS  mandatory
-    DESCRIPTION
-            "The EGP neighbor table."
-    ::= { egp 5 }
-
-egpNeighEntry OBJECT-TYPE
-    SYNTAX  EgpNeighEntry
-    ACCESS  not-accessible
-    STATUS  mandatory
-    DESCRIPTION
-            "Information about this entity's relationship with
-            a particular EGP neighbor."
-    INDEX   { egpNeighAddr }
-    ::= { egpNeighTable 1 }
-
-EgpNeighEntry ::=
-    SEQUENCE {
-        egpNeighState
-            INTEGER,
-        egpNeighAddr
-            IpAddress,
-        egpNeighAs
-            INTEGER,
-        egpNeighInMsgs
-            Counter,
-        egpNeighInErrs
-            Counter,
-        egpNeighOutMsgs
-            Counter,
-        egpNeighOutErrs
-            Counter,
-        egpNeighInErrMsgs
-            Counter,
-        egpNeighOutErrMsgs
-            Counter,
-        egpNeighStateUps
-            Counter,
-        egpNeighStateDowns
-            Counter,
-        egpNeighIntervalHello
-            INTEGER,
-        egpNeighIntervalPoll
-            INTEGER,
-        egpNeighMode
-            INTEGER,
-        egpNeighEventTrigger
-            INTEGER
-    }
-
-egpNeighState OBJECT-TYPE
-    SYNTAX  INTEGER {
-                idle(1),
-                acquisition(2),
-                down(3),
-                up(4),
-                cease(5)
-            }
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The EGP state of the local system with respect to
-            this entry's EGP neighbor.  Each EGP state is
-            represented by a value that is one greater than
-            the numerical value associated with said state in
-            RFC 904."
-    ::= { egpNeighEntry 1 }
-
-egpNeighAddr OBJECT-TYPE
-    SYNTAX  IpAddress
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The IP address of this entry's EGP neighbor."
-    ::= { egpNeighEntry 2 }
-
-egpNeighAs OBJECT-TYPE
-    SYNTAX  INTEGER
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The autonomous system of this EGP peer.  Zero
-            should be specified if the autonomous system
-            number of the neighbor is not yet known."
-    ::= { egpNeighEntry 3 }
-
-egpNeighInMsgs OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of EGP messages received without error
-            from this EGP peer."
-    ::= { egpNeighEntry 4 }
-
-egpNeighInErrs OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of EGP messages received from this EGP
-            peer that proved to be in error (e.g., bad EGP
-            checksum)."
-    ::= { egpNeighEntry 5 }
-
-egpNeighOutMsgs OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of locally generated EGP messages to
-            this EGP peer."
-    ::= { egpNeighEntry 6 }
-
-egpNeighOutErrs OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of locally generated EGP messages not
-            sent to this EGP peer due to resource limitations
-            within an EGP entity."
-    ::= { egpNeighEntry 7 }
-
-egpNeighInErrMsgs OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of EGP-defined error messages received
-            from this EGP peer."
-    ::= { egpNeighEntry 8 }
-
-egpNeighOutErrMsgs OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of EGP-defined error messages sent to
-            this EGP peer."
-    ::= { egpNeighEntry 9 }
-
-egpNeighStateUps OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of EGP state transitions to the UP
-            state with this EGP peer."
-    ::= { egpNeighEntry 10 }
-
-egpNeighStateDowns OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The number of EGP state transitions from the UP
-            state to any other state with this EGP peer."
-    ::= { egpNeighEntry 11 }
-
-egpNeighIntervalHello OBJECT-TYPE
-    SYNTAX  INTEGER
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The interval between EGP Hello command
-            retransmissions (in hundredths of a second).  This
-            represents the t1 timer as defined in RFC 904."
-    ::= { egpNeighEntry 12 }
-
-egpNeighIntervalPoll OBJECT-TYPE
-    SYNTAX  INTEGER
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The interval between EGP poll command
-            retransmissions (in hundredths of a second).  This
-            represents the t3 timer as defined in RFC 904."
-    ::= { egpNeighEntry 13 }
-
-egpNeighMode OBJECT-TYPE
-    SYNTAX  INTEGER { active(1), passive(2) }
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The polling mode of this EGP entity, either
-            passive or active."
-    ::= { egpNeighEntry 14 }
-
-egpNeighEventTrigger OBJECT-TYPE
-    SYNTAX  INTEGER { start(1), stop(2) }
-    ACCESS  read-write
-    STATUS  mandatory
-    DESCRIPTION
-            "A control variable used to trigger operator-
-            initiated Start and Stop events.  When read, this
-            variable always returns the most recent value that
-            egpNeighEventTrigger was set to.  If it has not
-            been set since the last initialization of the
-            network management subsystem on the node, it
-            returns a value of `stop'.
-
-            When set, this variable causes a Start or Stop
-            event on the specified neighbor, as specified on
-            pages 8-10 of RFC 904.  Briefly, a Start event
-            causes an Idle peer to begin neighbor acquisition
-            and a non-Idle peer to reinitiate neighbor
-            acquisition.  A stop event causes a non-Idle peer
-            to return to the Idle state until a Start event
-            occurs, either via egpNeighEventTrigger or
-            otherwise."
-    ::= { egpNeighEntry 15 }
-
-
--- additional EGP objects
-
-egpAs OBJECT-TYPE
-    SYNTAX  INTEGER
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The autonomous system number of this EGP entity."
-    ::= { egp 6 }
-
--- the Transmission group
-
--- Based on the transmission media underlying each interface
--- on a system, the corresponding portion of the Transmission
--- group is mandatory for that system.
-
--- When Internet-standard definitions for managing
--- transmission media are defined, the transmission group is
--- used to provide a prefix for the names of those objects.
-
--- Typically, such definitions reside in the experimental
--- portion of the MIB until they are "proven", then as a
--- part of the Internet standardization process, the
--- definitions are accordingly elevated and a new object
--- identifier, under the transmission group is defined. By
--- convention, the name assigned is:
---
---     type OBJECT IDENTIFIER    ::= { transmission number }
---
--- where "type" is the symbolic value used for the media in
--- the ifType column of the ifTable object, and "number" is
--- the actual integer value corresponding to the symbol.
-
-
--- the SNMP group
-
--- Implementation of the SNMP group is mandatory for all
--- systems which support an SNMP protocol entity.  Some of
--- the objects defined below will be zero-valued in those
--- SNMP implementations that are optimized to support only
--- those functions specific to either a management agent or
--- a management station.  In particular, it should be
--- observed that the objects below refer to an SNMP entity,
--- and there may be several SNMP entities residing on a
--- managed node (e.g., if the node is hosting acting as
--- a management station).
-
-snmpInPkts OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The total number of Messages delivered to the
-            SNMP entity from the transport service."
-    ::= { snmp 1 }
-
-snmpOutPkts OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The total number of SNMP Messages which were
-            passed from the SNMP protocol entity to the
-            transport service."
-    ::= { snmp 2 }
-
-snmpInBadVersions OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The total number of SNMP Messages which were
-            delivered to the SNMP protocol entity and were for
-            an unsupported SNMP version."
-    ::= { snmp 3 }
-
-snmpInBadCommunityNames OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The total number of SNMP Messages delivered to
-            the SNMP protocol entity which used a SNMP
-            community name not known to said entity."
-    ::= { snmp 4 }
-
-snmpInBadCommunityUses OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The total number of SNMP Messages delivered to
-            the SNMP protocol entity which represented an SNMP
-            operation which was not allowed by the SNMP
-            community named in the Message."
-    ::= { snmp 5 }
-
-snmpInASNParseErrs OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The total number of ASN.1 or BER errors
-            encountered by the SNMP protocol entity when
-            decoding received SNMP Messages."
-    ::= { snmp 6 }
-
--- { snmp 7 } is not used
-
-snmpInTooBigs OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The total number of SNMP PDUs which were
-            delivered to the SNMP protocol entity and for
-            which the value of the error-status field is
-            `tooBig'."
-    ::= { snmp 8 }
-
-snmpInNoSuchNames OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The total number of SNMP PDUs which were
-            delivered to the SNMP protocol entity and for
-            which the value of the error-status field is
-            `noSuchName'."
-    ::= { snmp 9 }
-
-snmpInBadValues OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The total number of SNMP PDUs which were
-            delivered to the SNMP protocol entity and for
-            which the value of the error-status field is
-            `badValue'."
-    ::= { snmp 10 }
-
-snmpInReadOnlys OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The total number valid SNMP PDUs which were
-            delivered to the SNMP protocol entity and for
-            which the value of the error-status field is
-            `readOnly'.  It should be noted that it is a
-            protocol error to generate an SNMP PDU which
-            contains the value `readOnly' in the error-status
-            field, as such this object is provided as a means
-            of detecting incorrect implementations of the
-            SNMP."
-    ::= { snmp 11 }
-
-snmpInGenErrs OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The total number of SNMP PDUs which were
-            delivered to the SNMP protocol entity and for
-            which the value of the error-status field is
-            `genErr'."
-    ::= { snmp 12 }
-
-snmpInTotalReqVars OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The total number of MIB objects which have been
-            retrieved successfully by the SNMP protocol entity
-            as the result of receiving valid SNMP Get-Request
-            and Get-Next PDUs."
-    ::= { snmp 13 }
-
-snmpInTotalSetVars OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The total number of MIB objects which have been
-            altered successfully by the SNMP protocol entity
-            as the result of receiving valid SNMP Set-Request
-            PDUs."
-    ::= { snmp 14 }
-
-snmpInGetRequests OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The total number of SNMP Get-Request PDUs which
-            have been accepted and processed by the SNMP
-            protocol entity."
-    ::= { snmp 15 }
-
-snmpInGetNexts OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The total number of SNMP Get-Next PDUs which have
-            been accepted and processed by the SNMP protocol
-            entity."
-    ::= { snmp 16 }
-
-snmpInSetRequests OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The total number of SNMP Set-Request PDUs which
-            have been accepted and processed by the SNMP
-            protocol entity."
-    ::= { snmp 17 }
-
-snmpInGetResponses OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The total number of SNMP Get-Response PDUs which
-            have been accepted and processed by the SNMP
-            protocol entity."
-    ::= { snmp 18 }
-
-snmpInTraps OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The total number of SNMP Trap PDUs which have
-            been accepted and processed by the SNMP protocol
-            entity."
-    ::= { snmp 19 }
-
-snmpOutTooBigs OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The total number of SNMP PDUs which were
-            generated by the SNMP protocol entity and for
-            which the value of the error-status field is
-            `tooBig.'"
-    ::= { snmp 20 }
-
-snmpOutNoSuchNames OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The total number of SNMP PDUs which were
-            generated by the SNMP protocol entity and for
-            which the value of the error-status is
-            `noSuchName'."
-    ::= { snmp 21 }
-
-snmpOutBadValues OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The total number of SNMP PDUs which were
-            generated by the SNMP protocol entity and for
-            which the value of the error-status field is
-            `badValue'."
-    ::= { snmp 22 }
-
--- { snmp 23 } is not used
-
-snmpOutGenErrs OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The total number of SNMP PDUs which were
-            generated by the SNMP protocol entity and for
-            which the value of the error-status field is
-            `genErr'."
-    ::= { snmp 24 }
-
-snmpOutGetRequests OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The total number of SNMP Get-Request PDUs which
-            have been generated by the SNMP protocol entity."
-    ::= { snmp 25 }
-
-snmpOutGetNexts OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The total number of SNMP Get-Next PDUs which have
-            been generated by the SNMP protocol entity."
-    ::= { snmp 26 }
-
-snmpOutSetRequests OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The total number of SNMP Set-Request PDUs which
-            have been generated by the SNMP protocol entity."
-    ::= { snmp 27 }
-
-snmpOutGetResponses OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The total number of SNMP Get-Response PDUs which
-            have been generated by the SNMP protocol entity."
-    ::= { snmp 28 }
-
-snmpOutTraps OBJECT-TYPE
-    SYNTAX  Counter
-    ACCESS  read-only
-    STATUS  mandatory
-    DESCRIPTION
-            "The total number of SNMP Trap PDUs which have
-            been generated by the SNMP protocol entity."
-    ::= { snmp 29 }
-
-snmpEnableAuthenTraps OBJECT-TYPE
-    SYNTAX  INTEGER { enabled(1), disabled(2) }
-    ACCESS  read-write
-    STATUS  mandatory
-    DESCRIPTION
-            "Indicates whether the SNMP agent process is
-            permitted to generate authentication-failure
-            traps.  The value of this object overrides any
-            configuration information; as such, it provides a
-            means whereby all authentication-failure traps may
-            be disabled.
-
-            Note that it is strongly recommended that this
-            object be stored in non-volatile memory so that it
-            remains constant between re-initializations of the
-            network management system."
-    ::= { snmp 30 }
-
-END
diff --git a/contrib/apps/LwipMibCompiler/Mibs/SNMPv2-CONF b/contrib/apps/LwipMibCompiler/Mibs/SNMPv2-CONF
deleted file mode 100644
index 904dbbb2..00000000
--- a/contrib/apps/LwipMibCompiler/Mibs/SNMPv2-CONF
+++ /dev/null
@@ -1,318 +0,0 @@
-SNMPv2-CONF DEFINITIONS ::= BEGIN
-
-IMPORTS ObjectName, NotificationName, ObjectSyntax
-                                               FROM SNMPv2-SMI;
-
--- definitions for conformance groups
-
-OBJECT-GROUP MACRO ::=
-BEGIN
-    TYPE NOTATION ::=
-                  ObjectsPart
-                  "STATUS" Status
-                  "DESCRIPTION" Text
-                  ReferPart
-
-    VALUE NOTATION ::=
-                  value(VALUE OBJECT IDENTIFIER)
-
-    ObjectsPart ::=
-                  "OBJECTS" "{" Objects "}"
-    Objects ::=
-                  Object
-                | Objects "," Object
-    Object ::=
-                  value(ObjectName)
-
-    Status ::=
-                  "current"
-                | "deprecated"
-                | "obsolete"
-
-    ReferPart ::=
-                  "REFERENCE" Text
-                | empty
-
-    -- a character string as defined in [2]
-    Text ::= value(IA5String)
-END
-
--- more definitions for conformance groups
-
-NOTIFICATION-GROUP MACRO ::=
-BEGIN
-    TYPE NOTATION ::=
-                  NotificationsPart
-                  "STATUS" Status
-                  "DESCRIPTION" Text
-                  ReferPart
-
-    VALUE NOTATION ::=
-                  value(VALUE OBJECT IDENTIFIER)
-
-    NotificationsPart ::=
-                  "NOTIFICATIONS" "{" Notifications "}"
-    Notifications ::=
-                  Notification
-                | Notifications "," Notification
-    Notification ::=
-                  value(NotificationName)
-
-    Status ::=
-                  "current"
-                | "deprecated"
-                | "obsolete"
-
-    ReferPart ::=
-                  "REFERENCE" Text
-                | empty
-
-    -- a character string as defined in [2]
-    Text ::= value(IA5String)
-END
-
--- definitions for compliance statements
-
-MODULE-COMPLIANCE MACRO ::=
-BEGIN
-    TYPE NOTATION ::=
-                  "STATUS" Status
-                  "DESCRIPTION" Text
-                  ReferPart
-                  ModulePart
-
-    VALUE NOTATION ::=
-                  value(VALUE OBJECT IDENTIFIER)
-
-    Status ::=
-                  "current"
-                | "deprecated"
-                | "obsolete"
-
-    ReferPart ::=
-                  "REFERENCE" Text
-                | empty
-
-    ModulePart ::=
-                  Modules
-    Modules ::=
-                  Module
-                | Modules Module
-    Module ::=
-                  -- name of module --
-                  "MODULE" ModuleName
-                  MandatoryPart
-                  CompliancePart
-
-    ModuleName ::=
-                  -- identifier must start with uppercase letter
-                  identifier ModuleIdentifier
-                  -- must not be empty unless contained
-                  -- in MIB Module
-                | empty
-    ModuleIdentifier ::=
-                  value(OBJECT IDENTIFIER)
-                | empty
-
-    MandatoryPart ::=
-                  "MANDATORY-GROUPS" "{" Groups "}"
-                | empty
-
-    Groups ::=
-                  Group
-                | Groups "," Group
-    Group ::=
-                  value(OBJECT IDENTIFIER)
-
-    CompliancePart ::=
-                  Compliances
-                | empty
-
-    Compliances ::=
-                  Compliance
-                | Compliances Compliance
-    Compliance ::=
-                  ComplianceGroup
-                | Object
-
-    ComplianceGroup ::=
-                  "GROUP" value(OBJECT IDENTIFIER)
-                  "DESCRIPTION" Text
-
-    Object ::=
-                  "OBJECT" value(ObjectName)
-                  SyntaxPart
-                  WriteSyntaxPart
-                  AccessPart
-                  "DESCRIPTION" Text
-
-    -- must be a refinement for object's SYNTAX clause
-    SyntaxPart ::= "SYNTAX" Syntax
-                | empty
-
-    -- must be a refinement for object's SYNTAX clause
-    WriteSyntaxPart ::= "WRITE-SYNTAX" Syntax
-                | empty
-
-    Syntax ::=    -- Must be one of the following:
-                       -- a base type (or its refinement),
-                       -- a textual convention (or its refinement), or
-                       -- a BITS pseudo-type
-                  type
-                | "BITS" "{" NamedBits "}"
-
-    NamedBits ::= NamedBit
-                | NamedBits "," NamedBit
-
-    NamedBit ::= identifier "(" number ")" -- number is nonnegative
-
-    AccessPart ::=
-                  "MIN-ACCESS" Access
-                | empty
-    Access ::=
-                  "not-accessible"
-                | "accessible-for-notify"
-                | "read-only"
-                | "read-write"
-                | "read-create"
-
-    -- a character string as defined in [2]
-    Text ::= value(IA5String)
-END
-
--- definitions for capabilities statements
-
-AGENT-CAPABILITIES MACRO ::=
-BEGIN
-    TYPE NOTATION ::=
-                  "PRODUCT-RELEASE" Text
-                  "STATUS" Status
-                  "DESCRIPTION" Text
-                  ReferPart
-                  ModulePart
-
-    VALUE NOTATION ::=
-                  value(VALUE OBJECT IDENTIFIER)
-
-    Status ::=
-                  "current"
-                | "obsolete"
-
-    ReferPart ::=
-                  "REFERENCE" Text
-                | empty
-
-    ModulePart ::=
-                  Modules
-                | empty
-    Modules ::=
-                  Module
-                | Modules Module
-    Module ::=
-                  -- name of module --
-                  "SUPPORTS" ModuleName
-                  "INCLUDES" "{" Groups "}"
-                  VariationPart
-
-    ModuleName ::=
-                  -- identifier must start with uppercase letter
-                  identifier ModuleIdentifier
-    ModuleIdentifier ::=
-                  value(OBJECT IDENTIFIER)
-                | empty
-
-    Groups ::=
-                  Group
-                | Groups "," Group
-    Group ::=
-                  value(OBJECT IDENTIFIER)
-
-    VariationPart ::=
-                  Variations
-                | empty
-    Variations ::=
-                  Variation
-                | Variations Variation
-
-    Variation ::=
-                  ObjectVariation
-                | NotificationVariation
-
-    NotificationVariation ::=
-                  "VARIATION" value(NotificationName)
-                  AccessPart
-                  "DESCRIPTION" Text
-
-    ObjectVariation ::=
-                  "VARIATION" value(ObjectName)
-                  SyntaxPart
-                  WriteSyntaxPart
-                  AccessPart
-                  CreationPart
-                  DefValPart
-                  "DESCRIPTION" Text
-
-    -- must be a refinement for object's SYNTAX clause
-    SyntaxPart ::= "SYNTAX" Syntax
-                | empty
-
-    WriteSyntaxPart ::= "WRITE-SYNTAX" Syntax
-                | empty
-
-    Syntax ::=    -- Must be one of the following:
-                       -- a base type (or its refinement),
-                       -- a textual convention (or its refinement), or
-                       -- a BITS pseudo-type
-                  type
-                | "BITS" "{" NamedBits "}"
-
-    NamedBits ::= NamedBit
-                | NamedBits "," NamedBit
-
-    NamedBit ::= identifier "(" number ")" -- number is nonnegative
-
-    AccessPart ::=
-                  "ACCESS" Access
-                | empty
-
-    Access ::=
-                  "not-implemented"
-                -- only "not-implemented" for notifications
-                | "accessible-for-notify"
-                | "read-only"
-                | "read-write"
-                | "read-create"
-                -- following is for backward-compatibility only
-                | "write-only"
-
-    CreationPart ::=
-                  "CREATION-REQUIRES" "{" Cells "}"
-                | empty
-    Cells ::=
-                  Cell
-                | Cells "," Cell
-    Cell ::=
-                  value(ObjectName)
-
-    DefValPart ::= "DEFVAL" "{" Defvalue "}"
-                | empty
-
-    Defvalue ::=  -- must be valid for the object's syntax
-                  -- in this macro's SYNTAX clause, if present,
-                  -- or if not, in object's OBJECT-TYPE macro
-                  value(ObjectSyntax)
-                | "{" BitsValue "}"
-
-    BitsValue ::= BitNames
-                | empty
-
-    BitNames ::=  BitName
-                | BitNames "," BitName
-
-    BitName ::= identifier
-
-    -- a character string as defined in [2]
-    Text ::= value(IA5String)
-END
-
-END
diff --git a/contrib/apps/LwipMibCompiler/Mibs/SNMPv2-MIB b/contrib/apps/LwipMibCompiler/Mibs/SNMPv2-MIB
deleted file mode 100644
index 9494e42c..00000000
--- a/contrib/apps/LwipMibCompiler/Mibs/SNMPv2-MIB
+++ /dev/null
@@ -1,903 +0,0 @@
-SNMPv2-MIB DEFINITIONS ::= BEGIN
-
-IMPORTS
-    MODULE-IDENTITY, OBJECT-TYPE, NOTIFICATION-TYPE,
-    TimeTicks, Counter32, snmpModules, mib-2
-        FROM SNMPv2-SMI
-    DisplayString, TestAndIncr, TimeStamp
-
-
-
-        FROM SNMPv2-TC
-    MODULE-COMPLIANCE, OBJECT-GROUP, NOTIFICATION-GROUP
-        FROM SNMPv2-CONF;
-
-snmpMIB MODULE-IDENTITY
-    LAST-UPDATED "200210160000Z"
-    ORGANIZATION "IETF SNMPv3 Working Group"
-    CONTACT-INFO
-            "WG-EMail:   snmpv3@lists.tislabs.com
-             Subscribe:  snmpv3-request@lists.tislabs.com
-
-             Co-Chair:   Russ Mundy
-                         Network Associates Laboratories
-             postal:     15204 Omega Drive, Suite 300
-                         Rockville, MD 20850-4601
-                         USA
-             EMail:      mundy@tislabs.com
-             phone:      +1 301 947-7107
-
-             Co-Chair:   David Harrington
-                         Enterasys Networks
-             postal:     35 Industrial Way
-                         P. O. Box 5005
-                         Rochester, NH 03866-5005
-                         USA
-             EMail:      dbh@enterasys.com
-             phone:      +1 603 337-2614
-
-             Editor:     Randy Presuhn
-                         BMC Software, Inc.
-             postal:     2141 North First Street
-                         San Jose, CA 95131
-                         USA
-             EMail:      randy_presuhn@bmc.com
-             phone:      +1 408 546-1006"
-    DESCRIPTION
-            "The MIB module for SNMP entities.
-
-             Copyright (C) The Internet Society (2002). This
-             version of this MIB module is part of RFC 3418;
-             see the RFC itself for full legal notices.
-            "
-    REVISION      "200210160000Z"
-    DESCRIPTION
-            "This revision of this MIB module was published as
-             RFC 3418."
-    REVISION      "199511090000Z"
-    DESCRIPTION
-
-
-
-            "This revision of this MIB module was published as
-             RFC 1907."
-    REVISION      "199304010000Z"
-    DESCRIPTION
-            "The initial revision of this MIB module was published
-            as RFC 1450."
-    ::= { snmpModules 1 }
-
-snmpMIBObjects OBJECT IDENTIFIER ::= { snmpMIB 1 }
-
---  ::= { snmpMIBObjects 1 }        this OID is obsolete
---  ::= { snmpMIBObjects 2 }        this OID is obsolete
---  ::= { snmpMIBObjects 3 }        this OID is obsolete
-
--- the System group
---
--- a collection of objects common to all managed systems.
-
-system   OBJECT IDENTIFIER ::= { mib-2 1 }
-
-sysDescr OBJECT-TYPE
-    SYNTAX      DisplayString (SIZE (0..255))
-    MAX-ACCESS  read-only
-    STATUS      current
-    DESCRIPTION
-            "A textual description of the entity.  This value should
-            include the full name and version identification of
-            the system's hardware type, software operating-system,
-            and networking software."
-    ::= { system 1 }
-
-sysObjectID OBJECT-TYPE
-    SYNTAX      OBJECT IDENTIFIER
-    MAX-ACCESS  read-only
-    STATUS      current
-    DESCRIPTION
-            "The vendor's authoritative identification of the
-            network management subsystem contained in the entity.
-            This value is allocated within the SMI enterprises
-            subtree (1.3.6.1.4.1) and provides an easy and
-            unambiguous means for determining `what kind of box' is
-            being managed.  For example, if vendor `Flintstones,
-            Inc.' was assigned the subtree 1.3.6.1.4.1.424242,
-            it could assign the identifier 1.3.6.1.4.1.424242.1.1
-            to its `Fred Router'."
-    ::= { system 2 }
-
-sysUpTime OBJECT-TYPE
-
-
-
-    SYNTAX      TimeTicks
-    MAX-ACCESS  read-only
-    STATUS      current
-    DESCRIPTION
-            "The time (in hundredths of a second) since the
-            network management portion of the system was last
-            re-initialized."
-    ::= { system 3 }
-
-sysContact OBJECT-TYPE
-    SYNTAX      DisplayString (SIZE (0..255))
-    MAX-ACCESS  read-write
-    STATUS      current
-    DESCRIPTION
-            "The textual identification of the contact person for
-            this managed node, together with information on how
-            to contact this person.  If no contact information is
-            known, the value is the zero-length string."
-    ::= { system 4 }
-
-sysName OBJECT-TYPE
-    SYNTAX      DisplayString (SIZE (0..255))
-    MAX-ACCESS  read-write
-    STATUS      current
-    DESCRIPTION
-            "An administratively-assigned name for this managed
-            node.  By convention, this is the node's fully-qualified
-            domain name.  If the name is unknown, the value is
-            the zero-length string."
-    ::= { system 5 }
-
-sysLocation OBJECT-TYPE
-    SYNTAX      DisplayString (SIZE (0..255))
-    MAX-ACCESS  read-write
-    STATUS      current
-    DESCRIPTION
-            "The physical location of this node (e.g., 'telephone
-            closet, 3rd floor').  If the location is unknown, the
-            value is the zero-length string."
-    ::= { system 6 }
-
-sysServices OBJECT-TYPE
-    SYNTAX      INTEGER (0..127)
-    MAX-ACCESS  read-only
-    STATUS      current
-    DESCRIPTION
-            "A value which indicates the set of services that this
-            entity may potentially offer.  The value is a sum.
-
-
-
-            This sum initially takes the value zero. Then, for
-            each layer, L, in the range 1 through 7, that this node
-            performs transactions for, 2 raised to (L - 1) is added
-            to the sum.  For example, a node which performs only
-            routing functions would have a value of 4 (2^(3-1)).
-            In contrast, a node which is a host offering application
-            services would have a value of 72 (2^(4-1) + 2^(7-1)).
-            Note that in the context of the Internet suite of
-            protocols, values should be calculated accordingly:
-
-                 layer      functionality
-                   1        physical (e.g., repeaters)
-                   2        datalink/subnetwork (e.g., bridges)
-                   3        internet (e.g., supports the IP)
-                   4        end-to-end  (e.g., supports the TCP)
-                   7        applications (e.g., supports the SMTP)
-
-            For systems including OSI protocols, layers 5 and 6
-            may also be counted."
-    ::= { system 7 }
-
--- object resource information
---
--- a collection of objects which describe the SNMP entity's
--- (statically and dynamically configurable) support of
--- various MIB modules.
-
-sysORLastChange OBJECT-TYPE
-    SYNTAX     TimeStamp
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-            "The value of sysUpTime at the time of the most recent
-            change in state or value of any instance of sysORID."
-    ::= { system 8 }
-
-sysORTable OBJECT-TYPE
-    SYNTAX     SEQUENCE OF SysOREntry
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-            "The (conceptual) table listing the capabilities of
-            the local SNMP application acting as a command
-            responder with respect to various MIB modules.
-            SNMP entities having dynamically-configurable support
-            of MIB modules will have a dynamically-varying number
-            of conceptual rows."
-    ::= { system 9 }
-
-
-
-sysOREntry OBJECT-TYPE
-    SYNTAX     SysOREntry
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-            "An entry (conceptual row) in the sysORTable."
-    INDEX      { sysORIndex }
-    ::= { sysORTable 1 }
-
-SysOREntry ::= SEQUENCE {
-    sysORIndex     INTEGER,
-    sysORID        OBJECT IDENTIFIER,
-    sysORDescr     DisplayString,
-    sysORUpTime    TimeStamp
-}
-
-sysORIndex OBJECT-TYPE
-    SYNTAX     INTEGER (1..2147483647)
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-            "The auxiliary variable used for identifying instances
-            of the columnar objects in the sysORTable."
-    ::= { sysOREntry 1 }
-
-sysORID OBJECT-TYPE
-    SYNTAX     OBJECT IDENTIFIER
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-            "An authoritative identification of a capabilities
-            statement with respect to various MIB modules supported
-            by the local SNMP application acting as a command
-            responder."
-    ::= { sysOREntry 2 }
-
-sysORDescr OBJECT-TYPE
-    SYNTAX     DisplayString
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-            "A textual description of the capabilities identified
-            by the corresponding instance of sysORID."
-    ::= { sysOREntry 3 }
-
-sysORUpTime OBJECT-TYPE
-    SYNTAX     TimeStamp
-    MAX-ACCESS read-only
-
-
-
-    STATUS     current
-    DESCRIPTION
-            "The value of sysUpTime at the time this conceptual
-            row was last instantiated."
-    ::= { sysOREntry 4 }
-
-
--- the SNMP group
---
--- a collection of objects providing basic instrumentation and
--- control of an SNMP entity.
-
-snmp     OBJECT IDENTIFIER ::= { mib-2 11 }
-
-snmpInPkts OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-            "The total number of messages delivered to the SNMP
-            entity from the transport service."
-    ::= { snmp 1 }
-
-snmpInBadVersions OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-            "The total number of SNMP messages which were delivered
-            to the SNMP entity and were for an unsupported SNMP
-            version."
-    ::= { snmp 3 }
-
-snmpInBadCommunityNames OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of community-based SNMP messages (for
-           example,  SNMPv1) delivered to the SNMP entity which
-           used an SNMP community name not known to said entity.
-           Also, implementations which authenticate community-based
-           SNMP messages using check(s) in addition to matching
-           the community name (for example, by also checking
-           whether the message originated from a transport address
-           allowed to use a specified community name) MAY include
-           in this value the number of messages which failed the
-           additional check(s).  It is strongly RECOMMENDED that
-
-
-
-           the documentation for any security model which is used
-           to authenticate community-based SNMP messages specify
-           the precise conditions that contribute to this value."
-    ::= { snmp 4 }
-
-snmpInBadCommunityUses OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of community-based SNMP messages (for
-           example, SNMPv1) delivered to the SNMP entity which
-           represented an SNMP operation that was not allowed for
-           the SNMP community named in the message.  The precise
-           conditions under which this counter is incremented
-           (if at all) depend on how the SNMP entity implements
-           its access control mechanism and how its applications
-           interact with that access control mechanism.  It is
-           strongly RECOMMENDED that the documentation for any
-           access control mechanism which is used to control access
-           to and visibility of MIB instrumentation specify the
-           precise conditions that contribute to this value."
-    ::= { snmp 5 }
-
-snmpInASNParseErrs OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-            "The total number of ASN.1 or BER errors encountered by
-            the SNMP entity when decoding received SNMP messages."
-    ::= { snmp 6 }
-
-snmpEnableAuthenTraps OBJECT-TYPE
-    SYNTAX      INTEGER { enabled(1), disabled(2) }
-    MAX-ACCESS  read-write
-    STATUS      current
-    DESCRIPTION
-            "Indicates whether the SNMP entity is permitted to
-            generate authenticationFailure traps.  The value of this
-            object overrides any configuration information; as such,
-            it provides a means whereby all authenticationFailure
-            traps may be disabled.
-
-            Note that it is strongly recommended that this object
-            be stored in non-volatile memory so that it remains
-            constant across re-initializations of the network
-            management system."
-
-
-
-    ::= { snmp 30 }
-
-snmpSilentDrops OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of Confirmed Class PDUs (such as
-           GetRequest-PDUs, GetNextRequest-PDUs,
-           GetBulkRequest-PDUs, SetRequest-PDUs, and
-           InformRequest-PDUs) delivered to the SNMP entity which
-           were silently dropped because the size of a reply
-           containing an alternate Response Class PDU (such as a
-           Response-PDU) with an empty variable-bindings field
-           was greater than either a local constraint or the
-           maximum message size associated with the originator of
-           the request."
-    ::= { snmp 31 }
-
-snmpProxyDrops OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-            "The total number of Confirmed Class PDUs
-            (such as GetRequest-PDUs, GetNextRequest-PDUs,
-            GetBulkRequest-PDUs, SetRequest-PDUs, and
-            InformRequest-PDUs) delivered to the SNMP entity which
-            were silently dropped because the transmission of
-            the (possibly translated) message to a proxy target
-            failed in a manner (other than a time-out) such that
-            no Response Class PDU (such as a Response-PDU) could
-            be returned."
-    ::= { snmp 32 }
-
--- information for notifications
---
--- a collection of objects which allow the SNMP entity, when
--- supporting a notification originator application,
--- to be configured to generate SNMPv2-Trap-PDUs.
-
-snmpTrap       OBJECT IDENTIFIER ::= { snmpMIBObjects 4 }
-
-snmpTrapOID OBJECT-TYPE
-    SYNTAX     OBJECT IDENTIFIER
-    MAX-ACCESS accessible-for-notify
-    STATUS     current
-    DESCRIPTION
-
-
-
-            "The authoritative identification of the notification
-            currently being sent.  This variable occurs as
-            the second varbind in every SNMPv2-Trap-PDU and
-            InformRequest-PDU."
-    ::= { snmpTrap 1 }
-
---  ::= { snmpTrap 2 }   this OID is obsolete
-
-snmpTrapEnterprise OBJECT-TYPE
-    SYNTAX     OBJECT IDENTIFIER
-    MAX-ACCESS accessible-for-notify
-    STATUS     current
-    DESCRIPTION
-            "The authoritative identification of the enterprise
-            associated with the trap currently being sent.  When an
-            SNMP proxy agent is mapping an RFC1157 Trap-PDU
-            into a SNMPv2-Trap-PDU, this variable occurs as the
-            last varbind."
-    ::= { snmpTrap 3 }
-
---  ::= { snmpTrap 4 }   this OID is obsolete
-
-
--- well-known traps
-
-snmpTraps      OBJECT IDENTIFIER ::= { snmpMIBObjects 5 }
-
-coldStart NOTIFICATION-TYPE
-    STATUS  current
-    DESCRIPTION
-            "A coldStart trap signifies that the SNMP entity,
-            supporting a notification originator application, is
-            reinitializing itself and that its configuration may
-            have been altered."
-    ::= { snmpTraps 1 }
-
-warmStart NOTIFICATION-TYPE
-    STATUS  current
-    DESCRIPTION
-            "A warmStart trap signifies that the SNMP entity,
-            supporting a notification originator application,
-            is reinitializing itself such that its configuration
-            is unaltered."
-    ::= { snmpTraps 2 }
-
--- Note the linkDown NOTIFICATION-TYPE ::= { snmpTraps 3 }
--- and the linkUp NOTIFICATION-TYPE ::= { snmpTraps 4 }
--- are defined in RFC 2863 [RFC2863]
-
-
-
-authenticationFailure NOTIFICATION-TYPE
-    STATUS  current
-    DESCRIPTION
-            "An authenticationFailure trap signifies that the SNMP
-             entity has received a protocol message that is not
-             properly authenticated.  While all implementations
-             of SNMP entities MAY be capable of generating this
-             trap, the snmpEnableAuthenTraps object indicates
-             whether this trap will be generated."
-    ::= { snmpTraps 5 }
-
--- Note the egpNeighborLoss notification is defined
--- as { snmpTraps 6 } in RFC 1213
-
--- the set group
---
--- a collection of objects which allow several cooperating
--- command generator applications to coordinate their use of the
--- set operation.
-
-snmpSet        OBJECT IDENTIFIER ::= { snmpMIBObjects 6 }
-
-snmpSetSerialNo OBJECT-TYPE
-    SYNTAX     TestAndIncr
-    MAX-ACCESS read-write
-    STATUS     current
-    DESCRIPTION
-            "An advisory lock used to allow several cooperating
-            command generator applications to coordinate their
-            use of the SNMP set operation.
-
-            This object is used for coarse-grain coordination.
-            To achieve fine-grain coordination, one or more similar
-            objects might be defined within each MIB group, as
-            appropriate."
-    ::= { snmpSet 1 }
-
--- conformance information
-
-snmpMIBConformance
-               OBJECT IDENTIFIER ::= { snmpMIB 2 }
-
-snmpMIBCompliances
-               OBJECT IDENTIFIER ::= { snmpMIBConformance 1 }
-snmpMIBGroups  OBJECT IDENTIFIER ::= { snmpMIBConformance 2 }
-
--- compliance statements
-
-
-
-
---    ::= { snmpMIBCompliances 1 }      this OID is obsolete
-snmpBasicCompliance MODULE-COMPLIANCE
-    STATUS  deprecated
-    DESCRIPTION
-            "The compliance statement for SNMPv2 entities which
-            implement the SNMPv2 MIB.
-
-            This compliance statement is replaced by
-            snmpBasicComplianceRev2."
-    MODULE  -- this module
-        MANDATORY-GROUPS { snmpGroup, snmpSetGroup, systemGroup,
-                           snmpBasicNotificationsGroup }
-
-        GROUP   snmpCommunityGroup
-        DESCRIPTION
-            "This group is mandatory for SNMPv2 entities which
-            support community-based authentication."
-
-    ::= { snmpMIBCompliances 2 }
-
-snmpBasicComplianceRev2 MODULE-COMPLIANCE
-    STATUS  current
-    DESCRIPTION
-            "The compliance statement for SNMP entities which
-            implement this MIB module."
-    MODULE  -- this module
-        MANDATORY-GROUPS { snmpGroup, snmpSetGroup, systemGroup,
-                           snmpBasicNotificationsGroup }
-
-        GROUP   snmpCommunityGroup
-        DESCRIPTION
-            "This group is mandatory for SNMP entities which
-            support community-based authentication."
-
-        GROUP   snmpWarmStartNotificationGroup
-        DESCRIPTION
-            "This group is mandatory for an SNMP entity which
-            supports command responder applications, and is
-            able to reinitialize itself such that its
-            configuration is unaltered."
-
-    ::= { snmpMIBCompliances 3 }
-
--- units of conformance
-
---  ::= { snmpMIBGroups 1 }           this OID is obsolete
---  ::= { snmpMIBGroups 2 }           this OID is obsolete
---  ::= { snmpMIBGroups 3 }           this OID is obsolete
-
-
-
---  ::= { snmpMIBGroups 4 }           this OID is obsolete
-
-snmpGroup OBJECT-GROUP
-    OBJECTS { snmpInPkts,
-              snmpInBadVersions,
-              snmpInASNParseErrs,
-              snmpSilentDrops,
-              snmpProxyDrops,
-              snmpEnableAuthenTraps }
-    STATUS  current
-    DESCRIPTION
-            "A collection of objects providing basic instrumentation
-            and control of an SNMP entity."
-    ::= { snmpMIBGroups 8 }
-
-snmpCommunityGroup OBJECT-GROUP
-    OBJECTS { snmpInBadCommunityNames,
-              snmpInBadCommunityUses }
-    STATUS  current
-    DESCRIPTION
-            "A collection of objects providing basic instrumentation
-            of a SNMP entity which supports community-based
-            authentication."
-    ::= { snmpMIBGroups 9 }
-
-snmpSetGroup OBJECT-GROUP
-    OBJECTS { snmpSetSerialNo }
-    STATUS  current
-    DESCRIPTION
-            "A collection of objects which allow several cooperating
-            command generator applications to coordinate their
-            use of the set operation."
-    ::= { snmpMIBGroups 5 }
-
-systemGroup OBJECT-GROUP
-    OBJECTS { sysDescr, sysObjectID, sysUpTime,
-              sysContact, sysName, sysLocation,
-              sysServices,
-              sysORLastChange, sysORID,
-              sysORUpTime, sysORDescr }
-    STATUS  current
-    DESCRIPTION
-            "The system group defines objects which are common to all
-            managed systems."
-    ::= { snmpMIBGroups 6 }
-
-snmpBasicNotificationsGroup NOTIFICATION-GROUP
-    NOTIFICATIONS { coldStart, authenticationFailure }
-
-
-
-    STATUS        current
-    DESCRIPTION
-       "The basic notifications implemented by an SNMP entity
-        supporting command responder applications."
-    ::= { snmpMIBGroups 7 }
-
-snmpWarmStartNotificationGroup NOTIFICATION-GROUP
-   NOTIFICATIONS { warmStart }
-   STATUS        current
-   DESCRIPTION
-     "An additional notification for an SNMP entity supporting
-     command responder applications, if it is able to reinitialize
-     itself such that its configuration is unaltered."
-  ::= { snmpMIBGroups 11 }
-
-snmpNotificationGroup OBJECT-GROUP
-    OBJECTS { snmpTrapOID, snmpTrapEnterprise }
-    STATUS  current
-    DESCRIPTION
-            "These objects are required for entities
-            which support notification originator applications."
-    ::= { snmpMIBGroups 12 }
-
--- definitions in RFC 1213 made obsolete by the inclusion of a
--- subset of the snmp group in this MIB
-
-snmpOutPkts OBJECT-TYPE
-    SYNTAX      Counter32
-    MAX-ACCESS  read-only
-    STATUS      obsolete
-    DESCRIPTION
-            "The total number of SNMP Messages which were
-            passed from the SNMP protocol entity to the
-            transport service."
-    ::= { snmp 2 }
-
--- { snmp 7 } is not used
-
-snmpInTooBigs OBJECT-TYPE
-    SYNTAX      Counter32
-    MAX-ACCESS  read-only
-    STATUS      obsolete
-    DESCRIPTION
-            "The total number of SNMP PDUs which were
-            delivered to the SNMP protocol entity and for
-            which the value of the error-status field was
-            `tooBig'."
-    ::= { snmp 8 }
-
-
-
-snmpInNoSuchNames OBJECT-TYPE
-    SYNTAX      Counter32
-    MAX-ACCESS  read-only
-    STATUS      obsolete
-    DESCRIPTION
-            "The total number of SNMP PDUs which were
-            delivered to the SNMP protocol entity and for
-            which the value of the error-status field was
-            `noSuchName'."
-    ::= { snmp 9 }
-
-snmpInBadValues OBJECT-TYPE
-    SYNTAX      Counter32
-    MAX-ACCESS  read-only
-    STATUS      obsolete
-    DESCRIPTION
-            "The total number of SNMP PDUs which were
-            delivered to the SNMP protocol entity and for
-            which the value of the error-status field was
-            `badValue'."
-    ::= { snmp 10 }
-
-snmpInReadOnlys OBJECT-TYPE
-    SYNTAX      Counter32
-    MAX-ACCESS  read-only
-    STATUS      obsolete
-    DESCRIPTION
-            "The total number valid SNMP PDUs which were delivered
-            to the SNMP protocol entity and for which the value
-            of the error-status field was `readOnly'.  It should
-            be noted that it is a protocol error to generate an
-            SNMP PDU which contains the value `readOnly' in the
-            error-status field, as such this object is provided
-            as a means of detecting incorrect implementations of
-            the SNMP."
-    ::= { snmp 11 }
-
-snmpInGenErrs OBJECT-TYPE
-    SYNTAX      Counter32
-    MAX-ACCESS  read-only
-    STATUS      obsolete
-    DESCRIPTION
-            "The total number of SNMP PDUs which were delivered
-            to the SNMP protocol entity and for which the value
-            of the error-status field was `genErr'."
-    ::= { snmp 12 }
-
-snmpInTotalReqVars OBJECT-TYPE
-
-
-
-    SYNTAX      Counter32
-    MAX-ACCESS  read-only
-    STATUS      obsolete
-    DESCRIPTION
-            "The total number of MIB objects which have been
-            retrieved successfully by the SNMP protocol entity
-            as the result of receiving valid SNMP Get-Request
-            and Get-Next PDUs."
-    ::= { snmp 13 }
-
-snmpInTotalSetVars OBJECT-TYPE
-    SYNTAX      Counter32
-    MAX-ACCESS  read-only
-    STATUS      obsolete
-    DESCRIPTION
-            "The total number of MIB objects which have been
-            altered successfully by the SNMP protocol entity as
-            the result of receiving valid SNMP Set-Request PDUs."
-    ::= { snmp 14 }
-
-snmpInGetRequests OBJECT-TYPE
-    SYNTAX      Counter32
-    MAX-ACCESS  read-only
-    STATUS      obsolete
-    DESCRIPTION
-            "The total number of SNMP Get-Request PDUs which
-            have been accepted and processed by the SNMP
-            protocol entity."
-    ::= { snmp 15 }
-
-snmpInGetNexts OBJECT-TYPE
-    SYNTAX      Counter32
-    MAX-ACCESS  read-only
-    STATUS      obsolete
-    DESCRIPTION
-            "The total number of SNMP Get-Next PDUs which have been
-            accepted and processed by the SNMP protocol entity."
-    ::= { snmp 16 }
-
-snmpInSetRequests OBJECT-TYPE
-    SYNTAX      Counter32
-    MAX-ACCESS  read-only
-    STATUS      obsolete
-    DESCRIPTION
-            "The total number of SNMP Set-Request PDUs which
-            have been accepted and processed by the SNMP protocol
-            entity."
-    ::= { snmp 17 }
-
-
-
-snmpInGetResponses OBJECT-TYPE
-    SYNTAX      Counter32
-    MAX-ACCESS  read-only
-    STATUS      obsolete
-    DESCRIPTION
-            "The total number of SNMP Get-Response PDUs which
-            have been accepted and processed by the SNMP protocol
-            entity."
-    ::= { snmp 18 }
-
-snmpInTraps OBJECT-TYPE
-    SYNTAX      Counter32
-    MAX-ACCESS  read-only
-    STATUS      obsolete
-    DESCRIPTION
-            "The total number of SNMP Trap PDUs which have been
-            accepted and processed by the SNMP protocol entity."
-    ::= { snmp 19 }
-
-snmpOutTooBigs OBJECT-TYPE
-    SYNTAX      Counter32
-    MAX-ACCESS  read-only
-    STATUS      obsolete
-    DESCRIPTION
-            "The total number of SNMP PDUs which were generated
-            by the SNMP protocol entity and for which the value
-            of the error-status field was `tooBig.'"
-    ::= { snmp 20 }
-
-snmpOutNoSuchNames OBJECT-TYPE
-    SYNTAX      Counter32
-    MAX-ACCESS  read-only
-    STATUS      obsolete
-    DESCRIPTION
-            "The total number of SNMP PDUs which were generated
-            by the SNMP protocol entity and for which the value
-            of the error-status was `noSuchName'."
-    ::= { snmp 21 }
-
-snmpOutBadValues OBJECT-TYPE
-    SYNTAX      Counter32
-    MAX-ACCESS  read-only
-    STATUS      obsolete
-    DESCRIPTION
-            "The total number of SNMP PDUs which were generated
-            by the SNMP protocol entity and for which the value
-            of the error-status field was `badValue'."
-    ::= { snmp 22 }
-
-
-
--- { snmp 23 } is not used
-
-snmpOutGenErrs OBJECT-TYPE
-    SYNTAX      Counter32
-    MAX-ACCESS  read-only
-    STATUS      obsolete
-    DESCRIPTION
-            "The total number of SNMP PDUs which were generated
-            by the SNMP protocol entity and for which the value
-            of the error-status field was `genErr'."
-    ::= { snmp 24 }
-
-snmpOutGetRequests OBJECT-TYPE
-    SYNTAX      Counter32
-    MAX-ACCESS  read-only
-    STATUS      obsolete
-    DESCRIPTION
-            "The total number of SNMP Get-Request PDUs which
-            have been generated by the SNMP protocol entity."
-    ::= { snmp 25 }
-
-snmpOutGetNexts OBJECT-TYPE
-    SYNTAX      Counter32
-    MAX-ACCESS  read-only
-    STATUS      obsolete
-    DESCRIPTION
-            "The total number of SNMP Get-Next PDUs which have
-            been generated by the SNMP protocol entity."
-    ::= { snmp 26 }
-
-snmpOutSetRequests OBJECT-TYPE
-    SYNTAX      Counter32
-    MAX-ACCESS  read-only
-    STATUS      obsolete
-    DESCRIPTION
-            "The total number of SNMP Set-Request PDUs which
-            have been generated by the SNMP protocol entity."
-    ::= { snmp 27 }
-
-snmpOutGetResponses OBJECT-TYPE
-    SYNTAX      Counter32
-    MAX-ACCESS  read-only
-    STATUS      obsolete
-    DESCRIPTION
-            "The total number of SNMP Get-Response PDUs which
-            have been generated by the SNMP protocol entity."
-    ::= { snmp 28 }
-
-
-
-
-snmpOutTraps OBJECT-TYPE
-    SYNTAX      Counter32
-    MAX-ACCESS  read-only
-    STATUS      obsolete
-    DESCRIPTION
-            "The total number of SNMP Trap PDUs which have
-            been generated by the SNMP protocol entity."
-    ::= { snmp 29 }
-
-snmpObsoleteGroup OBJECT-GROUP
-    OBJECTS { snmpOutPkts, snmpInTooBigs, snmpInNoSuchNames,
-              snmpInBadValues, snmpInReadOnlys, snmpInGenErrs,
-              snmpInTotalReqVars, snmpInTotalSetVars,
-              snmpInGetRequests, snmpInGetNexts, snmpInSetRequests,
-              snmpInGetResponses, snmpInTraps, snmpOutTooBigs,
-              snmpOutNoSuchNames, snmpOutBadValues,
-              snmpOutGenErrs, snmpOutGetRequests, snmpOutGetNexts,
-              snmpOutSetRequests, snmpOutGetResponses, snmpOutTraps
-              }
-    STATUS  obsolete
-    DESCRIPTION
-            "A collection of objects from RFC 1213 made obsolete
-            by this MIB module."
-    ::= { snmpMIBGroups 10 }
-
-END
diff --git a/contrib/apps/LwipMibCompiler/Mibs/SNMPv2-SMI b/contrib/apps/LwipMibCompiler/Mibs/SNMPv2-SMI
deleted file mode 100644
index 2132646c..00000000
--- a/contrib/apps/LwipMibCompiler/Mibs/SNMPv2-SMI
+++ /dev/null
@@ -1,352 +0,0 @@
-SNMPv2-SMI DEFINITIONS ::= BEGIN
-
-
--- the path to the root
-
-org            OBJECT IDENTIFIER ::= { iso 3 }  --  "iso" = 1
-dod            OBJECT IDENTIFIER ::= { org 6 }
-internet       OBJECT IDENTIFIER ::= { dod 1 }
-
-directory      OBJECT IDENTIFIER ::= { internet 1 }
-
-mgmt           OBJECT IDENTIFIER ::= { internet 2 }
-mib-2          OBJECT IDENTIFIER ::= { mgmt 1 }
-transmission   OBJECT IDENTIFIER ::= { mib-2 10 }
-
-experimental   OBJECT IDENTIFIER ::= { internet 3 }
-
-private        OBJECT IDENTIFIER ::= { internet 4 }
-enterprises    OBJECT IDENTIFIER ::= { private 1 }
-
-security       OBJECT IDENTIFIER ::= { internet 5 }
-
-snmpV2         OBJECT IDENTIFIER ::= { internet 6 }
-
--- transport domains
-snmpDomains    OBJECT IDENTIFIER ::= { snmpV2 1 }
-
--- transport proxies
-snmpProxys     OBJECT IDENTIFIER ::= { snmpV2 2 }
-
--- module identities
-snmpModules    OBJECT IDENTIFIER ::= { snmpV2 3 }
-
--- Extended UTCTime, to allow dates with four-digit years
--- (Note that this definition of ExtUTCTime is not to be IMPORTed
---  by MIB modules.)
-ExtUTCTime ::= OCTET STRING(SIZE(11 | 13))
-    -- format is YYMMDDHHMMZ or YYYYMMDDHHMMZ
-    --   where: YY   - last two digits of year (only years
-    --                 between 1900-1999)
-    --          YYYY - last four digits of the year (any year)
-    --          MM   - month (01 through 12)
-    --          DD   - day of month (01 through 31)
-    --          HH   - hours (00 through 23)
-    --          MM   - minutes (00 through 59)
-    --          Z    - denotes GMT (the ASCII character Z)
-    --
-    -- For example, "9502192015Z" and "199502192015Z" represent
-    -- 8:15pm GMT on 19 February 1995. Years after 1999 must use
-    -- the four digit year format. Years 1900-1999 may use the
-    -- two or four digit format.
-
--- definitions for information modules
-
-MODULE-IDENTITY MACRO ::=
-BEGIN
-    TYPE NOTATION ::=
-                  "LAST-UPDATED" value(Update ExtUTCTime)
-                  "ORGANIZATION" Text
-                  "CONTACT-INFO" Text
-                  "DESCRIPTION" Text
-                  RevisionPart
-
-    VALUE NOTATION ::=
-                  value(VALUE OBJECT IDENTIFIER)
-
-    RevisionPart ::=
-                  Revisions
-                | empty
-    Revisions ::=
-                  Revision
-                | Revisions Revision
-    Revision ::=
-                  "REVISION" value(Update ExtUTCTime)
-                  "DESCRIPTION" Text
-
-    -- a character string as defined in section 3.1.1
-    Text ::= value(IA5String)
-END
-
-
-OBJECT-IDENTITY MACRO ::=
-BEGIN
-    TYPE NOTATION ::=
-                  "STATUS" Status
-                  "DESCRIPTION" Text
-                  ReferPart
-
-    VALUE NOTATION ::=
-                  value(VALUE OBJECT IDENTIFIER)
-
-    Status ::=
-                  "current"
-                | "deprecated"
-                | "obsolete"
-
-    ReferPart ::=
-                  "REFERENCE" Text
-                | empty
-
-    -- a character string as defined in section 3.1.1
-    Text ::= value(IA5String)
-END
-
-
--- names of objects
--- (Note that these definitions of ObjectName and NotificationName
---  are not to be IMPORTed by MIB modules.)
-
-ObjectName ::=
-    OBJECT IDENTIFIER
-
-NotificationName ::=
-    OBJECT IDENTIFIER
-
--- syntax of objects
-
--- the "base types" defined here are:
---   3 built-in ASN.1 types: INTEGER, OCTET STRING, OBJECT IDENTIFIER
---   8 application-defined types: Integer32, IpAddress, Counter32,
---              Gauge32, Unsigned32, TimeTicks, Opaque, and Counter64
-
-ObjectSyntax ::=
-    CHOICE {
-        simple
-            SimpleSyntax,
-
-          -- note that SEQUENCEs for conceptual tables and
-          -- rows are not mentioned here...
-
-        application-wide
-            ApplicationSyntax
-    }
-
--- built-in ASN.1 types
-
-SimpleSyntax ::=
-    CHOICE {
-        -- INTEGERs with a more restrictive range
-        -- may also be used
-        integer-value               -- includes Integer32
-            INTEGER (-2147483648..2147483647),
-
-        -- OCTET STRINGs with a more restrictive size
-        -- may also be used
-        string-value
-            OCTET STRING (SIZE (0..65535)),
-
-        objectID-value
-            OBJECT IDENTIFIER
-    }
-
--- indistinguishable from INTEGER, but never needs more than
--- 32-bits for a two's complement representation
-Integer32 ::=
-        INTEGER (-2147483648..2147483647)
-
-
--- application-wide types
-
-ApplicationSyntax ::=
-    CHOICE {
-        ipAddress-value
-            IpAddress,
-
-        counter-value
-            Counter32,
-
-        timeticks-value
-            TimeTicks,
-
-        arbitrary-value
-            Opaque,
-
-        big-counter-value
-            Counter64,
-
-        unsigned-integer-value  -- includes Gauge32
-            Unsigned32
-    }
-
--- in network-byte order
--- (this is a tagged type for historical reasons)
-IpAddress ::=
-    [APPLICATION 0]
-        IMPLICIT OCTET STRING (SIZE (4))
-
--- this wraps
-Counter32 ::=
-    [APPLICATION 1]
-        IMPLICIT INTEGER (0..4294967295)
-
--- this doesn't wrap
-Gauge32 ::=
-    [APPLICATION 2]
-        IMPLICIT INTEGER (0..4294967295)
-
--- an unsigned 32-bit quantity
--- indistinguishable from Gauge32
-Unsigned32 ::=
-    [APPLICATION 2]
-        IMPLICIT INTEGER (0..4294967295)
-
--- hundredths of seconds since an epoch
-TimeTicks ::=
-    [APPLICATION 3]
-        IMPLICIT INTEGER (0..4294967295)
-
--- for backward-compatibility only
-Opaque ::=
-    [APPLICATION 4]
-        IMPLICIT OCTET STRING
-
--- for counters that wrap in less than one hour with only 32 bits
-Counter64 ::=
-    [APPLICATION 6]
-        IMPLICIT INTEGER (0..18446744073709551615)
-
-
--- definition for objects
-
-OBJECT-TYPE MACRO ::=
-BEGIN
-    TYPE NOTATION ::=
-                  "SYNTAX" Syntax
-                  UnitsPart
-                  "MAX-ACCESS" Access
-                  "STATUS" Status
-                  "DESCRIPTION" Text
-                  ReferPart
-                  IndexPart
-                  DefValPart
-
-    VALUE NOTATION ::=
-                  value(VALUE ObjectName)
-
-    Syntax ::=   -- Must be one of the following:
-                       -- a base type (or its refinement),
-                       -- a textual convention (or its refinement), or
-                       -- a BITS pseudo-type
-                   type
-                | "BITS" "{" NamedBits "}"
-
-    NamedBits ::= NamedBit
-                | NamedBits "," NamedBit
-
-    NamedBit ::=  identifier "(" number ")" -- number is nonnegative
-
-    UnitsPart ::=
-                  "UNITS" Text
-                | empty
-
-    Access ::=
-                  "not-accessible"
-                | "accessible-for-notify"
-                | "read-only"
-                | "read-write"
-                | "read-create"
-
-    Status ::=
-                  "current"
-                | "deprecated"
-                | "obsolete"
-
-    ReferPart ::=
-                  "REFERENCE" Text
-                | empty
-
-    IndexPart ::=
-                  "INDEX"    "{" IndexTypes "}"
-                | "AUGMENTS" "{" Entry      "}"
-                | empty
-    IndexTypes ::=
-                  IndexType
-                | IndexTypes "," IndexType
-    IndexType ::=
-                  "IMPLIED" Index
-                | Index
-    Index ::=
-                    -- use the SYNTAX value of the
-                    -- correspondent OBJECT-TYPE invocation
-                  value(ObjectName)
-    Entry ::=
-                    -- use the INDEX value of the
-                    -- correspondent OBJECT-TYPE invocation
-                  value(ObjectName)
-
-    DefValPart ::= "DEFVAL" "{" Defvalue "}"
-                | empty
-
-    Defvalue ::=  -- must be valid for the type specified in
-                  -- SYNTAX clause of same OBJECT-TYPE macro
-                  value(ObjectSyntax)
-                | "{" BitsValue "}"
-
-    BitsValue ::= BitNames
-                | empty
-
-    BitNames ::=  BitName
-                | BitNames "," BitName
-
-    BitName ::= identifier
-
-    -- a character string as defined in section 3.1.1
-    Text ::= value(IA5String)
-END
-
-
--- definitions for notifications
-
-NOTIFICATION-TYPE MACRO ::=
-BEGIN
-    TYPE NOTATION ::=
-                  ObjectsPart
-                  "STATUS" Status
-                  "DESCRIPTION" Text
-                  ReferPart
-
-    VALUE NOTATION ::=
-                  value(VALUE NotificationName)
-
-    ObjectsPart ::=
-                  "OBJECTS" "{" Objects "}"
-                | empty
-    Objects ::=
-                  Object
-                | Objects "," Object
-    Object ::=
-                  value(ObjectName)
-
-    Status ::=
-                  "current"
-                | "deprecated"
-                | "obsolete"
-
-    ReferPart ::=
-                  "REFERENCE" Text
-                | empty
-
-    -- a character string as defined in section 3.1.1
-    Text ::= value(IA5String)
-END
-
--- definitions of administrative identifiers
-
-zeroDotZero    OBJECT-IDENTITY
-    STATUS     current
-    DESCRIPTION
-            "A value used for null identifiers."
-    ::= { 0 0 }
-
-END
diff --git a/contrib/apps/LwipMibCompiler/Mibs/SNMPv2-TC b/contrib/apps/LwipMibCompiler/Mibs/SNMPv2-TC
deleted file mode 100644
index a68f9690..00000000
--- a/contrib/apps/LwipMibCompiler/Mibs/SNMPv2-TC
+++ /dev/null
@@ -1,786 +0,0 @@
-SNMPv2-TC DEFINITIONS ::= BEGIN
-
-IMPORTS
-    TimeTicks         FROM SNMPv2-SMI;
-
-
--- definition of textual conventions
-
-TEXTUAL-CONVENTION MACRO ::=
-BEGIN
-    TYPE NOTATION ::=
-                  DisplayPart
-                  "STATUS" Status
-                  "DESCRIPTION" Text
-                  ReferPart
-                  "SYNTAX" Syntax
-
-    VALUE NOTATION ::=
-                   value(VALUE Syntax)      -- adapted ASN.1
-
-    DisplayPart ::=
-                  "DISPLAY-HINT" Text
-                | empty
-
-    Status ::=
-                  "current"
-                | "deprecated"
-                | "obsolete"
-
-    ReferPart ::=
-                  "REFERENCE" Text
-                | empty
-
-    -- a character string as defined in [2]
-    Text ::= value(IA5String)
-
-    Syntax ::=   -- Must be one of the following:
-                       -- a base type (or its refinement), or
-                       -- a BITS pseudo-type
-                  type
-                | "BITS" "{" NamedBits "}"
-
-    NamedBits ::= NamedBit
-                | NamedBits "," NamedBit
-
-    NamedBit ::=  identifier "(" number ")" -- number is nonnegative
-
-END
-
-
-
-
-DisplayString ::= TEXTUAL-CONVENTION
-    DISPLAY-HINT "255a"
-    STATUS       current
-    DESCRIPTION
-            "Represents textual information taken from the NVT ASCII
-            character set, as defined in pages 4, 10-11 of RFC 854.
-
-            To summarize RFC 854, the NVT ASCII repertoire specifies:
-
-              - the use of character codes 0-127 (decimal)
-
-              - the graphics characters (32-126) are interpreted as
-                US ASCII
-
-              - NUL, LF, CR, BEL, BS, HT, VT and FF have the special
-                meanings specified in RFC 854
-
-              - the other 25 codes have no standard interpretation
-
-              - the sequence 'CR LF' means newline
-
-              - the sequence 'CR NUL' means carriage-return
-
-              - an 'LF' not preceded by a 'CR' means moving to the
-                same column on the next line.
-
-              - the sequence 'CR x' for any x other than LF or NUL is
-                illegal.  (Note that this also means that a string may
-                end with either 'CR LF' or 'CR NUL', but not with CR.)
-
-            Any object defined using this syntax may not exceed 255
-            characters in length."
-    SYNTAX       OCTET STRING (SIZE (0..255))
-
-PhysAddress ::= TEXTUAL-CONVENTION
-    DISPLAY-HINT "1x:"
-    STATUS       current
-    DESCRIPTION
-            "Represents media- or physical-level addresses."
-    SYNTAX       OCTET STRING
-
-
-MacAddress ::= TEXTUAL-CONVENTION
-    DISPLAY-HINT "1x:"
-    STATUS       current
-    DESCRIPTION
-            "Represents an 802 MAC address represented in the
-            `canonical' order defined by IEEE 802.1a, i.e., as if it
-            were transmitted least significant bit first, even though
-            802.5 (in contrast to other 802.x protocols) requires MAC
-            addresses to be transmitted most significant bit first."
-    SYNTAX       OCTET STRING (SIZE (6))
-
-TruthValue ::= TEXTUAL-CONVENTION
-    STATUS       current
-    DESCRIPTION
-            "Represents a boolean value."
-    SYNTAX       INTEGER { true(1), false(2) }
-
-TestAndIncr ::= TEXTUAL-CONVENTION
-    STATUS       current
-    DESCRIPTION
-            "Represents integer-valued information used for atomic
-            operations.  When the management protocol is used to specify
-            that an object instance having this syntax is to be
-            modified, the new value supplied via the management protocol
-            must precisely match the value presently held by the
-            instance.  If not, the management protocol set operation
-            fails with an error of `inconsistentValue'.  Otherwise, if
-            the current value is the maximum value of 2^31-1 (2147483647
-            decimal), then the value held by the instance is wrapped to
-            zero; otherwise, the value held by the instance is
-            incremented by one.  (Note that regardless of whether the
-            management protocol set operation succeeds, the variable-
-            binding in the request and response PDUs are identical.)
-
-            The value of the ACCESS clause for objects having this
-            syntax is either `read-write' or `read-create'.  When an
-            instance of a columnar object having this syntax is created,
-            any value may be supplied via the management protocol.
-
-            When the network management portion of the system is re-
-            initialized, the value of every object instance having this
-            syntax must either be incremented from its value prior to
-            the re-initialization, or (if the value prior to the re-
-            initialization is unknown) be set to a pseudo-randomly
-            generated value."
-    SYNTAX       INTEGER (0..2147483647)
-
-AutonomousType ::= TEXTUAL-CONVENTION
-    STATUS       current
-    DESCRIPTION
-            "Represents an independently extensible type identification
-            value.  It may, for example, indicate a particular sub-tree
-            with further MIB definitions, or define a particular type of
-            protocol or hardware."
-    SYNTAX       OBJECT IDENTIFIER
-
-
-InstancePointer ::= TEXTUAL-CONVENTION
-    STATUS       obsolete
-    DESCRIPTION
-            "A pointer to either a specific instance of a MIB object or
-            a conceptual row of a MIB table in the managed device.  In
-            the latter case, by convention, it is the name of the
-            particular instance of the first accessible columnar object
-            in the conceptual row.
-
-            The two uses of this textual convention are replaced by
-            VariablePointer and RowPointer, respectively."
-    SYNTAX       OBJECT IDENTIFIER
-
-
-VariablePointer ::= TEXTUAL-CONVENTION
-    STATUS       current
-    DESCRIPTION
-            "A pointer to a specific object instance.  For example,
-            sysContact.0 or ifInOctets.3."
-    SYNTAX       OBJECT IDENTIFIER
-
-
-RowPointer ::= TEXTUAL-CONVENTION
-    STATUS       current
-    DESCRIPTION
-            "Represents a pointer to a conceptual row.  The value is the
-            name of the instance of the first accessible columnar object
-            in the conceptual row.
-
-            For example, ifIndex.3 would point to the 3rd row in the
-            ifTable (note that if ifIndex were not-accessible, then
-            ifDescr.3 would be used instead)."
-    SYNTAX       OBJECT IDENTIFIER
-
-RowStatus ::= TEXTUAL-CONVENTION
-    STATUS       current
-    DESCRIPTION
-            "The RowStatus textual convention is used to manage the
-            creation and deletion of conceptual rows, and is used as the
-            value of the SYNTAX clause for the status column of a
-            conceptual row (as described in Section 7.7.1 of [2].)
-            The status column has six defined values:
-
-                 - `active', which indicates that the conceptual row is
-                 available for use by the managed device;
-
-                 - `notInService', which indicates that the conceptual
-                 row exists in the agent, but is unavailable for use by
-                 the managed device (see NOTE below); 'notInService' has
-                 no implication regarding the internal consistency of
-                 the row, availability of resources, or consistency with
-                 the current state of the managed device;
-
-                 - `notReady', which indicates that the conceptual row
-                 exists in the agent, but is missing information
-                 necessary in order to be available for use by the
-                 managed device (i.e., one or more required columns in
-                 the conceptual row have not been instanciated);
-
-                 - `createAndGo', which is supplied by a management
-                 station wishing to create a new instance of a
-                 conceptual row and to have its status automatically set
-                 to active, making it available for use by the managed
-                 device;
-
-                 - `createAndWait', which is supplied by a management
-                 station wishing to create a new instance of a
-                 conceptual row (but not make it available for use by
-                 the managed device); and,
-
-                 - `destroy', which is supplied by a management station
-                 wishing to delete all of the instances associated with
-                 an existing conceptual row.
-
-            Whereas five of the six values (all except `notReady') may
-            be specified in a management protocol set operation, only
-            three values will be returned in response to a management
-            protocol retrieval operation:  `notReady', `notInService' or
-            `active'.  That is, when queried, an existing conceptual row
-            has only three states:  it is either available for use by
-            the managed device (the status column has value `active');
-            it is not available for use by the managed device, though
-            the agent has sufficient information to attempt to make it
-            so (the status column has value `notInService'); or, it is
-            not available for use by the managed device, and an attempt
-            to make it so would fail because the agent has insufficient
-            information (the state column has value `notReady').
-
-                                     NOTE WELL
-
-                 This textual convention may be used for a MIB table,
-                 irrespective of whether the values of that table's
-                 conceptual rows are able to be modified while it is
-                 active, or whether its conceptual rows must be taken
-                 out of service in order to be modified.  That is, it is
-                 the responsibility of the DESCRIPTION clause of the
-                 status column to specify whether the status column must
-                 not be `active' in order for the value of some other
-                 column of the same conceptual row to be modified.  If
-                 such a specification is made, affected columns may be
-                 changed by an SNMP set PDU if the RowStatus would not
-                 be equal to `active' either immediately before or after
-                 processing the PDU.  In other words, if the PDU also
-                 contained a varbind that would change the RowStatus
-                 value, the column in question may be changed if the
-                 RowStatus was not equal to `active' as the PDU was
-                 received, or if the varbind sets the status to a value
-                 other than 'active'.
-
-
-            Also note that whenever any elements of a row exist, the
-            RowStatus column must also exist.
-
-            To summarize the effect of having a conceptual row with a
-            status column having a SYNTAX clause value of RowStatus,
-            consider the following state diagram:
-
-
-                                         STATE
-              +--------------+-----------+-------------+-------------
-              |      A       |     B     |      C      |      D
-              |              |status col.|status column|
-              |status column |    is     |      is     |status column
-    ACTION    |does not exist|  notReady | notInService|  is active
---------------+--------------+-----------+-------------+-------------
-set status    |noError    ->D|inconsist- |inconsistent-|inconsistent-
-column to     |       or     |   entValue|        Value|        Value
-createAndGo   |inconsistent- |           |             |
-              |         Value|           |             |
---------------+--------------+-----------+-------------+-------------
-set status    |noError  see 1|inconsist- |inconsistent-|inconsistent-
-column to     |       or     |   entValue|        Value|        Value
-createAndWait |wrongValue    |           |             |
---------------+--------------+-----------+-------------+-------------
-set status    |inconsistent- |inconsist- |noError      |noError
-column to     |         Value|   entValue|             |
-active        |              |           |             |
-              |              |     or    |             |
-              |              |           |             |
-              |              |see 2   ->D|see 8     ->D|          ->D
---------------+--------------+-----------+-------------+-------------
-set status    |inconsistent- |inconsist- |noError      |noError   ->C
-column to     |         Value|   entValue|             |
-notInService  |              |           |             |
-              |              |     or    |             |      or
-              |              |           |             |
-              |              |see 3   ->C|          ->C|see 6
---------------+--------------+-----------+-------------+-------------
-set status    |noError       |noError    |noError      |noError   ->A
-column to     |              |           |             |      or
-destroy       |           ->A|        ->A|          ->A|see 7
---------------+--------------+-----------+-------------+-------------
-set any other |see 4         |noError    |noError      |see 5
-column to some|              |           |             |
-value         |              |      see 1|          ->C|          ->D
---------------+--------------+-----------+-------------+-------------
-
-            (1) goto B or C, depending on information available to the
-            agent.
-
-            (2) if other variable bindings included in the same PDU,
-            provide values for all columns which are missing but
-            required, and all columns have acceptable values, then
-            return noError and goto D.
-
-            (3) if other variable bindings included in the same PDU,
-            provide legal values for all columns which are missing but
-            required, then return noError and goto C.
-
-            (4) at the discretion of the agent, the return value may be
-            either:
-
-                 inconsistentName:  because the agent does not choose to
-                 create such an instance when the corresponding
-                 RowStatus instance does not exist, or
-
-                 inconsistentValue:  if the supplied value is
-                 inconsistent with the state of some other MIB object's
-                 value, or
-
-                 noError: because the agent chooses to create the
-                 instance.
-
-            If noError is returned, then the instance of the status
-            column must also be created, and the new state is B or C,
-            depending on the information available to the agent.  If
-            inconsistentName or inconsistentValue is returned, the row
-            remains in state A.
-
-            (5) depending on the MIB definition for the column/table,
-            either noError or inconsistentValue may be returned.
-
-            (6) the return value can indicate one of the following
-            errors:
-
-                 wrongValue: because the agent does not support
-                 notInService (e.g., an agent which does not support
-                 createAndWait), or
-
-                 inconsistentValue: because the agent is unable to take
-                 the row out of service at this time, perhaps because it
-                 is in use and cannot be de-activated.
-
-            (7) the return value can indicate the following error:
-
-                 inconsistentValue: because the agent is unable to
-                 remove the row at this time, perhaps because it is in
-                 use and cannot be de-activated.
-
-            (8) the transition to D can fail, e.g., if the values of the
-            conceptual row are inconsistent, then the error code would
-            be inconsistentValue.
-
-            NOTE: Other processing of (this and other varbinds of) the
-            set request may result in a response other than noError
-            being returned, e.g., wrongValue, noCreation, etc.
-
-
-                              Conceptual Row Creation
-
-            There are four potential interactions when creating a
-            conceptual row:  selecting an instance-identifier which is
-            not in use; creating the conceptual row; initializing any
-            objects for which the agent does not supply a default; and,
-            making the conceptual row available for use by the managed
-            device.
-
-            Interaction 1: Selecting an Instance-Identifier
-
-            The algorithm used to select an instance-identifier varies
-            for each conceptual row.  In some cases, the instance-
-            identifier is semantically significant, e.g., the
-            destination address of a route, and a management station
-            selects the instance-identifier according to the semantics.
-
-            In other cases, the instance-identifier is used solely to
-            distinguish conceptual rows, and a management station
-            without specific knowledge of the conceptual row might
-            examine the instances present in order to determine an
-            unused instance-identifier.  (This approach may be used, but
-            it is often highly sub-optimal; however, it is also a
-            questionable practice for a naive management station to
-            attempt conceptual row creation.)
-
-            Alternately, the MIB module which defines the conceptual row
-            might provide one or more objects which provide assistance
-            in determining an unused instance-identifier.  For example,
-            if the conceptual row is indexed by an integer-value, then
-            an object having an integer-valued SYNTAX clause might be
-            defined for such a purpose, allowing a management station to
-            issue a management protocol retrieval operation.  In order
-            to avoid unnecessary collisions between competing management
-            stations, `adjacent' retrievals of this object should be
-            different.
-
-            Finally, the management station could select a pseudo-random
-            number to use as the index.  In the event that this index
-            was already in use and an inconsistentValue was returned in
-            response to the management protocol set operation, the
-            management station should simply select a new pseudo-random
-            number and retry the operation.
-
-            A MIB designer should choose between the two latter
-            algorithms based on the size of the table (and therefore the
-            efficiency of each algorithm).  For tables in which a large
-            number of entries are expected, it is recommended that a MIB
-            object be defined that returns an acceptable index for
-            creation.  For tables with small numbers of entries, it is
-            recommended that the latter pseudo-random index mechanism be
-            used.
-
-            Interaction 2: Creating the Conceptual Row
-
-            Once an unused instance-identifier has been selected, the
-            management station determines if it wishes to create and
-            activate the conceptual row in one transaction or in a
-            negotiated set of interactions.
-
-            Interaction 2a: Creating and Activating the Conceptual Row
-
-            The management station must first determine the column
-            requirements, i.e., it must determine those columns for
-            which it must or must not provide values.  Depending on the
-            complexity of the table and the management station's
-            knowledge of the agent's capabilities, this determination
-            can be made locally by the management station.  Alternately,
-            the management station issues a management protocol get
-            operation to examine all columns in the conceptual row that
-            it wishes to create.  In response, for each column, there
-            are three possible outcomes:
-
-                 - a value is returned, indicating that some other
-                 management station has already created this conceptual
-                 row.  We return to interaction 1.
-
-                 - the exception `noSuchInstance' is returned,
-                 indicating that the agent implements the object-type
-                 associated with this column, and that this column in at
-                 least one conceptual row would be accessible in the MIB
-                 view used by the retrieval were it to exist. For those
-                 columns to which the agent provides read-create access,
-                 the `noSuchInstance' exception tells the management
-                 station that it should supply a value for this column
-                 when the conceptual row is to be created.
-
-                 - the exception `noSuchObject' is returned, indicating
-                 that the agent does not implement the object-type
-                 associated with this column or that there is no
-                 conceptual row for which this column would be
-                 accessible in the MIB view used by the retrieval.  As
-                 such, the management station can not issue any
-                 management protocol set operations to create an
-                 instance of this column.
-
-            Once the column requirements have been determined, a
-            management protocol set operation is accordingly issued.
-            This operation also sets the new instance of the status
-            column to `createAndGo'.
-
-            When the agent processes the set operation, it verifies that
-            it has sufficient information to make the conceptual row
-            available for use by the managed device.  The information
-            available to the agent is provided by two sources:  the
-            management protocol set operation which creates the
-            conceptual row, and, implementation-specific defaults
-            supplied by the agent (note that an agent must provide
-            implementation-specific defaults for at least those objects
-            which it implements as read-only).  If there is sufficient
-            information available, then the conceptual row is created, a
-            `noError' response is returned, the status column is set to
-            `active', and no further interactions are necessary (i.e.,
-            interactions 3 and 4 are skipped).  If there is insufficient
-            information, then the conceptual row is not created, and the
-            set operation fails with an error of `inconsistentValue'.
-            On this error, the management station can issue a management
-            protocol retrieval operation to determine if this was
-            because it failed to specify a value for a required column,
-            or, because the selected instance of the status column
-            already existed.  In the latter case, we return to
-            interaction 1.  In the former case, the management station
-            can re-issue the set operation with the additional
-            information, or begin interaction 2 again using
-            `createAndWait' in order to negotiate creation of the
-            conceptual row.
-
-                                     NOTE WELL
-
-                 Regardless of the method used to determine the column
-                 requirements, it is possible that the management
-                 station might deem a column necessary when, in fact,
-                 the agent will not allow that particular columnar
-                 instance to be created or written.  In this case, the
-                 management protocol set operation will fail with an
-                 error such as `noCreation' or `notWritable'.  In this
-                 case, the management station decides whether it needs
-                 to be able to set a value for that particular columnar
-                 instance.  If not, the management station re-issues the
-                 management protocol set operation, but without setting
-                 a value for that particular columnar instance;
-                 otherwise, the management station aborts the row
-                 creation algorithm.
-
-            Interaction 2b: Negotiating the Creation of the Conceptual
-            Row
-
-            The management station issues a management protocol set
-            operation which sets the desired instance of the status
-            column to `createAndWait'.  If the agent is unwilling to
-            process a request of this sort, the set operation fails with
-            an error of `wrongValue'.  (As a consequence, such an agent
-            must be prepared to accept a single management protocol set
-            operation, i.e., interaction 2a above, containing all of the
-            columns indicated by its column requirements.)  Otherwise,
-            the conceptual row is created, a `noError' response is
-            returned, and the status column is immediately set to either
-            `notInService' or `notReady', depending on whether it has
-            sufficient information to (attempt to) make the conceptual
-            row available for use by the managed device.  If there is
-            sufficient information available, then the status column is
-            set to `notInService'; otherwise, if there is insufficient
-            information, then the status column is set to `notReady'.
-            Regardless, we proceed to interaction 3.
-
-            Interaction 3: Initializing non-defaulted Objects
-
-            The management station must now determine the column
-            requirements.  It issues a management protocol get operation
-            to examine all columns in the created conceptual row.  In
-            the response, for each column, there are three possible
-            outcomes:
-
-                 - a value is returned, indicating that the agent
-                 implements the object-type associated with this column
-                 and had sufficient information to provide a value.  For
-                 those columns to which the agent provides read-create
-                 access (and for which the agent allows their values to
-                 be changed after their creation), a value return tells
-                 the management station that it may issue additional
-                 management protocol set operations, if it desires, in
-                 order to change the value associated with this column.
-
-                 - the exception `noSuchInstance' is returned,
-                 indicating that the agent implements the object-type
-                 associated with this column, and that this column in at
-                 least one conceptual row would be accessible in the MIB
-                 view used by the retrieval were it to exist. However,
-                 the agent does not have sufficient information to
-                 provide a value, and until a value is provided, the
-                 conceptual row may not be made available for use by the
-                 managed device.  For those columns to which the agent
-                 provides read-create access, the `noSuchInstance'
-                 exception tells the management station that it must
-                 issue additional management protocol set operations, in
-                 order to provide a value associated with this column.
-
-                 - the exception `noSuchObject' is returned, indicating
-                 that the agent does not implement the object-type
-                 associated with this column or that there is no
-                 conceptual row for which this column would be
-                 accessible in the MIB view used by the retrieval.  As
-                 such, the management station can not issue any
-                 management protocol set operations to create an
-                 instance of this column.
-
-            If the value associated with the status column is
-            `notReady', then the management station must first deal with
-            all `noSuchInstance' columns, if any.  Having done so, the
-            value of the status column becomes `notInService', and we
-            proceed to interaction 4.
-
-            Interaction 4: Making the Conceptual Row Available
-
-            Once the management station is satisfied with the values
-            associated with the columns of the conceptual row, it issues
-            a management protocol set operation to set the status column
-            to `active'.  If the agent has sufficient information to
-            make the conceptual row available for use by the managed
-            device, the management protocol set operation succeeds (a
-            `noError' response is returned).  Otherwise, the management
-            protocol set operation fails with an error of
-            `inconsistentValue'.
-
-                                     NOTE WELL
-
-                 A conceptual row having a status column with value
-                 `notInService' or `notReady' is unavailable to the
-                 managed device.  As such, it is possible for the
-                 managed device to create its own instances during the
-                 time between the management protocol set operation
-                 which sets the status column to `createAndWait' and the
-                 management protocol set operation which sets the status
-                 column to `active'.  In this case, when the management
-                 protocol set operation is issued to set the status
-                 column to `active', the values held in the agent
-                 supersede those used by the managed device.
-
-            If the management station is prevented from setting the
-            status column to `active' (e.g., due to management station
-            or network failure) the conceptual row will be left in the
-            `notInService' or `notReady' state, consuming resources
-            indefinitely.  The agent must detect conceptual rows that
-            have been in either state for an abnormally long period of
-            time and remove them.  It is the responsibility of the
-            DESCRIPTION clause of the status column to indicate what an
-            abnormally long period of time would be.  This period of
-            time should be long enough to allow for human response time
-            (including `think time') between the creation of the
-            conceptual row and the setting of the status to `active'.
-            In the absence of such information in the DESCRIPTION
-            clause, it is suggested that this period be approximately 5
-            minutes in length.  This removal action applies not only to
-            newly-created rows, but also to previously active rows which
-            are set to, and left in, the notInService state for a
-            prolonged period exceeding that which is considered normal
-            for such a conceptual row.
-
-                             Conceptual Row Suspension
-
-            When a conceptual row is `active', the management station
-            may issue a management protocol set operation which sets the
-            instance of the status column to `notInService'.  If the
-            agent is unwilling to do so, the set operation fails with an
-            error of `wrongValue' or `inconsistentValue'.  Otherwise,
-            the conceptual row is taken out of service, and a `noError'
-            response is returned.  It is the responsibility of the
-            DESCRIPTION clause of the status column to indicate under
-            what circumstances the status column should be taken out of
-            service (e.g., in order for the value of some other column
-            of the same conceptual row to be modified).
-
-
-                              Conceptual Row Deletion
-
-            For deletion of conceptual rows, a management protocol set
-            operation is issued which sets the instance of the status
-            column to `destroy'.  This request may be made regardless of
-            the current value of the status column (e.g., it is possible
-            to delete conceptual rows which are either `notReady',
-            `notInService' or `active'.)  If the operation succeeds,
-            then all instances associated with the conceptual row are
-            immediately removed."
-    SYNTAX       INTEGER {
-                     -- the following two values are states:
-                     -- these values may be read or written
-                     active(1),
-                     notInService(2),
-
-                     -- the following value is a state:
-                     -- this value may be read, but not written
-                     notReady(3),
-
-                     -- the following three values are
-                     -- actions: these values may be written,
-                     --   but are never read
-                     createAndGo(4),
-                     createAndWait(5),
-                     destroy(6)
-                 }
-
-TimeStamp ::= TEXTUAL-CONVENTION
-    STATUS       current
-    DESCRIPTION
-            "The value of the sysUpTime object at which a specific
-            occurrence happened.  The specific occurrence must be
-            defined in the description of any object defined using this
-            type.
-
-            If sysUpTime is reset to zero as a result of a re-
-            initialization of the network management (sub)system, then
-            the values of all TimeStamp objects are also reset.
-            However, after approximately 497 days without a re-
-            initialization, the sysUpTime object will reach 2^^32-1 and
-            then increment around to zero; in this case, existing values
-            of TimeStamp objects do not change.  This can lead to
-            ambiguities in the value of TimeStamp objects."
-    SYNTAX       TimeTicks
-
-
-TimeInterval ::= TEXTUAL-CONVENTION
-    STATUS       current
-    DESCRIPTION
-            "A period of time, measured in units of 0.01 seconds."
-    SYNTAX       INTEGER (0..2147483647)
-
-DateAndTime ::= TEXTUAL-CONVENTION
-    DISPLAY-HINT "2d-1d-1d,1d:1d:1d.1d,1a1d:1d"
-    STATUS       current
-    DESCRIPTION
-            "A date-time specification.
-
-            field  octets  contents                  range
-            -----  ------  --------                  -----
-              1      1-2   year*                     0..65536
-              2       3    month                     1..12
-              3       4    day                       1..31
-              4       5    hour                      0..23
-              5       6    minutes                   0..59
-              6       7    seconds                   0..60
-                           (use 60 for leap-second)
-              7       8    deci-seconds              0..9
-              8       9    direction from UTC        '+' / '-'
-              9      10    hours from UTC*           0..13
-             10      11    minutes from UTC          0..59
-
-            * Notes:
-            - the value of year is in network-byte order
-            - daylight saving time in New Zealand is +13
-
-            For example, Tuesday May 26, 1992 at 1:30:15 PM EDT would be
-            displayed as:
-
-                             1992-5-26,13:30:15.0,-4:0
-
-            Note that if only local time is known, then timezone
-            information (fields 8-10) is not present."
-    SYNTAX       OCTET STRING (SIZE (8 | 11))
-
-
-StorageType ::= TEXTUAL-CONVENTION
-    STATUS       current
-    DESCRIPTION
-            "Describes the memory realization of a conceptual row.  A
-            row which is volatile(2) is lost upon reboot.  A row which
-            is either nonVolatile(3), permanent(4) or readOnly(5), is
-            backed up by stable storage.  A row which is permanent(4)
-            can be changed but not deleted.  A row which is readOnly(5)
-            cannot be changed nor deleted.
-
-            If the value of an object with this syntax is either
-            permanent(4) or readOnly(5), it cannot be written.
-            Conversely, if the value is either other(1), volatile(2) or
-            nonVolatile(3), it cannot be modified to be permanent(4) or
-            readOnly(5).  (All illegal modifications result in a
-            'wrongValue' error.)
-
-            Every usage of this textual convention is required to
-            specify the columnar objects which a permanent(4) row must
-            at a minimum allow to be writable."
-    SYNTAX       INTEGER {
-                     other(1),       -- eh?
-                     volatile(2),    -- e.g., in RAM
-                     nonVolatile(3), -- e.g., in NVRAM
-                     permanent(4),   -- e.g., partially in ROM
-                     readOnly(5)     -- e.g., completely in ROM
-                 }
-
-TDomain ::= TEXTUAL-CONVENTION
-    STATUS       current
-    DESCRIPTION
-          "Denotes a kind of transport service.
-
-          Some possible values, such as snmpUDPDomain, are defined in
-          the SNMPv2-TM MIB module.  Other possible values are defined
-          in other MIB modules."
-    REFERENCE    "The SNMPv2-TM MIB module is defined in RFC 1906."
-    SYNTAX       OBJECT IDENTIFIER
-
-
-TAddress ::= TEXTUAL-CONVENTION
-    STATUS       current
-    DESCRIPTION
-          "Denotes a transport service address.
-
-          A TAddress value is always interpreted within the context of a
-          TDomain value.  Thus, each definition of a TDomain value must
-          be accompanied by a definition of a textual convention for use
-          with that TDomain.  Some possible textual conventions, such as
-          SnmpUDPAddress for snmpUDPDomain, are defined in the SNMPv2-TM
-          MIB module.  Other possible textual conventions are defined in
-          other MIB modules."
-    REFERENCE    "The SNMPv2-TM MIB module is defined in RFC 1906."
-    SYNTAX       OCTET STRING (SIZE (1..255))
-
-
-END
diff --git a/contrib/apps/LwipMibCompiler/Mibs/SNMPv2-TM b/contrib/apps/LwipMibCompiler/Mibs/SNMPv2-TM
deleted file mode 100644
index dadbc4a8..00000000
--- a/contrib/apps/LwipMibCompiler/Mibs/SNMPv2-TM
+++ /dev/null
@@ -1,194 +0,0 @@
-SNMPv2-TM DEFINITIONS ::= BEGIN
-
-IMPORTS
-    MODULE-IDENTITY, OBJECT-IDENTITY,
-    snmpModules, snmpDomains, snmpProxys
-        FROM SNMPv2-SMI
-    TEXTUAL-CONVENTION
-        FROM SNMPv2-TC;
-
-snmpv2tm MODULE-IDENTITY
-    LAST-UPDATED "200210160000Z"
-    ORGANIZATION "IETF SNMPv3 Working Group"
-    CONTACT-INFO
-            "WG-EMail:   snmpv3@lists.tislabs.com
-             Subscribe:  snmpv3-request@lists.tislabs.com
-
-             Co-Chair:   Russ Mundy
-                         Network Associates Laboratories
-             postal:     15204 Omega Drive, Suite 300
-                         Rockville, MD 20850-4601
-                         USA
-             EMail:      mundy@tislabs.com
-             phone:      +1 301 947-7107
-
-
-
-             Co-Chair:   David Harrington
-                         Enterasys Networks
-             postal:     35 Industrial Way
-                         P. O. Box 5005
-                         Rochester, NH 03866-5005
-                         USA
-             EMail:      dbh@enterasys.com
-             phone:      +1 603 337-2614
-
-             Editor:     Randy Presuhn
-                         BMC Software, Inc.
-             postal:     2141 North First Street
-                         San Jose, CA 95131
-                         USA
-             EMail:      randy_presuhn@bmc.com
-             phone:      +1 408 546-1006"
-    DESCRIPTION
-            "The MIB module for SNMP transport mappings.
-
-             Copyright (C) The Internet Society (2002). This
-             version of this MIB module is part of RFC 3417;
-             see the RFC itself for full legal notices.
-            "
-    REVISION     "200210160000Z"
-    DESCRIPTION
-            "Clarifications, published as RFC 3417."
-    REVISION    "199601010000Z"
-    DESCRIPTION
-            "Clarifications, published as RFC 1906."
-    REVISION    "199304010000Z"
-    DESCRIPTION
-            "The initial version, published as RFC 1449."
-    ::= { snmpModules 19 }
-
--- SNMP over UDP over IPv4
-
-snmpUDPDomain  OBJECT-IDENTITY
-    STATUS     current
-    DESCRIPTION
-            "The SNMP over UDP over IPv4 transport domain.
-            The corresponding transport address is of type
-            SnmpUDPAddress."
-    ::= { snmpDomains 1 }
-
-
-
-
-
-
-
-
-SnmpUDPAddress ::= TEXTUAL-CONVENTION
-    DISPLAY-HINT "1d.1d.1d.1d/2d"
-    STATUS       current
-    DESCRIPTION
-            "Represents a UDP over IPv4 address:
-
-               octets   contents        encoding
-                1-4     IP-address      network-byte order
-                5-6     UDP-port        network-byte order
-            "
-    SYNTAX       OCTET STRING (SIZE (6))
-
--- SNMP over OSI
-
-snmpCLNSDomain OBJECT-IDENTITY
-    STATUS     current
-    DESCRIPTION
-            "The SNMP over CLNS transport domain.
-            The corresponding transport address is of type
-            SnmpOSIAddress."
-    ::= { snmpDomains 2 }
-
-snmpCONSDomain OBJECT-IDENTITY
-    STATUS     current
-    DESCRIPTION
-            "The SNMP over CONS transport domain.
-            The corresponding transport address is of type
-            SnmpOSIAddress."
-    ::= { snmpDomains 3 }
-
-SnmpOSIAddress ::= TEXTUAL-CONVENTION
-    DISPLAY-HINT "*1x:/1x:"
-    STATUS       current
-    DESCRIPTION
-            "Represents an OSI transport-address:
-
-          octets   contents           encoding
-             1     length of NSAP     'n' as an unsigned-integer
-                                         (either 0 or from 3 to 20)
-          2..(n+1) NSAP                concrete binary representation
-          (n+2)..m TSEL                string of (up to 64) octets
-            "
-    SYNTAX       OCTET STRING (SIZE (1 | 4..85))
-
-
-
-
-
-
-
-
--- SNMP over DDP
-
-snmpDDPDomain  OBJECT-IDENTITY
-    STATUS     current
-    DESCRIPTION
-            "The SNMP over DDP transport domain.  The corresponding
-            transport address is of type SnmpNBPAddress."
-    ::= { snmpDomains 4 }
-
-SnmpNBPAddress ::= TEXTUAL-CONVENTION
-    STATUS       current
-    DESCRIPTION
-            "Represents an NBP name:
-
-         octets        contents          encoding
-            1          length of object  'n' as an unsigned integer
-          2..(n+1)     object            string of (up to 32) octets
-           n+2         length of type    'p' as an unsigned integer
-      (n+3)..(n+2+p)   type              string of (up to 32) octets
-          n+3+p        length of zone    'q' as an unsigned integer
-    (n+4+p)..(n+3+p+q) zone              string of (up to 32) octets
-
-            For comparison purposes, strings are
-            case-insensitive. All strings may contain any octet
-            other than 255 (hex ff)."
-    SYNTAX       OCTET STRING (SIZE (3..99))
-
--- SNMP over IPX
-
-snmpIPXDomain  OBJECT-IDENTITY
-    STATUS     current
-    DESCRIPTION
-            "The SNMP over IPX transport domain.  The corresponding
-            transport address is of type SnmpIPXAddress."
-    ::= { snmpDomains 5 }
-
-SnmpIPXAddress ::= TEXTUAL-CONVENTION
-    DISPLAY-HINT "4x.1x:1x:1x:1x:1x:1x.2d"
-    STATUS       current
-    DESCRIPTION
-            "Represents an IPX address:
-
-               octets   contents            encoding
-                1-4     network-number      network-byte order
-                5-10    physical-address    network-byte order
-               11-12    socket-number       network-byte order
-            "
-    SYNTAX       OCTET STRING (SIZE (12))
-
-
-
--- for proxy to SNMPv1 (RFC 1157)
-
-rfc1157Proxy   OBJECT IDENTIFIER ::= { snmpProxys 1 }
-
-rfc1157Domain  OBJECT-IDENTITY
-    STATUS     deprecated
-    DESCRIPTION
-            "The transport domain for SNMPv1 over UDP over IPv4.
-            The corresponding transport address is of type
-            SnmpUDPAddress."
-    ::= { rfc1157Proxy 1 }
-
---  ::= { rfc1157Proxy 2 }            this OID is obsolete
-
-END
diff --git a/contrib/apps/LwipMibCompiler/Mibs/TCP-MIB b/contrib/apps/LwipMibCompiler/Mibs/TCP-MIB
deleted file mode 100644
index 5b9e0bf3..00000000
--- a/contrib/apps/LwipMibCompiler/Mibs/TCP-MIB
+++ /dev/null
@@ -1,829 +0,0 @@
-TCP-MIB DEFINITIONS ::= BEGIN
-
-IMPORTS
-    MODULE-IDENTITY, OBJECT-TYPE, Integer32, Unsigned32,
-    Gauge32, Counter32, Counter64, IpAddress, mib-2
-                                       FROM SNMPv2-SMI
-    MODULE-COMPLIANCE, OBJECT-GROUP    FROM SNMPv2-CONF
-    InetAddress, InetAddressType,
-    InetPortNumber                     FROM INET-ADDRESS-MIB;
-
-tcpMIB MODULE-IDENTITY
-    LAST-UPDATED "200502180000Z"  -- 18 February 2005
-    ORGANIZATION
-           "IETF IPv6 MIB Revision Team
-            http://www.ietf.org/html.charters/ipv6-charter.html"
-    CONTACT-INFO
-           "Rajiv Raghunarayan (editor)
-
-            Cisco Systems Inc.
-            170 West Tasman Drive
-            San Jose, CA 95134
-
-            Phone: +1 408 853 9612
-            Email: <raraghun@cisco.com>
-
-            Send comments to <ipv6@ietf.org>"
-    DESCRIPTION
-           "The MIB module for managing TCP implementations.
-
-            Copyright (C) The Internet Society (2005). This version
-            of this MIB module is a part of RFC 4022; see the RFC
-            itself for full legal notices."
-    REVISION      "200502180000Z"  -- 18 February 2005
-    DESCRIPTION
-           "IP version neutral revision, published as RFC 4022."
-    REVISION      "9411010000Z"
-    DESCRIPTION
-           "Initial SMIv2 version, published as RFC 2012."
-    REVISION      "9103310000Z"
-    DESCRIPTION
-           "The initial revision of this MIB module was part of
-            MIB-II."
-    ::= { mib-2 49 }
-
--- the TCP base variables group
-
-
-
-
-tcp      OBJECT IDENTIFIER ::= { mib-2 6 }
-
--- Scalars
-
-tcpRtoAlgorithm OBJECT-TYPE
-    SYNTAX      INTEGER {
-                    other(1),    -- none of the following
-                    constant(2), -- a constant rto
-                    rsre(3),     -- MIL-STD-1778, Appendix B
-                    vanj(4),     -- Van Jacobson's algorithm
-                    rfc2988(5)   -- RFC 2988
-                }
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The algorithm used to determine the timeout value used for
-            retransmitting unacknowledged octets."
-    ::= { tcp 1 }
-
-tcpRtoMin OBJECT-TYPE
-    SYNTAX     Integer32 (0..2147483647)
-    UNITS      "milliseconds"
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The minimum value permitted by a TCP implementation for
-            the retransmission timeout, measured in milliseconds.
-            More refined semantics for objects of this type depend
-            on the algorithm used to determine the retransmission
-            timeout; in particular, the IETF standard algorithm
-            rfc2988(5) provides a minimum value."
-    ::= { tcp 2 }
-
-tcpRtoMax OBJECT-TYPE
-    SYNTAX     Integer32 (0..2147483647)
-    UNITS      "milliseconds"
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The maximum value permitted by a TCP implementation for
-            the retransmission timeout, measured in milliseconds.
-            More refined semantics for objects of this type depend
-            on the algorithm used to determine the retransmission
-            timeout; in particular, the IETF standard algorithm
-            rfc2988(5) provides an upper bound (as part of an
-            adaptive backoff algorithm)."
-    ::= { tcp 3 }
-
-
-
-
-tcpMaxConn OBJECT-TYPE
-    SYNTAX     Integer32 (-1 | 0..2147483647)
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The limit on the total number of TCP connections the entity
-            can support.  In entities where the maximum number of
-            connections is dynamic, this object should contain the
-            value -1."
-    ::= { tcp 4 }
-
-tcpActiveOpens OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of times that TCP connections have made a direct
-            transition to the SYN-SENT state from the CLOSED state.
-
-            Discontinuities in the value of this counter are
-            indicated via discontinuities in the value of sysUpTime."
-    ::= { tcp 5 }
-
-tcpPassiveOpens OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of times TCP connections have made a direct
-            transition to the SYN-RCVD state from the LISTEN state.
-
-            Discontinuities in the value of this counter are
-            indicated via discontinuities in the value of sysUpTime."
-    ::= { tcp 6 }
-
-tcpAttemptFails OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of times that TCP connections have made a direct
-            transition to the CLOSED state from either the SYN-SENT
-            state or the SYN-RCVD state, plus the number of times that
-            TCP connections have made a direct transition to the
-            LISTEN state from the SYN-RCVD state.
-
-            Discontinuities in the value of this counter are
-            indicated via discontinuities in the value of sysUpTime."
-
-
-
-    ::= { tcp 7 }
-
-tcpEstabResets OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of times that TCP connections have made a direct
-            transition to the CLOSED state from either the ESTABLISHED
-            state or the CLOSE-WAIT state.
-
-            Discontinuities in the value of this counter are
-            indicated via discontinuities in the value of sysUpTime."
-    ::= { tcp 8 }
-
-tcpCurrEstab OBJECT-TYPE
-    SYNTAX     Gauge32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of TCP connections for which the current state
-            is either ESTABLISHED or CLOSE-WAIT."
-    ::= { tcp 9 }
-
-tcpInSegs OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of segments received, including those
-            received in error.  This count includes segments received
-            on currently established connections.
-
-            Discontinuities in the value of this counter are
-            indicated via discontinuities in the value of sysUpTime."
-    ::= { tcp 10 }
-
-tcpOutSegs OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of segments sent, including those on
-            current connections but excluding those containing only
-            retransmitted octets.
-
-            Discontinuities in the value of this counter are
-            indicated via discontinuities in the value of sysUpTime."
-
-
-
-    ::= { tcp 11 }
-
-tcpRetransSegs OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of segments retransmitted; that is, the
-            number of TCP segments transmitted containing one or more
-            previously transmitted octets.
-
-            Discontinuities in the value of this counter are
-            indicated via discontinuities in the value of sysUpTime."
-    ::= { tcp 12 }
-
-tcpInErrs OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of segments received in error (e.g., bad
-            TCP checksums).
-
-            Discontinuities in the value of this counter are
-            indicated via discontinuities in the value of sysUpTime."
-    ::= { tcp 14 }
-
-tcpOutRsts OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of TCP segments sent containing the RST flag.
-
-            Discontinuities in the value of this counter are
-            indicated via discontinuities in the value of sysUpTime."
-    ::= { tcp 15 }
-
--- { tcp 16 } was used to represent the ipv6TcpConnTable in RFC 2452,
--- which has since been obsoleted.  It MUST not be used.
-
-tcpHCInSegs OBJECT-TYPE
-    SYNTAX     Counter64
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of segments received, including those
-            received in error.  This count includes segments received
-
-
-
-            on currently established connections.  This object is
-            the 64-bit equivalent of tcpInSegs.
-
-            Discontinuities in the value of this counter are
-            indicated via discontinuities in the value of sysUpTime."
-    ::= { tcp 17 }
-
-tcpHCOutSegs OBJECT-TYPE
-    SYNTAX     Counter64
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of segments sent, including those on
-            current connections but excluding those containing only
-            retransmitted octets.  This object is the 64-bit
-            equivalent of tcpOutSegs.
-
-            Discontinuities in the value of this counter are
-            indicated via discontinuities in the value of sysUpTime."
-    ::= { tcp 18 }
-
-
--- The TCP Connection table
-
-tcpConnectionTable OBJECT-TYPE
-    SYNTAX     SEQUENCE OF TcpConnectionEntry
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "A table containing information about existing TCP
-            connections.  Note that unlike earlier TCP MIBs, there
-            is a separate table for connections in the LISTEN state."
-    ::= { tcp 19 }
-
-tcpConnectionEntry OBJECT-TYPE
-    SYNTAX     TcpConnectionEntry
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "A conceptual row of the tcpConnectionTable containing
-            information about a particular current TCP connection.
-            Each row of this table is transient in that it ceases to
-            exist when (or soon after) the connection makes the
-            transition to the CLOSED state."
-    INDEX   { tcpConnectionLocalAddressType,
-              tcpConnectionLocalAddress,
-              tcpConnectionLocalPort,
-              tcpConnectionRemAddressType,
-
-
-
-              tcpConnectionRemAddress,
-              tcpConnectionRemPort }
-    ::= { tcpConnectionTable 1 }
-
-TcpConnectionEntry ::= SEQUENCE {
-        tcpConnectionLocalAddressType   InetAddressType,
-        tcpConnectionLocalAddress       InetAddress,
-        tcpConnectionLocalPort          InetPortNumber,
-        tcpConnectionRemAddressType     InetAddressType,
-        tcpConnectionRemAddress         InetAddress,
-        tcpConnectionRemPort            InetPortNumber,
-        tcpConnectionState              INTEGER,
-        tcpConnectionProcess            Unsigned32
-    }
-
-tcpConnectionLocalAddressType OBJECT-TYPE
-    SYNTAX     InetAddressType
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "The address type of tcpConnectionLocalAddress."
-    ::= { tcpConnectionEntry 1 }
-
-tcpConnectionLocalAddress OBJECT-TYPE
-    SYNTAX     InetAddress
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "The local IP address for this TCP connection.  The type
-            of this address is determined by the value of
-            tcpConnectionLocalAddressType.
-
-            As this object is used in the index for the
-            tcpConnectionTable, implementors should be
-            careful not to create entries that would result in OIDs
-            with more than 128 subidentifiers; otherwise the information
-            cannot be accessed by using SNMPv1, SNMPv2c, or SNMPv3."
-    ::= { tcpConnectionEntry 2 }
-
-tcpConnectionLocalPort OBJECT-TYPE
-    SYNTAX     InetPortNumber
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "The local port number for this TCP connection."
-    ::= { tcpConnectionEntry 3 }
-
-tcpConnectionRemAddressType OBJECT-TYPE
-
-
-
-    SYNTAX     InetAddressType
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "The address type of tcpConnectionRemAddress."
-    ::= { tcpConnectionEntry 4 }
-
-tcpConnectionRemAddress OBJECT-TYPE
-    SYNTAX     InetAddress
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "The remote IP address for this TCP connection.  The type
-            of this address is determined by the value of
-            tcpConnectionRemAddressType.
-
-            As this object is used in the index for the
-            tcpConnectionTable, implementors should be
-            careful not to create entries that would result in OIDs
-            with more than 128 subidentifiers; otherwise the information
-            cannot be accessed by using SNMPv1, SNMPv2c, or SNMPv3."
-    ::= { tcpConnectionEntry 5 }
-
-tcpConnectionRemPort OBJECT-TYPE
-    SYNTAX     InetPortNumber
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "The remote port number for this TCP connection."
-    ::= { tcpConnectionEntry 6 }
-
-tcpConnectionState OBJECT-TYPE
-    SYNTAX     INTEGER {
-                    closed(1),
-                    listen(2),
-                    synSent(3),
-                    synReceived(4),
-                    established(5),
-                    finWait1(6),
-                    finWait2(7),
-                    closeWait(8),
-                    lastAck(9),
-                    closing(10),
-                    timeWait(11),
-                    deleteTCB(12)
-                }
-    MAX-ACCESS read-write
-    STATUS     current
-
-
-
-    DESCRIPTION
-           "The state of this TCP connection.
-
-            The value listen(2) is included only for parallelism to the
-            old tcpConnTable and should not be used.  A connection in
-            LISTEN state should be present in the tcpListenerTable.
-
-            The only value that may be set by a management station is
-            deleteTCB(12).  Accordingly, it is appropriate for an agent
-            to return a `badValue' response if a management station
-            attempts to set this object to any other value.
-
-            If a management station sets this object to the value
-            deleteTCB(12), then the TCB (as defined in [RFC793]) of
-            the corresponding connection on the managed node is
-            deleted, resulting in immediate termination of the
-            connection.
-
-            As an implementation-specific option, a RST segment may be
-            sent from the managed node to the other TCP endpoint (note,
-            however, that RST segments are not sent reliably)."
-    ::= { tcpConnectionEntry 7 }
-
-tcpConnectionProcess OBJECT-TYPE
-    SYNTAX     Unsigned32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The system's process ID for the process associated with
-            this connection, or zero if there is no such process.  This
-            value is expected to be the same as HOST-RESOURCES-MIB::
-            hrSWRunIndex or SYSAPPL-MIB::sysApplElmtRunIndex for some
-            row in the appropriate tables."
-    ::= { tcpConnectionEntry 8 }
-
--- The TCP Listener table
-
-tcpListenerTable OBJECT-TYPE
-    SYNTAX     SEQUENCE OF TcpListenerEntry
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "A table containing information about TCP listeners.  A
-            listening application can be represented in three
-            possible ways:
-
-            1. An application that is willing to accept both IPv4 and
-               IPv6 datagrams is represented by
-
-
-
-               a tcpListenerLocalAddressType of unknown (0) and
-               a tcpListenerLocalAddress of ''h (a zero-length
-               octet-string).
-
-            2. An application that is willing to accept only IPv4 or
-               IPv6 datagrams is represented by a
-               tcpListenerLocalAddressType of the appropriate address
-               type and a tcpListenerLocalAddress of '0.0.0.0' or '::'
-               respectively.
-
-            3. An application that is listening for data destined
-               only to a specific IP address, but from any remote
-               system, is represented by a tcpListenerLocalAddressType
-               of an appropriate address type, with
-               tcpListenerLocalAddress as the specific local address.
-
-            NOTE: The address type in this table represents the
-            address type used for the communication, irrespective
-            of the higher-layer abstraction.  For example, an
-            application using IPv6 'sockets' to communicate via
-            IPv4 between ::ffff:10.0.0.1 and ::ffff:10.0.0.2 would
-            use InetAddressType ipv4(1))."
-    ::= { tcp 20 }
-
-tcpListenerEntry OBJECT-TYPE
-    SYNTAX     TcpListenerEntry
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "A conceptual row of the tcpListenerTable containing
-            information about a particular TCP listener."
-    INDEX   { tcpListenerLocalAddressType,
-              tcpListenerLocalAddress,
-              tcpListenerLocalPort }
-    ::= { tcpListenerTable 1 }
-
-TcpListenerEntry ::= SEQUENCE {
-        tcpListenerLocalAddressType       InetAddressType,
-        tcpListenerLocalAddress           InetAddress,
-        tcpListenerLocalPort              InetPortNumber,
-        tcpListenerProcess                Unsigned32
-    }
-
-tcpListenerLocalAddressType OBJECT-TYPE
-    SYNTAX     InetAddressType
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-
-
-
-           "The address type of tcpListenerLocalAddress.  The value
-            should be unknown (0) if connection initiations to all
-            local IP addresses are accepted."
-    ::= { tcpListenerEntry 1 }
-
-tcpListenerLocalAddress OBJECT-TYPE
-    SYNTAX     InetAddress
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "The local IP address for this TCP connection.
-
-            The value of this object can be represented in three
-            possible ways, depending on the characteristics of the
-            listening application:
-
-            1. For an application willing to accept both IPv4 and
-               IPv6 datagrams, the value of this object must be
-               ''h (a zero-length octet-string), with the value
-               of the corresponding tcpListenerLocalAddressType
-               object being unknown (0).
-
-            2. For an application willing to accept only IPv4 or
-               IPv6 datagrams, the value of this object must be
-               '0.0.0.0' or '::' respectively, with
-               tcpListenerLocalAddressType representing the
-               appropriate address type.
-
-            3. For an application which is listening for data
-               destined only to a specific IP address, the value
-               of this object is the specific local address, with
-               tcpListenerLocalAddressType representing the
-               appropriate address type.
-
-            As this object is used in the index for the
-            tcpListenerTable, implementors should be
-            careful not to create entries that would result in OIDs
-            with more than 128 subidentifiers; otherwise the information
-            cannot be accessed, using SNMPv1, SNMPv2c, or SNMPv3."
-    ::= { tcpListenerEntry 2 }
-
-tcpListenerLocalPort OBJECT-TYPE
-    SYNTAX     InetPortNumber
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "The local port number for this TCP connection."
-    ::= { tcpListenerEntry 3 }
-
-
-
-tcpListenerProcess OBJECT-TYPE
-    SYNTAX     Unsigned32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The system's process ID for the process associated with
-            this listener, or zero if there is no such process.  This
-            value is expected to be the same as HOST-RESOURCES-MIB::
-            hrSWRunIndex or SYSAPPL-MIB::sysApplElmtRunIndex for some
-            row in the appropriate tables."
-    ::= { tcpListenerEntry 4 }
-
-
--- The deprecated TCP Connection table
-
-tcpConnTable OBJECT-TYPE
-    SYNTAX     SEQUENCE OF TcpConnEntry
-    MAX-ACCESS not-accessible
-    STATUS     deprecated
-    DESCRIPTION
-           "A table containing information about existing IPv4-specific
-            TCP connections or listeners.  This table has been
-            deprecated in favor of the version neutral
-            tcpConnectionTable."
-    ::= { tcp 13 }
-
-tcpConnEntry OBJECT-TYPE
-    SYNTAX     TcpConnEntry
-    MAX-ACCESS not-accessible
-    STATUS     deprecated
-    DESCRIPTION
-           "A conceptual row of the tcpConnTable containing information
-            about a particular current IPv4 TCP connection.  Each row
-            of this table is transient in that it ceases to exist when
-            (or soon after) the connection makes the transition to the
-            CLOSED state."
-    INDEX   { tcpConnLocalAddress,
-              tcpConnLocalPort,
-              tcpConnRemAddress,
-              tcpConnRemPort }
-    ::= { tcpConnTable 1 }
-
-TcpConnEntry ::= SEQUENCE {
-        tcpConnState         INTEGER,
-        tcpConnLocalAddress  IpAddress,
-        tcpConnLocalPort     Integer32,
-        tcpConnRemAddress    IpAddress,
-        tcpConnRemPort       Integer32
-
-
-
-    }
-
-tcpConnState OBJECT-TYPE
-    SYNTAX     INTEGER {
-                    closed(1),
-                    listen(2),
-                    synSent(3),
-                    synReceived(4),
-                    established(5),
-                    finWait1(6),
-                    finWait2(7),
-                    closeWait(8),
-                    lastAck(9),
-                    closing(10),
-                    timeWait(11),
-                    deleteTCB(12)
-                }
-    MAX-ACCESS read-write
-    STATUS     deprecated
-    DESCRIPTION
-           "The state of this TCP connection.
-
-            The only value that may be set by a management station is
-            deleteTCB(12).  Accordingly, it is appropriate for an agent
-            to return a `badValue' response if a management station
-            attempts to set this object to any other value.
-
-            If a management station sets this object to the value
-            deleteTCB(12), then the TCB (as defined in [RFC793]) of
-            the corresponding connection on the managed node is
-            deleted, resulting in immediate termination of the
-            connection.
-
-            As an implementation-specific option, a RST segment may be
-            sent from the managed node to the other TCP endpoint (note,
-            however, that RST segments are not sent reliably)."
-    ::= { tcpConnEntry 1 }
-
-tcpConnLocalAddress OBJECT-TYPE
-    SYNTAX     IpAddress
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The local IP address for this TCP connection.  In the case
-            of a connection in the listen state willing to
-            accept connections for any IP interface associated with the
-            node, the value 0.0.0.0 is used."
-    ::= { tcpConnEntry 2 }
-
-
-
-tcpConnLocalPort OBJECT-TYPE
-    SYNTAX     Integer32 (0..65535)
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The local port number for this TCP connection."
-    ::= { tcpConnEntry 3 }
-
-tcpConnRemAddress OBJECT-TYPE
-    SYNTAX     IpAddress
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The remote IP address for this TCP connection."
-    ::= { tcpConnEntry 4 }
-
-tcpConnRemPort OBJECT-TYPE
-    SYNTAX     Integer32 (0..65535)
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The remote port number for this TCP connection."
-    ::= { tcpConnEntry 5 }
-
--- conformance information
-
-tcpMIBConformance OBJECT IDENTIFIER ::= { tcpMIB 2 }
-
-tcpMIBCompliances OBJECT IDENTIFIER ::= { tcpMIBConformance 1 }
-tcpMIBGroups      OBJECT IDENTIFIER ::= { tcpMIBConformance 2 }
-
--- compliance statements
-
-tcpMIBCompliance2 MODULE-COMPLIANCE
-    STATUS     current
-    DESCRIPTION
-           "The compliance statement for systems that implement TCP.
-
-            A number of INDEX objects cannot be
-            represented in the form of OBJECT clauses in SMIv2 but
-            have the following compliance requirements,
-            expressed in OBJECT clause form in this description
-            clause:
-
-            -- OBJECT      tcpConnectionLocalAddressType
-            -- SYNTAX      InetAddressType { ipv4(1), ipv6(2) }
-            -- DESCRIPTION
-            --     This MIB requires support for only global IPv4
-
-
-
-            --     and IPv6 address types.
-            --
-            -- OBJECT      tcpConnectionRemAddressType
-            -- SYNTAX      InetAddressType { ipv4(1), ipv6(2) }
-            -- DESCRIPTION
-            --     This MIB requires support for only global IPv4
-            --     and IPv6 address types.
-            --
-            -- OBJECT      tcpListenerLocalAddressType
-            -- SYNTAX      InetAddressType { unknown(0), ipv4(1),
-            --                               ipv6(2) }
-            -- DESCRIPTION
-            --     This MIB requires support for only global IPv4
-            --     and IPv6 address types.  The type unknown also
-            --     needs to be supported to identify a special
-            --     case in the listener table: a listen using
-            --     both IPv4 and IPv6 addresses on the device.
-            --
-           "
-    MODULE  -- this module
-        MANDATORY-GROUPS { tcpBaseGroup, tcpConnectionGroup,
-                           tcpListenerGroup }
-        GROUP       tcpHCGroup
-        DESCRIPTION
-           "This group is mandatory for systems that are capable
-            of receiving or transmitting more than 1 million TCP
-            segments per second.  1 million segments per second will
-            cause a Counter32 to wrap in just over an hour."
-        OBJECT      tcpConnectionState
-        SYNTAX      INTEGER { closed(1), listen(2), synSent(3),
-                              synReceived(4), established(5),
-                              finWait1(6), finWait2(7), closeWait(8),
-                              lastAck(9), closing(10), timeWait(11) }
-        MIN-ACCESS  read-only
-        DESCRIPTION
-           "Write access is not required, nor is support for the value
-            deleteTCB (12)."
-    ::= { tcpMIBCompliances 2 }
-
-tcpMIBCompliance MODULE-COMPLIANCE
-    STATUS     deprecated
-    DESCRIPTION
-           "The compliance statement for IPv4-only systems that
-            implement TCP.  In order to be IP version independent, this
-            compliance statement is deprecated in favor of
-            tcpMIBCompliance2.  However, agents are still encouraged
-            to implement these objects in order to interoperate with
-            the deployed base of managers."
-
-
-
-    MODULE  -- this module
-        MANDATORY-GROUPS { tcpGroup }
-        OBJECT      tcpConnState
-        MIN-ACCESS  read-only
-        DESCRIPTION
-           "Write access is not required."
-    ::= { tcpMIBCompliances 1 }
-
-
--- units of conformance
-
-tcpGroup OBJECT-GROUP
-    OBJECTS   { tcpRtoAlgorithm, tcpRtoMin, tcpRtoMax,
-                tcpMaxConn, tcpActiveOpens,
-                tcpPassiveOpens, tcpAttemptFails,
-                tcpEstabResets, tcpCurrEstab, tcpInSegs,
-                tcpOutSegs, tcpRetransSegs, tcpConnState,
-                tcpConnLocalAddress, tcpConnLocalPort,
-                tcpConnRemAddress, tcpConnRemPort,
-                tcpInErrs, tcpOutRsts }
-    STATUS     deprecated
-    DESCRIPTION
-           "The tcp group of objects providing for management of TCP
-            entities."
-    ::= { tcpMIBGroups 1 }
-
-tcpBaseGroup OBJECT-GROUP
-    OBJECTS   { tcpRtoAlgorithm, tcpRtoMin, tcpRtoMax,
-                tcpMaxConn, tcpActiveOpens,
-                tcpPassiveOpens, tcpAttemptFails,
-                tcpEstabResets, tcpCurrEstab, tcpInSegs,
-                tcpOutSegs, tcpRetransSegs,
-                tcpInErrs, tcpOutRsts }
-    STATUS     current
-    DESCRIPTION
-           "The group of counters common to TCP entities."
-    ::= { tcpMIBGroups 2 }
-
-tcpConnectionGroup OBJECT-GROUP
-    OBJECTS    { tcpConnectionState, tcpConnectionProcess }
-    STATUS     current
-    DESCRIPTION
-           "The group provides general information about TCP
-            connections."
-    ::= { tcpMIBGroups 3 }
-
-tcpListenerGroup OBJECT-GROUP
-    OBJECTS    { tcpListenerProcess }
-
-
-
-    STATUS     current
-    DESCRIPTION
-           "This group has objects providing general information about
-            TCP listeners."
-    ::= { tcpMIBGroups 4 }
-
-tcpHCGroup OBJECT-GROUP
-    OBJECTS    { tcpHCInSegs, tcpHCOutSegs }
-    STATUS     current
-    DESCRIPTION
-           "The group of objects providing for counters of high speed
-            TCP implementations."
-    ::= { tcpMIBGroups 5 }
-
-END
diff --git a/contrib/apps/LwipMibCompiler/Mibs/UDP-MIB b/contrib/apps/LwipMibCompiler/Mibs/UDP-MIB
deleted file mode 100644
index b947b812..00000000
--- a/contrib/apps/LwipMibCompiler/Mibs/UDP-MIB
+++ /dev/null
@@ -1,579 +0,0 @@
-UDP-MIB DEFINITIONS ::= BEGIN
-
-IMPORTS
-    MODULE-IDENTITY, OBJECT-TYPE, Integer32, Counter32, Counter64,
-    Unsigned32, IpAddress, mib-2       FROM SNMPv2-SMI
-    MODULE-COMPLIANCE, OBJECT-GROUP    FROM SNMPv2-CONF
-    InetAddress, InetAddressType,
-    InetPortNumber                     FROM INET-ADDRESS-MIB;
-
-udpMIB MODULE-IDENTITY
-    LAST-UPDATED "200505200000Z"  -- May 20, 2005
-    ORGANIZATION
-           "IETF IPv6 Working Group
-            http://www.ietf.org/html.charters/ipv6-charter.html"
-    CONTACT-INFO
-           "Bill Fenner (editor)
-
-            AT&T Labs -- Research
-            75 Willow Rd.
-            Menlo Park, CA 94025
-
-            Phone: +1 650 330-7893
-            Email: <fenner@research.att.com>
-
-            John Flick (editor)
-
-            Hewlett-Packard Company
-            8000 Foothills Blvd. M/S 5557
-            Roseville, CA 95747
-
-            Phone: +1 916 785 4018
-            Email: <john.flick@hp.com>
-
-            Send comments to <ipv6@ietf.org>"
-
-
-
-    DESCRIPTION
-           "The MIB module for managing UDP implementations.
-            Copyright (C) The Internet Society (2005).  This
-            version of this MIB module is part of RFC 4113;
-            see the RFC itself for full legal notices."
-    REVISION      "200505200000Z"  -- May 20, 2005
-    DESCRIPTION
-           "IP version neutral revision, incorporating the
-            following revisions:
-
-            - Added udpHCInDatagrams and udpHCOutDatagrams in order
-              to provide high-capacity counters for fast networks.
-            - Added text to the descriptions of all counter objects
-              to indicate how discontinuities are detected.
-            - Deprecated the IPv4-specific udpTable and replaced it
-              with the version neutral udpEndpointTable.  This
-              table includes support for connected UDP endpoints
-              and support for identification of the operating
-              system process associated with a UDP endpoint.
-            - Deprecated the udpGroup and replaced it with object
-              groups representing the current set of objects.
-            - Deprecated udpMIBCompliance and replaced it with
-              udpMIBCompliance2, which includes the compliance
-              information for the new object groups.
-
-            This version published as RFC 4113."
-    REVISION      "199411010000Z"    -- November 1, 1994
-    DESCRIPTION
-           "Initial SMIv2 version, published as RFC 2013."
-    REVISION      "199103310000Z"    -- March 31, 1991
-    DESCRIPTION
-           "The initial revision of this MIB module was part of
-            MIB-II, published as RFC 1213."
-    ::= { mib-2 50 }
-
--- the UDP group
-
-udp      OBJECT IDENTIFIER ::= { mib-2 7 }
-
-udpInDatagrams OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of UDP datagrams delivered to UDP
-            users.
-
-
-
-
-
-            Discontinuities in the value of this counter can occur
-            at re-initialization of the management system, and at
-            other times as indicated by discontinuities in the
-            value of sysUpTime."
-    ::= { udp 1 }
-
-udpNoPorts OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of received UDP datagrams for which
-            there was no application at the destination port.
-
-            Discontinuities in the value of this counter can occur
-            at re-initialization of the management system, and at
-            other times as indicated by discontinuities in the
-            value of sysUpTime."
-    ::= { udp 2 }
-
-udpInErrors OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The number of received UDP datagrams that could not be
-            delivered for reasons other than the lack of an
-            application at the destination port.
-
-            Discontinuities in the value of this counter can occur
-            at re-initialization of the management system, and at
-            other times as indicated by discontinuities in the
-            value of sysUpTime."
-    ::= { udp 3 }
-
-udpOutDatagrams OBJECT-TYPE
-    SYNTAX     Counter32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of UDP datagrams sent from this
-            entity.
-
-            Discontinuities in the value of this counter can occur
-            at re-initialization of the management system, and at
-            other times as indicated by discontinuities in the
-            value of sysUpTime."
-    ::= { udp 4 }
-
-
-
-udpHCInDatagrams OBJECT-TYPE
-    SYNTAX     Counter64
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of UDP datagrams delivered to UDP
-            users, for devices that can receive more than 1
-            million UDP datagrams per second.
-
-            Discontinuities in the value of this counter can occur
-            at re-initialization of the management system, and at
-            other times as indicated by discontinuities in the
-            value of sysUpTime."
-    ::= { udp 8 }
-
-udpHCOutDatagrams OBJECT-TYPE
-    SYNTAX     Counter64
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The total number of UDP datagrams sent from this
-            entity, for devices that can transmit more than 1
-            million UDP datagrams per second.
-
-            Discontinuities in the value of this counter can occur
-            at re-initialization of the management system, and at
-            other times as indicated by discontinuities in the
-            value of sysUpTime."
-    ::= { udp 9 }
-
---
--- { udp 6 } was defined as the ipv6UdpTable in RFC2454's
--- IPV6-UDP-MIB.  This RFC obsoletes RFC 2454, so { udp 6 } is
--- obsoleted.
---
-
--- The UDP "Endpoint" table.
-
-udpEndpointTable OBJECT-TYPE
-    SYNTAX     SEQUENCE OF UdpEndpointEntry
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "A table containing information about this entity's UDP
-            endpoints on which a local application is currently
-            accepting or sending datagrams.
-
-
-
-
-
-            The address type in this table represents the address
-            type used for the communication, irrespective of the
-            higher-layer abstraction.  For example, an application
-            using IPv6 'sockets' to communicate via IPv4 between
-            ::ffff:10.0.0.1 and ::ffff:10.0.0.2 would use
-            InetAddressType ipv4(1).
-
-            Unlike the udpTable in RFC 2013, this table also allows
-            the representation of an application that completely
-            specifies both local and remote addresses and ports.  A
-            listening application is represented in three possible
-            ways:
-
-            1) An application that is willing to accept both IPv4
-               and IPv6 datagrams is represented by a
-               udpEndpointLocalAddressType of unknown(0) and a
-               udpEndpointLocalAddress of ''h (a zero-length
-               octet-string).
-
-            2) An application that is willing to accept only IPv4
-               or only IPv6 datagrams is represented by a
-               udpEndpointLocalAddressType of the appropriate
-               address type and a udpEndpointLocalAddress of
-               '0.0.0.0' or '::' respectively.
-
-            3) An application that is listening for datagrams only
-               for a specific IP address but from any remote
-               system is represented by a
-               udpEndpointLocalAddressType of the appropriate
-               address type, with udpEndpointLocalAddress
-               specifying the local address.
-
-            In all cases where the remote is a wildcard, the
-            udpEndpointRemoteAddressType is unknown(0), the
-            udpEndpointRemoteAddress is ''h (a zero-length
-            octet-string), and the udpEndpointRemotePort is 0.
-
-            If the operating system is demultiplexing UDP packets
-            by remote address and port, or if the application has
-            'connected' the socket specifying a default remote
-            address and port, the udpEndpointRemote* values should
-            be used to reflect this."
-    ::= { udp 7 }
-
-udpEndpointEntry OBJECT-TYPE
-    SYNTAX     UdpEndpointEntry
-    MAX-ACCESS not-accessible
-    STATUS     current
-
-
-
-    DESCRIPTION
-           "Information about a particular current UDP endpoint.
-
-            Implementers need to be aware that if the total number
-            of elements (octets or sub-identifiers) in
-            udpEndpointLocalAddress and udpEndpointRemoteAddress
-            exceeds 111, then OIDs of column instances in this table
-            will have more than 128 sub-identifiers and cannot be
-            accessed using SNMPv1, SNMPv2c, or SNMPv3."
-    INDEX   { udpEndpointLocalAddressType,
-              udpEndpointLocalAddress,
-              udpEndpointLocalPort,
-              udpEndpointRemoteAddressType,
-              udpEndpointRemoteAddress,
-              udpEndpointRemotePort,
-              udpEndpointInstance }
-    ::= { udpEndpointTable 1 }
-
-UdpEndpointEntry ::= SEQUENCE {
-        udpEndpointLocalAddressType   InetAddressType,
-        udpEndpointLocalAddress       InetAddress,
-        udpEndpointLocalPort          InetPortNumber,
-        udpEndpointRemoteAddressType  InetAddressType,
-        udpEndpointRemoteAddress      InetAddress,
-        udpEndpointRemotePort         InetPortNumber,
-        udpEndpointInstance           Unsigned32,
-        udpEndpointProcess            Unsigned32
-    }
-
-udpEndpointLocalAddressType OBJECT-TYPE
-    SYNTAX     InetAddressType
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "The address type of udpEndpointLocalAddress.  Only
-            IPv4, IPv4z, IPv6, and IPv6z addresses are expected, or
-            unknown(0) if datagrams for all local IP addresses are
-            accepted."
-    ::= { udpEndpointEntry 1 }
-
-udpEndpointLocalAddress OBJECT-TYPE
-    SYNTAX     InetAddress
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "The local IP address for this UDP endpoint.
-
-            The value of this object can be represented in three
-
-
-
-            possible ways, depending on the characteristics of the
-            listening application:
-
-            1. For an application that is willing to accept both
-               IPv4 and IPv6 datagrams, the value of this object
-               must be ''h (a zero-length octet-string), with
-               the value of the corresponding instance of the
-               udpEndpointLocalAddressType object being unknown(0).
-
-            2. For an application that is willing to accept only IPv4
-               or only IPv6 datagrams, the value of this object
-               must be '0.0.0.0' or '::', respectively, while the
-               corresponding instance of the
-               udpEndpointLocalAddressType object represents the
-               appropriate address type.
-
-            3. For an application that is listening for data
-               destined only to a specific IP address, the value
-               of this object is the specific IP address for which
-               this node is receiving packets, with the
-               corresponding instance of the
-               udpEndpointLocalAddressType object representing the
-               appropriate address type.
-
-            As this object is used in the index for the
-            udpEndpointTable, implementors of this table should be
-            careful not to create entries that would result in OIDs
-            with more than 128 subidentifiers; else the information
-            cannot be accessed using SNMPv1, SNMPv2c, or SNMPv3."
-    ::= { udpEndpointEntry 2 }
-
-udpEndpointLocalPort OBJECT-TYPE
-    SYNTAX     InetPortNumber
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "The local port number for this UDP endpoint."
-    ::= { udpEndpointEntry 3 }
-
-udpEndpointRemoteAddressType OBJECT-TYPE
-    SYNTAX     InetAddressType
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "The address type of udpEndpointRemoteAddress.  Only
-            IPv4, IPv4z, IPv6, and IPv6z addresses are expected, or
-            unknown(0) if datagrams for all remote IP addresses are
-            accepted.  Also, note that some combinations of
-
-
-
-            udpEndpointLocalAdressType and
-            udpEndpointRemoteAddressType are not supported.  In
-            particular, if the value of this object is not
-            unknown(0), it is expected to always refer to the
-            same IP version as udpEndpointLocalAddressType."
-    ::= { udpEndpointEntry 4 }
-
-udpEndpointRemoteAddress OBJECT-TYPE
-    SYNTAX     InetAddress
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "The remote IP address for this UDP endpoint.  If
-            datagrams from any remote system are to be accepted,
-            this value is ''h (a zero-length octet-string).
-            Otherwise, it has the type described by
-            udpEndpointRemoteAddressType and is the address of the
-            remote system from which datagrams are to be accepted
-            (or to which all datagrams will be sent).
-
-            As this object is used in the index for the
-            udpEndpointTable, implementors of this table should be
-            careful not to create entries that would result in OIDs
-            with more than 128 subidentifiers; else the information
-            cannot be accessed using SNMPv1, SNMPv2c, or SNMPv3."
-    ::= { udpEndpointEntry 5 }
-
-udpEndpointRemotePort OBJECT-TYPE
-    SYNTAX     InetPortNumber
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "The remote port number for this UDP endpoint.  If
-            datagrams from any remote system are to be accepted,
-            this value is zero."
-    ::= { udpEndpointEntry 6 }
-
-udpEndpointInstance OBJECT-TYPE
-    SYNTAX     Unsigned32 (1..'ffffffff'h)
-    MAX-ACCESS not-accessible
-    STATUS     current
-    DESCRIPTION
-           "The instance of this tuple.  This object is used to
-            distinguish among multiple processes 'connected' to
-            the same UDP endpoint.  For example, on a system
-            implementing the BSD sockets interface, this would be
-            used to support the SO_REUSEADDR and SO_REUSEPORT
-            socket options."
-
-
-
-    ::= { udpEndpointEntry 7 }
-
-udpEndpointProcess OBJECT-TYPE
-    SYNTAX     Unsigned32
-    MAX-ACCESS read-only
-    STATUS     current
-    DESCRIPTION
-           "The system's process ID for the process associated with
-            this endpoint, or zero if there is no such process.
-            This value is expected to be the same as
-            HOST-RESOURCES-MIB::hrSWRunIndex or SYSAPPL-MIB::
-            sysApplElmtRunIndex for some row in the appropriate
-            tables."
-    ::= { udpEndpointEntry 8 }
-
--- The deprecated UDP Listener table
-
--- The deprecated UDP listener table only contains information
--- about this entity's IPv4 UDP end-points on which a local
--- application is currently accepting datagrams.  It does not
--- provide more detailed connection information, or information
--- about IPv6 endpoints.
-
-udpTable OBJECT-TYPE
-    SYNTAX     SEQUENCE OF UdpEntry
-    MAX-ACCESS not-accessible
-    STATUS     deprecated
-    DESCRIPTION
-           "A table containing IPv4-specific UDP listener
-            information.  It contains information about all local
-            IPv4 UDP end-points on which an application is
-            currently accepting datagrams.  This table has been
-            deprecated in favor of the version neutral
-            udpEndpointTable."
-    ::= { udp 5 }
-
-udpEntry OBJECT-TYPE
-    SYNTAX     UdpEntry
-    MAX-ACCESS not-accessible
-    STATUS     deprecated
-    DESCRIPTION
-           "Information about a particular current UDP listener."
-    INDEX   { udpLocalAddress, udpLocalPort }
-    ::= { udpTable 1 }
-
-UdpEntry ::= SEQUENCE {
-    udpLocalAddress   IpAddress,
-    udpLocalPort      Integer32
-
-
-
-}
-
-udpLocalAddress OBJECT-TYPE
-    SYNTAX     IpAddress
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The local IP address for this UDP listener.  In the
-            case of a UDP listener that is willing to accept
-            datagrams for any IP interface associated with the
-            node, the value 0.0.0.0 is used."
-    ::= { udpEntry 1 }
-
-udpLocalPort OBJECT-TYPE
-    SYNTAX     Integer32 (0..65535)
-    MAX-ACCESS read-only
-    STATUS     deprecated
-    DESCRIPTION
-           "The local port number for this UDP listener."
-    ::= { udpEntry 2 }
-
--- conformance information
-
-udpMIBConformance OBJECT IDENTIFIER ::= { udpMIB 2 }
-udpMIBCompliances OBJECT IDENTIFIER ::= { udpMIBConformance 1 }
-udpMIBGroups      OBJECT IDENTIFIER ::= { udpMIBConformance 2 }
-
--- compliance statements
-
-udpMIBCompliance2 MODULE-COMPLIANCE
-    STATUS     current
-    DESCRIPTION
-           "The compliance statement for systems that implement
-            UDP.
-
-            There are a number of INDEX objects that cannot be
-            represented in the form of OBJECT clauses in SMIv2, but
-            for which we have the following compliance
-            requirements, expressed in OBJECT clause form in this
-            description clause:
-
-            -- OBJECT      udpEndpointLocalAddressType
-            -- SYNTAX      InetAddressType { unknown(0), ipv4(1),
-            --                               ipv6(2), ipv4z(3),
-            --                               ipv6z(4) }
-            -- DESCRIPTION
-            --     Support for dns(5) is not required.
-            -- OBJECT      udpEndpointLocalAddress
-
-
-
-            -- SYNTAX      InetAddress (SIZE(0|4|8|16|20))
-            -- DESCRIPTION
-            --     Support is only required for zero-length
-            --     octet-strings, and for scoped and unscoped
-            --     IPv4 and IPv6 addresses.
-            -- OBJECT      udpEndpointRemoteAddressType
-            -- SYNTAX      InetAddressType { unknown(0), ipv4(1),
-            --                               ipv6(2), ipv4z(3),
-            --                               ipv6z(4) }
-            -- DESCRIPTION
-            --     Support for dns(5) is not required.
-            -- OBJECT      udpEndpointRemoteAddress
-            -- SYNTAX      InetAddress (SIZE(0|4|8|16|20))
-            -- DESCRIPTION
-            --     Support is only required for zero-length
-            --     octet-strings, and for scoped and unscoped
-            --     IPv4 and IPv6 addresses.
-           "
-    MODULE  -- this module
-         MANDATORY-GROUPS { udpBaseGroup, udpEndpointGroup }
-         GROUP       udpHCGroup
-         DESCRIPTION
-                "This group is mandatory for systems that
-                 are capable of receiving or transmitting more than
-                 1 million UDP datagrams per second.  1 million
-                 datagrams per second will cause a Counter32 to
-                 wrap in just over an hour."
-    ::= { udpMIBCompliances 2 }
-
-udpMIBCompliance MODULE-COMPLIANCE
-    STATUS     deprecated
-    DESCRIPTION
-           "The compliance statement for IPv4-only systems that
-            implement UDP.  For IP version independence, this
-            compliance statement is deprecated in favor of
-            udpMIBCompliance2.  However, agents are still
-            encouraged to implement these objects in order to
-            interoperate with the deployed base of managers."
-    MODULE  -- this module
-        MANDATORY-GROUPS { udpGroup }
-    ::= { udpMIBCompliances 1 }
-
--- units of conformance
-
-udpGroup OBJECT-GROUP
-    OBJECTS   { udpInDatagrams, udpNoPorts,
-                udpInErrors, udpOutDatagrams,
-                udpLocalAddress, udpLocalPort }
-
-
-
-    STATUS     deprecated
-    DESCRIPTION
-           "The deprecated group of objects providing for
-            management of UDP over IPv4."
-    ::= { udpMIBGroups 1 }
-
-udpBaseGroup OBJECT-GROUP
-    OBJECTS   { udpInDatagrams, udpNoPorts, udpInErrors,
-                udpOutDatagrams }
-    STATUS     current
-    DESCRIPTION
-           "The group of objects providing for counters of UDP
-            statistics."
-    ::= { udpMIBGroups 2 }
-
-udpHCGroup OBJECT-GROUP
-    OBJECTS   { udpHCInDatagrams, udpHCOutDatagrams }
-    STATUS     current
-    DESCRIPTION
-           "The group of objects providing for counters of high
-            speed UDP implementations."
-    ::= { udpMIBGroups 3 }
-
-udpEndpointGroup OBJECT-GROUP
-    OBJECTS    { udpEndpointProcess }
-    STATUS     current
-    DESCRIPTION
-           "The group of objects providing for the IP version
-            independent management of UDP 'endpoints'."
-    ::= { udpMIBGroups 4 }
-
-END
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/DisplayHint.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/DisplayHint.cs
deleted file mode 100644
index 831f1177..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/DisplayHint.cs
+++ /dev/null
@@ -1,84 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Collections;
-
-namespace Lextm.SharpSnmpLib.Mib
-{
-    public class DisplayHint
-    {
-        private enum NumType {
-            dec,
-            hex,
-            oct,
-            bin,
-            str
-        }
-
-        private string _str;
-        private NumType _type;
-        private int _decimalPoints = 0;
-
-        public DisplayHint(string str)
-        {
-            _str = str;
-            if (str.StartsWith("d"))
-            {
-                _type = NumType.dec;
-                if (str.StartsWith("d-"))
-                {
-                    _decimalPoints = Convert.ToInt32(str.Substring(2));
-                }
-            }
-            else if (str.StartsWith("o"))
-            {
-                _type = NumType.oct;
-            }
-            else if (str.StartsWith("h"))
-            {
-                _type = NumType.hex;
-            }
-            else if (str.StartsWith("b"))
-            {
-                _type = NumType.bin;
-            }
-            else
-            {
-                _type = NumType.str;
-                foreach (char c in str)
-                {
-
-                }
-            }
-
-        }
-
-        public override string ToString()
-        {
-            return _str;
-        }
-
-        internal object Decode(int i)
-        {
-            switch (_type)
-            {
-                case NumType.dec:
-                    if (_decimalPoints == 0)
-                    {
-                        return i;
-                    }
-                    else
-                    {
-                        return i / Math.Pow(10.0, _decimalPoints);
-                    }
-                case NumType.hex:
-                    return System.Convert.ToString(i, 16);
-                case NumType.oct:
-                    return System.Convert.ToString(i, 8);
-                case NumType.bin:
-                    return System.Convert.ToString(i, 2);
-                default:
-                    return null;
-            }
-        }
-    }
-}
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Entities/AgentCapabilities.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Entities/AgentCapabilities.cs
deleted file mode 100644
index 2f79cce5..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Entities/AgentCapabilities.cs
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * Created by SharpDevelop.
- * User: lextm
- * Date: 2008/5/31
- * Time: 13:18
- * 
- * To change this template use Tools | Options | Coding | Edit Standard Headers.
- */
-
-namespace Lextm.SharpSnmpLib.Mib.Elements.Entities
-{
-    /// <summary>
-    /// The AGENT-CAPABILITIES construct is used to specify implementation characteristics of an SNMP agent sub-system with respect to object types and events.
-    /// </summary>
-    public sealed class AgentCapabilities : EntityBase
-    {       
-        /// <summary>
-        /// Creates an <see cref="AgentCapabilities"/> instance.
-        /// </summary>
-        /// <param name="module"></param>
-        /// <param name="header"></param>
-        /// <param name="lexer"></param>
-        public AgentCapabilities(IModule module, SymbolList preAssignSymbols, ISymbolEnumerator symbols)
-            : base(module, preAssignSymbols, symbols)
-        {
-        }
-       
-    }
-}
\ No newline at end of file
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Entities/EntityBase.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Entities/EntityBase.cs
deleted file mode 100644
index 6da9b18c..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Entities/EntityBase.cs
+++ /dev/null
@@ -1,46 +0,0 @@
-﻿using System;
-
-namespace Lextm.SharpSnmpLib.Mib.Elements.Entities
-{
-    public abstract class EntityBase: IEntity
-    {
-        private readonly IModule _module;
-        private string _parent;
-        private readonly uint   _value;
-        private readonly string _name;
-
-        public EntityBase(IModule module, SymbolList preAssignSymbols, ISymbolEnumerator symbols)
-        {
-            _module = module;
-            _name   = preAssignSymbols[0].ToString();
-
-            Lexer.ParseOidValue(symbols, out _parent, out _value);
-        }
-
-        public IModule Module
-        {
-            get { return _module; }
-        }
-
-        public string Parent
-        {
-            get { return _parent; }
-            set { _parent = value; }
-        }
-
-        public uint Value
-        {
-            get { return _value; }
-        }
-
-        public string Name
-        {
-            get { return _name; }
-        }
-        
-        public virtual string Description
-        {
-            get { return string.Empty; }
-        }
-    }
-}
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Entities/IEntity.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Entities/IEntity.cs
deleted file mode 100644
index 7360a472..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Entities/IEntity.cs
+++ /dev/null
@@ -1,62 +0,0 @@
-// Entity interface.
-// Copyright (C) 2008-2010 Malcolm Crowe, Lex Li, and other contributors.
-// 
-// This library is free software; you can redistribute it and/or
-// modify it under the terms of the GNU Lesser General Public
-// License as published by the Free Software Foundation; either
-// version 2.1 of the License, or (at your option) any later version.
-// 
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-// Lesser General Public License for more details.
-// 
-// You should have received a copy of the GNU Lesser General Public
-// License along with this library; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-
-/*
- * Created by SharpDevelop.
- * User: lextm
- * Date: 2008/5/19
- * Time: 20:10
- * 
- * To change this template use Tools | Options | Coding | Edit Standard Headers.
- */
-
-using System;
-
-namespace Lextm.SharpSnmpLib.Mib.Elements.Entities
-{
-    /// <summary>
-    /// Basic interface for all elements building up the MIB tree, thus having an OID as value.
-    /// </summary>
-    public interface IEntity : IDeclaration
-    {
-        /// <summary>
-        /// Parent name.
-        /// </summary>
-        string Parent
-        {
-            get;
-            set;
-        }
-        
-        /// <summary>
-        /// Value.
-        /// </summary>
-        uint Value
-        {
-            get;            
-        }
-
-        /// <summary>
-        /// Gets the description.
-        /// </summary>
-        /// <value>The description.</value>
-        string Description
-        {
-            get;
-        }
-    }
-}
\ No newline at end of file
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Entities/ModuleCompliance.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Entities/ModuleCompliance.cs
deleted file mode 100644
index 008c3545..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Entities/ModuleCompliance.cs
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * Created by SharpDevelop.
- * User: lextm
- * Date: 2008/5/21
- * Time: 19:35
- * 
- * To change this template use Tools | Options | Coding | Edit Standard Headers.
- */
-
-namespace Lextm.SharpSnmpLib.Mib.Elements.Entities
-{
-    /// <summary>
-    /// Description of ModuleComplianceNode.
-    /// </summary>
-    public sealed class ModuleCompliance : EntityBase
-    {
-        public ModuleCompliance(IModule module, SymbolList preAssignSymbols, ISymbolEnumerator symbols)
-            : base(module, preAssignSymbols, symbols)
-        {
-        }
-       
-    }
-}
\ No newline at end of file
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Entities/ModuleIdentity.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Entities/ModuleIdentity.cs
deleted file mode 100644
index 6de28ce6..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Entities/ModuleIdentity.cs
+++ /dev/null
@@ -1,10 +0,0 @@
-namespace Lextm.SharpSnmpLib.Mib.Elements.Entities
-{
-    public sealed class ModuleIdentity : EntityBase
-    {
-        public ModuleIdentity(IModule module, SymbolList preAssignSymbols, ISymbolEnumerator symbols)
-            : base(module, preAssignSymbols, symbols)
-        {
-        }
-    }
-}
\ No newline at end of file
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Entities/NotificationGroup.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Entities/NotificationGroup.cs
deleted file mode 100644
index 27d3e4ce..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Entities/NotificationGroup.cs
+++ /dev/null
@@ -1,22 +0,0 @@
-/*
- * Created by SharpDevelop.
- * User: lextm
- * Date: 2008/5/21
- * Time: 19:34
- * 
- * To change this template use Tools | Options | Coding | Edit Standard Headers.
- */
-
-namespace Lextm.SharpSnmpLib.Mib.Elements.Entities
-{
-    /// <summary>
-    /// Description of NotificationGroupNode.
-    /// </summary>
-    public sealed class NotificationGroup : EntityBase
-    {
-        public NotificationGroup(IModule module, SymbolList preAssignSymbols, ISymbolEnumerator symbols)
-            : base(module, preAssignSymbols, symbols)
-        {
-        }
-   }
-}
\ No newline at end of file
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Entities/NotificationType.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Entities/NotificationType.cs
deleted file mode 100644
index 7386e217..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Entities/NotificationType.cs
+++ /dev/null
@@ -1,11 +0,0 @@
-
-namespace Lextm.SharpSnmpLib.Mib.Elements.Entities
-{
-    public sealed class NotificationType : EntityBase
-    {
-        public NotificationType(IModule module, SymbolList preAssignSymbols, ISymbolEnumerator symbols)
-            : base(module, preAssignSymbols, symbols)
-        {
-        }
-   }
-}
\ No newline at end of file
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Entities/ObjectGroup.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Entities/ObjectGroup.cs
deleted file mode 100644
index d846cdbb..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Entities/ObjectGroup.cs
+++ /dev/null
@@ -1,22 +0,0 @@
-/*
- * Created by SharpDevelop.
- * User: lextm
- * Date: 2008/5/21
- * Time: 19:27
- * 
- * To change this template use Tools | Options | Coding | Edit Standard Headers.
- */
-
-namespace Lextm.SharpSnmpLib.Mib.Elements.Entities
-{
-    /// <summary>
-    /// Description of ObjectGroupNode.
-    /// </summary>
-    public sealed class ObjectGroup : EntityBase
-    {
-        public ObjectGroup(IModule module, SymbolList preAssignSymbols, ISymbolEnumerator symbols)
-            : base(module, preAssignSymbols, symbols)
-        {
-        }
-   }
-}
\ No newline at end of file
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Entities/ObjectIdentity.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Entities/ObjectIdentity.cs
deleted file mode 100644
index 9c1e0848..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Entities/ObjectIdentity.cs
+++ /dev/null
@@ -1,21 +0,0 @@
-
-namespace Lextm.SharpSnmpLib.Mib.Elements.Entities
-{
-    /// <summary>
-    /// Object identifier node.
-    /// </summary>
-    public sealed class ObjectIdentity : EntityBase
-    {
-       
-        /// <summary>
-        /// Creates a <see cref="ObjectIdentity"/>.
-        /// </summary>
-        /// <param name="module">Module name</param>
-        /// <param name="header">Header</param>
-        /// <param name="lexer">Lexer</param>
-        public ObjectIdentity(IModule module, SymbolList preAssignSymbols, ISymbolEnumerator symbols)
-            : base(module, preAssignSymbols, symbols)
-        {
-        }
-    }
-}
\ No newline at end of file
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Entities/ObjectType.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Entities/ObjectType.cs
deleted file mode 100644
index 3a8b567a..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Entities/ObjectType.cs
+++ /dev/null
@@ -1,336 +0,0 @@
-using System;
-using System.Collections.Generic;
-using Lextm.SharpSnmpLib.Mib.Elements.Types;
-
-namespace Lextm.SharpSnmpLib.Mib.Elements.Entities
-{
-    public sealed class ObjectType : EntityBase, ITypeReferrer
-    {
-        private ITypeAssignment _syntax;
-        private string _units;
-        private MaxAccess _access;
-        private Status _status;
-        private string _description;
-        private string _reference;
-        private IList<string> _indices;
-        private string _augments;
-        private string _defVal;
-
-        public ObjectType(IModule module, SymbolList preAssignSymbols, ISymbolEnumerator symbols)
-            : base(module, preAssignSymbols, symbols)
-        {
-            ParseProperties(preAssignSymbols);
-        }
-
-        private void ParseProperties(SymbolList header)
-        {
-            ISymbolEnumerator headerSymbols = header.GetSymbolEnumerator();
-            Symbol temp = headerSymbols.NextNonEOLSymbol();
-
-            // Skip name
-            temp = headerSymbols.NextNonEOLSymbol();
-            temp.Expect(Symbol.ObjectType);
-
-            _syntax         = ParseSyntax       (Module, headerSymbols);
-            _units          = ParseUnits        (headerSymbols);
-            _access         = ParseAccess       (headerSymbols);
-            _status         = ParseStatus       (headerSymbols);
-            _description    = ParseDescription  (headerSymbols);
-            _reference      = ParseReference    (headerSymbols);
-            _indices        = ParseIndices      (headerSymbols);
-            _augments        = ParseAugments     (headerSymbols);
-            _defVal         = ParseDefVal       (headerSymbols);
-        }
-
-        private static string ParseAugments(ISymbolEnumerator symbols)
-        {
-            Symbol current = symbols.NextNonEOLSymbol();
-
-            if (current == Symbol.Augments)
-            {
-                string augment = null;
-
-                current = symbols.NextNonEOLSymbol();
-                current.Expect(Symbol.OpenBracket);
-
-                current = symbols.NextNonEOLSymbol();
-                augment = current.ToString();
-
-                current = symbols.NextNonEOLSymbol();
-                current.Expect(Symbol.CloseBracket);
-
-                return augment;
-            }
-            else if (current != null)
-            {
-                symbols.PutBack(current);
-            }
-            
-            return null;
-        }
-
-        private static string ParseDefVal(ISymbolEnumerator symbols)
-        {
-            Symbol current = symbols.NextNonEOLSymbol();
-
-            if (current == Symbol.DefVal)
-            {
-                current = symbols.NextNonEOLSymbol();
-                current.Expect(Symbol.OpenBracket);
-
-                string defVal = null;
-                current = symbols.NextNonEOLSymbol();
-
-                if (current == Symbol.OpenBracket)
-                {
-                    int depth = 1;
-                    // TODO: decode this.
-                    while (depth > 0)
-                    {
-                        current = symbols.NextNonEOLSymbol();
-                        if (current == Symbol.OpenBracket)
-                        {
-                            depth++;
-                        }
-                        else if (current == Symbol.CloseBracket)
-                        {
-                            depth--;
-                        }
-                    }
-                }
-                else
-                {
-                    defVal = current.ToString();
-                    current = symbols.NextNonEOLSymbol();
-                    current.Expect(Symbol.CloseBracket);
-                }
-
-                return defVal;
-            }
-            else if (current != null)
-            {
-                symbols.PutBack(current);
-            }
-
-            return null;
-        }
-
-        private static IList<string> ParseIndices(ISymbolEnumerator symbols)
-        {
-            Symbol current = symbols.NextNonEOLSymbol();
-
-            if (current == Symbol.Index)
-            {
-                current = symbols.NextNonEOLSymbol();
-                current.Expect(Symbol.OpenBracket);
-
-                List<string> indices = new List<string>();
-
-                while (current != Symbol.CloseBracket)
-                {
-                   current = symbols.NextNonEOLSymbol();
-                   
-                   bool lastIndex = false;
-                    if (current == Symbol.Implied)
-                    {
-                        current = symbols.NextNonEOLSymbol();
-                        lastIndex = true; // 'IMPLIED' may only be used for last index 
-                    }
-
-                    current.Assert((current != Symbol.Comma) && (current != Symbol.CloseBracket), "Expected index name but found symbol!");
-                    indices.Add(current.ToString());
-
-                    current = symbols.NextNonEOLSymbol();
-                    if (lastIndex)
-                    {
-                       current.Expect(Symbol.CloseBracket);
-                    }
-                    else
-                    {
-                       current.Expect(Symbol.Comma, Symbol.CloseBracket);
-                    }
-                }
-
-                return indices;
-            }
-            else if (current != null)
-            {
-                symbols.PutBack(current);
-            }
-
-            return null;
-        }
-
-        private static string ParseReference(ISymbolEnumerator symbols)
-        {
-            Symbol current = symbols.NextNonEOLSymbol();
-
-            if (current == Symbol.Reference)
-            {
-                return symbols.NextNonEOLSymbol().ToString();
-            }
-            else if (current != null)
-            {
-                symbols.PutBack(current);
-            }
-
-            return null;
-        }
-
-        private static string ParseDescription(ISymbolEnumerator symbols)
-        {
-            Symbol current = symbols.NextNonEOLSymbol();
-
-            if (current == Symbol.Description)
-            {
-                return symbols.NextNonEOLSymbol().ToString().Trim(new char[] { '"' });
-            }
-            else if (current != null)
-            {
-                symbols.PutBack(current);
-            }
-
-            return null;
-        }
-
-        private static Status ParseStatus(ISymbolEnumerator symbols)
-        {
-            Status status = Status.obsolete;
-
-            Symbol current = symbols.NextNonEOLSymbol();
-            current.Expect(Symbol.Status);
-            
-            current = symbols.NextNonEOLSymbol();
-            try
-            {
-                status = (Status)Enum.Parse(typeof(Status), current.ToString());
-            }
-            catch (ArgumentException)
-            {
-                current.Assert(false, "Invalid/Unknown status");
-            }
-            
-            return status;
-        }
-
-        private static MaxAccess ParseAccess(ISymbolEnumerator symbols)
-        {
-            MaxAccess access = MaxAccess.notAccessible;
-
-            Symbol current = symbols.NextNonEOLSymbol();
-            current.Expect(Symbol.MaxAccess, Symbol.Access);
-
-            current = symbols.NextNonEOLSymbol();
-            switch (current.ToString())
-            {
-                case "not-accessible":
-                    access = MaxAccess.notAccessible;
-                    break;
-                case "accessible-for-notify":
-                    access = MaxAccess.accessibleForNotify;
-                    break;
-                case "read-only":
-                    access = MaxAccess.readOnly;
-                    break;
-                case "read-write":
-                    access = MaxAccess.readWrite;
-                    break;
-                case "read-create":
-                    access = MaxAccess.readCreate;
-                    break;
-                case "write-only":
-                    access = MaxAccess.readWrite;
-                    break;
-                default:
-                    current.Assert(false, "Invalid/Unknown access");
-                    break;
-            }
-
-            return access;
-        }
-
-        private static string ParseUnits(ISymbolEnumerator symbols)
-        {
-            Symbol current = symbols.NextNonEOLSymbol();
-
-            if (current == Symbol.Units)
-            {
-                return symbols.NextNonEOLSymbol().ToString();
-            }
-            else if (current != null)
-            {
-                symbols.PutBack(current);
-            }
-
-            return null;
-        }
-
-        private static ITypeAssignment ParseSyntax(IModule module, ISymbolEnumerator symbols)
-        {
-            Symbol current = symbols.NextNonEOLSymbol();
-            current.Expect(Symbol.Syntax);
-
-            return Lexer.ParseBasicTypeDef(module, String.Empty, symbols, isMacroSyntax: true);
-        }
-
-        private static bool IsProperty(Symbol sym)
-        {
-            string s = sym.ToString();
-            return s == "SYNTAX" || s == "MAX-ACCESS" || s == "STATUS" || s == "DESCRIPTION";
-        }
-
-        public ITypeAssignment Syntax
-        {
-            get { return _syntax; }
-            internal set { _syntax = value; }
-        }
-
-        public override string Description
-        {
-            get { return _description; }
-        }
-
-        public MaxAccess Access
-        {
-            get { return _access; }
-        }
-
-        public IList<string> Indices
-        {
-            get { return _indices; }
-        }
-
-        public string Augments
-        {
-            get { return _augments; }
-        }
-
-        #region ITypeReferrer Member
-
-        public ITypeAssignment ReferredType
-        {
-            get { return _syntax; }
-            set { _syntax = value; }
-        }
-
-        public ITypeAssignment BaseType
-        {
-            get
-            {
-                ITypeReferrer   tr     = this;
-                ITypeAssignment result = null;
-
-                while ((tr != null) && (tr.ReferredType != null))
-                {
-                    result = tr.ReferredType;
-                    tr = tr.ReferredType as ITypeReferrer;
-                }
-
-                return result;
-            }
-        }
-
-        #endregion
-
-    }
-}
\ No newline at end of file
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Entities/OidValueAssignment.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Entities/OidValueAssignment.cs
deleted file mode 100644
index 3c659407..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Entities/OidValueAssignment.cs
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Created by SharpDevelop.
- * User: lextm
- * Date: 2008/5/17
- * Time: 20:49
- * 
- * To change this template use Tools | Options | Coding | Edit Standard Headers.
- */
-
-using System;
-
-namespace Lextm.SharpSnmpLib.Mib.Elements.Entities
-{
-    /// <summary>
-    /// Object identifier node.
-    /// </summary>
-    public sealed class OidValueAssignment : EntityBase
-    {
-        /// <summary>
-        /// Creates a <see cref="OidValueAssignment"/>.
-        /// </summary>
-        /// <param name="module">Module</param>
-        /// <param name="name">Name</param>
-        /// <param name="lexer">Lexer</param>
-        public OidValueAssignment(IModule module, SymbolList preAssignSymbols, ISymbolEnumerator symbols)
-            : base(module, preAssignSymbols, symbols)
-        {
-        }
-    }
-}
\ No newline at end of file
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Exports.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Exports.cs
deleted file mode 100644
index c1e66e32..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Exports.cs
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Created by SharpDevelop.
- * User: lextm
- * Date: 2008/6/7
- * Time: 17:34
- * 
- * To change this template use Tools | Options | Coding | Edit Standard Headers.
- */
-
-using System.Collections.Generic;
-
-namespace Lextm.SharpSnmpLib.Mib.Elements
-{
-    /// <summary>
-    /// Description of Exports.
-    /// </summary>
-    public sealed class Exports: IElement
-    {
-        private IModule _module;
-        private readonly IList<string> _types = new List<string>();
-
-        public Exports(IModule module, ISymbolEnumerator s)
-        {
-            _module = module;
-
-            Symbol previous = null;
-            Symbol current;
-            do
-            {
-                current = s.NextSymbol();
-
-                if (current == Symbol.EOL)
-                {
-                    continue;
-                }
-                else if (((current == Symbol.Comma) || (current == Symbol.Semicolon)) && (previous != null))
-                {
-                    previous.AssertIsValidIdentifier();
-                    _types.Add(previous.ToString());
-                }
-
-                previous = current;
-            }
-            while (current != Symbol.Semicolon);
-        }
-
-        #region IElement Member
-
-        public IModule Module
-        {
-            get { return _module; }
-        }
-
-        #endregion
-    }
-}
\ No newline at end of file
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/IDeclaration.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/IDeclaration.cs
deleted file mode 100644
index 0958ac61..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/IDeclaration.cs
+++ /dev/null
@@ -1,18 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-
-namespace Lextm.SharpSnmpLib.Mib.Elements
-{
-    public interface IDeclaration: IElement
-    {
-        /// <summary>
-        /// Name.
-        /// </summary>
-        string Name
-        {
-            get;
-        }
-    }
-}
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/IElement.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/IElement.cs
deleted file mode 100644
index e2db7fd3..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/IElement.cs
+++ /dev/null
@@ -1,35 +0,0 @@
-﻿// Construct interface.
-// Copyright (C) 2008-2010 Malcolm Crowe, Lex Li, and other contributors.
-// 
-// This library is free software; you can redistribute it and/or
-// modify it under the terms of the GNU Lesser General Public
-// License as published by the Free Software Foundation; either
-// version 2.1 of the License, or (at your option) any later version.
-// 
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-// Lesser General Public License for more details.
-// 
-// You should have received a copy of the GNU Lesser General Public
-// License along with this library; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-
-namespace Lextm.SharpSnmpLib.Mib.Elements
-{
-    /// <summary>
-    /// Construct interface.
-    /// </summary>
-    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1040:AvoidEmptyInterfaces")]
-    public interface IElement
-    {
-        /// <summary>
-        /// Containing module.
-        /// </summary>
-        IModule Module
-        {
-            get;
-        }
-
-    }
-}
\ No newline at end of file
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/ITypeReferrer.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/ITypeReferrer.cs
deleted file mode 100644
index f0f57056..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/ITypeReferrer.cs
+++ /dev/null
@@ -1,10 +0,0 @@
-﻿using Lextm.SharpSnmpLib.Mib.Elements.Types;
-
-namespace Lextm.SharpSnmpLib.Mib.Elements
-{
-    public interface ITypeReferrer
-    {
-        ITypeAssignment ReferredType { get; set; }
-        ITypeAssignment BaseType { get; }
-    }
-}
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Imports.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Imports.cs
deleted file mode 100644
index 3a4ec6ec..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Imports.cs
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * Created by SharpDevelop.
- * User: lextm
- * Date: 2008/5/31
- * Time: 12:07
- * 
- * To change this template use Tools | Options | Coding | Edit Standard Headers.
- */
-
-using System.Collections.Generic;
-
-namespace Lextm.SharpSnmpLib.Mib.Elements
-{
-    /// <summary>
-    /// The IMPORTS construct is used to specify items used in the current MIB module which are defined in another MIB module or ASN.1 module.
-    /// </summary>
-    public sealed class Imports : List<ImportsFrom>, IElement
-    {
-        private IModule _module;
-
-        /// <summary>
-        /// Creates an <see cref="Imports"/> instance.
-        /// </summary>
-        /// <param name="lexer"></param>
-        public Imports(IModule module, ISymbolEnumerator symbols)
-        {
-            _module = module;
-
-            Symbol current;
-            while ((current = symbols.NextSymbol()) != Symbol.Semicolon)
-            {
-                if (current == Symbol.EOL)
-                {
-                    continue;
-                }
-
-                ImportsFrom imports = new ImportsFrom(current, symbols);
-
-                this.Add(imports);
-            }
-        }
-
-        public IList<string> Dependents
-        {
-            get
-            {
-                List<string> result = new List<string>();
-
-                foreach (ImportsFrom import in this)
-                {
-                    result.Add(import.Module);
-                }
-
-                return result;
-            }
-        }
-
-        public ImportsFrom GetImportFromType(string type)
-        {
-            foreach (ImportsFrom import in this)
-            {
-                if (import.Types.Contains(type))
-                {
-                    return import;
-                }
-            }
-
-            return null;
-        }
-       
-        #region IElement Member
-
-        public IModule Module
-        {
-            get { return _module; }
-        }
-
-        #endregion
-
-    }
-}
\ No newline at end of file
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/ImportsFrom.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/ImportsFrom.cs
deleted file mode 100644
index cd5154bd..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/ImportsFrom.cs
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Created by SharpDevelop.
- * User: lextm
- * Date: 2008/5/31
- * Time: 12:07
- * 
- * To change this template use Tools | Options | Coding | Edit Standard Headers.
- */
-
-using System.Collections.Generic;
-
-namespace Lextm.SharpSnmpLib.Mib.Elements
-{
-    public sealed class ImportsFrom
-    {
-        private readonly string _module;
-        private readonly List<string> _types = new List<string>();
-
-        public ImportsFrom(Symbol last, ISymbolEnumerator symbols)
-        {
-            Symbol previous = last;
-            Symbol current;
-            while ((current = symbols.NextSymbol()) != Symbol.From)
-            {
-                if (current == Symbol.EOL) 
-                {
-                    continue;
-                }
-                
-                if (current == Symbol.Comma)
-                {
-                    previous.AssertIsValidIdentifier();
-                    _types.Add(previous.ToString());
-                }
-                
-                previous = current;
-            }
-
-            previous.AssertIsValidIdentifier();
-            _types.Add(previous.ToString());
-
-            _module = symbols.NextSymbol().ToString().ToUpperInvariant(); // module names are uppercase
-        }
-        
-        public string Module
-        {
-            get { return _module; }
-        }
-
-        public IList<string> Types
-        {
-            get { return _types; }
-        }
-
-        public override string ToString()
-        {
-            return string.Join(", ", _types.ToArray()) + " FROM " + _module;
-        }
-    }
-}
\ No newline at end of file
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/TrapType.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/TrapType.cs
deleted file mode 100644
index 9c5ca457..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/TrapType.cs
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Created by SharpDevelop.
- * User: lextm
- * Date: 2008/5/31
- * Time: 12:20
- * 
- * To change this template use Tools | Options | Coding | Edit Standard Headers.
- */
-
-namespace Lextm.SharpSnmpLib.Mib.Elements
-{
-    public sealed class TrapType : IDeclaration
-    {
-        private readonly IModule _module;
-        private readonly string _name;
-        private readonly int _value;
-
-        public TrapType(IModule module, SymbolList preAssignSymbols, ISymbolEnumerator symbols)
-        {
-            _module = module;
-            _name = preAssignSymbols[0].ToString();
-
-            Symbol valueSymbol = symbols.NextNonEOLSymbol();
-
-            bool succeeded = int.TryParse(valueSymbol.ToString(), out _value);
-            valueSymbol.Assert(succeeded, "not a decimal");
-        }
-
-        public int Value
-        {
-            get { return _value; }
-        }
-
-        #region IDeclaration Member
-
-        public IModule Module
-        {
-            get { return _module; }
-        }
-
-        public string Name
-        {
-            get { return _name; }
-        }
-
-        #endregion
-    }
-}
\ No newline at end of file
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Types/BaseType.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Types/BaseType.cs
deleted file mode 100644
index a4412812..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Types/BaseType.cs
+++ /dev/null
@@ -1,54 +0,0 @@
-﻿
-namespace Lextm.SharpSnmpLib.Mib.Elements.Types
-{
-    public abstract class BaseType : ITypeAssignment
-    {
-        private IModule _module;
-        private string _name;
-
-        protected BaseType(IModule module, string name)
-        {
-            _module = module;
-            _name   = name;
-        }
-
-        public virtual IModule Module
-        {
-            // differentiate between:
-            //    FddiTimeNano ::= INTEGER (0..2147483647) 
-            //    which is an IntegerType which appears under Types in a MibModule and therefore has a name and module
-            // and
-            //    SYNTAX INTEGER (0..2147483647) 
-            //    which is also an IntegerType but not defined as a separate type and therefore has NO name and NO module
-            get
-            {
-                if (!string.IsNullOrEmpty(_name))
-                {
-                    return _module;
-                }
-                else
-                {
-                    return null;
-                }                
-            }
-            protected set { _module = value; }
-        }
-
-        public virtual string Name
-        {
-            get
-            {
-                if (!string.IsNullOrEmpty(_name))
-                {
-                    return _name;
-                }
-                else
-                {
-                    return "{ Implicit Base Type }";
-                }
-            }
-            protected set { _name = value; }
-        }
-
-    }
-}
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Types/BitsType.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Types/BitsType.cs
deleted file mode 100644
index a64c8dbe..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Types/BitsType.cs
+++ /dev/null
@@ -1,26 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-
-namespace Lextm.SharpSnmpLib.Mib.Elements.Types
-{
-    public class BitsType : BaseType
-    {
-        private ValueMap _map;
-
-        public BitsType(IModule module, string name, ISymbolEnumerator symbols)
-            : base(module, name)
-        {
-            _map = Lexer.DecodeEnumerations(symbols);
-        }
-
-        public ValueMap Map
-        {
-            get { return _map; }
-        }
-
-        public string this[int value]
-        {
-            get { return _map[value]; }
-        }
-    }
-}
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Types/Choice.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Types/Choice.cs
deleted file mode 100644
index c66d1f3f..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Types/Choice.cs
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Created by SharpDevelop.
- * User: lextm
- * Date: 2008/5/31
- * Time: 11:39
- * 
- * To change this template use Tools | Options | Coding | Edit Standard Headers.
- */
-
-namespace Lextm.SharpSnmpLib.Mib.Elements.Types
-{
-    /// <summary>
-    /// The CHOICE type represents a list of alternatives..
-    /// </summary>
-    public sealed class Choice : BaseType
-    {
-        /// <summary>
-        /// Creates a <see cref="Choice"/> instance.
-        /// </summary>
-        /// <param name="module"></param>
-        /// <param name="name"></param>
-        /// <param name="lexer"></param>
-        public Choice(IModule module, string name, ISymbolEnumerator symbols)
-            : base(module, name)
-        {
-            while (symbols.NextNonEOLSymbol() != Symbol.OpenBracket)
-            {
-            }
-
-            while (symbols.NextNonEOLSymbol() != Symbol.CloseBracket)
-            {
-            }
-        }
-    }
-}
\ No newline at end of file
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Types/ITypeAssignment.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Types/ITypeAssignment.cs
deleted file mode 100644
index e962f9df..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Types/ITypeAssignment.cs
+++ /dev/null
@@ -1,6 +0,0 @@
-﻿namespace Lextm.SharpSnmpLib.Mib.Elements.Types
-{
-    public interface ITypeAssignment : IDeclaration
-    {
-    }
-}
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Types/IntegerType.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Types/IntegerType.cs
deleted file mode 100644
index 4841ad51..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Types/IntegerType.cs
+++ /dev/null
@@ -1,117 +0,0 @@
-/*
- * Created by SharpDevelop.
- * User: lextm
- * Date: 2008/7/25
- * Time: 20:41
- * 
- * To change this template use Tools | Options | Coding | Edit Standard Headers.
- */
-
-using System;
-using System.Collections.Generic;
-
-namespace Lextm.SharpSnmpLib.Mib.Elements.Types
-{
-    /// <summary>
-    /// The INTEGER type represents a list of alternatives, or a range of numbers..
-    /// Includes Integer32 as it's indistinguishable from INTEGER.
-    /// </summary>
-    /**
-     * As this type is used for Integer32 as well as INTEGER it incorrectly
-     * allows enumeration sub-typing of Integer32.  This is ok as currently we
-     * do not care about detecting incorrect MIBs and this doesn't block the
-     * decoding of correct MIBs.
-     */
-    public sealed class IntegerType : BaseType
-    {
-        public enum Types
-        {
-            Integer,
-            Integer32
-        }
-
-        private Types _type;
-        private bool _isEnumeration;
-        private ValueMap _map;
-        private ValueRanges _ranges;
-
-        /// <summary>
-        /// Creates an <see cref="IntegerType"/> instance.
-        /// </summary>
-        /// <param name="module"></param>
-        /// <param name="name"></param>
-        /// <param name="enumerator"></param>
-        public IntegerType(IModule module, string name, Symbol type, ISymbolEnumerator symbols)
-            : base (module, name)
-        {
-            Types? t = GetExactType(type);
-            type.Assert(t.HasValue, "Unknown symbol for unsigned type!");
-            _type = t.Value;
-
-            _isEnumeration = false;
-
-            Symbol current = symbols.NextNonEOLSymbol();
-            if (current == Symbol.OpenBracket)
-            {
-                _isEnumeration = true;
-                symbols.PutBack(current);
-                _map = Lexer.DecodeEnumerations(symbols);
-            }
-            else if (current == Symbol.OpenParentheses)
-            {
-                symbols.PutBack(current);
-                _ranges = Lexer.DecodeRanges(symbols);
-                current.Assert(!_ranges.IsSizeDeclaration, "SIZE keyword is not allowed for ranges of integer types!");
-            }
-            else
-            {
-                symbols.PutBack(current);
-            }
-        }
-
-        public Types Type
-        {
-            get { return _type; }
-        }
-
-        public ValueRanges Ranges
-        {
-            get { return _ranges; }
-        }
-
-        public bool IsEnumeration
-        {
-            get
-            {
-                return _isEnumeration;
-            }
-        }
-
-        public ValueMap Enumeration
-        {
-            get { return _isEnumeration ? _map : null; }
-        }
-
-        internal static Types? GetExactType(Symbol symbol)
-        {
-            if (symbol == Symbol.Integer)
-            {
-                // represents the ASN.1 builtin INTEGER type:
-                //  may be represent any arbitrary (signed/unsigned) integer (in theory may have any size)
-                return Types.Integer;
-            }
-            else if (symbol == Symbol.Integer32)
-            {
-                // Integer32 ::= INTEGER (-2147483648..2147483647) // from SNMPv2-SMI
-                return Types.Integer32;
-            }
-
-            return null;
-        }
-
-        internal static bool IsIntegerType(Symbol symbol)
-        {
-            return GetExactType(symbol).HasValue;
-        }
-    }
-}
\ No newline at end of file
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Types/IpAddressType.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Types/IpAddressType.cs
deleted file mode 100644
index 84d78d66..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Types/IpAddressType.cs
+++ /dev/null
@@ -1,21 +0,0 @@
-﻿
-namespace Lextm.SharpSnmpLib.Mib.Elements.Types
-{
-    public class IpAddressType : OctetStringType
-    {
-        public IpAddressType(IModule module, string name, ISymbolEnumerator symbols)
-            : base(module, name, symbols)
-        {
-            if (this.Size.Count != 0)
-            {
-                throw new MibException("Size definition not allowed for IpAddress type!");
-            }
-
-            // IpAddress type is defined as:
-            // IpAddress ::=
-            //    [APPLICATION 0]
-            //        IMPLICIT OCTET STRING (SIZE (4))
-            this.Size.Add(new ValueRange(4, null));
-        }
-    }
-}
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Types/Macro.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Types/Macro.cs
deleted file mode 100644
index 9f911ac9..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Types/Macro.cs
+++ /dev/null
@@ -1,34 +0,0 @@
-﻿
-namespace Lextm.SharpSnmpLib.Mib.Elements.Types
-{
-    public sealed class Macro : ITypeAssignment
-    {
-        private IModule _module;
-        private string _name;
-
-        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1804:RemoveUnusedLocals", MessageId = "temp")]
-        public Macro(IModule module, SymbolList preAssignSymbols, ISymbolEnumerator symbols)
-        {
-            _module = module;
-            _name = preAssignSymbols[0].ToString();
-            
-            while (symbols.NextNonEOLSymbol() != Symbol.Begin)
-            {                
-            }
-
-            while (symbols.NextNonEOLSymbol() != Symbol.End)
-            {
-            }
-        }
-
-        public IModule Module
-        {
-            get { return _module; }
-        }
-
-        public string Name
-        {
-            get { return _name; }
-        }
-    }
-}
\ No newline at end of file
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Types/ObjectIdentifierType.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Types/ObjectIdentifierType.cs
deleted file mode 100644
index cacd415a..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Types/ObjectIdentifierType.cs
+++ /dev/null
@@ -1,11 +0,0 @@
-﻿
-namespace Lextm.SharpSnmpLib.Mib.Elements.Types
-{
-    public class ObjectIdentifierType : BaseType
-    {
-        public ObjectIdentifierType(IModule module, string name, ISymbolEnumerator symbols)
-            : base(module, name)
-        {
-        }
-    }
-}
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Types/OctetStringType.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Types/OctetStringType.cs
deleted file mode 100644
index f6453ce8..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Types/OctetStringType.cs
+++ /dev/null
@@ -1,31 +0,0 @@
-﻿using System.Collections.Generic;
-
-namespace Lextm.SharpSnmpLib.Mib.Elements.Types
-{
-    public class OctetStringType : BaseType
-    {
-        private ValueRanges _size;
-
-        public OctetStringType(IModule module, string name, ISymbolEnumerator symbols)
-            : base(module, name)
-        {
-            Symbol current = symbols.NextNonEOLSymbol();
-            if (current == Symbol.OpenParentheses)
-            {
-                symbols.PutBack(current);
-                _size = Lexer.DecodeRanges(symbols);
-                current.Assert(_size.IsSizeDeclaration, "SIZE keyword is required for ranges of octet string!");
-            }
-            else
-            {
-                symbols.PutBack(current);
-                _size   = new ValueRanges(isSizeDecl: true);
-            }
-        }
-
-        public ValueRanges Size
-        {
-            get { return _size; }
-        }
-    }
-}
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Types/OpaqueType.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Types/OpaqueType.cs
deleted file mode 100644
index 5a7eda33..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Types/OpaqueType.cs
+++ /dev/null
@@ -1,11 +0,0 @@
-﻿
-namespace Lextm.SharpSnmpLib.Mib.Elements.Types
-{
-    public class OpaqueType : OctetStringType
-    {
-        public OpaqueType(IModule module, string name, ISymbolEnumerator symbols)
-            : base(module, name, symbols)
-        {
-        }
-    }
-}
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Types/Sequence.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Types/Sequence.cs
deleted file mode 100644
index 0162de30..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Types/Sequence.cs
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Created by SharpDevelop.
- * User: lextm
- * Date: 2008/5/21
- * Time: 19:43
- * 
- * To change this template use Tools | Options | Coding | Edit Standard Headers.
- */
-
-
-namespace Lextm.SharpSnmpLib.Mib.Elements.Types
-{
-    /// <summary>
-    /// The SEQUENCE type represents a set of specified types. This is roughtly analogous to a <code>struct</code> in C.
-    /// </summary>
-    public sealed class Sequence : BaseType
-    {
-        /// <summary>
-        /// Creates a <see cref="Sequence" /> instance.
-        /// </summary>
-        /// <param name="module">The module.</param>
-        /// <param name="name">The name.</param>
-        /// <param name="symbols">The enumerator.</param>
-        public Sequence(IModule module, string name, ISymbolEnumerator symbols)
-            : base(module, name)
-        {
-            // parse between ( )
-            Symbol temp = symbols.NextNonEOLSymbol();
-            int bracketSection = 0;
-            temp.Expect(Symbol.OpenBracket);
-            bracketSection++;
-            while (bracketSection > 0)
-            {
-                temp = symbols.NextNonEOLSymbol();
-                if (temp == Symbol.OpenBracket)
-                {
-                    bracketSection++;
-                }
-                else if (temp == Symbol.CloseBracket)
-                {
-                    bracketSection--;
-                }
-            }
-        }
-    }
-}
\ No newline at end of file
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Types/SequenceOf.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Types/SequenceOf.cs
deleted file mode 100644
index 4160ca40..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Types/SequenceOf.cs
+++ /dev/null
@@ -1,23 +0,0 @@
-using System.Collections.Generic;
-
-namespace Lextm.SharpSnmpLib.Mib.Elements.Types
-{
-    /// <summary>
-    /// The SEQUENCE OF type represents a list of data sets..
-    /// </summary>
-    public sealed class SequenceOf : BaseType
-    {
-        private string _type;
-
-        public SequenceOf(IModule module, string name, ISymbolEnumerator sym)
-            : base(module, name)
-        {
-            _type = sym.NextNonEOLSymbol().ToString();
-        }
-
-        public string Type
-        {
-            get { return _type; }
-        }
-    }
-}
\ No newline at end of file
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Types/TextualConvention.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Types/TextualConvention.cs
deleted file mode 100644
index ab477315..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Types/TextualConvention.cs
+++ /dev/null
@@ -1,238 +0,0 @@
-﻿using System;
-
-namespace Lextm.SharpSnmpLib.Mib.Elements.Types
-{
-    public sealed class TextualConvention : ITypeAssignment, ITypeReferrer
-    {
-        private IModule _module;
-        private string _name;
-        private DisplayHint _displayHint;
-        private Status _status;
-        private string _description;
-        private string _reference;
-        private ITypeAssignment _syntax;
-
-        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId = "module")]
-        public TextualConvention(IModule module, string name, ISymbolEnumerator symbols)
-        {
-            _module = module;
-            _name = name;
-
-            _displayHint = ParseDisplayHint(symbols);
-            _status      = ParseStatus(symbols);
-            _description = ParseDescription(symbols);
-            _reference   = ParseReference(symbols);
-            _syntax      = ParseSyntax(module, symbols);
-        }
-
-        private static DisplayHint ParseDisplayHint(ISymbolEnumerator symbols)
-        {
-            Symbol current = symbols.NextNonEOLSymbol();
-
-            if (current == Symbol.DisplayHint)
-            {
-                return new DisplayHint(symbols.NextNonEOLSymbol().ToString().Trim(new char[] { '"' }));
-            }
-
-            symbols.PutBack(current);
-            return null;
-        }
-
-        private static Status ParseStatus(ISymbolEnumerator symbols)
-        {
-            Symbol current = symbols.NextNonEOLSymbol();
-            current.Expect(Symbol.Status);
-
-            try
-            {
-                return (Status)Enum.Parse(typeof(Status), symbols.NextNonEOLSymbol().ToString());
-            }
-            catch (ArgumentException)
-            {
-                current.Assert(false, "Invalid/Unknown status");
-            }
-
-            return Status.current;
-        }
-
-        private static string ParseDescription(ISymbolEnumerator symbols)
-        {
-            Symbol current = symbols.NextNonEOLSymbol();
-            current.Expect(Symbol.Description);
-
-            return symbols.NextNonEOLSymbol().ToString().Trim(new char[] { '"' });
-        }
-
-        private static string ParseReference(ISymbolEnumerator symbols)
-        {
-            Symbol current = symbols.NextNonEOLSymbol();
-
-            if (current == Symbol.Reference)
-            {
-                string reference = symbols.NextNonEOLSymbol().ToString();
-                if ((reference.Length >= 2) && reference.StartsWith("\"") && reference.EndsWith("\""))
-                {
-                    return reference.Substring(1, reference.Length-2);
-                }
-
-                return reference;
-            }
-
-            symbols.PutBack(current);
-            return null;
-        }
-
-        private static ITypeAssignment ParseSyntax(IModule module, ISymbolEnumerator symbols)
-        {
-            Symbol current = symbols.NextNonEOLSymbol();
-            current.Expect(Symbol.Syntax);
-
-            /* 
-             * RFC2579 definition:
-             *       Syntax ::=   -- Must be one of the following:
-             *                    -- a base type (or its refinement), or
-             *                    -- a BITS pseudo-type
-             *               type
-             *             | "BITS" "{" NamedBits "}"
-             *
-             * From section 3.5:
-             *      The data structure must be one of the alternatives defined
-             *      in the ObjectSyntax CHOICE or the BITS construct.  Note
-             *      that this means that the SYNTAX clause of a Textual
-             *      Convention can not refer to a previously defined Textual
-             *      Convention.
-             *      
-             *      The SYNTAX clause of a TEXTUAL CONVENTION macro may be
-             *      sub-typed in the same way as the SYNTAX clause of an
-             *      OBJECT-TYPE macro.
-             * 
-             * Therefore the possible values are (grouped by underlying type):
-             *      INTEGER, Integer32
-             *      OCTET STRING, Opaque
-             *      OBJECT IDENTIFIER
-             *      IpAddress
-             *      Counter64
-             *      Unsigned32, Counter32, Gauge32, TimeTicks
-             *      BITS
-             * With appropriate sub-typing.
-             */
-
-            return Lexer.ParseBasicTypeDef(module, String.Empty, symbols, isMacroSyntax: true);
-        }
-
-        public IModule Module
-        {
-            get { return _module; }
-        }
-
-        public string Name
-        {
-            get { return _name; }
-        }
-
-        public string DisplayHint
-        {
-            get { return _displayHint == null ? null : _displayHint.ToString(); }
-        }
-
-        public Status Status
-        {
-            get { return _status; }
-        }
-
-        public string Description
-        {
-            get { return _description; }
-        }
-
-        public string Reference
-        {
-            get { return _reference; }
-        }
-
-        public ITypeAssignment Syntax
-        {
-            get { return _syntax; }
-        }
-
-        //internal object Decode(Variable v)
-        //{
-        //    if (_syntax is IntegerType)
-        //    {
-        //        Integer32 i = v.Data as Integer32;
-        //        if (i == null || (_syntax as IntegerType).IsEnumeration)
-        //        {
-        //            return null;
-        //        }
-        //        else if (_displayHint != null)
-        //        {
-        //            return _displayHint.Decode(i.ToInt32());
-        //        }
-        //        else
-        //        {
-        //            return i.ToInt32();
-        //        }
-        //    }
-        //    else if (_syntax is UnsignedType)
-        //    {
-        //        Integer32 i = v.Data as Integer32;
-        //        if (i == null)
-        //        {
-        //            return null;
-        //        }
-        //        else if (_displayHint != null)
-        //        {
-        //            return _displayHint.Decode(i.ToInt32());
-        //        }
-        //        else
-        //        {
-        //            return i.ToInt32();
-        //        }
-        //    }
-        //    else if (_syntax is OctetStringType)
-        //    {
-        //        OctetString o = v.Data as OctetString;
-        //        if (o == null)
-        //        {
-        //            return null;
-        //        }
-        //        else
-        //        {
-        //            // TODO: Follow the format specifier for octet strings.
-        //            return null;
-        //        }
-        //    }
-        //    else
-        //    {
-        //        return null;
-        //    }
-        //}
-
-        #region ITypeReferrer Member
-
-        public ITypeAssignment ReferredType
-        {
-            get { return _syntax; }
-            set { _syntax = value; }
-        }
-
-        public ITypeAssignment BaseType
-        {
-            get
-            {
-                ITypeReferrer   tr     = this;
-                ITypeAssignment result = this;
-
-                while ((tr != null) && (tr.ReferredType != null))
-                {
-                    result = tr.ReferredType;
-                    tr = tr.ReferredType as ITypeReferrer;
-                }
-
-                return result;
-            }
-        }
-
-        #endregion
-    }
-}
\ No newline at end of file
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Types/TypeAssignment.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Types/TypeAssignment.cs
deleted file mode 100644
index b074ef62..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Types/TypeAssignment.cs
+++ /dev/null
@@ -1,147 +0,0 @@
-/*
- * Created by SharpDevelop.
- * User: lextm
- * Date: 2008/5/18
- * Time: 13:24
- * 
- * To change this template use Tools | Options | Coding | Edit Standard Headers.
- */
-using System;
-using System.Collections.Generic;
-
-namespace Lextm.SharpSnmpLib.Mib.Elements.Types
-{
-    /* Please be aware of the following possible constructs:
-     * 
-     *    isnsRegEntityIndex          OBJECT-TYPE
-     *    SYNTAX                      IsnsEntityIndexIdOrZero
-     *                                ( 1 .. 4294967295 )
-     *    MAX-ACCESS              not-accessible
-     * 
-     * 
-     */
-
-    /// <summary/>
-    /// </summary>
-    public sealed class TypeAssignment : ITypeAssignment
-    {
-        private IModule _module;
-        private string _name;
-        private string _type;
-        private ValueRanges _ranges;
-        private ValueMap _map;
-
-        /// <summary>
-        /// Creates an <see cref="TypeAssignment" />.
-        /// </summary>
-        /// <param name="module">The module.</param>
-        /// <param name="name">The name.</param>
-        /// <param name="type">The type.</param>
-        /// <param name="symbols">The symbols.</param>
-        /// <param name="isMacroSyntax">if set to <c>true</c> indicates that the syntax clause of a macro is parsed (e.g. OBJECT-TYPE, TEXTUAL-CONVENTION).</param>
-        public TypeAssignment(IModule module, string name, Symbol type, ISymbolEnumerator symbols, bool isMacroSyntax)
-        {
-            _module = module;
-            _name   = name;
-
-            SymbolList typeSymbols = new SymbolList();
-            typeSymbols.Add(type);
-
-            Symbol current = symbols.NextSymbol();
-            while (current != Symbol.EOL)
-            {
-                if (current == Symbol.OpenParentheses)
-                {
-                    // parse range of unknown type
-                    symbols.PutBack(current);
-                    _ranges = Lexer.DecodeRanges(symbols);
-                    break;
-                }
-                else if (current == Symbol.OpenBracket)
-                {
-                    symbols.PutBack(current);
-                    _map = Lexer.DecodeEnumerations(symbols);
-                    break;
-                }
-
-                typeSymbols.Add(current);
-                current = symbols.NextSymbol();
-            }
-
-            _type = typeSymbols.Join(" ");
-
-            if ((_ranges == null) && (_map == null))
-            {
-                current = symbols.NextNonEOLSymbol();
-                if (current == Symbol.OpenParentheses)
-                {
-                    // parse range of unknown type
-                    symbols.PutBack(current);
-                    _ranges = Lexer.DecodeRanges(symbols);
-                }
-                else if (current == Symbol.OpenBracket)
-                {
-                    symbols.PutBack(current);
-                    _map = Lexer.DecodeEnumerations(symbols);
-                }
-                else if (current != null)
-                {
-                    symbols.PutBack(current);
-                }
-            }
-
-            if (isMacroSyntax)
-            {
-                // inside a macro the syntax is limited to one line, except there are brackets used for ranges/enums
-                return;
-            }
-
-            // outside macro Syntax clause we  wait for two consecutive linebreaks with a following valid identifier as end condition         
-            Symbol previous = current;
-            Symbol veryPrevious = null;
-
-            while ((current = symbols.NextSymbol()) != null)
-            {
-                if ((veryPrevious == Symbol.EOL) && (previous == Symbol.EOL) && current.IsValidIdentifier())
-                {
-                    symbols.PutBack(current);
-                    return;
-                }
-
-                veryPrevious = previous;
-                previous = current;
-            }
-            
-            previous.Assert(false, "end of file reached");
-        }
-
-        public string Type
-        {
-            get { return _type; }
-        }
-
-        public ValueRanges Ranges
-        {
-            get { return _ranges; }
-        }
-
-        public IDictionary<long, string> Map
-        {
-            get { return _map; }
-        }
-
-        #region ITypeAssignment Member
-
-        public IModule Module
-        {
-            get { return _module; }
-        }
-
-        public string Name
-        {
-            get { return _name; }
-        }
-
-        #endregion
-    }
-}
\ No newline at end of file
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Types/UnsignedType.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Types/UnsignedType.cs
deleted file mode 100644
index 4866fc90..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Elements/Types/UnsignedType.cs
+++ /dev/null
@@ -1,103 +0,0 @@
-﻿using System.Collections.Generic;
-
-namespace Lextm.SharpSnmpLib.Mib.Elements.Types
-{
-    /**
-     * As this type is used for Counter32 and TimeTicks as well as Unsigned32
-     * and Gauge32 it incorrectly allows range restrictions of Counter32 and
-     * TimeTicks.  This is ok as currently we do not care about detecting
-     * incorrect MIBs and this doesn't block the decoding of correct MIBs.
-     */
-    public class UnsignedType : BaseType
-    {
-        public enum Types
-        {
-            Unsigned32,
-            Gauge32,
-            Counter32,
-            TimeTicks,
-            Counter64,
-        }
-
-        private Types _type;
-        private ValueRanges _ranges;
-
-        public UnsignedType(IModule module, string name, Symbol type, ISymbolEnumerator symbols)
-            : base(module, name)
-        {
-            Types? t = GetExactType(type);
-            type.Assert(t.HasValue, "Unknown symbol for unsigned type!");
-            _type = t.Value;
-
-            Symbol current = symbols.NextNonEOLSymbol();
-            if (current == Symbol.OpenParentheses)
-            {
-                current.Assert((_type != Types.Counter64), "Ranges are not supported for Counter64 type!"); // our internal struct can only hold int64 values
-
-                symbols.PutBack(current);
-                _ranges = Lexer.DecodeRanges(symbols);
-                current.Assert(!_ranges.IsSizeDeclaration, "SIZE keyword is not allowed for ranges of unsigned types!");
-            }
-            else
-            {
-                symbols.PutBack(current);
-            }
-        }
-
-        public Types Type
-        {
-            get { return _type; }
-        }
-
-        public ValueRanges Ranges
-        {
-            get { return _ranges; }
-        }
-
-        internal static Types? GetExactType(Symbol symbol)
-        {
-            if (symbol == Symbol.Unsigned32)
-            {
-                // [APPLICATION 2] IMPLICIT INTEGER (0..4294967295) // from SNMPv2-SMI
-                return Types.Unsigned32;
-            }
-            else if (symbol == Symbol.Gauge32)
-            {
-                // [APPLICATION 2] IMPLICIT INTEGER (0..4294967295) // from SNMPv2-SMI
-                return Types.Gauge32;
-            }
-            else if (symbol == Symbol.Counter32)
-            {
-                // [APPLICATION 1] IMPLICIT INTEGER (0..4294967295) // from SNMPv2-SMI
-                return Types.Counter32;
-            }
-            else if (symbol == Symbol.TimeTicks)
-            {
-                // [APPLICATION 3] IMPLICIT INTEGER (0..4294967295) // from SNMPv2-SMI + RFC1155-SMI
-                return Types.TimeTicks;
-            }
-            else if (symbol == Symbol.Gauge)
-            {
-                // [APPLICATION 2] IMPLICIT INTEGER (0..4294967295) // from RFC1155-SMI
-                return Types.Gauge32;
-            }
-            else if (symbol == Symbol.Counter)
-            {
-                // [APPLICATION 1] IMPLICIT INTEGER (0..4294967295) // from RFC1155-SMI
-                return Types.Counter32;
-            }
-            else if (symbol == Symbol.Counter64)
-            {
-               // [APPLICATION 6] IMPLICIT INTEGER (0..18446744073709551615) // from SNMPv2-SMI
-               return Types.Counter64;
-            }
-
-            return null;
-        }
-
-        internal static bool IsUnsignedType(Symbol symbol)
-        {
-            return GetExactType(symbol).HasValue;
-        }
-    }
-}
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/IModule.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/IModule.cs
deleted file mode 100644
index d41ab129..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/IModule.cs
+++ /dev/null
@@ -1,81 +0,0 @@
-// Module interface.
-// Copyright (C) 2008-2010 Malcolm Crowe, Lex Li, and other contributors.
-// 
-// This library is free software; you can redistribute it and/or
-// modify it under the terms of the GNU Lesser General Public
-// License as published by the Free Software Foundation; either
-// version 2.1 of the License, or (at your option) any later version.
-// 
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-// Lesser General Public License for more details.
-// 
-// You should have received a copy of the GNU Lesser General Public
-// License along with this library; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-
-/*
- * Created by SharpDevelop.
- * User: lextm
- * Date: 5/1/2009
- * Time: 10:40 AM
- * 
- * To change this template use Tools | Options | Coding | Edit Standard Headers.
- */
-using System.Collections.Generic;
-using Lextm.SharpSnmpLib.Mib.Elements.Entities;
-using Lextm.SharpSnmpLib.Mib.Elements.Types;
-using Lextm.SharpSnmpLib.Mib.Elements;
-
-namespace Lextm.SharpSnmpLib.Mib
-{
-    /// <summary>
-    /// MIB Module interface.
-    /// </summary>
-    public interface IModule
-    {
-        /// <summary>
-        /// Module name.
-        /// </summary>
-        string Name
-        {
-            get;
-        }
-
-        Exports Exports
-        {
-            get;
-        }
-
-        Imports Imports
-        {
-            get;
-        }
-
-        /// <summary>
-        /// Entities + Types + all other elements implementing IDeclaration
-        /// </summary>
-        IList<IDeclaration> Declarations
-        {
-            get;
-        }
-
-        /// <summary>
-        /// Entities.
-        /// </summary>
-        IList<IEntity> Entities
-        {
-            get;
-        }
-
-        /// <summary>
-        /// Known types.
-        /// </summary>
-        IList<ITypeAssignment> Types
-        {
-            get;
-        }
-       
-    }
-}
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/ISymbolEnumerator.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/ISymbolEnumerator.cs
deleted file mode 100644
index e9dd5920..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/ISymbolEnumerator.cs
+++ /dev/null
@@ -1,9 +0,0 @@
-﻿using System.Collections.Generic;
-
-namespace Lextm.SharpSnmpLib.Mib
-{
-    public interface ISymbolEnumerator: IEnumerator<Symbol>
-    {
-        bool PutBack(Symbol item);
-    }
-}
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Lexer.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Lexer.cs
deleted file mode 100644
index d54b9b93..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Lexer.cs
+++ /dev/null
@@ -1,581 +0,0 @@
-/*
- * Created by SharpDevelop.
- * User: lextm
- * Date: 2008/5/17
- * Time: 16:50
- *
- * To change this template use Tools | Options | Coding | Edit Standard Headers.
- */
-
-using System;
-using System.Collections.Generic;
-using System.IO;
-using System.Text;
-using Lextm.SharpSnmpLib.Mib.Elements.Types;
-
-namespace Lextm.SharpSnmpLib.Mib
-{
-    /// <summary>
-    /// Lexer class that parses MIB files into symbol list.
-    /// </summary>
-    public sealed class Lexer
-    {
-        private readonly SymbolList _symbols = new SymbolList();
-
-        public Lexer(string file)
-            : this(file, new StreamReader(file))
-        {
-        }
-
-        public Lexer(string file, TextReader stream)
-        {
-            this.Parse(file, stream);
-        }
-
-
-        public ISymbolEnumerator GetEnumerator()
-        {
-            return _symbols.GetSymbolEnumerator();
-        }
-
-
-        #region Parsing of MIB File
-
-        private class ParseParams
-        {
-            public string File;
-            public StringBuilder Temp = new StringBuilder();
-            public bool StringSection = false;
-            public bool AssignSection = false;
-            public bool AssignAhead = false;
-            public bool DotSection = false;
-
-        }
-
-        /// <summary>
-        /// Parses MIB file to symbol list.
-        /// </summary>
-        /// <param name="file">File</param>
-        /// <param name="stream">File stream</param>
-        private void Parse(string file, TextReader stream)
-        {
-            if (stream == null)
-            {
-                throw new ArgumentNullException("stream");
-            }
-
-            ParseParams pp = new ParseParams();
-            pp.File = file;
-            
-            string line;
-            int row = 0;
-            while ((line = stream.ReadLine()) != null)
-            {
-                if (!pp.StringSection && line.TrimStart().StartsWith("--", StringComparison.Ordinal))
-                {
-                    row++;
-                    continue; // commented line
-                }
-
-                ParseLine(pp, line, row);
-                row++;
-            }
-        }
-
-        private void ParseLine(ParseParams pp, string line, int row)
-        {
-            line = line + "\n";
-            int count = line.Length;
-            for (int i = 0; i < count; i++)
-            {
-                char current = line[i];
-                bool moveNext = Parse(pp, current, row, i);
-                if (moveNext)
-                {
-                    break;
-                }
-            }
-        }
-
-        private bool Parse(ParseParams pp, char current, int row, int column)
-        {
-            switch (current)
-            {
-                case '\n':
-                case '{':
-                case '}':
-                case '(':
-                case ')':
-                case '[':
-                case ']':
-                case ';':
-                case ',':
-                case '|':
-                    if (!pp.StringSection)
-                    {
-                        bool moveNext = ParseLastSymbol(pp, row, column);
-                        if (moveNext)
-                        {
-                            _symbols.Add(CreateSpecialSymbol(pp.File, '\n', row, column));
-                            return true;
-                        }
-
-                        _symbols.Add(CreateSpecialSymbol(pp.File, current, row, column));
-                        return false;
-                    }
-
-                    break;
-                case '"':
-                    pp.StringSection = !pp.StringSection;
-                    break;
-                case '\r':
-                    return false;
-                default:
-                    if ((int)current == 0x1A)
-                    {
-                        // IMPORTANT: ignore invisible characters such as SUB.
-                        return false;
-                    }
-                    
-                    if (Char.IsWhiteSpace(current) && !pp.AssignSection && !pp.StringSection)
-                    {                     
-                        bool moveNext = ParseLastSymbol(pp, row, column);
-                        if (moveNext)
-                        {
-                            _symbols.Add(CreateSpecialSymbol(pp.File, '\n', row, column));
-                            return true;
-                        }
-
-                        return false;
-                    }
-                    
-                    if (pp.AssignAhead)
-                    {
-                        pp.AssignAhead = false;
-                        ParseLastSymbol(pp, row, column);
-                        break;
-                    }
-
-                    if (pp.DotSection && current != '.')
-                    {
-                        ParseLastSymbol(pp, row, column);
-                        pp.DotSection = false;
-                    }
-
-                    if (current == '.' && !pp.StringSection)
-                    {
-                        if (!pp.DotSection)
-                        {
-                            ParseLastSymbol(pp, row, column);
-                            pp.DotSection = true;
-                        }
-                    }
-                    
-                    if (current == ':' && !pp.StringSection)
-                    {    
-                        if (!pp.AssignSection)
-                        {
-                            ParseLastSymbol(pp, row, column);
-                        }
-                        
-                        pp.AssignSection = true;
-                    }
-                    
-                    if (current == '=' && !pp.StringSection)
-                    {
-                        pp.AssignSection = false; 
-                        pp.AssignAhead = true;
-                    }
-
-                    break;
-            }
-
-            pp.Temp.Append(current);
-            return false;
-        }
-
-        private bool ParseLastSymbol(ParseParams pp, int row, int column)
-        {
-            if (pp.Temp.Length > 0)
-            {
-                Symbol s = new Symbol(pp.File, pp.Temp.ToString(), row, column);
-
-                pp.Temp.Length = 0;
-
-                if (s.ToString().StartsWith(Symbol.Comment.ToString()))
-                {
-                    // ignore the rest symbols on this line because they are in comment.
-                    return true;
-                }
-
-                _symbols.Add(s);
-            }
-
-            return false;
-        }
-
-        private static Symbol CreateSpecialSymbol(string file, char value, int row, int column)
-        {
-            string str;
-            switch (value)
-            {
-                case '\n':
-                    str = Environment.NewLine;
-                    break;
-                case '{':
-                    str = "{";
-                    break;
-                case '}':
-                    str = "}";
-                    break;
-                case '(':
-                    str = "(";
-                    break;
-                case ')':
-                    str = ")";
-                    break;
-                case '[':
-                    str = "[";
-                    break;
-                case ']':
-                    str = "]";
-                    break;
-                case ';':
-                    str = ";";
-                    break;
-                case ',':
-                    str = ",";
-                    break;
-                case '|':
-                    str = "|";
-                    break;
-                default:
-                    throw new ArgumentException("value is not a special character");
-            }
-
-            return new Symbol(file, str, row, column);
-        }
-
-        #endregion
-
-        #region Static Parse Helper
-
-        public static ITypeAssignment ParseBasicTypeDef(IModule module, string name, ISymbolEnumerator symbols, bool isMacroSyntax = false)
-        {
-            Symbol current = symbols.NextNonEOLSymbol();
-
-            if (current == Symbol.Bits)
-            {
-                return new BitsType(module, name, symbols);
-            }
-            if (IntegerType.IsIntegerType(current))
-            {
-                return new IntegerType(module, name, current, symbols);
-            }
-            if (UnsignedType.IsUnsignedType(current))
-            {
-                return new UnsignedType(module, name, current, symbols);
-            }
-            if (current == Symbol.Opaque)
-            {
-                return new OpaqueType(module, name, symbols);
-            }
-            if (current == Symbol.IpAddress)
-            {
-                return new IpAddressType(module, name, symbols);
-            }
-            if (current == Symbol.TextualConvention)
-            {
-                return new TextualConvention(module, name, symbols);
-            }
-            if (current == Symbol.Octet)
-            {
-                Symbol next = symbols.NextNonEOLSymbol();
-
-                if (next == Symbol.String)
-                {
-                    return new OctetStringType(module, name, symbols);
-                }
-
-                symbols.PutBack(next);
-            }
-            if (current == Symbol.Object)
-            {
-                Symbol next = symbols.NextNonEOLSymbol();
-
-                if (next == Symbol.Identifier)
-                {
-                    return new ObjectIdentifierType(module, name, symbols);
-                }
-
-                symbols.PutBack(next);
-            }
-            if (current == Symbol.Sequence)
-            {
-                Symbol next = symbols.NextNonEOLSymbol();
-
-                if (next == Symbol.Of)
-                {
-                    return new SequenceOf(module, name, symbols);
-                }
-                else
-                {
-                    symbols.PutBack(next);
-                    return new Sequence(module, name, symbols);
-                }
-            }
-            if (current == Symbol.Choice)
-            {
-                return new Choice(module, name, symbols);
-            }
-
-
-            return new TypeAssignment(module, name, current, symbols, isMacroSyntax);
-        }
-
-        public static void ParseOidValue(ISymbolEnumerator symbols, out string parent, out uint value)
-        {
-            parent = null;
-            value = 0;
-            
-            Symbol current  = symbols.NextNonEOLSymbol();
-            current.Expect(Symbol.OpenBracket);
-
-            Symbol previous = null;
-            StringBuilder longParent = new StringBuilder();
-
-            current = symbols.NextNonEOLSymbol();
-            longParent.Append(current);
-
-            while ((current = symbols.NextNonEOLSymbol()) != null)
-            {
-                bool succeeded;
-
-                if (current == Symbol.OpenParentheses)
-                {
-                    longParent.Append(current);
-                    
-                    current = symbols.NextNonEOLSymbol();
-                    succeeded = UInt32.TryParse(current.ToString(), out value);
-                    current.Assert(succeeded, "not a decimal");
-                    longParent.Append(current);
-                    current = symbols.NextNonEOLSymbol();
-                    current.Expect(Symbol.CloseParentheses);
-                    longParent.Append(current);
-                    continue;
-                }
-
-                if (current == Symbol.CloseBracket)
-                {
-                    parent = longParent.ToString();
-                    return;
-                }
-
-                succeeded = UInt32.TryParse(current.ToString(), out value);
-                if (succeeded)
-                {
-                    // numerical way
-                    while ((current = symbols.NextNonEOLSymbol()) != Symbol.CloseBracket)
-                    {
-                        longParent.Append(".").Append(value);
-                        succeeded = UInt32.TryParse(current.ToString(), out value);
-                        current.Assert(succeeded, "not a decimal");
-                    }
-
-                    current.Expect(Symbol.CloseBracket);
-                    parent = longParent.ToString();
-                    return;
-                }
-
-                longParent.Append(".");
-                longParent.Append(current);
-                current = symbols.NextNonEOLSymbol();
-                current.Expect(Symbol.OpenParentheses);
-                longParent.Append(current);
-                current = symbols.NextNonEOLSymbol();
-                succeeded = UInt32.TryParse(current.ToString(), out value);
-                current.Assert(succeeded, "not a decimal");
-                longParent.Append(current);
-                current = symbols.NextNonEOLSymbol();
-                current.Expect(Symbol.CloseParentheses);
-                longParent.Append(current);
-                previous = current;
-            }
-
-            throw MibException.Create("end of file reached", previous);
-        }
-
-
-        public static ValueRanges DecodeRanges(ISymbolEnumerator symbols)
-        {
-            ValueRanges result = new ValueRanges();
-
-            Symbol startSymbol = symbols.NextNonEOLSymbol();
-            Symbol current = startSymbol;
-            current.Expect(Symbol.OpenParentheses);
-
-            while (current != Symbol.CloseParentheses)
-            {
-                Symbol value1Symbol = symbols.NextNonEOLSymbol();
-
-                if ((value1Symbol == Symbol.Size) && !result.IsSizeDeclaration)
-                {
-                    result.IsSizeDeclaration = true;
-                    symbols.NextNonEOLSymbol().Expect(Symbol.OpenParentheses);
-                    continue;
-                }
-
-                // check for valid number
-                Int64? value1 = DecodeNumber(value1Symbol);
-                if (!value1.HasValue)
-                {
-                    value1Symbol.Assert(false, "Invalid range declaration!");                    
-                }
-
-                // process next symbol
-                ValueRange range;
-                current = symbols.NextNonEOLSymbol();
-
-                if (current == Symbol.DoubleDot)
-                {
-                    // its a continous range
-                    Symbol value2Symbol = symbols.NextNonEOLSymbol();
-                    Int64? value2 = DecodeNumber(value2Symbol);
-                    value2Symbol.Assert(value2.HasValue && (value2.Value >= value1.Value), "Invalid range declaration!");
-
-                    if (value2.Value == value1.Value)
-                    {
-                        range = new ValueRange(value1.Value, null);
-                    }
-                    else
-                    {
-                        range = new ValueRange(value1.Value, value2.Value);
-                    }
-
-                    current = symbols.NextNonEOLSymbol();
-                }
-                else
-                {
-                    // its a single number
-                    range = new ValueRange(value1.Value, null);
-                }
-
-                // validate range
-                if (result.IsSizeDeclaration)
-                {
-                    value1Symbol.Assert(range.Start >= 0, "Invalid range declaration! Size must be greater than 0");
-                }
-
-                result.Add(range);
-                
-                // check next symbol
-                current.Expect(Symbol.Pipe, Symbol.CloseParentheses);
-            }
-
-            if (result.IsSizeDeclaration)
-            {
-                current = symbols.NextNonEOLSymbol();
-                current.Expect(Symbol.CloseParentheses);
-            }
-
-            // validate ranges in between
-            for (int i=0; i<result.Count; i++)
-            {
-                for (int k=i+1; k<result.Count; k++)
-                {
-                    startSymbol.Assert(!result[i].IntersectsWith(result[k]), "Invalid range declaration! Overlapping of ranges!");
-                }
-            }
-
-            return result;
-        }
-
-        public static Int64? DecodeNumber(Symbol number)
-        {
-            Int64  result;
-            string numString = (number != null) ? number.ToString() : null;
-
-            if (!String.IsNullOrEmpty(numString))
-            {
-                if (numString.StartsWith("'") && (numString.Length > 3))
-                {
-                    // search second apostrophe
-                    int end = numString.IndexOf('\'', 1);
-                    if (end == (numString.Length - 2))
-                    {
-                        try
-                        {
-                            switch (numString[numString.Length - 1])
-                            {
-                                case 'b':
-                                case 'B':
-                                    result = Convert.ToInt64(numString.Substring(1, numString.Length - 3), 2);
-                                    return result;
-                                case 'h':
-                                case 'H':
-                                    result = Convert.ToInt64(numString.Substring(1, numString.Length - 3), 16);
-                                    return result;
-                            }
-                        }
-                        catch
-                        {
-                        }
-                    }
-                }
-                else if (Int64.TryParse(numString, out result))
-                {
-                    return result;
-                }
-            }
-
-            return null;
-        }
-
-        public static ValueMap DecodeEnumerations(ISymbolEnumerator symbols)
-        {
-            Symbol current = symbols.NextNonEOLSymbol();
-            current.Expect(Symbol.OpenBracket);
-
-            ValueMap map = new ValueMap();
-            do
-            {
-                current = symbols.NextNonEOLSymbol();
-                string identifier = current.ToString();
-
-                current = symbols.NextNonEOLSymbol();
-                current.Expect(Symbol.OpenParentheses);
-
-                current = symbols.NextNonEOLSymbol();
-                Int64 enumValue;
-                if (Int64.TryParse(current.ToString(), out enumValue))
-                {
-                    try
-                    {
-                        // Have to include the number as it seems repeated identifiers are allowed ??
-                        map.Add(enumValue, String.Format("{0}({1})", identifier, enumValue));
-                    }
-                    catch (ArgumentException ex)
-                    {
-                        current.Assert(false, ex.Message);
-                    }
-                }
-                else
-                {
-                    // Need to get "DefinedValue".
-                }
-
-                current = symbols.NextNonEOLSymbol();
-                current.Expect(Symbol.CloseParentheses);
-
-                current = symbols.NextNonEOLSymbol();
-            } while (current == Symbol.Comma);
-
-            current.Expect(Symbol.CloseBracket);
-
-            return map;
-        }
-
-        #endregion
-
-    }
-}
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/MaxAccess.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/MaxAccess.cs
deleted file mode 100644
index f8029900..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/MaxAccess.cs
+++ /dev/null
@@ -1,17 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-
-namespace Lextm.SharpSnmpLib.Mib
-{
-    public enum MaxAccess
-    {
-        notAccessible,
-        accessibleForNotify,
-        readOnly,
-        readWrite,
-        readCreate
-    }
-
-}
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/MibDocument.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/MibDocument.cs
deleted file mode 100644
index aac3b280..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/MibDocument.cs
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- * Created by SharpDevelop.
- * User: lextm
- * Date: 2008/5/17
- * Time: 17:38
- * 
- * To change this template use Tools | Options | Coding | Edit Standard Headers.
- */
-
-using System.Collections.Generic;
-
-namespace Lextm.SharpSnmpLib.Mib
-{
-    /// <summary>
-    /// MIB document.
-    /// </summary>
-    public sealed class MibDocument
-    {
-        private readonly List<IModule> _modules = new List<IModule>();
-
-        /// <summary>
-        /// Initializes a new instance of the <see cref="MibDocument" /> class.
-        /// </summary>
-        /// <param name="file">The file.</param>
-        public MibDocument(string file)
-            : this(new Lexer(file))
-        {
-        }
-
-        /// <summary>
-        /// Initializes a new instance of the <see cref="MibDocument"/> class.
-        /// </summary>
-        /// <param name="lexer">The lexer.</param>
-        public MibDocument(Lexer lexer)
-        {
-            ISymbolEnumerator symbols = lexer.GetEnumerator();
-
-            Symbol current;
-            while ((current = symbols.NextNonEOLSymbol()) != null)
-            {
-                symbols.PutBack(current);
-                _modules.Add(new MibModule(symbols));                
-            }
-        }
-        
-        /// <summary>
-        /// <see cref="MibModule"/> containing in this document.
-        /// </summary>
-        public IList<IModule> Modules
-        {
-            get
-            {
-                return _modules;
-            }
-        }
-    }
-}
\ No newline at end of file
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/MibException.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/MibException.cs
deleted file mode 100644
index efd89b3f..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/MibException.cs
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- * Created by SharpDevelop.
- * User: lextm
- * Date: 2008/5/17
- * Time: 16:33
- * 
- * To change this template use Tools | Options | Coding | Edit Standard Headers.
- */
-
-using System;
-using System.Globalization;
-#if (!SILVERLIGHT)
-using System.Runtime.Serialization;
-using System.Security.Permissions; 
-#endif
-
-namespace Lextm.SharpSnmpLib.Mib
-{
-    /// <summary>
-    /// Description of MibException.
-    /// </summary>
-    [Serializable]
-    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Mib")]
-    public sealed class MibException : Exception
-    {
-        /// <summary>
-        /// Symbol.
-        /// </summary>
-        public Symbol Symbol { get; private set; }
-
-        /// <summary>
-        /// Creates a <see cref="MibException"/>.
-        /// </summary>
-        public MibException()
-        {
-        }
-        
-        /// <summary>
-        /// Creates a <see cref="SnmpException"/> instance with a specific <see cref="string"/>.
-        /// </summary>
-        /// <param name="message">Message</param>
-        public MibException(string message) : base(message)
-        {
-        }
-
-        /// <summary>
-        /// Creates a <see cref="MibException"/> instance with a specific <see cref="string"/> and an <see cref="Exception"/>.
-        /// </summary>
-        /// <param name="message">Message</param>
-        /// <param name="inner">Inner exception</param>
-        public MibException(string message, Exception inner)
-            : base(message, inner)
-        {
-        }
-#if (!SILVERLIGHT)        
-        /// <summary>
-        /// Creates a <see cref="MibException"/> instance.
-        /// </summary>
-        /// <param name="info">Info</param>
-        /// <param name="context">Context</param>
-        private MibException(SerializationInfo info, StreamingContext context) : base(info, context)
-        {
-            if (info == null)
-            {
-                throw new ArgumentNullException("info");
-            }
-            
-            Symbol = (Symbol)info.GetValue("Symbol", typeof(Symbol));
-        }
-        
-        /// <summary>
-        /// Gets object data.
-        /// </summary>
-        /// <param name="info">Info</param>
-        /// <param name="context">Context</param>
-        [SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
-        public override void GetObjectData(SerializationInfo info, StreamingContext context)
-        {
-            base.GetObjectData(info, context);
-            info.AddValue("Symbol", Symbol);
-        }
-#endif
-
-        /// <summary>
-        /// Creates a <see cref="MibException"/> with a specific <see cref="Symbol"/>.
-        /// </summary>
-        /// <param name="message">Message</param>
-        /// <param name="symbol">Symbol</param>
-        /// <returns></returns>
-        public static MibException Create(string message, Symbol symbol)
-        {
-            if (symbol == null)
-            {
-                throw new ArgumentNullException("symbol");
-            }
-
-            if (String.IsNullOrEmpty(message))
-            {
-                message = "Unknown MIB Exception";
-            }
-
-            message = String.Format(
-                "{0} (file: \"{1}\"; row: {2}; column: {3})",
-                message,
-                symbol.File,
-                symbol.Row + 1,
-                symbol.Column + 1);
-
-            MibException ex = new MibException(message) { Symbol = symbol };
-            return ex;
-        }
-    }
-}
\ No newline at end of file
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/MibModule.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/MibModule.cs
deleted file mode 100644
index 3c6b7707..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/MibModule.cs
+++ /dev/null
@@ -1,294 +0,0 @@
-/*
- * Created by SharpDevelop.
- * User: lextm
- * Date: 2008/5/17
- * Time: 17:38
- * 
- * To change this template use Tools | Options | Coding | Edit Standard Headers.
- */
-
-using System;
-using System.Collections.Generic;
-using Lextm.SharpSnmpLib.Mib.Elements;
-using Lextm.SharpSnmpLib.Mib.Elements.Entities;
-using Lextm.SharpSnmpLib.Mib.Elements.Types;
-
-namespace Lextm.SharpSnmpLib.Mib
-{
-    /// <summary>
-    /// MIB module class.
-    /// </summary>
-    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Mib")]
-    public sealed class MibModule : IModule
-    {
-        private readonly string _name;
-        private readonly Imports _imports;
-        private readonly Exports _exports;
-        private readonly List<IElement> _tokens = new List<IElement>();
-    
-        /// <summary>
-        /// Creates a <see cref="MibModule"/> with a specific <see cref="Lexer"/>.
-        /// </summary>
-        /// <param name="name">Module name</param>
-        /// <param name="symbols">Lexer</param>
-        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "lexer")]
-        public MibModule(ISymbolEnumerator symbols)
-        {
-            if (symbols == null)
-            {
-                throw new ArgumentNullException("lexer");
-            }
-
-            Symbol temp = symbols.NextNonEOLSymbol();
-            temp.AssertIsValidIdentifier();
-            _name = temp.ToString().ToUpperInvariant(); // all module names are uppercase
-            
-            temp = symbols.NextNonEOLSymbol();
-            temp.Expect(Symbol.Definitions);
-            
-            temp = symbols.NextNonEOLSymbol();
-            temp.Expect(Symbol.Assign);
-            
-            temp = symbols.NextSymbol();
-            temp.Expect(Symbol.Begin);
-            
-            temp = symbols.NextNonEOLSymbol();
-            if (temp == Symbol.Imports)
-            {
-                _imports = ParseDependents(symbols);
-            }
-            else if (temp == Symbol.Exports)
-            {
-                _exports = ParseExports(symbols);
-            }
-            else
-            {
-                symbols.PutBack(temp);
-            }
-
-            ParseEntities(symbols);
-        }
-
-        #region Accessors
-
-        /// <summary>
-        /// Module name.
-        /// </summary>
-        public string Name
-        {
-            get { return _name; }
-        }
-        
-        public Exports Exports
-        {
-            get { return _exports; }
-        }
-
-        public Imports Imports
-        {
-            get { return _imports; }
-        }
-
-        public List<IElement> Tokens
-        {
-            get { return this._tokens; }
-        }
-
-        /// <summary>
-        /// Entities + Types + all other elements implementing IDeclaration
-        /// </summary>
-        public IList<IDeclaration> Declarations
-        {
-            get
-            {
-                IList<IDeclaration> result = new List<IDeclaration>();
-                foreach (IElement e in _tokens)
-                {
-                    IDeclaration decl = e as IDeclaration;
-                    if (decl != null)
-                    {
-                        result.Add(decl);
-                    }
-                }
-
-                return result;
-            }
-        }
-
-        /// <summary>
-        /// OID nodes.
-        /// </summary>
-        public IList<IEntity> Entities
-        {
-            get
-            {
-                IList<IEntity> result = new List<IEntity>();
-                foreach (IElement e in _tokens)
-                {
-                    IEntity entity = e as IEntity;
-                    if (entity != null)
-                    {
-                        result.Add(entity);
-                    }
-                }
-
-                return result;
-            }
-        }
-
-        public IList<ITypeAssignment> Types
-        {
-            get
-            {
-                IList<ITypeAssignment> result = new List<ITypeAssignment>();
-                foreach (IElement e in _tokens)
-                {
-                    ITypeAssignment type = e as ITypeAssignment;
-                    if (type != null)
-                    {
-                        result.Add(type);
-                    }
-                }
-
-                return result;
-            }
-        }
-
-        #endregion
-
-        #region Parsing of Symbols
-
-        private Exports ParseExports(ISymbolEnumerator symbols)
-        {
-            return new Exports(this, symbols);
-        }
-
-        private Imports ParseDependents(ISymbolEnumerator symbols)
-        {
-            return new Imports(this, symbols);
-        }
-        
-        private void ParseEntities(ISymbolEnumerator symbols)
-        {
-            Symbol     temp   = symbols.NextNonEOLSymbol();
-            SymbolList buffer = new SymbolList();
-
-            while (temp != Symbol.End)
-            {
-                if (temp == Symbol.Assign)
-                {
-                    ParseEntity(buffer, symbols);
-                    buffer.Clear();
-                    // skip linebreaks behind an entity
-                    temp = symbols.NextNonEOLSymbol();
-                }
-                else
-                {
-                    buffer.Add(temp);
-                    temp = symbols.NextSymbol();
-                }
-            }
-        }
-
-        private void ParseEntity(SymbolList preAssignSymbols, ISymbolEnumerator symbols)
-        {
-            if ((preAssignSymbols == null) || (preAssignSymbols.Count == 0))
-            {
-                Symbol s = symbols.NextSymbol();
-                if (s != null)
-                {
-                    s.Assert(false, "Invalid Entitiy declaration");
-                }
-                else
-                {
-                    throw new MibException("Invalid Entitiy declaration");
-                }
-            }
-
-            // check for a valid identifier
-            preAssignSymbols[0].AssertIsValidIdentifier();
-            
-            if (preAssignSymbols.Count == 1)
-            {
-                // its a typedef
-                _tokens.Add(Lexer.ParseBasicTypeDef(this, preAssignSymbols[0].ToString(), symbols, isMacroSyntax: false));
-                return;
-            }
-
-            ISymbolEnumerator preAssignSymbolsEnumerator = preAssignSymbols.GetSymbolEnumerator();
-            preAssignSymbolsEnumerator.NextNonEOLSymbol(); // returns identifier
-            Symbol type = preAssignSymbolsEnumerator.NextNonEOLSymbol();
-
-            // parse declarations
-            if (type == Symbol.Object)
-            {
-                Symbol next = preAssignSymbolsEnumerator.NextNonEOLSymbol();
-
-                if (next == Symbol.Identifier)
-                {
-                    _tokens.Add(new OidValueAssignment(this, preAssignSymbols, symbols));
-                    return;
-                }
-                else if (next != null)
-                {
-                    preAssignSymbolsEnumerator.PutBack(next);
-                }
-            }
-            if (type == Symbol.ModuleIdentity)
-            {
-                _tokens.Add(new ModuleIdentity(this, preAssignSymbols, symbols));
-                return;
-            }
-            if (type == Symbol.ObjectType)
-            {
-                _tokens.Add(new ObjectType(this, preAssignSymbols, symbols));
-                return;
-            }
-            if (type == Symbol.ObjectGroup)
-            {
-                _tokens.Add(new ObjectGroup(this, preAssignSymbols, symbols));
-                return;
-            }
-            if (type == Symbol.NotificationGroup)
-            {
-                _tokens.Add(new NotificationGroup(this, preAssignSymbols, symbols));
-                return;
-            }
-            if (type == Symbol.ModuleCompliance)
-            {
-                _tokens.Add(new ModuleCompliance(this, preAssignSymbols, symbols));
-                return;
-            }
-            if (type == Symbol.NotificationType)
-            {
-                _tokens.Add(new NotificationType(this, preAssignSymbols, symbols));
-                return;
-            }
-            if (type == Symbol.ObjectIdentity)
-            {
-                _tokens.Add(new ObjectIdentity(this, preAssignSymbols, symbols));
-                return;
-            }
-            if (type == Symbol.Macro)
-            {
-                _tokens.Add(new Macro(this, preAssignSymbols, symbols));
-                return;
-            }
-            if (type == Symbol.TrapType)
-            {
-                _tokens.Add(new TrapType(this, preAssignSymbols, symbols));
-                return;
-            }
-            if (type == Symbol.AgentCapabilities)
-            {
-                _tokens.Add(new AgentCapabilities(this, preAssignSymbols, symbols));
-                return;
-            }
-
-            preAssignSymbols[1].Assert(false, "Unknown/Invalid declaration");
-        }
-
-        #endregion
-
-    }
-}
\ No newline at end of file
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/MibResolver.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/MibResolver.cs
deleted file mode 100644
index 96978e1a..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/MibResolver.cs
+++ /dev/null
@@ -1,97 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.IO;
-using System.Reflection;
-
-namespace Lextm.SharpSnmpLib.Mib
-{
-    public interface IMibResolver
-    {
-        IModule Resolve(string moduleName);
-    }
-
-    public class FileSystemMibResolver : IMibResolver
-    {
-        private string _path;
-        private bool _recursive;
-
-        public FileSystemMibResolver(string path, bool recursive)
-        {
-            _path = path;
-            _recursive = recursive;
-        }
-
-        #region IMibResolver Member
-
-        public IModule Resolve(string moduleName)
-        {
-            if (Directory.Exists(_path))
-            {
-                string[] matchedFiles = Directory.GetFiles(
-                    _path,
-                    "*",
-                    (_recursive) ? SearchOption.AllDirectories : SearchOption.TopDirectoryOnly);
-
-                if ((matchedFiles != null) && (matchedFiles.Length >= 1))
-                {
-                    foreach (string matchedFile in matchedFiles)
-                    {
-						if (Path.GetFileNameWithoutExtension(matchedFile.ToLowerInvariant()) == moduleName.ToLowerInvariant())
-						{
-							try
-							{
-								MibDocument md = new MibDocument (matchedFile);
-								if (md.Modules.Count > 0)
-								{
-									return md.Modules [0];
-								}
-							} catch
-							{
-							}
-						}
-                    }                  
-                }
-            }
-
-            return null;
-        }
-
-        #endregion
-
-    }
-
-    // earlier code for search of versioned MIBs:
-    //
-    //private const string Pattern = "-V[0-9]+$";
-    //public static bool AllDependentsAvailable(MibModule module, IDictionary<string, MibModule> modules)
-    //{
-    //    foreach (string dependent in module.Dependents)
-    //    {
-    //        if (!DependentFound(dependent, modules))
-    //        {
-    //            return false;
-    //        }
-    //    }
-
-    //    return true;
-    //}
-
-    //private static bool DependentFound(string dependent, IDictionary<string, MibModule> modules)
-    //{
-    //    if (!Regex.IsMatch(dependent, Pattern))
-    //    {
-    //        return modules.ContainsKey(dependent);
-    //    }
-
-    //    if (modules.ContainsKey(dependent))
-    //    {
-    //        return true;
-    //    }
-
-    //    string dependentNonVersion = Regex.Replace(dependent, Pattern, string.Empty);
-    //    return modules.ContainsKey(dependentNonVersion);
-    //}
-
-}
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/MibTree.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/MibTree.cs
deleted file mode 100644
index a5174bc1..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/MibTree.cs
+++ /dev/null
@@ -1,130 +0,0 @@
-﻿using System.Collections.Generic;
-using Lextm.SharpSnmpLib.Mib.Elements.Entities;
-
-namespace Lextm.SharpSnmpLib.Mib
-{
-    /// <summary>
-    /// Builds up a tree from a single MIB
-    /// </summary>
-    public class MibTree
-    {
-        private readonly List<MibTreeNode> _root = new List<MibTreeNode>();
-
-        public MibTree(MibModule module)
-        {
-            IList<IEntity> entities = module.Entities;
-
-            if (entities.Count > 0)
-            {
-                // try to find module identity as root
-                foreach (IEntity element in entities)
-                {
-                    ModuleIdentity mi = element as ModuleIdentity;
-
-                    if (mi != null)
-                    {
-                        _root.Add(new MibTreeNode(null, mi));
-                    }
-                }
-
-                // find OID assignments as root, if there are any that are not below ModuleIdentity
-                foreach (IEntity element in entities)
-                {
-                    OidValueAssignment oa = element as OidValueAssignment;
-
-                    if (oa != null)
-                    {
-                        _root.Add(new MibTreeNode(null, oa));
-                    }
-                }
-
-                FilterRealRoots (entities);
-
-                foreach (MibTreeNode mibTreeNode in _root)
-                {
-                    entities.Remove (mibTreeNode.Entity);
-                }
-
-                if (_root.Count == 0)
-                {
-                    //no module identity, assume first entity is root
-                    _root.Add(new MibTreeNode(null, entities[0]));
-                }
-
-                foreach (MibTreeNode mibTreeNode in _root)
-                {
-					if (entities.Contains (mibTreeNode.Entity))
-					{
-						entities.Remove (mibTreeNode.Entity);
-					}
-                    BuildTree(mibTreeNode, entities);
-                    UpdateTreeNodeTypes(mibTreeNode);
-                }
-            }
-        }
-
-        public IList<MibTreeNode> Root
-        {
-            get { return _root; }
-        }
-
-        private bool EntityExists(IList<IEntity> entities, string name)
-		{
-            foreach(IEntity entity in entities)
-			{
-                if (entity.Name == name)
-				{
-                    return true;
-                }
-            }
-            return false;
-        }
-
-        private void FilterRealRoots(IList<IEntity> entities)
-        {
-            int i = 0;
-            while (i < _root.Count)
-			{
-                if (EntityExists(entities, _root[i].Entity.Parent))
-                {
-                    _root.RemoveAt(i);
-                }
-                else
-                {
-                    i++;
-                }
-            }
-		}
-		
-		private void BuildTree(MibTreeNode node, IList<IEntity> entities)
-        {
-            int i = 0;
-            while (i < entities.Count)
-            {
-                if (entities[i].Parent == node.Entity.Name)
-                {
-                    node.AddChild(entities[i]);
-                    entities.RemoveAt(i);
-                }
-                else
-                {
-                    i++;
-                }
-            }
-
-            foreach (MibTreeNode childNode in node.ChildNodes)
-            {
-                BuildTree(childNode, entities);
-            }
-        }
-        
-        private void UpdateTreeNodeTypes(MibTreeNode node)
-        {
-            node.UpdateNodeType();
-            foreach (MibTreeNode childNode in node.ChildNodes)
-            {
-                UpdateTreeNodeTypes(childNode);
-            }
-        }
-    }
-}
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/MibTreeNode.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/MibTreeNode.cs
deleted file mode 100644
index 386c8e5c..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/MibTreeNode.cs
+++ /dev/null
@@ -1,112 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using Lextm.SharpSnmpLib.Mib.Elements.Entities;
-using Lextm.SharpSnmpLib.Mib.Elements.Types;
-
-namespace Lextm.SharpSnmpLib.Mib
-{
-    [Flags]
-    public enum MibTreeNodeType
-    {
-        Unknown             = 0,
-        Container           = (1 << 0),
-        Scalar              = (1 << 1),
-        Table               = (1 << 2),
-        TableRow            = (1 << 3),
-        TableCell           = (1 << 4),
-        NotificationRelated = (1 << 5),
-        ConformanceRelated  = (1 << 6)
-    }
-
-
-    public class MibTreeNode
-    {
-        private MibTreeNode       _parent     = null;
-        private List<MibTreeNode> _childNodes = new List<MibTreeNode>();
-        private IEntity           _entity     = null;
-        private MibTreeNodeType   _nodeType   = MibTreeNodeType.Unknown;
-
-        public MibTreeNode(MibTreeNode parent, IEntity entity)
-        {
-            _parent = parent;
-            _entity = entity;
-        }
-
-        public MibTreeNode Parent
-        {
-            get { return _parent; }
-        }
-
-        public IEntity Entity
-        {
-            get { return _entity; }
-        }
-
-        public MibTreeNodeType NodeType
-        {
-            get { return _nodeType; }
-        }
-
-        public List<MibTreeNode> ChildNodes
-        {
-            get { return _childNodes; }
-        }
-
-        public MibTreeNode AddChild(IEntity element)
-        {
-            MibTreeNode result = new MibTreeNode(this, element);
-            this.ChildNodes.Add(result);
-
-            return result;
-        }
-
-        public void UpdateNodeType()
-        {
-            _nodeType = MibTreeNodeType.Unknown;
-
-            if (_entity != null)
-            {
-                if ((_entity is OidValueAssignment) || (_entity is ObjectIdentity))
-                {
-                    _nodeType |= MibTreeNodeType.Container;
-                    return;
-                }
-                else if (_childNodes.Count > 0)
-                {
-                    _nodeType |= MibTreeNodeType.Container;
-                }
-
-                if (_entity is ObjectType)
-                {
-                    ObjectType ot = _entity as ObjectType;
-
-                    if (ot.Syntax is SequenceOf)
-                    {
-                        _nodeType |= MibTreeNodeType.Table;
-                    }
-                    else if (ot.Syntax is Sequence)
-                    {
-                        _nodeType |= MibTreeNodeType.TableRow;
-                    }
-                    else if ((_parent != null) && ((_parent.NodeType & MibTreeNodeType.TableRow) != 0))
-                    {
-                        _nodeType |= MibTreeNodeType.TableCell;
-                        _nodeType |= MibTreeNodeType.Scalar;
-                    }
-                    else
-                    {
-                        _nodeType |= MibTreeNodeType.Scalar;
-                    }
-                }
-                else if ((_entity is ModuleCompliance) || (_entity is ObjectGroup) || (_entity is NotificationGroup))
-                {
-                    _nodeType |= MibTreeNodeType.ConformanceRelated;
-                }
-                else if ((_entity is NotificationGroup) || (_entity is NotificationType))
-                {
-                    _nodeType |= MibTreeNodeType.NotificationRelated;
-                }
-            }
-        }
-    }
-}
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/MibTypesResolver.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/MibTypesResolver.cs
deleted file mode 100644
index 1e7529af..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/MibTypesResolver.cs
+++ /dev/null
@@ -1,216 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Text.RegularExpressions;
-using Lextm.SharpSnmpLib.Mib.Elements;
-using Lextm.SharpSnmpLib.Mib.Elements.Entities;
-using Lextm.SharpSnmpLib.Mib.Elements.Types;
-
-namespace Lextm.SharpSnmpLib.Mib
-{
-	 public static class MibTypesResolver
-	 {
-		  private static readonly Regex              _namedOidPathRegex = new Regex(@"^(?<Name>[^\(]+)\((?<Value>\d+)\)$");
-		  private static readonly List<IMibResolver> _resolver      = new List<IMibResolver>();
-		  private static readonly List<IModule>      _cachedModules = new List<IModule>();
-
-		  public static void RegisterResolver(IMibResolver resolver)
-		  {
-				if (resolver != null)
-				{
-					 _resolver.Add(resolver);
-				}
-		  }
-
-		  public static IModule ResolveModule(string moduleName)
-		  {
-				// check if module is already cached
-				foreach (MibModule cachedModule in _cachedModules)
-				{
-					 if (cachedModule.Name == moduleName)
-					 {
-						  return cachedModule;
-					 }
-				}
-
-				foreach (IMibResolver resolver in _resolver)
-				{
-					 IModule resolvedModule = resolver.Resolve(moduleName);
-					 if (resolvedModule != null)
-					 {
-						  ResolveTypes(resolvedModule);
-						  _cachedModules.Add(resolvedModule);
-						  return resolvedModule;
-					 }
-				}
-
-				return null;
-		  }
-
-		  public static void ResolveTypes(IModule module)
-		  {
-				foreach (IEntity entity in module.Entities)
-				{
-					 ITypeReferrer typeReferringEntity = entity as ITypeReferrer;
-
-					 if (typeReferringEntity != null)
-					 {
-						  CheckTypeReferrer(module, typeReferringEntity);
-					 }
-				}
-
-				if (!_cachedModules.Contains(module))
-				{
-					 _cachedModules.Add(module);
-				}
-		  }
-
-		  private static void CheckTypeReferrer(IModule module, ITypeReferrer typeReferringEntity)
-		  {
-				TypeAssignment unknownType = typeReferringEntity.ReferredType as TypeAssignment;
-				if (unknownType != null)
-				{
-					 typeReferringEntity.ReferredType = ResolveType(module, unknownType);
-
-					 if (typeReferringEntity.ReferredType is TypeAssignment)
-					 {
-						  Console.WriteLine(String.Format("Could not resolve type '{0}' declared in module '{1}'", (typeReferringEntity.ReferredType as TypeAssignment).Type, typeReferringEntity.ReferredType.Module.Name));
-					 }
-				}
-
-				ITypeReferrer nextTypeReferringEntity = typeReferringEntity.ReferredType as ITypeReferrer;
-				if (nextTypeReferringEntity != null)
-				{
-					 CheckTypeReferrer(module, nextTypeReferringEntity);
-				}
-		  }
-
-		  public static ITypeAssignment ResolveType(IModule module, TypeAssignment type)
-		  {
-				ITypeAssignment result = ResolveDeclaration(module, type.Type) as ITypeAssignment;
-
-				return (result != null) ? result : type;
-		  }
-
-		  public static IDeclaration ResolveDeclaration(IModule module, string name)
-		  {
-				if ((module == null) || String.IsNullOrEmpty(name))
-				{
-					 return null;
-				}
-
-				// check module internal types
-				foreach (IDeclaration decl in module.Declarations)
-				{
-				if (decl.Name == name)
-					 {
-					return decl;
-					 }
-				}
-
-				// check if type is imported
-				if (module.Imports != null)
-				{
-					 ImportsFrom imports = module.Imports.GetImportFromType(name);
-					 if (imports != null)
-					 {
-						  IModule importedModule = ResolveModule(imports.Module);
-						  if (importedModule != null)
-						  {
-								return ResolveDeclaration(importedModule, name);
-						  }
-					 }
-				}
-
-				return null;
-		  }
-
-		  public static ObjectIdentifier ResolveOid(IEntity entity)
-		  {
-				ObjectIdentifier result = new ObjectIdentifier();
-
-				if (entity != null)
-				{
-					 ResolveOid(entity, result);
-				}
-
-				return result;
-		  }
-
-		  private static void ResolveOid(IEntity entity, ObjectIdentifier result)
-		  {
-				result.Prepend(entity.Name, entity.Value);
-				
-				// check parent
-				if (!String.IsNullOrEmpty(entity.Parent))
-				{
-					 string[] pathParts = entity.Parent.Split('.');
-					 uint value;
-
-					 // all parts except the first should have their value directly or indirectly with them
-					 if (pathParts.Length > 1)
-					 {
-						  for (int i=pathParts.Length-1; i>=1; i--)
-						  {
-								if (uint.TryParse(pathParts[i], out value))
-								{
-									 result.Prepend("", value);
-								}
-								else
-								{
-									 Match m = _namedOidPathRegex.Match(pathParts[i]);
-									 if (m.Success)
-									 {
-										  result.Prepend(m.Groups["Name"].Value, uint.Parse(m.Groups["Value"].Value));
-									 }
-									 else
-									 {
-										  throw new MibException("Invalid OID path detected for entity '" + entity.Name + "' in module '" + entity.Module + "'!");
-									 }
-								}
-						  }
-					 }
-
-					 // parse root part: either another entity or a standard root object
-					 if (IsOidRoot(pathParts[0], out value))
-					 {
-						  result.Prepend(pathParts[0], value);
-					 }
-					 else
-					 {
-						  // try to find entity inside this module
-						  if (entity.Module != null)
-						  {
-								entity = ResolveDeclaration(entity.Module, pathParts[0]) as IEntity;
-
-								if (entity != null)
-								{
-									 ResolveOid(entity, result);
-								}
-								else
-								{
-									 result.Prepend("", uint.MaxValue);
-								}
-						  }
-						  else
-						  {
-								result.Prepend("", uint.MaxValue);
-						  }
-					 }
-				}
-		  }
-
-		  public static bool IsOidRoot(string name, out uint value)
-		  {
-				value = uint.MaxValue;
-
-				switch (name)
-				{
-					 case "ccitt": value = 0; return true;
-					 case "iso": value = 1; return true;
-					 case "joint-iso-ccitt": value = 2; return true;
-				}
-
-				return false;
-		  }
-	 }
-}
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/ObjectIdentifier.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/ObjectIdentifier.cs
deleted file mode 100644
index 04248043..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/ObjectIdentifier.cs
+++ /dev/null
@@ -1,54 +0,0 @@
-﻿using System.Collections.Generic;
-using System.Text;
-
-namespace Lextm.SharpSnmpLib.Mib
-{
-    public class ObjectIdentifier: List<KeyValuePair<string, uint>>
-    {
-        public void Add(string name, uint oid)
-        {
-            this.Add(new KeyValuePair<string, uint>(name, oid));
-        }
-
-        public void Prepend(string name, uint oid)
-        {
-            this.Insert(0, new KeyValuePair<string, uint>(name, oid));
-        }
-
-        public void Insert(int index, string name, uint oid)
-        {
-            this.Insert(index, new KeyValuePair<string, uint>(name, oid));
-        }
-
-        public string GetOidString()
-        {
-            StringBuilder result = new StringBuilder();
-
-            foreach (KeyValuePair<string, uint> level in this)
-            {
-                result.Append(level.Value);
-                result.Append('.');
-            }
-
-            if (result.Length > 0)
-            {
-                result.Length--;
-            }
-
-            return result.ToString();
-        }
-
-        public uint[] GetOidValues()
-        {
-            List<uint> result = new List<uint>();
-            
-            foreach (KeyValuePair<string, uint> level in this)
-            {
-                result.Add(level.Value);
-            }
-
-            return result.ToArray();
-        }
-
-    }
-}
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Status.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Status.cs
deleted file mode 100644
index 4ddd3bab..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Status.cs
+++ /dev/null
@@ -1,17 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-
-namespace Lextm.SharpSnmpLib.Mib
-{
-    public enum Status
-    {
-        current,
-        deprecated,
-        obsolete,
-        mandatory,
-        optional
-    }
-
-}
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Symbol.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Symbol.cs
deleted file mode 100644
index b11386d8..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/Symbol.cs
+++ /dev/null
@@ -1,357 +0,0 @@
-/*
- * Created by SharpDevelop.
- * User: lextm
- * Date: 2008/5/17
- * Time: 17:14
- * 
- * To change this template use Tools | Options | Coding | Edit Standard Headers.
- */
-
-using System;
-using System.Configuration;
-using System.Globalization;
-using System.Text;
-
-namespace Lextm.SharpSnmpLib.Mib
-{
-    /// <summary>
-    /// Description of Symbol.
-    /// </summary>
-    public sealed class Symbol : IEquatable<Symbol>
-    {
-        private readonly string _text;
-        private readonly int _row;
-        private readonly int _column;
-        private readonly string _file;
-        
-        private Symbol(string text) : this(null, text, -1, -1)
-        {
-        }
-        
-        /// <summary>
-        /// Creates a <see cref="Symbol"/>.
-        /// </summary>
-        /// <param name="file">File</param>
-        /// <param name="text">Text</param>
-        /// <param name="row">Row number</param>
-        /// <param name="column">column number</param>
-        public Symbol(string file, string text, int row, int column)
-        {
-            _file = file;
-            _text = text;
-            _row = row;
-            _column = column;
-        }
-        
-        /// <summary>
-        /// File.
-        /// </summary>
-        public string File
-        {
-            get
-            {
-                return _file;
-            }
-        }
-        
-        /// <summary>
-        /// Row number.
-        /// </summary>
-        public int Row
-        {
-            get
-            {
-                return _row;
-            }
-        }
-        
-        /// <summary>
-        /// Column number.
-        /// </summary>
-        public int Column
-        {
-            get
-            {
-                return _column;
-            }
-        }        
-        
-        /// <summary>
-        /// Returns a <see cref="String"/> that represents this <see cref="Symbol"/>.
-        /// </summary>
-        /// <returns></returns>
-        public override string ToString()
-        {
-            return _text;
-        }
-        
-        /// <summary>
-        /// Determines whether the specified <see cref="Object"/> is equal to the current <see cref="Symbol"/>.
-        /// </summary>
-        /// <param name="obj">The <see cref="Object"/> to compare with the current <see cref="Symbol"/>. </param>
-        /// <returns><value>true</value> if the specified <see cref="Object"/> is equal to the current <see cref="Symbol"/>; otherwise, <value>false</value>.
-        /// </returns>
-        public override bool Equals(object obj)
-        {
-            if (obj == null)
-            {
-                return false;
-            }
-            
-            if (ReferenceEquals(this, obj))
-            {
-                return true;
-            }
-            
-            return GetType() == obj.GetType() && Equals((Symbol)obj);
-        }
-        
-        /// <summary>
-        /// Serves as a hash function for a particular type.
-        /// </summary>
-        /// <returns>A hash code for the current <see cref="Symbol"/>.</returns>
-        public override int GetHashCode()
-        {
-            return _text.GetHashCode();
-        }
-
-        /// <summary>
-        /// The equality operator.
-        /// </summary>
-        /// <param name="left">Left <see cref="Symbol"/> object</param>
-        /// <param name="right">Right <see cref="Symbol"/> object</param>
-        /// <returns>
-        /// Returns <c>true</c> if the values of its operands are equal, <c>false</c> otherwise.</returns>
-        public static bool operator ==(Symbol left, Symbol right)
-        {
-            return Equals(left, right);
-        }
-        
-        /// <summary>
-        /// Determines whether the specified <see cref="Symbol"/> is equal to the current <see cref="Symbol"/>.
-        /// </summary>
-        /// <param name="left">Left <see cref="Symbol"/> object</param>
-        /// <param name="right">Right <see cref="Symbol"/> object</param>
-        /// <returns>
-        /// Returns <c>true</c> if the values of its operands are equal, <c>false</c> otherwise.</returns>
-        public static bool Equals(Symbol left, Symbol right)
-        {
-            object l = left;
-            object r = right;
-            if (l == r)
-            {
-                return true;
-            }
-
-            if (l == null || r == null)
-            {
-                return false;
-            }
-
-            return left._text.Equals(right._text);
-        }
-        
-        /// <summary>
-        /// The inequality operator.
-        /// </summary>
-        /// <param name="left">Left <see cref="Symbol"/> object</param>
-        /// <param name="right">Right <see cref="Symbol"/> object</param>
-        /// <returns>
-        /// Returns <c>true</c> if the values of its operands are not equal, <c>false</c> otherwise.</returns>
-        public static bool operator !=(Symbol left, Symbol right)
-        {
-            return !(left == right);
-        }
-
-        #region IEquatable<Symbol> Members
-        /// <summary>
-        /// Indicates whether the current object is equal to another object of the same type.
-        /// </summary>
-        /// <param name="other">An object to compare with this object.</param>
-        /// <returns><value>true</value> if the current object is equal to the <paramref name="other"/> parameter; otherwise, <value>false</value>.
-        /// </returns>
-        public bool Equals(Symbol other)
-        {
-            return Equals(this, other);
-        }
-
-        #endregion
-        
-        public static readonly Symbol Definitions = new Symbol("DEFINITIONS");        
-        public static readonly Symbol Begin = new Symbol("BEGIN");        
-        public static readonly Symbol Object = new Symbol("OBJECT");        
-        public static readonly Symbol Identifier = new Symbol("IDENTIFIER");
-        public static readonly Symbol Assign = new Symbol("::=");
-        public static readonly Symbol OpenBracket = new Symbol("{");
-        public static readonly Symbol CloseBracket = new Symbol("}");
-        public static readonly Symbol Comment = new Symbol("--");
-        public static readonly Symbol Imports = new Symbol("IMPORTS");
-        public static readonly Symbol Semicolon = new Symbol(";");
-        public static readonly Symbol From = new Symbol("FROM");
-        public static readonly Symbol ModuleIdentity = new Symbol("MODULE-IDENTITY");
-        public static readonly Symbol ObjectType = new Symbol("OBJECT-TYPE");
-        public static readonly Symbol ObjectGroup = new Symbol("OBJECT-GROUP");
-        public static readonly Symbol NotificationGroup = new Symbol("NOTIFICATION-GROUP");
-        public static readonly Symbol ModuleCompliance = new Symbol("MODULE-COMPLIANCE");
-        public static readonly Symbol Sequence = new Symbol("SEQUENCE");
-        public static readonly Symbol NotificationType = new Symbol("NOTIFICATION-TYPE");
-        public static readonly Symbol EOL = new Symbol(Environment.NewLine);
-        public static readonly Symbol ObjectIdentity = new Symbol("OBJECT-IDENTITY");
-        public static readonly Symbol End = new Symbol("END");
-        public static readonly Symbol Macro = new Symbol("MACRO");
-        public static readonly Symbol Choice = new Symbol("CHOICE");
-        public static readonly Symbol TrapType = new Symbol("TRAP-TYPE");
-        public static readonly Symbol AgentCapabilities = new Symbol("AGENT-CAPABILITIES");
-        public static readonly Symbol Comma = new Symbol(",");
-        public static readonly Symbol TextualConvention = new Symbol("TEXTUAL-CONVENTION");
-        public static readonly Symbol Syntax = new Symbol("SYNTAX");
-        public static readonly Symbol Bits = new Symbol("BITS");
-        public static readonly Symbol Octet = new Symbol("OCTET");
-        public static readonly Symbol String = new Symbol("STRING");
-        public static readonly Symbol OpenParentheses = new Symbol("(");
-        public static readonly Symbol CloseParentheses = new Symbol(")");
-        public static readonly Symbol Exports = new Symbol("EXPORTS");
-        public static readonly Symbol DisplayHint = new Symbol("DISPLAY-HINT");
-        public static readonly Symbol Status = new Symbol("STATUS");
-        public static readonly Symbol Description = new Symbol("DESCRIPTION");
-        public static readonly Symbol Reference = new Symbol("REFERENCE");
-        public static readonly Symbol DoubleDot = new Symbol("..");
-        public static readonly Symbol Pipe = new Symbol("|");
-        public static readonly Symbol Size = new Symbol("SIZE");
-        public static readonly Symbol Units = new Symbol("UNITS");
-        public static readonly Symbol MaxAccess = new Symbol("MAX-ACCESS");
-        public static readonly Symbol Access = new Symbol("ACCESS");
-        public static readonly Symbol Index = new Symbol("INDEX");
-        public static readonly Symbol Augments = new Symbol("AUGMENTS");
-        public static readonly Symbol DefVal = new Symbol("DEFVAL");
-        public static readonly Symbol Of = new Symbol("OF");
-        public static readonly Symbol Integer = new Symbol("INTEGER");
-        public static readonly Symbol Integer32 = new Symbol("Integer32");
-        public static readonly Symbol IpAddress = new Symbol("IpAddress");
-        public static readonly Symbol Counter32 = new Symbol("Counter32");
-        public static readonly Symbol Counter = new Symbol("Counter");
-        public static readonly Symbol TimeTicks = new Symbol("TimeTicks");
-        public static readonly Symbol Opaque = new Symbol("Opaque");
-        public static readonly Symbol Counter64 = new Symbol("Counter64");
-        public static readonly Symbol Unsigned32 = new Symbol("Unsigned32");
-        public static readonly Symbol Gauge32 = new Symbol("Gauge32");
-        public static readonly Symbol Gauge = new Symbol("Gauge");
-        public static readonly Symbol TruthValue = new Symbol("TruthValue");
-        public static readonly Symbol Implied = new Symbol("IMPLIED");
-
-        internal void Expect(Symbol expected, params Symbol[] orExpected)
-        {
-            bool isExpected = (this == expected);
-
-            if (!isExpected && (orExpected != null) && (orExpected.Length > 0))
-            {
-                // check the alternatives
-                for (int i=0; i<orExpected.Length; i++)
-                {
-                    if (this == orExpected[i])
-                    {
-                        isExpected = true;
-                        break;
-                    }
-                }              
-            }
-
-            if (!isExpected)
-            {
-                if ((orExpected == null) || (orExpected.Length == 0))
-                {
-                    Assert(false, "Unexpected symbol found! Expected '" + expected.ToString() + "'");
-                }
-                else
-                {
-                    StringBuilder msg = new StringBuilder("Unexpected symbol found! Expected one of the following: '");
-                    msg.Append(expected);
-
-                    // check the alternatives
-                    for (int i=0; i<orExpected.Length; i++)
-                    {
-                        msg.Append("', '");
-                        msg.Append(expected);
-                    }
-                    msg.Append("'");
-
-                    Assert(false, msg.ToString());
-                }
-            }
-        }
-
-        internal void Assert(bool condition, string message)
-        {
-            if (!condition)
-            {
-                throw MibException.Create(message, this);
-            }
-        }
-
-        internal void AssertIsValidIdentifier()
-        {
-            string message;
-            bool isValid = IsValidIdentifier(ToString(), out message);
-            Assert(isValid, message);
-        }
-
-        internal bool IsValidIdentifier()
-        {      
-            string message;
-            return IsValidIdentifier(ToString(), out message);
-        }
-
-        private static bool IsValidIdentifier(string name, out string message)
-        {
-            if (UseStricterValidation && (name.Length < 1 || name.Length > 64))
-            {
-                message = "an identifier must consist of 1 to 64 letters, digits, and hyphens";
-                return false;
-            }
-
-            if (!Char.IsLetter(name[0]))
-            {
-                message = "the initial character must be a letter";
-                return false;
-            }
-
-            if (name.EndsWith("-", StringComparison.Ordinal))
-            {
-                message = "a hyphen cannot be the last character of an identifier";
-                return false;
-            }
-
-            if (name.Contains("--"))
-            {
-                message = "a hyphen cannot be immediately followed by another hyphen in an identifier";
-                return false;
-            }
-
-            if (UseStricterValidation && name.Contains("_"))
-            {
-                message = "underscores are not allowed in identifiers";
-                return false;
-            }
-
-            // TODO: SMIv2 forbids "-" except in module names and keywords
-            message = null;
-            return true;
-        }
-
-        private static bool? _useStricterValidation;
-
-        private static bool UseStricterValidation
-        {
-            get
-            {
-                if (_useStricterValidation == null)
-                {
-                    object setting = ConfigurationManager.AppSettings["StricterValidationEnabled"];
-                    _useStricterValidation = setting != null && Convert.ToBoolean(setting.ToString(), CultureInfo.InvariantCulture);
-                }
-
-                return _useStricterValidation.Value;
-            }
-        }
-    }
-}
\ No newline at end of file
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/SymbolList.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/SymbolList.cs
deleted file mode 100644
index 5b2218e8..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/SymbolList.cs
+++ /dev/null
@@ -1,146 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-
-namespace Lextm.SharpSnmpLib.Mib
-{
-    public class SymbolList : List<Symbol>
-    {
-        public class SymbolEnumerator : ISymbolEnumerator
-        {
-            private SymbolList _list  = null;
-            private int        _index = -1;
-
-            internal SymbolEnumerator(SymbolList list)
-            {
-                if (list == null)
-                {
-                    throw new ArgumentNullException("lexer");
-                }
-
-                _list = list;
-            }
-
-            #region ISymbolEnumerator Member
-
-            public bool PutBack(Symbol item)
-            {
-                if ((_index < 0) || (_index >= _list.Count) || (item != _list[_index]))
-                {
-                    throw new ArgumentException(@"wrong last symbol", "last");
-                    //return false;
-                }
-
-                _index--;
-                return true;
-            }
-
-            #endregion
-
-            #region IEnumerator<Symbol> Member
-
-            public Symbol Current
-            {
-                get
-                {
-                    if ((_index >= 0) && (_index <= _list.Count))
-                    {
-                        return _list[_index];
-                    }
-
-                    return null;
-                }
-            }
-
-            #endregion
-
-            #region IDisposable Member
-
-            public void Dispose()
-            {
-            }
-
-            #endregion
-
-            #region IEnumerator Member
-
-            object System.Collections.IEnumerator.Current
-            {
-                get { return this.Current; }
-            }
-
-            public bool MoveNext()
-            {
-                _index++;
-                return (_index >= 0) && (_index < _list.Count);
-            }
-
-            public void Reset()
-            {
-                _index = -1;
-            }
-
-            #endregion
-        }
-
-        /// <summary>
-        /// Initializes a new instance of the <see cref="SymbolList"/> class.
-        /// </summary>
-        public SymbolList()
-        {
-        }
-
-        public ISymbolEnumerator GetSymbolEnumerator()
-        {
-            return new SymbolEnumerator(this);
-        }
-
-        public string Join(string separator)
-        {
-            if (separator == null)
-                separator = "";
-
-            StringBuilder result = new StringBuilder();
-
-            foreach (Symbol s in this)
-            {
-                result.Append(s);
-                result.Append(separator);
-            }
-
-            if (result.Length > 0)
-            {
-                result.Length -= separator.Length;
-            }
-
-            return result.ToString();
-        }
-    }
-
-    public static class SymbolEnumeratorExtension
-    {
-        public static Symbol NextSymbol(this IEnumerator<Symbol> enumerator)
-        {
-            if (enumerator.MoveNext())
-            {
-                return enumerator.Current;
-            }
-
-            return null;
-        }
-
-        public static Symbol NextNonEOLSymbol(this IEnumerator<Symbol> enumerator)
-        {
-            while (enumerator.MoveNext())
-            {
-                if (enumerator.Current != Symbol.EOL)
-                {
-                    return enumerator.Current;
-                }
-            }
-
-            return null;
-        }
-    }
-}
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/ValueMap.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/ValueMap.cs
deleted file mode 100644
index 184dd580..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/ValueMap.cs
+++ /dev/null
@@ -1,103 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-
-namespace Lextm.SharpSnmpLib.Mib
-{
-	public class ValueMap : Dictionary<Int64, string>
-	{
-		public ValueMap()
-		{
-		}
-
-		/// <summary>
-		/// Returns the values of the map as continous range. At best as one range.
-		/// </summary>
-		/// <returns></returns>
-		public ValueRanges GetContinousRanges()
-		{
-			ValueRanges result = new ValueRanges();
-
-			if (this.Count > 0)
-			{
-				List<Int64> values = new List<long>(this.Keys);
-				values.Sort();
-
-				Int64 last   = values[0];
-				Int64 offset = values[0];
-				for (int i=1; i<values.Count; i++)
-				{
-					if (values[i] != last + 1)
-					{
-						if (last == offset)
-						{
-							result.Add(new ValueRange(offset, null));
-						}
-						else
-						{
-							result.Add(new ValueRange(offset, last));
-						}
-
-						offset = values[i];
-					}
-
-					last = values[i];
-				}
-
-				if (last == offset)
-				{
-					result.Add(new ValueRange(offset, null));
-				}
-				else
-				{
-					result.Add(new ValueRange(offset, last));
-				}
-			}
-
-			return result;
-		}
-
-		/// <summary>
-		/// Gets the highest value contained in this value map.
-		/// </summary>
-		/// <returns></returns>
-		public Int64 GetHighestValue()
-		{
-			Int64 result = 0;
-
-			foreach (Int64 value in this.Keys)
-			{
-				if (value > result)
-				{
-					result = value;
-				}
-			}
-
-			return result;
-		}
-
-		/// <summary>
-		/// Interprets the single values as bit positions and creates a mask of it.
-		/// </summary>
-		/// <returns></returns>
-		public UInt32 GetBitMask()
-		{
-			UInt32 result = 0;
-
-			foreach (Int64 key in this.Keys)
-			{
-				if (key < 0)
-				{
-					throw new NotSupportedException("Negative numbers are not allowed for Bits!");
-				}
-				if (key > 31)
-				{
-					throw new NotSupportedException("Bits with more than 32 bits are not supported!");
-				}
-
-				result |= (UInt32)(1 << (int)key);
-			}
-
-			return result;
-		}
-	}
-}
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/ValueRange.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/ValueRange.cs
deleted file mode 100644
index 3ff5bcb7..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Mib/ValueRange.cs
+++ /dev/null
@@ -1,76 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-
-namespace Lextm.SharpSnmpLib.Mib
-{
-    public class ValueRanges: List<ValueRange>
-    {
-        public bool IsSizeDeclaration { get; internal set; }
-
-        public ValueRanges(bool isSizeDecl = false)
-        {
-            IsSizeDeclaration = isSizeDecl;
-        }
-
-        public bool Contains(Int64 value)
-        {
-            foreach (ValueRange range in this)
-            {
-                if (range.Contains(value))
-                {
-                    return true;
-                }
-            }
-
-            return false;
-        }
-    }
-
-    public class ValueRange
-    {
-        private readonly Int64 _start;
-        private readonly Int64? _end;
-
-        public ValueRange(Int64 first, Int64? second)
-        {
-            _start = first;
-            _end   = second;
-        }
-
-        public Int64 Start
-        {
-            get { return _start; }
-        }
-
-        public Int64? End
-        {
-            get { return _end; }
-        }
-
-        public bool IntersectsWith(ValueRange other)
-        {
-            if (this._end == null)
-            {
-                return other.Contains(this._start);
-            }
-            else if (other._end == null)
-            {
-                return this.Contains(other._start);
-            }
-
-            return (this._start <= other.End) && (this._end >= other._start);
-        }
-
-        public bool Contains(Int64 value)
-        {
-            if (_end == null)
-            {
-                return value == _start;
-            }
-            else
-            {
-                return (_start <= value) && (value <= _end);
-            }
-        }
-    }
-}
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Properties/AssemblyInfo.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Properties/AssemblyInfo.cs
deleted file mode 100644
index f96080d0..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Properties/AssemblyInfo.cs
+++ /dev/null
@@ -1,61 +0,0 @@
-// <summary>#SNMP Library. An open source SNMP implementation for .NET.</summary>
-// <copyright company="Lex Y. Li" file="AssemblyInfo.cs">Copyright (C) 2008  Lex Y. Li</copyright>
-// 
-// This library is free software; you can redistribute it and/or
-// modify it under the terms of the GNU Lesser General Public
-// License as published by the Free Software Foundation; either
-// version 2.1 of the License, or (at your option) any later version.
-// 
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-// Lesser General Public License for more details.
-// 
-// You should have received a copy of the GNU Lesser General Public
-// License along with this library; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-
-#region Using directives
-
-using System;
-using System.Reflection;
-using System.Resources;
-using System.Runtime.CompilerServices;
-using System.Runtime.InteropServices;
-
-#endregion
-
-// General Information about an assembly is controlled through the following
-// set of attributes. Change these attribute values to modify the information
-// associated with an assembly.
-[assembly: AssemblyTitle("SharpSnmpLib")]
-[assembly: AssemblyDescription("#SNMP Library for .NET")]
-[assembly: AssemblyConfiguration("Lesser GPL 2.1+")]
-[assembly: AssemblyCompany("LeXtudio")]
-[assembly: AssemblyProduct("#SNMPLib")]
-[assembly: AssemblyCopyright("(C) 2008-2010 Malcolm Crowe, Lex Li, Steve Santacroce, and other contributors.")]
-[assembly: AssemblyTrademark("")]
-[assembly: AssemblyCulture("")]
-
-// This sets the default COM visibility of types in the assembly to invisible.
-// If you need to expose index type to COM, use [ComVisible(true)] on that type.
-[assembly: ComVisible(false)]
-
-// The assembly version has following format :
-//
-// Major.Minor.Build.Revision
-//
-// You can specify all the values or you can use the default the Revision and
-// Build Numbers by using the '*' as shown below:
-[assembly: AssemblyVersion("7.0.011207.31")]
-#if (!CF)
-[assembly: AssemblyFileVersion("7.0.011207.31")]
-#endif
-[assembly: NeutralResourcesLanguage("en-US")]
-[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Lextm")]
-
-[assembly: InternalsVisibleTo("SharpSnmpLib.Tests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100f7030532c52524"
-+ "993841a0d09420340f3814e1b65473851bdcd18815510b035a2ae9ecee69c4cd2d9e4d6e6d5fbf"
-+ "a564e86c4a4cddc9597619a31c060846ebb2e99511a0323ff82b1ebd95d6a4912502945f0e769f"
-+ "190a69a439dbfb969ebad72a6f7e2e047907da4a7b9c08c6e98d5f1be8b8cafaf3eb978914059a"
-+ "245d4bc1")]
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Properties/Resources.Designer.cs b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Properties/Resources.Designer.cs
deleted file mode 100644
index 38bc6bb9..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Properties/Resources.Designer.cs
+++ /dev/null
@@ -1,63 +0,0 @@
-﻿//------------------------------------------------------------------------------
-// <auto-generated>
-//     Dieser Code wurde von einem Tool generiert.
-//     Laufzeitversion:4.0.30319.225
-//
-//     Änderungen an dieser Datei können falsches Verhalten verursachen und gehen verloren, wenn
-//     der Code erneut generiert wird.
-// </auto-generated>
-//------------------------------------------------------------------------------
-
-namespace Lextm.SharpSnmpLib.Mib {
-    using System;
-    
-    
-    /// <summary>
-    ///   Eine stark typisierte Ressourcenklasse zum Suchen von lokalisierten Zeichenfolgen usw.
-    /// </summary>
-    // Diese Klasse wurde von der StronglyTypedResourceBuilder automatisch generiert
-    // -Klasse über ein Tool wie ResGen oder Visual Studio automatisch generiert.
-    // Um einen Member hinzuzufügen oder zu entfernen, bearbeiten Sie die .ResX-Datei und führen dann ResGen
-    // mit der /str-Option erneut aus, oder Sie erstellen Ihr VS-Projekt neu.
-    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
-    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
-    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
-    internal class Resources {
-        
-        private static global::System.Resources.ResourceManager resourceMan;
-        
-        private static global::System.Globalization.CultureInfo resourceCulture;
-        
-        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
-        internal Resources() {
-        }
-        
-        /// <summary>
-        ///   Gibt die zwischengespeicherte ResourceManager-Instanz zurück, die von dieser Klasse verwendet wird.
-        /// </summary>
-        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
-        internal static global::System.Resources.ResourceManager ResourceManager {
-            get {
-                if (object.ReferenceEquals(resourceMan, null)) {
-                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Lextm.SharpSnmpLib.Properties.Resources", typeof(Resources).Assembly);
-                    resourceMan = temp;
-                }
-                return resourceMan;
-            }
-        }
-        
-        /// <summary>
-        ///   Überschreibt die CurrentUICulture-Eigenschaft des aktuellen Threads für alle
-        ///   Ressourcenzuordnungen, die diese stark typisierte Ressourcenklasse verwenden.
-        /// </summary>
-        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
-        internal static global::System.Globalization.CultureInfo Culture {
-            get {
-                return resourceCulture;
-            }
-            set {
-                resourceCulture = value;
-            }
-        }
-    }
-}
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Properties/Resources.resx b/contrib/apps/LwipMibCompiler/SharpSnmpLib/Properties/Resources.resx
deleted file mode 100644
index 7080a7d1..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/Properties/Resources.resx
+++ /dev/null
@@ -1,120 +0,0 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<root>
-  <!-- 
-    Microsoft ResX Schema 
-    
-    Version 2.0
-    
-    The primary goals of this format is to allow a simple XML format 
-    that is mostly human readable. The generation and parsing of the 
-    various data types are done through the TypeConverter classes 
-    associated with the data types.
-    
-    Example:
-    
-    ... ado.net/XML headers & schema ...
-    <resheader name="resmimetype">text/microsoft-resx</resheader>
-    <resheader name="version">2.0</resheader>
-    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
-    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
-    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
-    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
-    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
-        <value>[base64 mime encoded serialized .NET Framework object]</value>
-    </data>
-    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
-        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
-        <comment>This is a comment</comment>
-    </data>
-                
-    There are any number of "resheader" rows that contain simple 
-    name/value pairs.
-    
-    Each data row contains a name, and value. The row also contains a 
-    type or mimetype. Type corresponds to a .NET class that support 
-    text/value conversion through the TypeConverter architecture. 
-    Classes that don't support this are serialized and stored with the 
-    mimetype set.
-    
-    The mimetype is used for serialized objects, and tells the 
-    ResXResourceReader how to depersist the object. This is currently not 
-    extensible. For a given mimetype the value must be set accordingly:
-    
-    Note - application/x-microsoft.net.object.binary.base64 is the format 
-    that the ResXResourceWriter will generate, however the reader can 
-    read any of the formats listed below.
-    
-    mimetype: application/x-microsoft.net.object.binary.base64
-    value   : The object must be serialized with 
-            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
-            : and then encoded with base64 encoding.
-    
-    mimetype: application/x-microsoft.net.object.soap.base64
-    value   : The object must be serialized with 
-            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
-            : and then encoded with base64 encoding.
-
-    mimetype: application/x-microsoft.net.object.bytearray.base64
-    value   : The object must be serialized into a byte array 
-            : using a System.ComponentModel.TypeConverter
-            : and then encoded with base64 encoding.
-    -->
-  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
-    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
-    <xsd:element name="root" msdata:IsDataSet="true">
-      <xsd:complexType>
-        <xsd:choice maxOccurs="unbounded">
-          <xsd:element name="metadata">
-            <xsd:complexType>
-              <xsd:sequence>
-                <xsd:element name="value" type="xsd:string" minOccurs="0" />
-              </xsd:sequence>
-              <xsd:attribute name="name" use="required" type="xsd:string" />
-              <xsd:attribute name="type" type="xsd:string" />
-              <xsd:attribute name="mimetype" type="xsd:string" />
-              <xsd:attribute ref="xml:space" />
-            </xsd:complexType>
-          </xsd:element>
-          <xsd:element name="assembly">
-            <xsd:complexType>
-              <xsd:attribute name="alias" type="xsd:string" />
-              <xsd:attribute name="name" type="xsd:string" />
-            </xsd:complexType>
-          </xsd:element>
-          <xsd:element name="data">
-            <xsd:complexType>
-              <xsd:sequence>
-                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
-                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
-              </xsd:sequence>
-              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
-              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
-              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
-              <xsd:attribute ref="xml:space" />
-            </xsd:complexType>
-          </xsd:element>
-          <xsd:element name="resheader">
-            <xsd:complexType>
-              <xsd:sequence>
-                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
-              </xsd:sequence>
-              <xsd:attribute name="name" type="xsd:string" use="required" />
-            </xsd:complexType>
-          </xsd:element>
-        </xsd:choice>
-      </xsd:complexType>
-    </xsd:element>
-  </xsd:schema>
-  <resheader name="resmimetype">
-    <value>text/microsoft-resx</value>
-  </resheader>
-  <resheader name="version">
-    <value>2.0</value>
-  </resheader>
-  <resheader name="reader">
-    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
-  </resheader>
-  <resheader name="writer">
-    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
-  </resheader>
-</root>
\ No newline at end of file
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/SharpSnmpLib.Mib.csproj b/contrib/apps/LwipMibCompiler/SharpSnmpLib/SharpSnmpLib.Mib.csproj
deleted file mode 100644
index 2cf86578..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/SharpSnmpLib.Mib.csproj
+++ /dev/null
@@ -1,140 +0,0 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <PropertyGroup>
-    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
-    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
-    <ProductVersion>8.0.30703</ProductVersion>
-    <SchemaVersion>2.0</SchemaVersion>
-    <ProjectGuid>{CBE20411-5DB7-487D-825D-7694267BB6F5}</ProjectGuid>
-    <OutputType>Library</OutputType>
-    <AppDesignerFolder>Properties</AppDesignerFolder>
-    <RootNamespace>Lextm.SharpSnmpLib</RootNamespace>
-    <AssemblyName>SharpSnmpLib.Mib</AssemblyName>
-    <DocumentationFile>..\bin\SharpSnmpLib.Mib.xml</DocumentationFile>
-    <FileAlignment>512</FileAlignment>
-    <TargetFrameworkProfile />
-    <SignAssembly>True</SignAssembly>
-    <AssemblyOriginatorKeyFile>sharpsnmplib.snk</AssemblyOriginatorKeyFile>
-    <DelaySign>False</DelaySign>
-    <AssemblyOriginatorKeyMode>File</AssemblyOriginatorKeyMode>
-    <SccProjectName>
-    </SccProjectName>
-    <SccLocalPath>
-    </SccLocalPath>
-    <SccAuxPath>
-    </SccAuxPath>
-    <SccProvider>
-    </SccProvider>
-    <RunSourceAnalysis>False</RunSourceAnalysis>
-    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
-    <DebugSymbols>true</DebugSymbols>
-    <DebugType>full</DebugType>
-    <Optimize>false</Optimize>
-    <OutputPath>bin\Debug\</OutputPath>
-    <DefineConstants>DEBUG;TRACE</DefineConstants>
-    <ErrorReport>prompt</ErrorReport>
-    <WarningLevel>4</WarningLevel>
-    <DocumentationFile>
-    </DocumentationFile>
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
-    <DebugType>pdbonly</DebugType>
-    <Optimize>true</Optimize>
-    <OutputPath>bin\Release\</OutputPath>
-    <DefineConstants>TRACE</DefineConstants>
-    <ErrorReport>prompt</ErrorReport>
-    <WarningLevel>4</WarningLevel>
-    <DocumentationFile>
-    </DocumentationFile>
-  </PropertyGroup>
-  <ItemGroup>
-    <Reference Include="System" />
-    <Reference Include="System.Configuration" />
-  </ItemGroup>
-  <ItemGroup>
-    <Compile Include="Mib\DisplayHint.cs" />
-    <Compile Include="Mib\Elements\Entities\AgentCapabilities.cs" />
-    <Compile Include="Mib\Elements\Entities\EntityBase.cs" />
-    <Compile Include="Mib\Elements\Entities\IEntity.cs" />
-    <Compile Include="Mib\Elements\Entities\ModuleCompliance.cs" />
-    <Compile Include="Mib\Elements\Entities\ModuleIdentity.cs" />
-    <Compile Include="Mib\Elements\Entities\NotificationGroup.cs" />
-    <Compile Include="Mib\Elements\Entities\NotificationType.cs" />
-    <Compile Include="Mib\Elements\Entities\ObjectGroup.cs" />
-    <Compile Include="Mib\Elements\Entities\ObjectIdentity.cs" />
-    <Compile Include="Mib\Elements\Entities\ObjectType.cs" />
-    <Compile Include="Mib\Elements\Entities\OidValueAssignment.cs" />
-    <Compile Include="Mib\Elements\Exports.cs" />
-    <Compile Include="Mib\Elements\IElement.cs" />
-    <Compile Include="Mib\Elements\Imports.cs" />
-    <Compile Include="Mib\Elements\ImportsFrom.cs" />
-    <Compile Include="Mib\Elements\IDeclaration.cs" />
-    <Compile Include="Mib\Elements\TrapType.cs" />
-    <Compile Include="Mib\Elements\Types\BaseType.cs" />
-    <Compile Include="Mib\Elements\Types\BitsType.cs" />
-    <Compile Include="Mib\Elements\Types\Choice.cs" />
-    <Compile Include="Mib\Elements\Types\IntegerType.cs" />
-    <Compile Include="Mib\Elements\Types\IpAddressType.cs" />
-    <Compile Include="Mib\Elements\Types\ITypeAssignment.cs" />
-    <Compile Include="Mib\Elements\ITypeReferrer.cs" />
-    <Compile Include="Mib\Elements\Types\Macro.cs" />
-    <Compile Include="Mib\Elements\Types\ObjectIdentifierType.cs" />
-    <Compile Include="Mib\Elements\Types\OctetStringType.cs" />
-    <Compile Include="Mib\Elements\Types\OpaqueType.cs" />
-    <Compile Include="Mib\Elements\Types\Sequence.cs" />
-    <Compile Include="Mib\Elements\Types\SequenceOf.cs" />
-    <Compile Include="Mib\Elements\Types\TextualConvention.cs" />
-    <Compile Include="Mib\Elements\Types\TypeAssignment.cs" />
-    <Compile Include="Mib\Elements\Types\UnsignedType.cs" />
-    <Compile Include="Mib\IModule.cs" />
-    <Compile Include="Mib\ISymbolEnumerator.cs" />
-    <Compile Include="Mib\MaxAccess.cs" />
-    <Compile Include="Mib\MibResolver.cs" />
-    <Compile Include="Mib\MibTree.cs" />
-    <Compile Include="Mib\MibTreeNode.cs" />
-    <Compile Include="Mib\MibTypesResolver.cs" />
-    <Compile Include="Mib\ObjectIdentifier.cs" />
-    <Compile Include="Mib\Status.cs" />
-    <Compile Include="Mib\SymbolList.cs" />
-    <Compile Include="Mib\Lexer.cs" />
-    <Compile Include="Mib\MibDocument.cs" />
-    <Compile Include="Mib\MibModule.cs" />
-    <Compile Include="Mib\MibException.cs" />
-    <Compile Include="Mib\Symbol.cs" />
-    <Compile Include="Mib\ValueMap.cs" />
-    <Compile Include="Mib\ValueRange.cs" />
-    <Compile Include="Properties\AssemblyInfo.cs" />
-    <Compile Include="Properties\Resources.Designer.cs">
-      <AutoGen>True</AutoGen>
-      <DesignTime>True</DesignTime>
-      <DependentUpon>Resources.resx</DependentUpon>
-    </Compile>
-  </ItemGroup>
-  <ItemGroup>
-    <None Include="sharpsnmplib.snk" />
-  </ItemGroup>
-  <ItemGroup>
-    <None Include="license.txt" />
-  </ItemGroup>
-  <ItemGroup>
-    <EmbeddedResource Include="Properties\Resources.resx">
-      <Generator>ResXFileCodeGenerator</Generator>
-      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
-      <CustomToolNamespace>Lextm.SharpSnmpLib.Mib</CustomToolNamespace>
-      <SubType>Designer</SubType>
-    </EmbeddedResource>
-  </ItemGroup>
-  <ItemGroup>
-    <Folder Include="Resources\" />
-  </ItemGroup>
-  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
-  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
-       Other similar extension points exist, see Microsoft.Common.targets.
-  <Target Name="BeforeBuild">
-  </Target>
-  <Target Name="AfterBuild">
-  </Target>
-  -->
-</Project>
\ No newline at end of file
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/license.txt b/contrib/apps/LwipMibCompiler/SharpSnmpLib/license.txt
deleted file mode 100644
index 27946de2..00000000
--- a/contrib/apps/LwipMibCompiler/SharpSnmpLib/license.txt
+++ /dev/null
@@ -1,458 +0,0 @@
-﻿		  GNU LESSER GENERAL PUBLIC LICENSE
-		       Version 2.1, February 1999
-
- Copyright (C) 1991, 1999 Free Software Foundation, Inc.
-     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-[This is the first released version of the Lesser GPL.  It also counts
- as the successor of the GNU Library Public License, version 2, hence
- the version number 2.1.]
-
-			    Preamble
-
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-Licenses are intended to guarantee your freedom to share and change
-free software--to make sure the software is free for all its users.
-
-  This license, the Lesser General Public License, applies to some
-specially designated software packages--typically libraries--of the
-Free Software Foundation and other authors who decide to use it.  You
-can use it too, but we suggest you first think carefully about whether
-this license or the ordinary General Public License is the better
-strategy to use in any particular case, based on the explanations below.
-
-  When we speak of free software, we are referring to freedom of use,
-not price.  Our General Public Licenses are designed to make sure that
-you have the freedom to distribute copies of free software (and charge
-for this service if you wish); that you receive source code or can get
-it if you want it; that you can change the software and use pieces of
-it in new free programs; and that you are informed that you can do
-these things.
-
-  To protect your rights, we need to make restrictions that forbid
-distributors to deny you these rights or to ask you to surrender these
-rights.  These restrictions translate to certain responsibilities for
-you if you distribute copies of the library or if you modify it.
-
-  For example, if you distribute copies of the library, whether gratis
-or for a fee, you must give the recipients all the rights that we gave
-you.  You must make sure that they, too, receive or can get the source
-code.  If you link other code with the library, you must provide
-complete object files to the recipients, so that they can relink them
-with the library after making changes to the library and recompiling
-it.  And you must show them these terms so they know their rights.
-
-  We protect your rights with a two-step method: (1) we copyright the
-library, and (2) we offer you this license, which gives you legal
-permission to copy, distribute and/or modify the library.
-
-  To protect each distributor, we want to make it very clear that
-there is no warranty for the free library.  Also, if the library is
-modified by someone else and passed on, the recipients should know
-that what they have is not the original version, so that the original
-author's reputation will not be affected by problems that might be
-introduced by others.
-
-  Finally, software patents pose a constant threat to the existence of
-any free program.  We wish to make sure that a company cannot
-effectively restrict the users of a free program by obtaining a
-restrictive license from a patent holder.  Therefore, we insist that
-any patent license obtained for a version of the library must be
-consistent with the full freedom of use specified in this license.
-
-  Most GNU software, including some libraries, is covered by the
-ordinary GNU General Public License.  This license, the GNU Lesser
-General Public License, applies to certain designated libraries, and
-is quite different from the ordinary General Public License.  We use
-this license for certain libraries in order to permit linking those
-libraries into non-free programs.
-
-  When a program is linked with a library, whether statically or using
-a shared library, the combination of the two is legally speaking a
-combined work, a derivative of the original library.  The ordinary
-General Public License therefore permits such linking only if the
-entire combination fits its criteria of freedom.  The Lesser General
-Public License permits more lax criteria for linking other code with
-the library.
-
-  We call this license the "Lesser" General Public License because it
-does Less to protect the user's freedom than the ordinary General
-Public License.  It also provides other free software developers Less
-of an advantage over competing non-free programs.  These disadvantages
-are the reason we use the ordinary General Public License for many
-libraries.  However, the Lesser license provides advantages in certain
-special circumstances.
-
-  For example, on rare occasions, there may be a special need to
-encourage the widest possible use of a certain library, so that it becomes
-a de-facto standard.  To achieve this, non-free programs must be
-allowed to use the library.  A more frequent case is that a free
-library does the same job as widely used non-free libraries.  In this
-case, there is little to gain by limiting the free library to free
-software only, so we use the Lesser General Public License.
-
-  In other cases, permission to use a particular library in non-free
-programs enables a greater number of people to use a large body of
-free software.  For example, permission to use the GNU C Library in
-non-free programs enables many more people to use the whole GNU
-operating system, as well as its variant, the GNU/Linux operating
-system.
-
-  Although the Lesser General Public License is Less protective of the
-users' freedom, it does ensure that the user of a program that is
-linked with the Library has the freedom and the wherewithal to run
-that program using a modified version of the Library.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.  Pay close attention to the difference between a
-"work based on the library" and a "work that uses the library".  The
-former contains code derived from the library, whereas the latter must
-be combined with the library in order to run.
-
-		  GNU LESSER GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-  0. This License Agreement applies to any software library or other
-program which contains a notice placed by the copyright holder or
-other authorized party saying it may be distributed under the terms of
-this Lesser General Public License (also called "this License").
-Each licensee is addressed as "you".
-
-  A "library" means a collection of software functions and/or data
-prepared so as to be conveniently linked with application programs
-(which use some of those functions and data) to form executables.
-
-  The "Library", below, refers to any such software library or work
-which has been distributed under these terms.  A "work based on the
-Library" means either the Library or any derivative work under
-copyright law: that is to say, a work containing the Library or a
-portion of it, either verbatim or with modifications and/or translated
-straightforwardly into another language.  (Hereinafter, translation is
-included without limitation in the term "modification".)
-
-  "Source code" for a work means the preferred form of the work for
-making modifications to it.  For a library, complete source code means
-all the source code for all modules it contains, plus any associated
-interface definition files, plus the scripts used to control compilation
-and installation of the library.
-
-  Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running a program using the Library is not restricted, and output from
-such a program is covered only if its contents constitute a work based
-on the Library (independent of the use of the Library in a tool for
-writing it).  Whether that is true depends on what the Library does
-and what the program that uses the Library does.
-  
-  1. You may copy and distribute verbatim copies of the Library's
-complete source code as you receive it, in any medium, provided that
-you conspicuously and appropriately publish on each copy an
-appropriate copyright notice and disclaimer of warranty; keep intact
-all the notices that refer to this License and to the absence of any
-warranty; and distribute a copy of this License along with the
-Library.
-
-  You may charge a fee for the physical act of transferring a copy,
-and you may at your option offer warranty protection in exchange for a
-fee.
-
-  2. You may modify your copy or copies of the Library or any portion
-of it, thus forming a work based on the Library, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) The modified work must itself be a software library.
-
-    b) You must cause the files modified to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    c) You must cause the whole of the work to be licensed at no
-    charge to all third parties under the terms of this License.
-
-    d) If a facility in the modified Library refers to a function or a
-    table of data to be supplied by an application program that uses
-    the facility, other than as an argument passed when the facility
-    is invoked, then you must make a good faith effort to ensure that,
-    in the event an application does not supply such function or
-    table, the facility still operates, and performs whatever part of
-    its purpose remains meaningful.
-
-    (For example, a function in a library to compute square roots has
-    a purpose that is entirely well-defined independent of the
-    application.  Therefore, Subsection 2d requires that any
-    application-supplied function or table used by this function must
-    be optional: if the application does not supply it, the square
-    root function must still compute square roots.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Library,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Library, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote
-it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Library.
-
-In addition, mere aggregation of another work not based on the Library
-with the Library (or with a work based on the Library) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may opt to apply the terms of the ordinary GNU General Public
-License instead of this License to a given copy of the Library.  To do
-this, you must alter all the notices that refer to this License, so
-that they refer to the ordinary GNU General Public License, version 2,
-instead of to this License.  (If a newer version than version 2 of the
-ordinary GNU General Public License has appeared, then you can specify
-that version instead if you wish.)  Do not make any other change in
-these notices.
-
-  Once this change is made in a given copy, it is irreversible for
-that copy, so the ordinary GNU General Public License applies to all
-subsequent copies and derivative works made from that copy.
-
-  This option is useful when you wish to copy part of the code of
-the Library into a program that is not a library.
-
-  4. You may copy and distribute the Library (or a portion or
-derivative of it, under Section 2) in object code or executable form
-under the terms of Sections 1 and 2 above provided that you accompany
-it with the complete corresponding machine-readable source code, which
-must be distributed under the terms of Sections 1 and 2 above on a
-medium customarily used for software interchange.
-
-  If distribution of object code is made by offering access to copy
-from a designated place, then offering equivalent access to copy the
-source code from the same place satisfies the requirement to
-distribute the source code, even though third parties are not
-compelled to copy the source along with the object code.
-
-  5. A program that contains no derivative of any portion of the
-Library, but is designed to work with the Library by being compiled or
-linked with it, is called a "work that uses the Library".  Such a
-work, in isolation, is not a derivative work of the Library, and
-therefore falls outside the scope of this License.
-
-  However, linking a "work that uses the Library" with the Library
-creates an executable that is a derivative of the Library (because it
-contains portions of the Library), rather than a "work that uses the
-library".  The executable is therefore covered by this License.
-Section 6 states terms for distribution of such executables.
-
-  When a "work that uses the Library" uses material from a header file
-that is part of the Library, the object code for the work may be a
-derivative work of the Library even though the source code is not.
-Whether this is true is especially significant if the work can be
-linked without the Library, or if the work is itself a library.  The
-threshold for this to be true is not precisely defined by law.
-
-  If such an object file uses only numerical parameters, data
-structure layouts and accessors, and small macros and small inline
-functions (ten lines or less in length), then the use of the object
-file is unrestricted, regardless of whether it is legally a derivative
-work.  (Executables containing this object code plus portions of the
-Library will still fall under Section 6.)
-
-  Otherwise, if the work is a derivative of the Library, you may
-distribute the object code for the work under the terms of Section 6.
-Any executables containing that work also fall under Section 6,
-whether or not they are linked directly with the Library itself.
-
-  6. As an exception to the Sections above, you may also combine or
-link a "work that uses the Library" with the Library to produce a
-work containing portions of the Library, and distribute that work
-under terms of your choice, provided that the terms permit
-modification of the work for the customer's own use and reverse
-engineering for debugging such modifications.
-
-  You must give prominent notice with each copy of the work that the
-Library is used in it and that the Library and its use are covered by
-this License.  You must supply a copy of this License.  If the work
-during execution displays copyright notices, you must include the
-copyright notice for the Library among them, as well as a reference
-directing the user to the copy of this License.  Also, you must do one
-of these things:
-
-    a) Accompany the work with the complete corresponding
-    machine-readable source code for the Library including whatever
-    changes were used in the work (which must be distributed under
-    Sections 1 and 2 above); and, if the work is an executable linked
-    with the Library, with the complete machine-readable "work that
-    uses the Library", as object code and/or source code, so that the
-    user can modify the Library and then relink to produce a modified
-    executable containing the modified Library.  (It is understood
-    that the user who changes the contents of definitions files in the
-    Library will not necessarily be able to recompile the application
-    to use the modified definitions.)
-
-    b) Use a suitable shared library mechanism for linking with the
-    Library.  A suitable mechanism is one that (1) uses at run time a
-    copy of the library already present on the user's computer system,
-    rather than copying library functions into the executable, and (2)
-    will operate properly with a modified version of the library, if
-    the user installs one, as long as the modified version is
-    interface-compatible with the version that the work was made with.
-
-    c) Accompany the work with a written offer, valid for at
-    least three years, to give the same user the materials
-    specified in Subsection 6a, above, for a charge no more
-    than the cost of performing this distribution.
-
-    d) If distribution of the work is made by offering access to copy
-    from a designated place, offer equivalent access to copy the above
-    specified materials from the same place.
-
-    e) Verify that the user has already received a copy of these
-    materials or that you have already sent this user a copy.
-
-  For an executable, the required form of the "work that uses the
-Library" must include any data and utility programs needed for
-reproducing the executable from it.  However, as a special exception,
-the materials to be distributed need not include anything that is
-normally distributed (in either source or binary form) with the major
-components (compiler, kernel, and so on) of the operating system on
-which the executable runs, unless that component itself accompanies
-the executable.
-
-  It may happen that this requirement contradicts the license
-restrictions of other proprietary libraries that do not normally
-accompany the operating system.  Such a contradiction means you cannot
-use both them and the Library together in an executable that you
-distribute.
-
-  7. You may place library facilities that are a work based on the
-Library side-by-side in a single library together with other library
-facilities not covered by this License, and distribute such a combined
-library, provided that the separate distribution of the work based on
-the Library and of the other library facilities is otherwise
-permitted, and provided that you do these two things:
-
-    a) Accompany the combined library with a copy of the same work
-    based on the Library, uncombined with any other library
-    facilities.  This must be distributed under the terms of the
-    Sections above.
-
-    b) Give prominent notice with the combined library of the fact
-    that part of it is a work based on the Library, and explaining
-    where to find the accompanying uncombined form of the same work.
-
-  8. You may not copy, modify, sublicense, link with, or distribute
-the Library except as expressly provided under this License.  Any
-attempt otherwise to copy, modify, sublicense, link with, or
-distribute the Library is void, and will automatically terminate your
-rights under this License.  However, parties who have received copies,
-or rights, from you under this License will not have their licenses
-terminated so long as such parties remain in full compliance.
-
-  9. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Library or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Library (or any work based on the
-Library), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Library or works based on it.
-
-  10. Each time you redistribute the Library (or any work based on the
-Library), the recipient automatically receives a license from the
-original licensor to copy, distribute, link with or modify the Library
-subject to these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties with
-this License.
-
-  11. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Library at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Library by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Library.
-
-If any portion of this section is held invalid or unenforceable under any
-particular circumstance, the balance of the section is intended to apply,
-and the section as a whole is intended to apply in other circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  12. If the distribution and/or use of the Library is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Library under this License may add
-an explicit geographical distribution limitation excluding those countries,
-so that distribution is permitted only in or among countries not thus
-excluded.  In such case, this License incorporates the limitation as if
-written in the body of this License.
-
-  13. The Free Software Foundation may publish revised and/or new
-versions of the Lesser General Public License from time to time.
-Such new versions will be similar in spirit to the present version,
-but may differ in detail to address new problems or concerns.
-
-Each version is given a distinguishing version number.  If the Library
-specifies a version number of this License which applies to it and
-"any later version", you have the option of following the terms and
-conditions either of that version or of any later version published by
-the Free Software Foundation.  If the Library does not specify a
-license version number, you may choose any version ever published by
-the Free Software Foundation.
-
-  14. If you wish to incorporate parts of the Library into other free
-programs whose distribution conditions are incompatible with these,
-write to the author to ask for permission.  For software which is
-copyrighted by the Free Software Foundation, write to the Free
-Software Foundation; we sometimes make exceptions for this.  Our
-decision will be guided by the two goals of preserving the free status
-of all derivatives of our free software and of promoting the sharing
-and reuse of software generally.
-
-			    NO WARRANTY
-
-  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
-WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
-EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
-OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
-KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
-LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
-THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
-
-  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
-WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
-AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
-FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
-CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
-LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
-RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
-FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
-SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
-DAMAGES.
-
-		     END OF TERMS AND CONDITIONS
\ No newline at end of file
diff --git a/contrib/apps/LwipMibCompiler/SharpSnmpLib/sharpsnmplib.snk b/contrib/apps/LwipMibCompiler/SharpSnmpLib/sharpsnmplib.snk
deleted file mode 100644
index fe6f345a..00000000
Binary files a/contrib/apps/LwipMibCompiler/SharpSnmpLib/sharpsnmplib.snk and /dev/null differ
diff --git a/contrib/apps/LwipMibCompiler/example/compile_udp_mib.cmd b/contrib/apps/LwipMibCompiler/example/compile_udp_mib.cmd
deleted file mode 100644
index 1c84dbfe..00000000
--- a/contrib/apps/LwipMibCompiler/example/compile_udp_mib.cmd
+++ /dev/null
@@ -1 +0,0 @@
-..\LwipMibCompiler\bin\Debug\LwipMibCompiler.exe ..\Mibs\UDP-MIB .\ ..\Mibs\
diff --git a/contrib/apps/LwipMibCompiler/example/compile_udp_mib.sh b/contrib/apps/LwipMibCompiler/example/compile_udp_mib.sh
deleted file mode 100644
index 93798c01..00000000
--- a/contrib/apps/LwipMibCompiler/example/compile_udp_mib.sh
+++ /dev/null
@@ -1 +0,0 @@
-../LwipMibCompiler/bin/Debug/LwipMibCompiler.exe ../Mibs/UDP-MIB ./ ../Mibs/
diff --git a/contrib/apps/chargen/README b/contrib/apps/chargen/README
deleted file mode 100644
index 7dc2ee52..00000000
--- a/contrib/apps/chargen/README
+++ /dev/null
@@ -1,52 +0,0 @@
-
-        CHARGEN
-        
-This file implements a nice example of handling multiple tcp sockets in a
-server environment. Just call chargen_init() from your application after
-you have initialized lwip and added your network interfaces. Change the
-MAX_SERV option to increase or decrease the number of sessions supported.
-
-chargen will jam as much data as possible into the output socket, so it
-will take up a lot of CPU time. Therefore it will be a good idea to run it
-as the lowest possible priority (just ahead of any idle task).
- 
-This is also a good example of how to support multiple sessions in an
-embedded system where you might not have fork(). The multiple sessions are
-all handled by the same thread and select() is used for demultiplexing.
- 
-No makefile is provided, just add chargen to the makefile for your
-application. It is OS and HW independent.
-
-Once the chargen server is running in your application, go to another system
-and open a telnet session to your lwip platform at port 19. You should see an
-ASCII pattern start to stream on you screen.
-
-As an example, lets say that your system running lwip is at IP address
-192.168.10.244 and you have a linux system connected to it at IP address
-192.168.10.59. Issue the following command at a terminal prompt on the linux system:
-
-telnet 192.168.10.244 19
-
-You will see a pattern similar to the following on streaming by on your
-screen:
-
-ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{
-BCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|
-CDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}
-DEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
-EFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~!
-FGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~!"
-GHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~!"#
-HIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~!"#$
-IJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~!"#$%
-JKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~!"#$%&
-KLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~!"#$%&'
-LMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~!"#$%&'(
-
-It even works from windows: At a dos prompt you can also issue the same
-telnet command and you will get a similar (but much slower, at least on W98)
-data stream.
-
-David Haas
-
-
diff --git a/contrib/apps/chargen/chargen.c b/contrib/apps/chargen/chargen.c
deleted file mode 100644
index 47408eef..00000000
--- a/contrib/apps/chargen/chargen.c
+++ /dev/null
@@ -1,274 +0,0 @@
-/** @file
- *
- *  chargen server for lwip
- */
-/*
- * Copyright (c) 2003 NBS Card Technology, Paramus, NJ.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: David Haas <dhaas@alum.rpi.edu>
- *
- * Purpose:   chargen server for testing and demonstration purposes
- *
- * This file implements a nice example of handling multiple tcp sockets in a
- * server environment. Just call chargen_init() from your application after
- * you have initialized lwip and added your network interfaces. Change the
- * MAX_SERV option to increase or decrease the number of sessions supported.
- *
- * chargen will jam as much data as possible into the output socket, so it
- * will take up a lot of CPU time. Therefore it will be a good idea to run it
- * as the lowest possible priority (just ahead of any idle task).
- *
- * This is also a good example of how to support multiple sessions in an
- * embedded system where you might not have fork().
- */
-
-#include "lwip/opt.h"
-#include "lwip/sys.h"
-#include "lwip/sockets.h"
-#include "lwip/mem.h"
-
-#include <string.h>
-
-#include "chargen.h"
-
-#if LWIP_SOCKET && LWIP_SOCKET_SELECT
-
-#define MAX_SERV                 5         /* Maximum number of chargen services. Don't need too many */
-#define CHARGEN_THREAD_NAME      "chargen"
-#define CHARGEN_PRIORITY         254       /* Really low priority */
-#define CHARGEN_THREAD_STACKSIZE 0
-#define SEND_SIZE TCP_SNDLOWAT             /* If we only send this much, then when select
-                                              says we can send, we know we won't block */
-
-struct charcb {
-  struct charcb *next;
-  int socket;
-  struct sockaddr_storage cliaddr;
-  socklen_t clilen;
-  char nextchar;
-};
-
-static struct charcb *charcb_list = 0;
-
-/**************************************************************
- * void close_chargen(struct charcb *p_charcb)
- *
- * Close the socket and remove this charcb from the list.
- **************************************************************/
-static void
-close_chargen(struct charcb *p_charcb)
-{
-  struct charcb *p_search_charcb;
-
-  /* Either an error or tcp connection closed on other
-   * end. Close here */
-  lwip_close(p_charcb->socket);
-  /* Free charcb */
-  if (charcb_list == p_charcb) {
-    charcb_list = p_charcb->next;
-  } else {
-    for (p_search_charcb = charcb_list; p_search_charcb; p_search_charcb = p_search_charcb->next) {
-      if (p_search_charcb->next == p_charcb) {
-        p_search_charcb->next = p_charcb->next;
-        break;
-      }
-    }
-  }
-  mem_free(p_charcb);
-}
-
-/**************************************************************
- * void do_read(struct charcb *p_charcb)
- *
- * Socket definitely is ready for reading. Read a buffer from the socket and
- * discard the data.  If no data is read, then the socket is closed and the
- * charcb is removed from the list and freed.
- **************************************************************/
-static int
-do_read(struct charcb *p_charcb)
-{
-  char buffer[80];
-  int readcount;
-
-  /* Read some data */
-  readcount = lwip_read(p_charcb->socket, &buffer, 80);
-  if (readcount <= 0) {
-    close_chargen(p_charcb);
-    return -1;
-  }
-  return 0;
-}
-
-/**************************************************************
- * void chargen_thread(void *arg)
- *
- * chargen task. This server will wait for connections on well
- * known TCP port number: 19. For every connection, the server will
- * write as much data as possible to the tcp port.
- **************************************************************/
-static void
-chargen_thread(void *arg)
-{
-  int listenfd;
-#if LWIP_IPV6
-  struct sockaddr_in6 chargen_saddr;
-#else /* LWIP_IPV6 */
-  struct sockaddr_in chargen_saddr;
-#endif /* LWIP_IPV6 */
-  fd_set readset;
-  fd_set writeset;
-  int i, maxfdp1;
-  struct charcb *p_charcb;
-  LWIP_UNUSED_ARG(arg);
-
-  memset(&chargen_saddr, 0, sizeof (chargen_saddr));
-#if LWIP_IPV6
-  /* First acquire our socket for listening for connections */
-  listenfd = lwip_socket(AF_INET6, SOCK_STREAM, 0);
-  chargen_saddr.sin6_family = AF_INET6;
-  chargen_saddr.sin6_addr = in6addr_any;
-  chargen_saddr.sin6_port = lwip_htons(19); /* Chargen server port */
-#else /* LWIP_IPV6 */
-  /* First acquire our socket for listening for connections */
-  listenfd = lwip_socket(AF_INET, SOCK_STREAM, 0);
-  chargen_saddr.sin_family = AF_INET;
-  chargen_saddr.sin_addr.s_addr = PP_HTONL(INADDR_ANY);
-  chargen_saddr.sin_port = lwip_htons(19); /* Chargen server port */
-#endif /* LWIP_IPV6 */
-
-  LWIP_ASSERT("chargen_thread(): Socket create failed.", listenfd >= 0);
-
-  if (lwip_bind(listenfd, (struct sockaddr *) &chargen_saddr, sizeof (chargen_saddr)) == -1) {
-    LWIP_ASSERT("chargen_thread(): Socket bind failed.", 0);
-  }
-
-  /* Put socket into listening mode */
-  if (lwip_listen(listenfd, MAX_SERV) == -1) {
-    LWIP_ASSERT("chargen_thread(): Listen failed.", 0);
-  }
-
-
-  /* Wait forever for network input: This could be connections or data */
-  for (;;) {
-    maxfdp1 = listenfd + 1;
-
-    /* Determine what sockets need to be in readset */
-    FD_ZERO(&readset);
-    FD_ZERO(&writeset);
-    FD_SET(listenfd, &readset);
-    for (p_charcb = charcb_list; p_charcb; p_charcb = p_charcb->next) {
-      if (maxfdp1 < p_charcb->socket + 1) {
-        maxfdp1 = p_charcb->socket + 1;
-      }
-      FD_SET(p_charcb->socket, &readset);
-      FD_SET(p_charcb->socket, &writeset);
-    }
-
-    /* Wait for data or a new connection */
-    i = lwip_select(maxfdp1, &readset, &writeset, 0, 0);
-
-    if (i == 0) {
-      continue;
-    }
-    /* At least one descriptor is ready */
-    if (FD_ISSET(listenfd, &readset)) {
-      /* We have a new connection request!!! */
-      /* Lets create a new control block */
-      p_charcb = (struct charcb *) mem_malloc(sizeof (struct charcb));
-      if (p_charcb) {
-        p_charcb->socket = lwip_accept(listenfd,
-                (struct sockaddr *) &p_charcb->cliaddr,
-                &p_charcb->clilen);
-        if (p_charcb->socket < 0) {
-          mem_free(p_charcb);
-        } else {
-          /* Keep this tecb in our list */
-          p_charcb->next = charcb_list;
-          charcb_list = p_charcb;
-          p_charcb->nextchar = 0x21;
-        }
-      } else {
-        /* No memory to accept connection. Just accept and then close */
-        int sock;
-        struct sockaddr cliaddr;
-        socklen_t clilen;
-
-        sock = lwip_accept(listenfd, &cliaddr, &clilen);
-        if (sock >= 0) {
-          lwip_close(sock);
-        }
-      }
-    }
-    /* Go through list of connected clients and process data */
-    for (p_charcb = charcb_list; p_charcb; p_charcb = p_charcb->next) {
-      if (FD_ISSET(p_charcb->socket, &readset)) {
-        /* This socket is ready for reading. This could be because someone typed
-         * some characters or it could be because the socket is now closed. Try reading
-         * some data to see. */
-        if (do_read(p_charcb) < 0) {
-          break;
-        }
-      }
-      if (FD_ISSET(p_charcb->socket, &writeset)) {
-        char line[80];
-        char setchar = p_charcb->nextchar;
-
-        for (i = 0; i < 59; i++) {
-          line[i] = setchar;
-          if (++setchar == 0x7f) {
-            setchar = 0x21;
-          }
-        }
-        line[i] = 0;
-        strcat(line, "\n\r");
-        if (lwip_write(p_charcb->socket, line, strlen(line)) < 0) {
-          close_chargen(p_charcb);
-          break;
-        }
-        if (++p_charcb->nextchar == 0x7f) {
-          p_charcb->nextchar = 0x21;
-        }
-      }
-    }
-  }
-}
-
-
-/**************************************************************
- * void chargen_init(void)
- *
- * This function initializes the chargen service. This function
- * may only be called either before or after tasking has started.
- **************************************************************/
-void
-chargen_init(void)
-{
-  sys_thread_new(CHARGEN_THREAD_NAME, chargen_thread, 0, CHARGEN_THREAD_STACKSIZE, CHARGEN_PRIORITY);
-}
-
-#endif /* LWIP_SOCKET && LWIP_SOCKET_SELECT */
diff --git a/contrib/apps/chargen/chargen.h b/contrib/apps/chargen/chargen.h
deleted file mode 100644
index eb83e4f4..00000000
--- a/contrib/apps/chargen/chargen.h
+++ /dev/null
@@ -1,12 +0,0 @@
-#ifndef LWIP_CHARGEN_H
-#define LWIP_CHARGEN_H
-
-#include "lwip/opt.h"
-
-#if LWIP_SOCKET
-
-void chargen_init(void);
-
-#endif /* LWIP_SOCKET */
-
-#endif /* LWIP_CHARGEN_H */
diff --git a/contrib/apps/httpserver/README b/contrib/apps/httpserver/README
deleted file mode 100644
index 1f18bb81..00000000
--- a/contrib/apps/httpserver/README
+++ /dev/null
@@ -1,12 +0,0 @@
-HTTPSERVER
-
-This is a demonstration of how to make the most basic kind 
-of server using lWIP.
-
-* httpserver-raw.c - uses raw TCP calls (coming soon!)
-
-* httpserver-netconn.c - uses netconn and netbuf API
-
-This code updates the examples in Adam Dunkel's original
-lwIP documentation to match changes in the code since that
-PDF release. 
diff --git a/contrib/apps/httpserver/httpserver-netconn.c b/contrib/apps/httpserver/httpserver-netconn.c
deleted file mode 100644
index 26976bf8..00000000
--- a/contrib/apps/httpserver/httpserver-netconn.c
+++ /dev/null
@@ -1,103 +0,0 @@
-
-#include "lwip/opt.h"
-#include "lwip/arch.h"
-#include "lwip/api.h"
-
-#include "httpserver-netconn.h"
-
-#if LWIP_NETCONN
-
-#ifndef HTTPD_DEBUG
-#define HTTPD_DEBUG         LWIP_DBG_OFF
-#endif
-
-static const char http_html_hdr[] = "HTTP/1.1 200 OK\r\nContent-type: text/html\r\n\r\n";
-static const char http_index_html[] = "<html><head><title>Congrats!</title></head><body><h1>Welcome to our lwIP HTTP server!</h1><p>This is a small test page, served by httpserver-netconn.</body></html>";
-
-/** Serve one HTTP connection accepted in the http thread */
-static void
-http_server_netconn_serve(struct netconn *conn)
-{
-  struct netbuf *inbuf;
-  char *buf;
-  u16_t buflen;
-  err_t err;
-
-  /* Read the data from the port, blocking if nothing yet there.
-   We assume the request (the part we care about) is in one netbuf */
-  err = netconn_recv(conn, &inbuf);
-
-  if (err == ERR_OK) {
-    netbuf_data(inbuf, (void**)&buf, &buflen);
-
-    /* Is this an HTTP GET command? (only check the first 5 chars, since
-    there are other formats for GET, and we're keeping it very simple )*/
-    if (buflen>=5 &&
-        buf[0]=='G' &&
-        buf[1]=='E' &&
-        buf[2]=='T' &&
-        buf[3]==' ' &&
-        buf[4]=='/' ) {
-
-      /* Send the HTML header
-             * subtract 1 from the size, since we dont send the \0 in the string
-             * NETCONN_NOCOPY: our data is const static, so no need to copy it
-       */
-      netconn_write(conn, http_html_hdr, sizeof(http_html_hdr)-1, NETCONN_NOCOPY);
-
-      /* Send our HTML page */
-      netconn_write(conn, http_index_html, sizeof(http_index_html)-1, NETCONN_NOCOPY);
-    }
-  }
-  /* Close the connection (server closes in HTTP) */
-  netconn_close(conn);
-
-  /* Delete the buffer (netconn_recv gives us ownership,
-   so we have to make sure to deallocate the buffer) */
-  netbuf_delete(inbuf);
-}
-
-/** The main function, never returns! */
-static void
-http_server_netconn_thread(void *arg)
-{
-  struct netconn *conn, *newconn;
-  err_t err;
-  LWIP_UNUSED_ARG(arg);
-
-  /* Create a new TCP connection handle */
-  /* Bind to port 80 (HTTP) with default IP address */
-#if LWIP_IPV6
-  conn = netconn_new(NETCONN_TCP_IPV6);
-  netconn_bind(conn, IP6_ADDR_ANY, 80);
-#else /* LWIP_IPV6 */
-  conn = netconn_new(NETCONN_TCP);
-  netconn_bind(conn, IP_ADDR_ANY, 80);
-#endif /* LWIP_IPV6 */
-  LWIP_ERROR("http_server: invalid conn", (conn != NULL), return;);
-
-  /* Put the connection into LISTEN state */
-  netconn_listen(conn);
-
-  do {
-    err = netconn_accept(conn, &newconn);
-    if (err == ERR_OK) {
-      http_server_netconn_serve(newconn);
-      netconn_delete(newconn);
-    }
-  } while(err == ERR_OK);
-  LWIP_DEBUGF(HTTPD_DEBUG,
-    ("http_server_netconn_thread: netconn_accept received error %d, shutting down",
-    err));
-  netconn_close(conn);
-  netconn_delete(conn);
-}
-
-/** Initialize the HTTP server (start its thread) */
-void
-http_server_netconn_init(void)
-{
-  sys_thread_new("http_server_netconn", http_server_netconn_thread, NULL, DEFAULT_THREAD_STACKSIZE, DEFAULT_THREAD_PRIO);
-}
-
-#endif /* LWIP_NETCONN*/
diff --git a/contrib/apps/httpserver/httpserver-netconn.h b/contrib/apps/httpserver/httpserver-netconn.h
deleted file mode 100644
index d84b1036..00000000
--- a/contrib/apps/httpserver/httpserver-netconn.h
+++ /dev/null
@@ -1,6 +0,0 @@
-#ifndef LWIP_HTTPSERVER_NETCONN_H
-#define LWIP_HTTPSERVER_NETCONN_H
-
-void http_server_netconn_init(void);
-
-#endif /* LWIP_HTTPSERVER_NETCONN_H */
diff --git a/contrib/apps/netio/netio.c b/contrib/apps/netio/netio.c
deleted file mode 100644
index 7d12ac87..00000000
--- a/contrib/apps/netio/netio.c
+++ /dev/null
@@ -1,55 +0,0 @@
-#include "netio.h"
-
-#include "lwip/opt.h"
-#include "lwip/tcp.h"
-
-/* See http://www.nwlab.net/art/netio/netio.html to get the netio tool */
-
-#if LWIP_TCP && LWIP_CALLBACK_API
-static err_t
-netio_recv(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
-{
-  LWIP_UNUSED_ARG(arg);
-
-  if (err == ERR_OK && p != NULL) {
-    tcp_recved(pcb, p->tot_len);
-    pbuf_free(p);
-  } else {
-    pbuf_free(p);
-  }
-
-  if (err == ERR_OK && p == NULL) {
-    tcp_arg(pcb, NULL);
-    tcp_sent(pcb, NULL);
-    tcp_recv(pcb, NULL);
-    tcp_close(pcb);
-  }
-
-  return ERR_OK;
-}
-
-static err_t
-netio_accept(void *arg, struct tcp_pcb *pcb, err_t err)
-{
-  LWIP_UNUSED_ARG(arg);
-  LWIP_UNUSED_ARG(err);
-
-  if (pcb != NULL) {
-    tcp_arg(pcb, NULL);
-    tcp_sent(pcb, NULL);
-    tcp_recv(pcb, netio_recv);
-  }
-  return ERR_OK;
-}
-
-void
-netio_init(void)
-{
-  struct tcp_pcb *pcb;
-
-  pcb = tcp_new_ip_type(IPADDR_TYPE_ANY);
-  tcp_bind(pcb, IP_ANY_TYPE, 18767);
-  pcb = tcp_listen(pcb);
-  tcp_accept(pcb, netio_accept);
-}
-#endif /* LWIP_TCP && LWIP_CALLBACK_API */
diff --git a/contrib/apps/netio/netio.h b/contrib/apps/netio/netio.h
deleted file mode 100644
index 11d7730f..00000000
--- a/contrib/apps/netio/netio.h
+++ /dev/null
@@ -1,6 +0,0 @@
-#ifndef LWIP_NETIO_H
-#define LWIP_NETIO_H
-
-void netio_init(void);
-
-#endif /* LWIP_NETIO_H */
diff --git a/contrib/apps/ping/ping.c b/contrib/apps/ping/ping.c
deleted file mode 100644
index 429ab00b..00000000
--- a/contrib/apps/ping/ping.c
+++ /dev/null
@@ -1,396 +0,0 @@
-/**
- * @file
- * Ping sender module
- *
- */
-
-/*
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- */
-
-/**
- * This is an example of a "ping" sender (with raw API and socket API).
- * It can be used as a start point to maintain opened a network connection, or
- * like a network "watchdog" for your device.
- *
- */
-
-#include "lwip/opt.h"
-
-#if LWIP_RAW /* don't build if not configured for use in lwipopts.h */
-
-#include "ping.h"
-
-#include "lwip/mem.h"
-#include "lwip/raw.h"
-#include "lwip/icmp.h"
-#include "lwip/netif.h"
-#include "lwip/sys.h"
-#include "lwip/timeouts.h"
-#include "lwip/inet_chksum.h"
-#include "lwip/prot/ip4.h"
-
-#if PING_USE_SOCKETS
-#include "lwip/sockets.h"
-#include "lwip/inet.h"
-#include <string.h>
-#endif /* PING_USE_SOCKETS */
-
-
-/**
- * PING_DEBUG: Enable debugging for PING.
- */
-#ifndef PING_DEBUG
-#define PING_DEBUG     LWIP_DBG_ON
-#endif
-
-/** ping receive timeout - in milliseconds */
-#ifndef PING_RCV_TIMEO
-#define PING_RCV_TIMEO 1000
-#endif
-
-/** ping delay - in milliseconds */
-#ifndef PING_DELAY
-#define PING_DELAY     1000
-#endif
-
-/** ping identifier - must fit on a u16_t */
-#ifndef PING_ID
-#define PING_ID        0xAFAF
-#endif
-
-/** ping additional data size to include in the packet */
-#ifndef PING_DATA_SIZE
-#define PING_DATA_SIZE 32
-#endif
-
-/** ping result action - no default action */
-#ifndef PING_RESULT
-#define PING_RESULT(ping_ok)
-#endif
-
-/* ping variables */
-static const ip_addr_t* ping_target;
-static u16_t ping_seq_num;
-#ifdef LWIP_DEBUG
-static u32_t ping_time;
-#endif /* LWIP_DEBUG */
-#if !PING_USE_SOCKETS
-static struct raw_pcb *ping_pcb;
-#endif /* PING_USE_SOCKETS */
-
-/** Prepare a echo ICMP request */
-static void
-ping_prepare_echo( struct icmp_echo_hdr *iecho, u16_t len)
-{
-  size_t i;
-  size_t data_len = len - sizeof(struct icmp_echo_hdr);
-
-  ICMPH_TYPE_SET(iecho, ICMP_ECHO);
-  ICMPH_CODE_SET(iecho, 0);
-  iecho->chksum = 0;
-  iecho->id     = PING_ID;
-  iecho->seqno  = lwip_htons(++ping_seq_num);
-
-  /* fill the additional data buffer with some data */
-  for(i = 0; i < data_len; i++) {
-    ((char*)iecho)[sizeof(struct icmp_echo_hdr) + i] = (char)i;
-  }
-
-  iecho->chksum = inet_chksum(iecho, len);
-}
-
-#if PING_USE_SOCKETS
-
-/* Ping using the socket ip */
-static err_t
-ping_send(int s, const ip_addr_t *addr)
-{
-  int err;
-  struct icmp_echo_hdr *iecho;
-  struct sockaddr_storage to;
-  size_t ping_size = sizeof(struct icmp_echo_hdr) + PING_DATA_SIZE;
-  LWIP_ASSERT("ping_size is too big", ping_size <= 0xffff);
-
-#if LWIP_IPV6
-  if(IP_IS_V6(addr) && !ip6_addr_isipv4mappedipv6(ip_2_ip6(addr))) {
-    /* todo: support ICMP6 echo */
-    return ERR_VAL;
-  }
-#endif /* LWIP_IPV6 */
-
-  iecho = (struct icmp_echo_hdr *)mem_malloc((mem_size_t)ping_size);
-  if (!iecho) {
-    return ERR_MEM;
-  }
-
-  ping_prepare_echo(iecho, (u16_t)ping_size);
-
-#if LWIP_IPV4
-  if(IP_IS_V4(addr)) {
-    struct sockaddr_in *to4 = (struct sockaddr_in*)&to;
-    to4->sin_len    = sizeof(to4);
-    to4->sin_family = AF_INET;
-    inet_addr_from_ip4addr(&to4->sin_addr, ip_2_ip4(addr));
-  }
-#endif /* LWIP_IPV4 */
-
-#if LWIP_IPV6
-  if(IP_IS_V6(addr)) {
-    struct sockaddr_in6 *to6 = (struct sockaddr_in6*)&to;
-    to6->sin6_len    = sizeof(to6);
-    to6->sin6_family = AF_INET6;
-    inet6_addr_from_ip6addr(&to6->sin6_addr, ip_2_ip6(addr));
-  }
-#endif /* LWIP_IPV6 */
-
-  err = lwip_sendto(s, iecho, ping_size, 0, (struct sockaddr*)&to, sizeof(to));
-
-  mem_free(iecho);
-
-  return (err ? ERR_OK : ERR_VAL);
-}
-
-static void
-ping_recv(int s)
-{
-  char buf[64];
-  int len;
-  struct sockaddr_storage from;
-  int fromlen = sizeof(from);
-
-  while((len = lwip_recvfrom(s, buf, sizeof(buf), 0, (struct sockaddr*)&from, (socklen_t*)&fromlen)) > 0) {
-    if (len >= (int)(sizeof(struct ip_hdr)+sizeof(struct icmp_echo_hdr))) {
-      ip_addr_t fromaddr;
-      memset(&fromaddr, 0, sizeof(fromaddr));
-
-#if LWIP_IPV4
-      if(from.ss_family == AF_INET) {
-        struct sockaddr_in *from4 = (struct sockaddr_in*)&from;
-        inet_addr_to_ip4addr(ip_2_ip4(&fromaddr), &from4->sin_addr);
-        IP_SET_TYPE_VAL(fromaddr, IPADDR_TYPE_V4);
-      }
-#endif /* LWIP_IPV4 */
-
-#if LWIP_IPV6
-      if(from.ss_family == AF_INET6) {
-        struct sockaddr_in6 *from6 = (struct sockaddr_in6*)&from;
-        inet6_addr_to_ip6addr(ip_2_ip6(&fromaddr), &from6->sin6_addr);
-        IP_SET_TYPE_VAL(fromaddr, IPADDR_TYPE_V6);
-      }
-#endif /* LWIP_IPV6 */
-
-      LWIP_DEBUGF( PING_DEBUG, ("ping: recv "));
-      ip_addr_debug_print_val(PING_DEBUG, fromaddr);
-      LWIP_DEBUGF( PING_DEBUG, (" %"U32_F" ms\n", (sys_now() - ping_time)));
-
-      /* todo: support ICMP6 echo */
-#if LWIP_IPV4
-      if (IP_IS_V4_VAL(fromaddr)) {
-        struct ip_hdr *iphdr;
-        struct icmp_echo_hdr *iecho;
-
-        iphdr = (struct ip_hdr *)buf;
-        iecho = (struct icmp_echo_hdr *)(buf + (IPH_HL(iphdr) * 4));
-        if ((iecho->id == PING_ID) && (iecho->seqno == lwip_htons(ping_seq_num))) {
-          /* do some ping result processing */
-          PING_RESULT((ICMPH_TYPE(iecho) == ICMP_ER));
-          return;
-        } else {
-          LWIP_DEBUGF( PING_DEBUG, ("ping: drop\n"));
-        }
-      }
-#endif /* LWIP_IPV4 */
-    }
-    fromlen = sizeof(from);
-  }
-
-  if (len == 0) {
-    LWIP_DEBUGF( PING_DEBUG, ("ping: recv - %"U32_F" ms - timeout\n", (sys_now()-ping_time)));
-  }
-
-  /* do some ping result processing */
-  PING_RESULT(0);
-}
-
-static void
-ping_thread(void *arg)
-{
-  int s;
-  int ret;
-
-#if LWIP_SO_SNDRCVTIMEO_NONSTANDARD
-  int timeout = PING_RCV_TIMEO;
-#else
-  struct timeval timeout;
-  timeout.tv_sec = PING_RCV_TIMEO/1000;
-  timeout.tv_usec = (PING_RCV_TIMEO%1000)*1000;
-#endif
-  LWIP_UNUSED_ARG(arg);
-
-#if LWIP_IPV6
-  if(IP_IS_V4(ping_target) || ip6_addr_isipv4mappedipv6(ip_2_ip6(ping_target))) {
-    s = lwip_socket(AF_INET6, SOCK_RAW, IP_PROTO_ICMP);
-  } else {
-    s = lwip_socket(AF_INET6, SOCK_RAW, IP6_NEXTH_ICMP6);
-  }
-#else
-  s = lwip_socket(AF_INET,  SOCK_RAW, IP_PROTO_ICMP);
-#endif
-  if (s < 0) {
-    return;
-  }
-
-  ret = lwip_setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout));
-  LWIP_ASSERT("setting receive timeout failed", ret == 0);
-  LWIP_UNUSED_ARG(ret);
-
-  while (1) {
-    if (ping_send(s, ping_target) == ERR_OK) {
-      LWIP_DEBUGF( PING_DEBUG, ("ping: send "));
-      ip_addr_debug_print(PING_DEBUG, ping_target);
-      LWIP_DEBUGF( PING_DEBUG, ("\n"));
-
-#ifdef LWIP_DEBUG
-      ping_time = sys_now();
-#endif /* LWIP_DEBUG */
-      ping_recv(s);
-    } else {
-      LWIP_DEBUGF( PING_DEBUG, ("ping: send "));
-      ip_addr_debug_print(PING_DEBUG, ping_target);
-      LWIP_DEBUGF( PING_DEBUG, (" - error\n"));
-    }
-    sys_msleep(PING_DELAY);
-  }
-}
-
-#else /* PING_USE_SOCKETS */
-
-/* Ping using the raw ip */
-static u8_t
-ping_recv(void *arg, struct raw_pcb *pcb, struct pbuf *p, const ip_addr_t *addr)
-{
-  struct icmp_echo_hdr *iecho;
-  LWIP_UNUSED_ARG(arg);
-  LWIP_UNUSED_ARG(pcb);
-  LWIP_UNUSED_ARG(addr);
-  LWIP_ASSERT("p != NULL", p != NULL);
-
-  if ((p->tot_len >= (PBUF_IP_HLEN + sizeof(struct icmp_echo_hdr))) &&
-      pbuf_remove_header(p, PBUF_IP_HLEN) == 0) {
-    iecho = (struct icmp_echo_hdr *)p->payload;
-
-    if ((iecho->id == PING_ID) && (iecho->seqno == lwip_htons(ping_seq_num))) {
-      LWIP_DEBUGF( PING_DEBUG, ("ping: recv "));
-      ip_addr_debug_print(PING_DEBUG, addr);
-      LWIP_DEBUGF( PING_DEBUG, (" %"U32_F" ms\n", (sys_now()-ping_time)));
-
-      /* do some ping result processing */
-      PING_RESULT(1);
-      pbuf_free(p);
-      return 1; /* eat the packet */
-    }
-    /* not eaten, restore original packet */
-    pbuf_add_header(p, PBUF_IP_HLEN);
-  }
-
-  return 0; /* don't eat the packet */
-}
-
-static void
-ping_send(struct raw_pcb *raw, const ip_addr_t *addr)
-{
-  struct pbuf *p;
-  struct icmp_echo_hdr *iecho;
-  size_t ping_size = sizeof(struct icmp_echo_hdr) + PING_DATA_SIZE;
-
-  LWIP_DEBUGF( PING_DEBUG, ("ping: send "));
-  ip_addr_debug_print(PING_DEBUG, addr);
-  LWIP_DEBUGF( PING_DEBUG, ("\n"));
-  LWIP_ASSERT("ping_size <= 0xffff", ping_size <= 0xffff);
-
-  p = pbuf_alloc(PBUF_IP, (u16_t)ping_size, PBUF_RAM);
-  if (!p) {
-    return;
-  }
-  if ((p->len == p->tot_len) && (p->next == NULL)) {
-    iecho = (struct icmp_echo_hdr *)p->payload;
-
-    ping_prepare_echo(iecho, (u16_t)ping_size);
-
-    raw_sendto(raw, p, addr);
-#ifdef LWIP_DEBUG
-    ping_time = sys_now();
-#endif /* LWIP_DEBUG */
-  }
-  pbuf_free(p);
-}
-
-static void
-ping_timeout(void *arg)
-{
-  struct raw_pcb *pcb = (struct raw_pcb*)arg;
-
-  LWIP_ASSERT("ping_timeout: no pcb given!", pcb != NULL);
-
-  ping_send(pcb, ping_target);
-
-  sys_timeout(PING_DELAY, ping_timeout, pcb);
-}
-
-static void
-ping_raw_init(void)
-{
-  ping_pcb = raw_new(IP_PROTO_ICMP);
-  LWIP_ASSERT("ping_pcb != NULL", ping_pcb != NULL);
-
-  raw_recv(ping_pcb, ping_recv, NULL);
-  raw_bind(ping_pcb, IP_ADDR_ANY);
-  sys_timeout(PING_DELAY, ping_timeout, ping_pcb);
-}
-
-void
-ping_send_now(void)
-{
-  LWIP_ASSERT("ping_pcb != NULL", ping_pcb != NULL);
-  ping_send(ping_pcb, ping_target);
-}
-
-#endif /* PING_USE_SOCKETS */
-
-void
-ping_init(const ip_addr_t* ping_addr)
-{
-  ping_target = ping_addr;
-
-#if PING_USE_SOCKETS
-  sys_thread_new("ping_thread", ping_thread, NULL, DEFAULT_THREAD_STACKSIZE, DEFAULT_THREAD_PRIO);
-#else /* PING_USE_SOCKETS */
-  ping_raw_init();
-#endif /* PING_USE_SOCKETS */
-}
-
-#endif /* LWIP_RAW */
diff --git a/contrib/apps/ping/ping.h b/contrib/apps/ping/ping.h
deleted file mode 100644
index 1f21c7b0..00000000
--- a/contrib/apps/ping/ping.h
+++ /dev/null
@@ -1,19 +0,0 @@
-#ifndef LWIP_PING_H
-#define LWIP_PING_H
-
-#include "lwip/ip_addr.h"
-
-/**
- * PING_USE_SOCKETS: Set to 1 to use sockets, otherwise the raw api is used
- */
-#ifndef PING_USE_SOCKETS
-#define PING_USE_SOCKETS    LWIP_SOCKET
-#endif
-
-void ping_init(const ip_addr_t* ping_addr);
-
-#if !PING_USE_SOCKETS
-void ping_send_now(void);
-#endif /* !PING_USE_SOCKETS */
-
-#endif /* LWIP_PING_H */
diff --git a/contrib/apps/rtp/rtp.c b/contrib/apps/rtp/rtp.c
deleted file mode 100644
index 4be69731..00000000
--- a/contrib/apps/rtp/rtp.c
+++ /dev/null
@@ -1,308 +0,0 @@
-/**
- * @file
- * RTP client/server module
- *
- */
-
-/*
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- */
-
-#include "lwip/opt.h"
-
-#if LWIP_SOCKET && LWIP_IGMP /* don't build if not configured for use in lwipopts.h */
-
-#include "lwip/sys.h"
-#include "lwip/sockets.h"
-
-#include "rtp.h"
-
-#include "rtpdata.h"
-
-#include <string.h>
-
-/** This is an example of a "RTP" client/server based on a MPEG4 bitstream (with socket API).
- */
-
-/**
- * RTP_DEBUG: Enable debugging for RTP.
- */
-#ifndef RTP_DEBUG
-#define RTP_DEBUG                   LWIP_DBG_ON
-#endif
-
-/** RTP stream port */
-#ifndef RTP_STREAM_PORT
-#define RTP_STREAM_PORT             4000
-#endif
-
-/** RTP stream multicast address as IPv4 address in "u32_t" format */
-#ifndef RTP_STREAM_ADDRESS
-#define RTP_STREAM_ADDRESS          inet_addr("232.0.0.0")
-#endif
-
-/** RTP send delay - in milliseconds */
-#ifndef RTP_SEND_DELAY
-#define RTP_SEND_DELAY              40
-#endif
-
-/** RTP receive timeout - in milliseconds */
-#ifndef RTP_RECV_TIMEOUT
-#define RTP_RECV_TIMEOUT            2000
-#endif
-
-/** RTP stats display period - in received packets */
-#ifndef RTP_RECV_STATS
-#define RTP_RECV_STATS              50
-#endif
-
-/** RTP macro to let the application process the data */
-#ifndef RTP_RECV_PROCESSING
-#define RTP_RECV_PROCESSING(p,s)
-#endif
-
-/** RTP packet/payload size */
-#define RTP_PACKET_SIZE             1500
-#define RTP_PAYLOAD_SIZE            1024
-
-/** RTP header constants */
-#define RTP_VERSION                 0x80
-#define RTP_TIMESTAMP_INCREMENT     3600
-#define RTP_SSRC                    0
-#define RTP_PAYLOADTYPE             96
-#define RTP_MARKER_MASK             0x80
-
-/** RTP message header */
-#ifdef PACK_STRUCT_USE_INCLUDES
-#  include "arch/bpstruct.h"
-#endif
-PACK_STRUCT_BEGIN
-struct rtp_hdr {
-  PACK_STRUCT_FLD_8(u8_t  version);
-  PACK_STRUCT_FLD_8(u8_t  payloadtype);
-  PACK_STRUCT_FIELD(u16_t seqNum);
-  PACK_STRUCT_FIELD(u32_t timestamp);
-  PACK_STRUCT_FIELD(u32_t ssrc);
-} PACK_STRUCT_STRUCT;
-PACK_STRUCT_END
-#ifdef PACK_STRUCT_USE_INCLUDES
-#  include "arch/epstruct.h"
-#endif
-
-/** RTP packets */
-static u8_t rtp_send_packet[RTP_PACKET_SIZE];
-static u8_t rtp_recv_packet[RTP_PACKET_SIZE];
-
-/**
- * RTP send packets
- */
-static void
-rtp_send_packets( int sock, struct sockaddr_in* to)
-{
-  struct rtp_hdr* rtphdr;
-  u8_t*           rtp_payload;
-  size_t          rtp_payload_size;
-  size_t          rtp_data_index;
-
-  /* prepare RTP packet */
-  rtphdr = (struct rtp_hdr*)rtp_send_packet;
-  rtphdr->version     = RTP_VERSION;
-  rtphdr->payloadtype = 0;
-  rtphdr->ssrc        = PP_HTONL(RTP_SSRC);
-  rtphdr->timestamp   = lwip_htonl(lwip_ntohl(rtphdr->timestamp) + RTP_TIMESTAMP_INCREMENT);
-
-  /* send RTP stream packets */
-  rtp_data_index = 0;
-  do {
-    rtp_payload      = rtp_send_packet+sizeof(struct rtp_hdr);
-    rtp_payload_size = LWIP_MIN(RTP_PAYLOAD_SIZE, sizeof(rtp_data) - rtp_data_index);
-
-    MEMCPY(rtp_payload, rtp_data + rtp_data_index, rtp_payload_size);
-
-    /* set MARKER bit in RTP header on the last packet of an image */
-    if ((rtp_data_index + rtp_payload_size) >= sizeof(rtp_data)) {
-      rtphdr->payloadtype = RTP_PAYLOADTYPE | RTP_MARKER_MASK;
-    } else {
-      rtphdr->payloadtype = RTP_PAYLOADTYPE;
-    }
-
-    /* send RTP stream packet */
-    if (lwip_sendto(sock, rtp_send_packet, sizeof(struct rtp_hdr) + rtp_payload_size,
-        0, (struct sockaddr *)to, sizeof(struct sockaddr)) >= 0) {
-      rtphdr->seqNum  = lwip_htons((u16_t)(lwip_ntohs(rtphdr->seqNum) + 1));
-      rtp_data_index += rtp_payload_size;
-    } else {
-      LWIP_DEBUGF(RTP_DEBUG, ("rtp_sender: not sendto==%i\n", errno));
-    }
-  }while (rtp_data_index < sizeof(rtp_data));
-}
-
-/**
- * RTP send thread
- */
-static void
-rtp_send_thread(void *arg)
-{
-  int                sock;
-  struct sockaddr_in local;
-  struct sockaddr_in to;
-  u32_t              rtp_stream_address;
-
-  LWIP_UNUSED_ARG(arg);
-
-  /* initialize RTP stream address */
-  rtp_stream_address = RTP_STREAM_ADDRESS;
-
-  /* if we got a valid RTP stream address... */
-  if (rtp_stream_address != 0) {
-    /* create new socket */
-    sock = lwip_socket(AF_INET, SOCK_DGRAM, 0);
-    if (sock >= 0) {
-      /* prepare local address */
-      memset(&local, 0, sizeof(local));
-      local.sin_family      = AF_INET;
-      local.sin_port        = PP_HTONS(INADDR_ANY);
-      local.sin_addr.s_addr = PP_HTONL(INADDR_ANY);
-
-      /* bind to local address */
-      if (lwip_bind(sock, (struct sockaddr *)&local, sizeof(local)) == 0) {
-        /* prepare RTP stream address */
-        memset(&to, 0, sizeof(to));
-        to.sin_family      = AF_INET;
-        to.sin_port        = PP_HTONS(RTP_STREAM_PORT);
-        to.sin_addr.s_addr = rtp_stream_address;
-
-        /* send RTP packets */
-        memset(rtp_send_packet, 0, sizeof(rtp_send_packet));
-        while (1) {
-          rtp_send_packets( sock, &to);
-          sys_msleep(RTP_SEND_DELAY);
-        }
-      }
-
-      /* close the socket */
-      lwip_close(sock);
-    }
-  }
-}
-
-/**
- * RTP recv thread
- */
-static void
-rtp_recv_thread(void *arg)
-{
-  int                sock;
-  struct sockaddr_in local;
-  struct sockaddr_in from;
-  int                fromlen;
-  struct ip_mreq     ipmreq;
-  struct rtp_hdr*    rtphdr;
-  u32_t              rtp_stream_address;
-  int                timeout;
-  int                result;
-  int                recvrtppackets  = 0;
-  int                lostrtppackets  = 0;
-  u16_t              lastrtpseq = 0;
-
-  LWIP_UNUSED_ARG(arg);
-
-  /* initialize RTP stream address */
-  rtp_stream_address = RTP_STREAM_ADDRESS;
-
-  /* if we got a valid RTP stream address... */
-  if (rtp_stream_address != 0) {
-    /* create new socket */
-    sock = lwip_socket(AF_INET, SOCK_DGRAM, 0);
-    if (sock >= 0) {
-      /* prepare local address */
-      memset(&local, 0, sizeof(local));
-      local.sin_family      = AF_INET;
-      local.sin_port        = PP_HTONS(RTP_STREAM_PORT);
-      local.sin_addr.s_addr = PP_HTONL(INADDR_ANY);
-
-      /* bind to local address */
-      if (lwip_bind(sock, (struct sockaddr *)&local, sizeof(local)) == 0) {
-        /* set recv timeout */
-        timeout = RTP_RECV_TIMEOUT;
-        result = lwip_setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (char *)&timeout, sizeof(timeout));
-        if (result) {
-          LWIP_DEBUGF(RTP_DEBUG, ("rtp_recv_thread: setsockopt(SO_RCVTIMEO) failed: errno=%d\n", errno));
-        }
-
-        /* prepare multicast "ip_mreq" struct */
-        ipmreq.imr_multiaddr.s_addr = rtp_stream_address;
-        ipmreq.imr_interface.s_addr = PP_HTONL(INADDR_ANY);
-
-        /* join multicast group */
-        if (lwip_setsockopt(sock, IPPROTO_IP, IP_ADD_MEMBERSHIP, &ipmreq, sizeof(ipmreq)) == 0) {
-          /* receive RTP packets */
-          while(1) {
-            fromlen = sizeof(from);
-            result  = lwip_recvfrom(sock, rtp_recv_packet, sizeof(rtp_recv_packet), 0,
-              (struct sockaddr *)&from, (socklen_t *)&fromlen);
-            if ((result > 0) && ((size_t)result >= sizeof(struct rtp_hdr))) {
-              size_t recved = (size_t)result;
-              rtphdr = (struct rtp_hdr *)rtp_recv_packet;
-              recvrtppackets++;
-              if ((lastrtpseq == 0) || ((lastrtpseq + 1) == lwip_ntohs(rtphdr->seqNum))) {
-                RTP_RECV_PROCESSING((rtp_recv_packet + sizeof(rtp_hdr)), (recved-sizeof(rtp_hdr)));
-                LWIP_UNUSED_ARG(recved); /* just in case... */
-              } else {
-                lostrtppackets++;
-              }
-              lastrtpseq = lwip_ntohs(rtphdr->seqNum);
-              if ((recvrtppackets % RTP_RECV_STATS) == 0) {
-                LWIP_DEBUGF(RTP_DEBUG, ("rtp_recv_thread: recv %6i packet(s) / lost %4i packet(s) (%.4f%%)...\n", recvrtppackets, lostrtppackets, (lostrtppackets*100.0)/recvrtppackets));
-              }
-            } else {
-              LWIP_DEBUGF(RTP_DEBUG, ("rtp_recv_thread: recv timeout...\n"));
-            }
-          }
-
-          /* leave multicast group */
-          /* TODO: this code is never reached
-          result = lwip_setsockopt(sock, IPPROTO_IP, IP_DROP_MEMBERSHIP, &ipmreq, sizeof(ipmreq));
-          if (result) {
-            LWIP_DEBUGF(RTP_DEBUG, ("rtp_recv_thread: setsockopt(IP_DROP_MEMBERSHIP) failed: errno=%d\n", errno));
-          }*/
-        }
-      }
-
-      /* close the socket */
-      lwip_close(sock);
-    }
-  }
-}
-
-void
-rtp_init(void)
-{
-  sys_thread_new("rtp_send_thread", rtp_send_thread, NULL, DEFAULT_THREAD_STACKSIZE, DEFAULT_THREAD_PRIO);
-  sys_thread_new("rtp_recv_thread", rtp_recv_thread, NULL, DEFAULT_THREAD_STACKSIZE, DEFAULT_THREAD_PRIO);
-}
-
-#endif /* LWIP_SOCKET && LWIP_IGMP */
diff --git a/contrib/apps/rtp/rtp.h b/contrib/apps/rtp/rtp.h
deleted file mode 100644
index c53d89bd..00000000
--- a/contrib/apps/rtp/rtp.h
+++ /dev/null
@@ -1,8 +0,0 @@
-#ifndef LWIP_RTP_H
-#define LWIP_RTP_H
-
-#if LWIP_SOCKET && LWIP_IGMP
-void rtp_init(void);
-#endif /* LWIP_SOCKET && LWIP_IGMP */
-
-#endif /* LWIP_RTP_H */
diff --git a/contrib/apps/rtp/rtpdata.h b/contrib/apps/rtp/rtpdata.h
deleted file mode 100644
index 76ff344d..00000000
--- a/contrib/apps/rtp/rtpdata.h
+++ /dev/null
@@ -1,2040 +0,0 @@
-const unsigned char rtp_data[] = {
-  0x00, 0x00, 0x01, 0xb0, 0xf5, 0x00, 0x00, 0x01,
-  0xb5, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
-  0x01, 0x20, 0x00, 0x86, 0x84, 0x00, 0x67, 0x0c,
-  0x2c, 0x10, 0x90, 0x51, 0x8f, 0x00, 0x00, 0x01,
-  0xb2, 0x44, 0x69, 0x76, 0x58, 0x35, 0x30, 0x33,
-  0x62, 0x31, 0x33, 0x39, 0x33, 0x70, 0x00, 0x00,
-  0x01, 0xb2, 0x58, 0x76, 0x69, 0x44, 0x30, 0x30,
-  0x33, 0x39, 0x00, 0x00, 0x01, 0xb6, 0x18, 0x60,
-  0xab, 0x94, 0x03, 0xc0, 0xca, 0xc0, 0x3e, 0xd0,
-  0x78, 0x4f, 0xf9, 0x44, 0x91, 0xe9, 0xfa, 0xc9,
-  0xfe, 0xa1, 0xa4, 0xc1, 0x66, 0x03, 0x2e, 0x39,
-  0x0c, 0x7e, 0x0e, 0xaa, 0x02, 0x92, 0xf8, 0xd5,
-  0xec, 0xe2, 0x35, 0xb9, 0x35, 0x0c, 0xb3, 0x82,
-  0xa6, 0xad, 0xd0, 0xd1, 0xca, 0xb8, 0xe8, 0x10,
-  0x55, 0x78, 0x03, 0xc0, 0x38, 0x15, 0xba, 0xce,
-  0xe2, 0xea, 0x00, 0xc3, 0x60, 0xb1, 0x70, 0xf4,
-  0x14, 0x6c, 0x35, 0x4d, 0xe8, 0x5a, 0x1e, 0x58,
-  0xdf, 0x03, 0x01, 0xfd, 0x2a, 0x45, 0x54, 0xca,
-  0x0f, 0x05, 0x00, 0xbd, 0xd0, 0xcc, 0xb4, 0x90,
-  0x4c, 0x24, 0x6b, 0x20, 0x30, 0x95, 0xf1, 0x2f,
-  0xb4, 0xa7, 0x83, 0xdc, 0xce, 0x03, 0x05, 0x02,
-  0x1a, 0x5d, 0x1a, 0x2c, 0xbf, 0x51, 0x28, 0x8b,
-  0xd7, 0x6b, 0xdd, 0xf9, 0x44, 0xbb, 0x0e, 0x91,
-  0x64, 0xb9, 0xa6, 0x33, 0xd3, 0x6e, 0x34, 0xa4,
-  0xac, 0xac, 0x53, 0x0d, 0x79, 0xbe, 0xae, 0x5b,
-  0x47, 0x2e, 0xde, 0x62, 0xa1, 0x53, 0xcd, 0x7d,
-  0xfe, 0x66, 0xa1, 0x2b, 0x9c, 0xe1, 0xca, 0xbc,
-  0xea, 0x84, 0x1c, 0x68, 0xff, 0xbb, 0x28, 0xa1,
-  0x26, 0x18, 0x99, 0xb1, 0x4f, 0x68, 0x80, 0x28,
-  0x0e, 0x20, 0xc3, 0xbf, 0x0f, 0x80, 0xf8, 0x90,
-  0x3b, 0x1f, 0x16, 0xe4, 0xb0, 0x6f, 0x44, 0x16,
-  0x38, 0xb8, 0xc3, 0x81, 0x22, 0xfa, 0xe3, 0x09,
-  0xf6, 0x61, 0x6d, 0xef, 0x67, 0x56, 0x3b, 0x57,
-  0xb5, 0x23, 0x03, 0x1f, 0x6d, 0x0d, 0xb9, 0x08,
-  0xc6, 0x43, 0xba, 0xd1, 0x40, 0x5a, 0xe8, 0xca,
-  0x9e, 0x17, 0x1f, 0x6d, 0x5d, 0x16, 0x98, 0xab,
-  0xe6, 0x99, 0xf6, 0x37, 0xc6, 0x1b, 0xdc, 0xb9,
-  0xb3, 0xfe, 0x9a, 0x4b, 0x1e, 0xec, 0xf9, 0x5f,
-  0xb8, 0xc7, 0xfc, 0xbe, 0x6c, 0xd5, 0xf3, 0x9b,
-  0x17, 0x8b, 0x89, 0x82, 0xff, 0x30, 0x19, 0x20,
-  0x30, 0xe6, 0x29, 0x96, 0x75, 0x75, 0xeb, 0x00,
-  0x3f, 0xa1, 0x20, 0x5b, 0x06, 0x11, 0x98, 0x1f,
-  0xb2, 0xad, 0x3a, 0x59, 0xe6, 0x7d, 0x38, 0xa4,
-  0xb1, 0x4f, 0xfe, 0xdf, 0x3a, 0x4b, 0xdb, 0x69,
-  0xc3, 0x93, 0xcc, 0xdf, 0x5e, 0xf7, 0x2a, 0x38,
-  0x2a, 0x89, 0x84, 0x80, 0x6c, 0x12, 0x44, 0x95,
-  0x78, 0xd8, 0x7e, 0x3f, 0x4e, 0xcf, 0x3f, 0x39,
-  0xba, 0x9f, 0xfa, 0x8f, 0x2f, 0x62, 0xfa, 0xf0,
-  0xb6, 0x20, 0xa7, 0x06, 0x02, 0x3f, 0x28, 0x96,
-  0x80, 0xf0, 0x99, 0x8e, 0x82, 0x15, 0x11, 0x87,
-  0x35, 0xa4, 0xfd, 0x53, 0xcb, 0xcd, 0x68, 0x38,
-  0xe8, 0xdb, 0x8d, 0xc2, 0x71, 0xbc, 0x65, 0x3e,
-  0xac, 0x5b, 0x0d, 0xae, 0xc0, 0x3c, 0x77, 0xfe,
-  0xe8, 0xde, 0x3c, 0xbd, 0xdb, 0xb3, 0x39, 0x09,
-  0x56, 0x0a, 0xa2, 0xfe, 0x40, 0xd7, 0x6f, 0x56,
-  0x07, 0x02, 0xec, 0xd6, 0xed, 0x06, 0x5e, 0x2f,
-  0xb6, 0xce, 0xf1, 0x4f, 0x16, 0x88, 0x04, 0x41,
-  0x79, 0x0e, 0x98, 0xbe, 0x54, 0x75, 0x1a, 0xd6,
-  0x50, 0xcf, 0x82, 0x6a, 0xf7, 0xaf, 0x7f, 0xfb,
-  0x6d, 0x88, 0x97, 0x24, 0x40, 0x68, 0xa0, 0x57,
-  0x79, 0x57, 0xe9, 0x6b, 0xaa, 0xe5, 0xe4, 0x2b,
-  0xaa, 0x14, 0x64, 0x90, 0x6c, 0x50, 0x4a, 0xe3,
-  0x97, 0x43, 0xf6, 0x81, 0x90, 0xa9, 0xa6, 0xba,
-  0xb1, 0x21, 0x12, 0x5f, 0xe0, 0xdf, 0x88, 0x86,
-  0x03, 0x30, 0x94, 0xb2, 0x6d, 0xd2, 0xdc, 0x45,
-  0x14, 0x54, 0x1d, 0xe8, 0x38, 0x8d, 0xbe, 0x8a,
-  0xaf, 0x20, 0xa2, 0x3e, 0xa2, 0x5c, 0xc6, 0xae,
-  0xe6, 0xc4, 0x48, 0xec, 0xea, 0xc7, 0x4e, 0x17,
-  0xb2, 0x91, 0x52, 0xb4, 0xe9, 0x8b, 0x15, 0xfb,
-  0x99, 0x7c, 0xda, 0xb8, 0xad, 0x57, 0x31, 0x5b,
-  0x5b, 0x67, 0xaa, 0x1e, 0x93, 0x76, 0xa5, 0x25,
-  0xd9, 0x0d, 0x70, 0xd8, 0xb9, 0x11, 0x34, 0xfd,
-  0xaf, 0x0e, 0x0d, 0x42, 0x57, 0x97, 0x26, 0x06,
-  0xdf, 0x29, 0x7e, 0x79, 0x72, 0x22, 0x36, 0xa5,
-  0x9f, 0x6a, 0x16, 0x24, 0x6f, 0x10, 0x56, 0xec,
-  0x5b, 0x46, 0x50, 0x94, 0x88, 0xc4, 0xfa, 0x9e,
-  0xd8, 0x5b, 0xb7, 0x50, 0x72, 0x62, 0x25, 0xaa,
-  0x39, 0x84, 0x69, 0xaa, 0xfc, 0xbf, 0x9b, 0x45,
-  0xf7, 0xc5, 0x41, 0x97, 0x41, 0xc7, 0xac, 0x7f,
-  0x68, 0x92, 0xab, 0x64, 0xaa, 0x46, 0x32, 0x84,
-  0x77, 0x1b, 0xfc, 0xbc, 0x5a, 0x42, 0x28, 0xfa,
-  0x3e, 0x55, 0xf4, 0xe9, 0x44, 0xac, 0xc5, 0x4a,
-  0x6c, 0x93, 0xde, 0x03, 0x6d, 0xdc, 0xb8, 0x5b,
-  0xb7, 0x83, 0x7e, 0xc2, 0xaa, 0x33, 0x70, 0x34,
-  0x41, 0x46, 0x25, 0xa5, 0x6f, 0xdb, 0x96, 0x0f,
-  0xd3, 0xab, 0xd4, 0x17, 0x65, 0x96, 0x0c, 0x1e,
-  0x39, 0x4c, 0x9d, 0x90, 0x3f, 0x5b, 0x8d, 0xaa,
-  0xce, 0xac, 0xa6, 0x50, 0xf0, 0x66, 0xb2, 0x30,
-  0xce, 0x42, 0x61, 0xaa, 0xb6, 0x7e, 0xca, 0xbf,
-  0xfd, 0xbf, 0xef, 0x51, 0xed, 0xdf, 0x95, 0x0b,
-  0xa7, 0x34, 0x24, 0x13, 0x62, 0x44, 0x81, 0xdf,
-  0x3a, 0x8e, 0x95, 0x91, 0x67, 0xd7, 0x57, 0x54,
-  0x92, 0x1d, 0x79, 0xa3, 0x2a, 0xf3, 0x0c, 0x7a,
-  0x12, 0xa8, 0x33, 0xf9, 0x05, 0x02, 0x7b, 0xef,
-  0x12, 0x18, 0xab, 0x8b, 0x40, 0x38, 0x7e, 0x0c,
-  0x1f, 0x04, 0x30, 0x62, 0xa8, 0xd5, 0xd9, 0x78,
-  0xdd, 0x1c, 0xb4, 0x57, 0xc1, 0x83, 0xc4, 0x41,
-  0x08, 0x72, 0x5c, 0xc2, 0xb6, 0xd3, 0xd4, 0x85,
-  0x4a, 0x7e, 0x58, 0xc3, 0x19, 0xfa, 0xdd, 0x51,
-  0x03, 0x85, 0x1d, 0xe9, 0x10, 0x5e, 0x8c, 0x8f,
-  0x41, 0x03, 0xe9, 0xbc, 0xa8, 0xba, 0xeb, 0x73,
-  0x7d, 0x85, 0x69, 0xc7, 0x3b, 0xd9, 0x49, 0x0b,
-  0x39, 0x03, 0x12, 0x11, 0x8b, 0x72, 0x97, 0x62,
-  0x5f, 0xfe, 0x59, 0x4d, 0xc0, 0x3a, 0xdf, 0xcb,
-  0x3e, 0x80, 0x39, 0xd5, 0x7a, 0xb1, 0x45, 0x86,
-  0x06, 0xf6, 0xb6, 0xda, 0x98, 0xa1, 0x41, 0xae,
-  0x12, 0xd3, 0xd1, 0x71, 0x5a, 0xa5, 0x40, 0xc0,
-  0x8a, 0x3f, 0x4e, 0xac, 0x78, 0x93, 0x55, 0x31,
-  0xfc, 0xcf, 0x67, 0x93, 0x52, 0xc4, 0x53, 0x0d,
-  0xdf, 0x49, 0xd7, 0x83, 0x00, 0x18, 0x4b, 0xcd,
-  0x65, 0xaf, 0xb5, 0xd5, 0x6c, 0xc4, 0x14, 0xb7,
-  0xdb, 0x9d, 0x06, 0x17, 0xca, 0xe1, 0x60, 0x07,
-  0x6d, 0x57, 0xd0, 0xfb, 0x1a, 0xf5, 0xb2, 0x56,
-  0xca, 0xea, 0x21, 0x77, 0x41, 0xc0, 0x46, 0xc8,
-  0x85, 0xe3, 0x15, 0x6a, 0xdb, 0x80, 0x47, 0x6d,
-  0x05, 0x44, 0x06, 0x04, 0xf6, 0x92, 0x24, 0xdb,
-  0x9b, 0x6f, 0xfa, 0x8d, 0x72, 0x2d, 0x75, 0x7e,
-  0x33, 0x9c, 0xe7, 0x06, 0xbb, 0x3d, 0xa4, 0xb7,
-  0xee, 0x31, 0x46, 0x4b, 0x91, 0xe2, 0xb0, 0x54,
-  0x5c, 0x78, 0x9e, 0x45, 0x90, 0xe4, 0x76, 0xbe,
-  0xe1, 0x4c, 0xae, 0x89, 0x20, 0x6e, 0x77, 0x76,
-  0x94, 0x63, 0x93, 0xaa, 0x62, 0x0e, 0x28, 0x7b,
-  0xec, 0xc9, 0xc5, 0x25, 0x64, 0x5a, 0xe9, 0xcc,
-  0x91, 0x1a, 0x9c, 0xcf, 0x91, 0x47, 0x32, 0x12,
-  0x9f, 0x8b, 0x36, 0x07, 0x33, 0x4c, 0x45, 0x06,
-  0x19, 0xdb, 0x61, 0xc5, 0x68, 0xb7, 0xab, 0x2e,
-  0x7b, 0x5c, 0xa6, 0x4c, 0x6e, 0x08, 0x5f, 0xc1,
-  0xc4, 0x99, 0x64, 0xef, 0xd8, 0x05, 0x5c, 0x0f,
-  0x76, 0xdd, 0xab, 0x4f, 0x8e, 0x29, 0x54, 0x59,
-  0x1d, 0x30, 0x33, 0xfb, 0x3b, 0x43, 0x96, 0xf4,
-  0x52, 0x47, 0x2c, 0x66, 0x81, 0xca, 0xa6, 0x73,
-  0x51, 0xc1, 0xc0, 0x32, 0x98, 0xa3, 0x41, 0x1c,
-  0x40, 0x5e, 0x22, 0x05, 0xa0, 0xdb, 0xb0, 0x88,
-  0xdf, 0xee, 0x2f, 0x3a, 0xbb, 0xe2, 0xef, 0x79,
-  0x09, 0xa6, 0x0c, 0x0f, 0x4c, 0xdc, 0x81, 0xcc,
-  0x3d, 0x36, 0x52, 0x4e, 0xbd, 0x44, 0x0d, 0x0d,
-  0x84, 0xf5, 0x74, 0x33, 0x14, 0x1a, 0x87, 0xcb,
-  0xcc, 0x93, 0xa3, 0x69, 0x21, 0x20, 0x26, 0x23,
-  0xd9, 0x95, 0x0c, 0x22, 0x2b, 0x2f, 0x0d, 0xf4,
-  0x34, 0x74, 0x53, 0x16, 0x5d, 0x60, 0x96, 0x3e,
-  0x53, 0xd3, 0xcc, 0xc5, 0x72, 0x49, 0xc2, 0x4d,
-  0xea, 0x02, 0x21, 0x7f, 0xbd, 0x80, 0x1d, 0xf0,
-  0x87, 0xe6, 0xdb, 0xcc, 0x92, 0xdd, 0xfe, 0x78,
-  0x4a, 0xd2, 0xf9, 0x77, 0x24, 0xed, 0x5a, 0x31,
-  0x6c, 0xec, 0x71, 0x5d, 0x85, 0xad, 0xb3, 0xb9,
-  0x6f, 0x11, 0x2d, 0xfa, 0x42, 0x2b, 0xcb, 0x01,
-  0x08, 0x18, 0x11, 0x56, 0xcb, 0x01, 0xe1, 0xe0,
-  0x1f, 0x06, 0xe8, 0x3c, 0x6c, 0x01, 0xaa, 0x49,
-  0x86, 0xbf, 0x63, 0x79, 0x03, 0xbe, 0xd8, 0x47,
-  0x4f, 0x26, 0x0d, 0x11, 0xe3, 0x76, 0x27, 0x0e,
-  0xf1, 0x79, 0x44, 0x46, 0xc3, 0x3b, 0x4f, 0x05,
-  0x20, 0x40, 0xff, 0x59, 0x6f, 0xaa, 0x17, 0xf4,
-  0x40, 0xa1, 0x15, 0x0a, 0x4c, 0x0f, 0x94, 0x81,
-  0xb8, 0x0c, 0x8e, 0x8d, 0xc3, 0x80, 0xc1, 0xeb,
-  0x02, 0x16, 0xf4, 0xbe, 0xca, 0xa4, 0x3a, 0xa8,
-  0xec, 0x0c, 0x89, 0xc4, 0x59, 0xe4, 0x8b, 0x9a,
-  0x40, 0x7e, 0xae, 0xea, 0xa0, 0xeb, 0x6a, 0x99,
-  0x95, 0x73, 0x79, 0x62, 0x18, 0xb8, 0x38, 0x64,
-  0x73, 0x97, 0xb7, 0x58, 0xd1, 0x2d, 0x8d, 0xbe,
-  0xf3, 0x13, 0x2f, 0x7c, 0xc0, 0x1d, 0x61, 0x4e,
-  0x4c, 0xe6, 0x95, 0xce, 0x97, 0xf9, 0xbc, 0xf4,
-  0x5a, 0xce, 0xa1, 0x3b, 0x39, 0xef, 0xc5, 0x39,
-  0x4b, 0x72, 0x1b, 0xa5, 0x41, 0x92, 0x27, 0xda,
-  0x72, 0xc2, 0xbb, 0xd4, 0x8d, 0x34, 0x97, 0x9d,
-  0xb7, 0xde, 0xe7, 0xb0, 0x64, 0x8a, 0x0a, 0x0c,
-  0x0e, 0x60, 0x30, 0x62, 0xb8, 0xbb, 0x9f, 0x96,
-  0x05, 0x31, 0x33, 0xfa, 0x3c, 0x1f, 0xf4, 0x3d,
-  0x04, 0x3c, 0x5c, 0x1e, 0x1b, 0xfe, 0xf1, 0xfe,
-  0xa1, 0xb1, 0x03, 0x54, 0x99, 0x50, 0x61, 0xc5,
-  0xbc, 0x2d, 0x00, 0xfe, 0xaf, 0x01, 0xe1, 0x7f,
-  0xeb, 0xd4, 0x77, 0x0d, 0xb4, 0x0a, 0x9c, 0x18,
-  0x92, 0x3d, 0x5a, 0xbf, 0xc0, 0x98, 0x66, 0xcc,
-  0x06, 0x09, 0x6a, 0x50, 0xe9, 0x18, 0x32, 0x00,
-  0x78, 0xc8, 0x06, 0x68, 0xac, 0x8b, 0x3f, 0x38,
-  0xbf, 0x4a, 0x33, 0x30, 0x1c, 0x4f, 0xae, 0x16,
-  0x44, 0x98, 0x24, 0x08, 0xc9, 0x07, 0xed, 0x62,
-  0xbb, 0x89, 0x15, 0xca, 0x0f, 0x09, 0x00, 0x7a,
-  0x51, 0xc5, 0x93, 0x54, 0x45, 0xfb, 0x73, 0xdf,
-  0xe9, 0x42, 0x07, 0x90, 0x10, 0xcb, 0xdb, 0x2b,
-  0x47, 0x20, 0x2b, 0xaa, 0xf4, 0x5c, 0xa4, 0x28,
-  0x38, 0x9d, 0x5a, 0x44, 0x22, 0x0d, 0x54, 0x81,
-  0x1d, 0x07, 0x0a, 0x37, 0xee, 0x49, 0x8b, 0xfb,
-  0x3a, 0x8d, 0x7e, 0x83, 0x84, 0xfd, 0xf7, 0x98,
-  0xad, 0xac, 0xa7, 0x46, 0x07, 0x62, 0x72, 0x56,
-  0x1c, 0x03, 0x05, 0x4d, 0x70, 0xd8, 0x60, 0x62,
-  0x8a, 0x8d, 0xe8, 0x23, 0x03, 0x04, 0x6d, 0x60,
-  0xdc, 0x2a, 0x27, 0x92, 0x08, 0x8f, 0x65, 0xed,
-  0xbd, 0xca, 0xa5, 0x1d, 0x80, 0x8d, 0x11, 0x03,
-  0x83, 0xc7, 0x05, 0x04, 0x85, 0xcd, 0x2f, 0x3a,
-  0xd4, 0x83, 0x02, 0x91, 0x91, 0xc5, 0x76, 0xb5,
-  0x79, 0xcb, 0xfb, 0x29, 0x22, 0x90, 0x1e, 0x09,
-  0x9f, 0x2c, 0x07, 0x77, 0xa0, 0x38, 0xf8, 0x63,
-  0xf5, 0x2a, 0xd4, 0xc5, 0x0f, 0xd7, 0x43, 0x38,
-  0xb5, 0xe8, 0x38, 0x94, 0x29, 0x71, 0x68, 0xb4,
-  0x99, 0x0a, 0x4d, 0xf6, 0x94, 0x9d, 0x8e, 0x96,
-  0x58, 0x88, 0x63, 0x46, 0x02, 0x9d, 0x64, 0x83,
-  0x70, 0x72, 0x32, 0x6f, 0x90, 0x1d, 0x0e, 0xd5,
-  0xf5, 0xd9, 0x0d, 0xe8, 0x0f, 0xa3, 0x20, 0x5f,
-  0x26, 0x59, 0xc3, 0x50, 0x33, 0x04, 0xc9, 0x0c,
-  0xc8, 0xa2, 0xce, 0x12, 0x43, 0x44, 0xa3, 0x55,
-  0xe5, 0x07, 0x05, 0x1a, 0x69, 0xa8, 0xc4, 0x39,
-  0x92, 0xa2, 0x44, 0x0e, 0x08, 0xe0, 0xa2, 0x4a,
-  0x28, 0xd7, 0x80, 0xe1, 0x37, 0x96, 0x0c, 0x49,
-  0x28, 0x0f, 0x3c, 0xc8, 0xe2, 0xc1, 0x5d, 0x4f,
-  0xd4, 0x48, 0xa2, 0x21, 0x59, 0xf1, 0x0d, 0x9f,
-  0xaa, 0xc6, 0x77, 0xc8, 0xe5, 0xce, 0x0d, 0xca,
-  0x02, 0x87, 0x4a, 0x49, 0x01, 0xc8, 0x48, 0xc8,
-  0xf3, 0x1b, 0x2f, 0xdf, 0x6c, 0xcb, 0x88, 0x66,
-  0xf1, 0x40, 0xbd, 0x6a, 0x34, 0xfc, 0xb0, 0x89,
-  0xde, 0x11, 0xc5, 0xc6, 0xa2, 0x44, 0xc6, 0xdb,
-  0x67, 0xff, 0xd1, 0x79, 0x01, 0xa4, 0x9e, 0xf0,
-  0x1f, 0x10, 0x57, 0x2b, 0x24, 0xc5, 0x1c, 0x09,
-  0x45, 0x7e, 0xcc, 0x55, 0xe5, 0x0d, 0x64, 0xe2,
-  0x2c, 0xe4, 0xea, 0xe4, 0x81, 0x31, 0xfd, 0x61,
-  0x38, 0x8f, 0xba, 0x1f, 0xb4, 0xd9, 0x6c, 0xa8,
-  0xac, 0xe4, 0xe8, 0xca, 0x9e, 0xee, 0xa9, 0x51,
-  0xd7, 0xe9, 0x9d, 0xcc, 0xb0, 0x7c, 0x24, 0xc5,
-  0x13, 0xa0, 0x89, 0x78, 0x0b, 0x15, 0xd1, 0x09,
-  0xe4, 0xbf, 0x34, 0x6f, 0xcf, 0x0b, 0x82, 0x51,
-  0xb3, 0x70, 0x7d, 0x83, 0xe1, 0x24, 0x0d, 0x33,
-  0xad, 0xda, 0x5d, 0xfe, 0xe7, 0x38, 0x54, 0x52,
-  0x0e, 0x3d, 0xd5, 0xec, 0xef, 0x0b, 0x05, 0xe1,
-  0x16, 0xa9, 0x45, 0xec, 0x5f, 0x81, 0xb9, 0xc8,
-  0xff, 0x36, 0x0e, 0x0e, 0x01, 0x81, 0x31, 0xae,
-  0x4b, 0x35, 0xd8, 0x18, 0x17, 0x8c, 0x33, 0x7a,
-  0xa2, 0xee, 0x06, 0x5b, 0xd8, 0x0b, 0x07, 0xb0,
-  0x52, 0xbe, 0xf6, 0xf4, 0x38, 0xec, 0x35, 0x6e,
-  0x45, 0xc1, 0x5e, 0x51, 0xd3, 0x67, 0x93, 0x6d,
-  0xaf, 0xd0, 0xe0, 0x2a, 0xea, 0x6a, 0x1e, 0x03,
-  0x0c, 0x38, 0xa4, 0x38, 0xea, 0x34, 0x41, 0x99,
-  0xcb, 0xe0, 0xcd, 0xda, 0xf2, 0xee, 0x86, 0x28,
-  0x83, 0x38, 0x0b, 0x13, 0xd1, 0x73, 0x1e, 0x4f,
-  0xb5, 0x18, 0x7d, 0xef, 0xed, 0x09, 0xdf, 0xf7,
-  0x4a, 0x91, 0xdb, 0x41, 0x84, 0xf7, 0x07, 0x14,
-  0x15, 0x3b, 0x01, 0xc5, 0x28, 0x41, 0x78, 0x9f,
-  0xf6, 0x92, 0xce, 0x06, 0xe0, 0xb9, 0x9d, 0xa0,
-  0xee, 0xf0, 0x25, 0xa9, 0xd4, 0xe0, 0x71, 0xb4,
-  0x66, 0x0c, 0x11, 0x47, 0x01, 0x89, 0x34, 0x62,
-  0x11, 0x60, 0x27, 0xa0, 0xfb, 0x1f, 0xfe, 0xd1,
-  0x50, 0x6e, 0x0e, 0x23, 0xc3, 0xd8, 0x0e, 0xe8,
-  0x53, 0xa7, 0x94, 0x03, 0x12, 0x41, 0x9a, 0x90,
-  0x97, 0xce, 0x87, 0x0d, 0x42, 0x9d, 0x07, 0xce,
-  0xff, 0xef, 0x4e, 0x07, 0x1a, 0x31, 0x08, 0x92,
-  0x98, 0x0c, 0x49, 0x46, 0x74, 0x22, 0x2a, 0xf1,
-  0x01, 0x51, 0x48, 0x26, 0xe9, 0xf5, 0xcd, 0xb0,
-  0x0c, 0x2e, 0xa1, 0x3d, 0x29, 0x05, 0x4f, 0xa0,
-  0x12, 0x06, 0x08, 0x9c, 0x94, 0x08, 0x60, 0xce,
-  0xd0, 0x96, 0x81, 0x81, 0x18, 0x62, 0x03, 0xcc,
-  0xba, 0x15, 0xd6, 0x91, 0x11, 0x14, 0x7e, 0xb2,
-  0x7e, 0xd4, 0x56, 0x74, 0x37, 0xdc, 0x82, 0xfb,
-  0x21, 0xa1, 0x93, 0x91, 0x60, 0x3d, 0xcb, 0x28,
-  0x4b, 0x52, 0xe9, 0x26, 0x4a, 0x0c, 0x32, 0xca,
-  0x31, 0xab, 0x10, 0x19, 0x6e, 0x76, 0x50, 0x1e,
-  0x7c, 0x89, 0x2f, 0x42, 0x4a, 0x46, 0xf8, 0xb1,
-  0x5e, 0xdc, 0xbe, 0x81, 0x4a, 0x0c, 0x4e, 0x6a,
-  0x31, 0x70, 0xd4, 0x17, 0x62, 0x30, 0xf8, 0xbb,
-  0xaa, 0xba, 0x06, 0x98, 0xf4, 0x05, 0x40, 0x7c,
-  0x8e, 0x81, 0x22, 0xc7, 0x8b, 0xf2, 0x67, 0x49,
-  0x64, 0x58, 0x1c, 0xb8, 0xa0, 0x6d, 0xb9, 0xea,
-  0x5b, 0x11, 0x47, 0x18, 0xe7, 0xd0, 0xbc, 0xce,
-  0xf3, 0x9d, 0x19, 0x10, 0x92, 0x95, 0x45, 0x47,
-  0x78, 0x87, 0x81, 0x32, 0x6b, 0xc0, 0xe5, 0x7a,
-  0x79, 0x25, 0x37, 0x0d, 0x05, 0x06, 0x73, 0x39,
-  0x50, 0x9f, 0x8f, 0x5d, 0x09, 0x24, 0x34, 0x32,
-  0x18, 0x04, 0x62, 0x9c, 0xe8, 0x1e, 0x06, 0x52,
-  0x88, 0x1e, 0x26, 0x01, 0x30, 0x36, 0x81, 0x60,
-  0x63, 0x41, 0x6a, 0x77, 0xa8, 0x42, 0xd4, 0xba,
-  0x1f, 0x0e, 0x79, 0x06, 0x2d, 0x16, 0x83, 0x00,
-  0xe3, 0xe6, 0xcb, 0xba, 0x82, 0x4a, 0x27, 0xd7,
-  0x5e, 0xdc, 0x58, 0x44, 0x19, 0x28, 0x0c, 0xc7,
-  0x2f, 0x57, 0xb2, 0x83, 0x83, 0x40, 0xcc, 0x1c,
-  0xb8, 0x99, 0x41, 0xb9, 0xb0, 0xc8, 0x1f, 0x36,
-  0x00, 0x75, 0x14, 0xa9, 0x25, 0x34, 0x87, 0x83,
-  0x05, 0x13, 0x16, 0x7d, 0x91, 0x40, 0x3b, 0x9c,
-  0xe8, 0x38, 0x57, 0x17, 0xd2, 0x03, 0xc0, 0xff,
-  0x4e, 0x0c, 0x1f, 0x16, 0x96, 0xc0, 0xe3, 0x8d,
-  0x62, 0x75, 0xb8, 0x04, 0xae, 0x03, 0x80, 0x88,
-  0xa1, 0x56, 0x31, 0x57, 0x66, 0x2d, 0x8a, 0xef,
-  0x11, 0x6f, 0xca, 0xe9, 0x47, 0x79, 0xd0, 0x9d,
-  0x0c, 0xb0, 0x18, 0x47, 0x06, 0x03, 0x57, 0x2c,
-  0xda, 0x8f, 0x4a, 0x80, 0xd9, 0xa0, 0x62, 0x80,
-  0x60, 0x4d, 0x95, 0x18, 0x8c, 0x18, 0x45, 0xcb,
-  0x17, 0xad, 0x34, 0xa3, 0xd2, 0xa1, 0xb5, 0xd3,
-  0x32, 0xd9, 0xdb, 0xd1, 0x82, 0x98, 0x18, 0x83,
-  0xa9, 0xcd, 0xb5, 0x20, 0x77, 0x03, 0x5c, 0x5f,
-  0xa6, 0xdb, 0x48, 0x12, 0xd7, 0x46, 0xc8, 0xd1,
-  0x78, 0x1c, 0x1d, 0x17, 0x04, 0x91, 0xe8, 0xbc,
-  0x2a, 0xa0, 0x53, 0x83, 0x11, 0x29, 0xff, 0x18,
-  0xfe, 0x8d, 0x98, 0x6e, 0xad, 0x11, 0x65, 0xa0,
-  0xc8, 0x3c, 0x48, 0x48, 0x13, 0x55, 0x28, 0xf5,
-  0x61, 0x9d, 0xe0, 0x38, 0x5e, 0x12, 0xc0, 0x70,
-  0x44, 0xbf, 0x6f, 0x25, 0x9d, 0x2b, 0xcf, 0xb6,
-  0x79, 0x3d, 0xcf, 0x45, 0x32, 0xa8, 0x19, 0x67,
-  0x3a, 0x14, 0x43, 0x6d, 0x7d, 0xa1, 0x04, 0xb7,
-  0x3e, 0xd3, 0x75, 0x45, 0x2a, 0x6a, 0x6d, 0xb2,
-  0x12, 0x87, 0x90, 0xa0, 0x6b, 0xbf, 0x1a, 0x5b,
-  0xb7, 0x14, 0xd0, 0x26, 0x88, 0x5e, 0xb8, 0x4d,
-  0x70, 0x19, 0x65, 0x36, 0xdd, 0x9c, 0x40, 0x7a,
-  0xbf, 0x21, 0xc8, 0x38, 0x38, 0x01, 0xca, 0x1e,
-  0xc5, 0xee, 0xb3, 0x40, 0xc0, 0x9a, 0xd6, 0x24,
-  0xa7, 0xb4, 0x6b, 0x06, 0x18, 0xfc, 0x1c, 0x11,
-  0xaf, 0x6d, 0xcc, 0xbd, 0x5e, 0xc8, 0x8e, 0x07,
-  0xbc, 0xe0, 0x52, 0x8f, 0x9a, 0xb1, 0x74, 0x40,
-  0xe4, 0x63, 0x20, 0x99, 0x4f, 0xa8, 0xbc, 0x0e,
-  0xf2, 0x86, 0x80, 0xea, 0x09, 0x8a, 0xec, 0xdd,
-  0xe7, 0x39, 0x49, 0x6e, 0xc4, 0x5c, 0x5d, 0x0d,
-  0x45, 0xd1, 0x7b, 0x8b, 0xd5, 0xaf, 0x43, 0x17,
-  0xe9, 0x49, 0xac, 0x6d, 0x10, 0xa6, 0x4e, 0x5e,
-  0xa8, 0xc8, 0x20, 0xca, 0x54, 0x8e, 0xa1, 0x15,
-  0xb5, 0x0d, 0xa0, 0x66, 0x70, 0x93, 0x6f, 0x01,
-  0xc4, 0x2b, 0xc1, 0x46, 0xbd, 0x74, 0x96, 0x05,
-  0x75, 0x50, 0xc0, 0xc3, 0x8b, 0x22, 0x25, 0x07,
-  0x1d, 0xf6, 0x70, 0x92, 0x2d, 0x17, 0x09, 0xcb,
-  0xef, 0xbd, 0x88, 0xd6, 0x46, 0x7b, 0xbd, 0xa0,
-  0xe7, 0xe9, 0xc7, 0x09, 0x01, 0xc0, 0xb1, 0x29,
-  0x3a, 0xc1, 0xdd, 0x05, 0xd2, 0x6a, 0x60, 0x73,
-  0x06, 0x54, 0x26, 0x84, 0x0b, 0x22, 0x42, 0x7e,
-  0x0d, 0x62, 0xfe, 0xc5, 0xb8, 0x30, 0x3a, 0xa2,
-  0x5f, 0x5b, 0xee, 0x6c, 0xc2, 0x50, 0x7a, 0x18,
-  0x00, 0xdf, 0x86, 0x41, 0x97, 0x16, 0x3d, 0xd9,
-  0xcb, 0x09, 0x46, 0x40, 0xb0, 0x04, 0xe5, 0xa0,
-  0xbb, 0xa9, 0x8d, 0x84, 0xa6, 0xd4, 0xb7, 0x53,
-  0xb2, 0xdf, 0x33, 0x16, 0x41, 0x38, 0x2f, 0x3c,
-  0xa8, 0x21, 0xef, 0x3e, 0xd6, 0xcd, 0x8b, 0xf9,
-  0x1f, 0x03, 0x7a, 0x29, 0x18, 0x84, 0x26, 0x7f,
-  0xe1, 0xdf, 0x98, 0x1c, 0x36, 0x58, 0xdc, 0x51,
-  0xde, 0x2d, 0x35, 0x1f, 0x69, 0xa7, 0x0a, 0x82,
-  0x08, 0xe9, 0x59, 0x7f, 0x2b, 0x4a, 0x39, 0x25,
-  0x96, 0x5f, 0xf1, 0x08, 0xa6, 0x5b, 0x4b, 0x67,
-  0x51, 0x12, 0xf0, 0xf2, 0xae, 0x68, 0xbb, 0x72,
-  0xef, 0x0a, 0xb6, 0x02, 0xbd, 0x14, 0x42, 0x37,
-  0x1b, 0x80, 0xe2, 0x3a, 0xb7, 0xb4, 0x1c, 0x0a,
-  0x9b, 0xa0, 0xea, 0x11, 0x21, 0x4b, 0x07, 0xc9,
-  0x93, 0xb7, 0x7b, 0xd1, 0x13, 0x8d, 0x62, 0xfd,
-  0x28, 0xbd, 0x44, 0x0e, 0x0f, 0x4e, 0x49, 0xb4,
-  0x43, 0x11, 0xc0, 0x38, 0x38, 0x08, 0xd2, 0xd9,
-  0x2e, 0x2c, 0x03, 0x9f, 0xa7, 0xd6, 0x37, 0x46,
-  0x01, 0x1f, 0x58, 0x56, 0xc0, 0x9c, 0x07, 0x0c,
-  0x9d, 0xba, 0x0a, 0x9a, 0x15, 0xd4, 0x63, 0x6a,
-  0x13, 0x69, 0xe0, 0x6f, 0x4c, 0xd0, 0x53, 0xc0,
-  0xf6, 0x6f, 0x3c, 0xb7, 0x7d, 0xcb, 0x3b, 0x40,
-  0x8e, 0xfa, 0x04, 0x48, 0x16, 0x35, 0x8b, 0x7d,
-  0xbc, 0x81, 0xaa, 0xb2, 0xe8, 0xbf, 0x7a, 0x0c,
-  0x1c, 0xfe, 0x86, 0x26, 0x8e, 0x86, 0x25, 0x83,
-  0x9d, 0x07, 0x11, 0xcf, 0xb8, 0x5b, 0x88, 0xe9,
-  0x5e, 0x12, 0x21, 0x13, 0xed, 0xb1, 0xfa, 0x0c,
-  0x87, 0xf0, 0xa3, 0x96, 0x05, 0x75, 0x33, 0x7a,
-  0x3d, 0x1f, 0x09, 0x49, 0x58, 0x56, 0x9d, 0x95,
-  0x5e, 0x52, 0x9b, 0x30, 0x3d, 0x64, 0x3d, 0xe4,
-  0xde, 0xcb, 0x3c, 0x59, 0x56, 0x0d, 0xd4, 0x94,
-  0x43, 0xf6, 0x24, 0xb7, 0x19, 0x1f, 0xa5, 0x6f,
-  0xd7, 0xc5, 0x9f, 0x56, 0xde, 0xe7, 0x38, 0x8a,
-  0xed, 0x3c, 0x15, 0xc1, 0x9b, 0x6b, 0x55, 0xab,
-  0x11, 0xa4, 0xce, 0xef, 0xd2, 0x4c, 0x88, 0x00,
-  0xad, 0x15, 0x18, 0xff, 0xb5, 0xad, 0xdf, 0x6f,
-  0xa4, 0xdc, 0xbc, 0xab, 0x84, 0x65, 0x30, 0xab,
-  0x09, 0x6b, 0xf4, 0xff, 0x43, 0x78, 0x30, 0x08,
-  0xa7, 0xa0, 0xa9, 0xa2, 0xf0, 0x8b, 0x72, 0x82,
-  0xa0, 0x5c, 0x12, 0xb0, 0x27, 0xe1, 0x84, 0x09,
-  0x27, 0x6e, 0x2d, 0x62, 0xc6, 0xd1, 0x85, 0x1a,
-  0x72, 0xb1, 0xbf, 0x83, 0xcc, 0x7f, 0xfa, 0x13,
-  0x54, 0xe0, 0x71, 0xfa, 0x0e, 0x23, 0x7d, 0x06,
-  0x25, 0x18, 0x4a, 0x11, 0x69, 0x43, 0x76, 0xe8,
-  0xc8, 0x18, 0x23, 0x96, 0x15, 0x2c, 0x7f, 0x4e,
-  0x8b, 0x01, 0x83, 0x6d, 0x18, 0x83, 0x04, 0x5b,
-  0x80, 0xa8, 0xc1, 0x9d, 0x01, 0xfa, 0xe2, 0xa3,
-  0x8d, 0x4f, 0xe9, 0x63, 0x0d, 0xfe, 0xe7, 0x7b,
-  0xcc, 0x5e, 0x86, 0xf5, 0x1b, 0xae, 0x0e, 0x93,
-  0xa0, 0x1f, 0x36, 0x33, 0xe8, 0x0e, 0x74, 0xcf,
-  0xa0, 0x43, 0x11, 0x82, 0x6d, 0x5a, 0xa8, 0xa6,
-  0x1a, 0xcb, 0xa1, 0xb4, 0x99, 0x6a, 0x08, 0x8f,
-  0x68, 0x30, 0x2c, 0x5f, 0x51, 0xfd, 0x10, 0x1a,
-  0xff, 0xd6, 0xec, 0xe7, 0x7a, 0xc7, 0xaf, 0x49,
-  0x16, 0xbb, 0x51, 0x50, 0xad, 0xbf, 0x8b, 0x76,
-  0x86, 0x20, 0x9b, 0x11, 0x81, 0xc5, 0x1b, 0x6f,
-  0x06, 0xdf, 0xfc, 0x28, 0xda, 0xe9, 0x03, 0x6a,
-  0xc1, 0x83, 0x96, 0xc1, 0x86, 0x3a, 0x12, 0xd2,
-  0x8a, 0x8c, 0x83, 0x85, 0xd0, 0xa0, 0xf3, 0x2e,
-  0x86, 0xee, 0xe1, 0xb7, 0xa1, 0x6d, 0x16, 0x2e,
-  0xf4, 0x46, 0xc1, 0x45, 0x99, 0xd2, 0x6d, 0x72,
-  0xd2, 0xe6, 0x52, 0x84, 0x07, 0x84, 0xf3, 0xc0,
-  0xe0, 0x0e, 0xa2, 0x1f, 0x6c, 0xce, 0xf6, 0x83,
-  0xc1, 0xc0, 0x3f, 0x47, 0xb9, 0x68, 0xc8, 0x11,
-  0x04, 0x14, 0x40, 0xc3, 0x43, 0x13, 0xa0, 0xf3,
-  0xff, 0xff, 0xbe, 0xfe, 0x58, 0xd4, 0x51, 0x7b,
-  0x0a, 0x01, 0x62, 0x48, 0xe1, 0x9b, 0x6b, 0x65,
-  0x8b, 0x54, 0x41, 0xc8, 0x9d, 0x57, 0x57, 0x64,
-  0xf7, 0x51, 0x83, 0x0c, 0x47, 0x25, 0x01, 0xc8,
-  0xad, 0x4a, 0x58, 0x4b, 0x05, 0xe0, 0xc0, 0x3d,
-  0x10, 0x4e, 0xb5, 0x85, 0xb8, 0xbc, 0xb0, 0x1e,
-  0x2a, 0x00, 0xb0, 0x58, 0xbd, 0x5e, 0xca, 0x4a,
-  0x0c, 0x2e, 0x19, 0x82, 0xe5, 0x3e, 0x8b, 0xa0,
-  0xe0, 0xc8, 0x8a, 0xae, 0xe7, 0xbe, 0x55, 0xbc,
-  0x45, 0x4a, 0x60, 0x60, 0x09, 0xcb, 0x89, 0x4c,
-  0x32, 0x08, 0x6d, 0x09, 0x0d, 0xb4, 0xd2, 0x54,
-  0xf8, 0xa8, 0xab, 0xca, 0x6f, 0xc4, 0xbf, 0x00,
-  0xe6, 0xb6, 0x8c, 0x4f, 0xc6, 0x16, 0xf7, 0x67,
-  0x1a, 0x9b, 0x2a, 0x1c, 0xe0, 0x0e, 0x44, 0x80,
-  0x80, 0x34, 0xb2, 0x9d, 0x59, 0x58, 0x17, 0xd1,
-  0x87, 0x81, 0x60, 0x2c, 0xf8, 0x0a, 0xad, 0x69,
-  0x49, 0x5d, 0x40, 0x43, 0x1b, 0x4e, 0x83, 0x7c,
-  0x48, 0x88, 0x92, 0x09, 0x3f, 0x05, 0x78, 0xf6,
-  0xc0, 0x60, 0xc9, 0xea, 0xd0, 0x66, 0xd3, 0x20,
-  0x08, 0x5b, 0xa0, 0xaf, 0x1d, 0xb3, 0xa1, 0x35,
-  0x2e, 0x1c, 0xc8, 0x33, 0x09, 0x1a, 0x34, 0x6d,
-  0x83, 0x06, 0x61, 0x21, 0x5a, 0x99, 0x57, 0xd1,
-  0xcc, 0xa2, 0x96, 0xed, 0x05, 0xc3, 0x61, 0x84,
-  0x1e, 0x07, 0xfc, 0x3e, 0x55, 0x2d, 0x01, 0xe4,
-  0x92, 0xc4, 0x56, 0xd6, 0xff, 0xc0, 0xa0, 0x6a,
-  0x23, 0x89, 0x29, 0xc4, 0x76, 0x43, 0xf6, 0x7c,
-  0xd6, 0x55, 0x0a, 0x0a, 0xb1, 0x00, 0x13, 0xaf,
-  0xa2, 0xa0, 0xe4, 0x5c, 0x11, 0xb2, 0xa2, 0x51,
-  0x80, 0x46, 0x98, 0xc3, 0x1e, 0x1b, 0x35, 0xc2,
-  0x5c, 0xb5, 0xf4, 0xfb, 0xf2, 0x1c, 0x83, 0x83,
-  0x80, 0x7c, 0xf8, 0x01, 0xfd, 0x9a, 0x85, 0x49,
-  0x69, 0xc7, 0xd8, 0x1a, 0xc3, 0x0f, 0xa3, 0x27,
-  0xb5, 0xa6, 0xc5, 0xdb, 0x3a, 0x15, 0x6e, 0x5e,
-  0xdb, 0x93, 0x60, 0x8b, 0x28, 0x31, 0x48, 0xc0,
-  0x35, 0x09, 0x3b, 0x5f, 0x28, 0x18, 0x54, 0x01,
-  0x80, 0x66, 0x8c, 0x8e, 0x7e, 0xd6, 0xaa, 0x8d,
-  0xa9, 0x9c, 0xa6, 0xe3, 0x10, 0xb6, 0x8c, 0x16,
-  0xd0, 0x97, 0x4f, 0x78, 0x15, 0x21, 0x88, 0xb8,
-  0x85, 0xb9, 0x01, 0xd1, 0x67, 0x69, 0xfd, 0xbe,
-  0xe4, 0x52, 0xd6, 0xc4, 0x6a, 0x24, 0x07, 0x54,
-  0x28, 0x08, 0xa6, 0x6f, 0x94, 0x03, 0x22, 0xf8,
-  0x67, 0x46, 0x20, 0x9a, 0x4c, 0x93, 0x90, 0x1c,
-  0x09, 0x90, 0x32, 0x46, 0x32, 0x0a, 0x2d, 0xe8,
-  0x27, 0xc5, 0xdc, 0xf6, 0xc9, 0xde, 0x4e, 0x1a,
-  0x45, 0x02, 0x5b, 0xab, 0xeb, 0x4a, 0x2f, 0x4d,
-  0x95, 0x29, 0xe8, 0x0f, 0x04, 0xcc, 0xb8, 0xbc,
-  0x6b, 0x32, 0x06, 0x08, 0x0d, 0xc0, 0x5f, 0xdb,
-  0x24, 0x46, 0xb1, 0xbe, 0x85, 0x5a, 0xeb, 0x4a,
-  0xa0, 0x40, 0x42, 0x48, 0x59, 0x37, 0xbd, 0x18,
-  0x82, 0x72, 0x63, 0xfd, 0xa5, 0x12, 0x83, 0x90,
-  0x85, 0x1e, 0xd5, 0x83, 0x35, 0xe0, 0xb9, 0x02,
-  0xc7, 0xcd, 0x88, 0x23, 0x86, 0xe7, 0xc7, 0x12,
-  0x4b, 0xcd, 0x1c, 0x59, 0x51, 0x29, 0x0c, 0x3b,
-  0xc9, 0xd0, 0x4d, 0xf9, 0x6a, 0x33, 0xba, 0xef,
-  0x2e, 0xe5, 0xd8, 0x69, 0x1a, 0x14, 0x44, 0x29,
-  0xe6, 0xcb, 0xee, 0x7f, 0xd6, 0x9b, 0x25, 0x0c,
-  0x51, 0x05, 0x48, 0xe4, 0xf9, 0x6a, 0xfd, 0xc9,
-  0x9d, 0x8b, 0xd9, 0xd1, 0x3a, 0x14, 0x7d, 0xa9,
-  0x38, 0x5a, 0x55, 0xd4, 0x57, 0x7f, 0xfb, 0x62,
-  0x11, 0x80, 0x30, 0x61, 0x1d, 0x6a, 0x00, 0x92,
-  0x2e, 0x9a, 0x7b, 0x82, 0x4a, 0x75, 0x77, 0x3b,
-  0x61, 0xb6, 0xbe, 0x36, 0xa1, 0x87, 0x67, 0x46,
-  0x0f, 0x30, 0xaf, 0x70, 0xbd, 0x8d, 0xc8, 0x31,
-  0x53, 0x37, 0xc0, 0xc1, 0x8c, 0x15, 0x1d, 0x4d,
-  0x38, 0xb5, 0x5c, 0x1c, 0x0b, 0xc1, 0x53, 0x17,
-  0xe0, 0x75, 0xb6, 0x68, 0x19, 0x9d, 0x2b, 0xf4,
-  0xe2, 0x09, 0x41, 0x30, 0xbe, 0xd0, 0xf7, 0xb2,
-  0x2c, 0x69, 0xd1, 0x33, 0x83, 0xa6, 0x59, 0x66,
-  0x17, 0xcb, 0x59, 0x6c, 0x18, 0x0c, 0x27, 0x1b,
-  0xfe, 0xd4, 0x72, 0xac, 0x75, 0x25, 0x65, 0xca,
-  0xfa, 0x0c, 0x05, 0xac, 0x29, 0x06, 0x04, 0xe1,
-  0x78, 0xe8, 0x79, 0x4a, 0xf2, 0xa9, 0xe6, 0xfb,
-  0xf1, 0x0e, 0x7e, 0xcd, 0x95, 0x6c, 0xed, 0x5a,
-  0x9a, 0xa6, 0xc5, 0x01, 0x4d, 0x38, 0x36, 0x24,
-  0x6b, 0xac, 0xe8, 0xf0, 0x77, 0xb9, 0xe9, 0x6f,
-  0x55, 0x8f, 0x52, 0x48, 0xb2, 0xeb, 0xe6, 0x29,
-  0xb7, 0xa6, 0xa5, 0x71, 0xbe, 0x57, 0x9e, 0xd0,
-  0xda, 0xa1, 0xe5, 0x08, 0xaa, 0x65, 0xc1, 0x13,
-  0xe8, 0x43, 0xef, 0x06, 0xac, 0xf8, 0x1f, 0x37,
-  0xff, 0xb7, 0x53, 0x7e, 0x65, 0xd9, 0xf4, 0xdf,
-  0x99, 0xc5, 0x25, 0x9b, 0x9b, 0x5c, 0x71, 0x90,
-  0x6c, 0x49, 0xbe, 0x55, 0xff, 0x69, 0x70, 0xfa,
-  0xff, 0xca, 0x7f, 0xe4, 0xe2, 0x4c, 0x42, 0x84,
-  0x3a, 0x7d, 0xb0, 0x07, 0x07, 0x8c, 0x29, 0x80,
-  0xc5, 0xa3, 0xc6, 0xee, 0xe1, 0x66, 0xe3, 0x1f,
-  0xdf, 0xd5, 0x15, 0x08, 0x89, 0x16, 0x3c, 0x30,
-  0x39, 0xcf, 0xaf, 0x35, 0x10, 0x2a, 0x38, 0x19,
-  0xbe, 0x26, 0xb8, 0x13, 0x83, 0x00, 0x1c, 0xe4,
-  0xda, 0xc5, 0x2b, 0xcf, 0xd2, 0xad, 0xc2, 0xa9,
-  0x37, 0xb7, 0xb5, 0x01, 0x41, 0x0d, 0x40, 0x38,
-  0x01, 0x9d, 0xe5, 0x12, 0x7f, 0xb4, 0x38, 0x54,
-  0x5c, 0xdb, 0x7c, 0x02, 0x73, 0x7e, 0x2c, 0x17,
-  0x2a, 0x1e, 0x09, 0x0a, 0xb3, 0x7c, 0x5d, 0x07,
-  0xbb, 0xf5, 0xfb, 0xff, 0xa6, 0x9e, 0xef, 0x29,
-  0xb5, 0x0b, 0x70, 0x6a, 0xa0, 0x6d, 0x01, 0x67,
-  0xe9, 0x2d, 0x98, 0x72, 0xa6, 0x44, 0x47, 0x12,
-  0xa2, 0x58, 0x25, 0x2b, 0xdc, 0x67, 0x71, 0xa5,
-  0x57, 0x0b, 0x15, 0x65, 0xba, 0xa6, 0x07, 0xb3,
-  0xb6, 0x22, 0x35, 0xde, 0x13, 0x09, 0xda, 0x08,
-  0x0d, 0xb3, 0xad, 0x83, 0xc1, 0x40, 0x42, 0x3b,
-  0xb7, 0x22, 0x90, 0xf5, 0xbe, 0x5d, 0xea, 0xcb,
-  0x01, 0x88, 0xa5, 0x72, 0x60, 0xbe, 0x23, 0x64,
-  0x6d, 0x57, 0xbb, 0x10, 0x7f, 0x94, 0x41, 0xac,
-  0x73, 0x84, 0xb1, 0x75, 0xc1, 0x38, 0xeb, 0x25,
-  0xbe, 0x6e, 0xf4, 0xb9, 0x8f, 0xa9, 0xd5, 0x84,
-  0x14, 0xad, 0xfe, 0xc3, 0x48, 0x11, 0x52, 0x99,
-  0x3a, 0x4e, 0x70, 0xe7, 0x65, 0x5a, 0x29, 0x85,
-  0x2a, 0x02, 0x68, 0x99, 0xaf, 0xaa, 0xfa, 0xad,
-  0x2c, 0xd1, 0x09, 0x46, 0xc4, 0x0d, 0xfd, 0xba,
-  0x0c, 0x18, 0x98, 0x6d, 0x97, 0x5a, 0xd3, 0x0d,
-  0xf9, 0x57, 0xbd, 0x75, 0x4e, 0x7f, 0x3b, 0xd5,
-  0xf2, 0xa3, 0x9d, 0xde, 0xaf, 0x10, 0x13, 0x97,
-  0xd5, 0x1c, 0xdb, 0xa3, 0xa2, 0xe9, 0x50, 0x7d,
-  0x44, 0xdd, 0xe4, 0x0d, 0xea, 0x08, 0x27, 0x33,
-  0x41, 0xba, 0xd5, 0xda, 0xc4, 0x2c, 0xec, 0xe7,
-  0x66, 0x35, 0xc9, 0x3b, 0xd9, 0x27, 0x73, 0x83,
-  0x17, 0x0d, 0x08, 0x3d, 0x35, 0x34, 0xa6, 0x9e,
-  0xd7, 0xea, 0x84, 0xb2, 0xcf, 0x87, 0x95, 0x94,
-  0xd5, 0x8b, 0x2e, 0x11, 0x89, 0x02, 0x06, 0x25,
-  0x6a, 0x46, 0xd5, 0xe5, 0xa5, 0xb9, 0x54, 0x67,
-  0x22, 0x9d, 0x2b, 0x92, 0xa0, 0x3c, 0x5e, 0xc5,
-  0x78, 0x38, 0xac, 0xc2, 0xff, 0xe1, 0x57, 0xbc,
-  0xb2, 0xd5, 0x48, 0xc7, 0x85, 0x10, 0x81, 0x54,
-  0x89, 0x3d, 0xbb, 0xdc, 0xb8, 0xd8, 0xf5, 0x9c,
-  0x8c, 0xa7, 0xe9, 0x46, 0x45, 0xd7, 0x40, 0x88,
-  0x8c, 0xdc, 0x56, 0xdc, 0x46, 0xa3, 0x06, 0xfc,
-  0xce, 0x91, 0x69, 0x8a, 0x55, 0x02, 0x8b, 0x72,
-  0xe7, 0xdb, 0x1f, 0xa5, 0x2b, 0x06, 0x40, 0x55,
-  0x31, 0x45, 0x9d, 0x40, 0xdd, 0x90, 0x54, 0x9a,
-  0x70, 0x64, 0x89, 0x15, 0xc9, 0xbe, 0x4f, 0xb3,
-  0x6d, 0xe5, 0x1c, 0xab, 0xc2, 0xc8, 0x30, 0x94,
-  0xea, 0x5e, 0x54, 0xab, 0x14, 0x7b, 0xfe, 0xce,
-  0x9b, 0xe6, 0xae, 0x50, 0xa6, 0xe9, 0x18, 0xb6,
-  0xb1, 0x95, 0x44, 0x53, 0xcf, 0x7b, 0x96, 0x7b,
-  0x98, 0x59, 0x43, 0x8e, 0x95, 0x0c, 0x21, 0x3b,
-  0x95, 0xc2, 0xb5, 0xe1, 0x42, 0x80, 0xc0, 0xf6,
-  0x99, 0xa4, 0xe0, 0x19, 0x83, 0xe1, 0x29, 0x28,
-  0xf3, 0xd4, 0x72, 0xdb, 0x77, 0xd4, 0x3c, 0xaa,
-  0x70, 0x3c, 0x45, 0xbd, 0x1b, 0x76, 0xf4, 0x80,
-  0x30, 0x60, 0x34, 0x12, 0x6f, 0xe2, 0x84, 0x96,
-  0xaf, 0x36, 0x29, 0xfb, 0x52, 0x73, 0xa8, 0xff,
-  0x2d, 0xe9, 0xe3, 0x3f, 0xf4, 0xa8, 0xb2, 0xf7,
-  0x4d, 0x15, 0x45, 0x83, 0x9b, 0x38, 0x33, 0x8b,
-  0x8a, 0xf0, 0x80, 0xd4, 0x5e, 0x79, 0x7e, 0xf2,
-  0xd1, 0xb8, 0xbe, 0x2f, 0xb2, 0x94, 0x9e, 0x24,
-  0x73, 0xfe, 0x02, 0x63, 0x26, 0x79, 0xa4, 0xdd,
-  0x4a, 0xda, 0x4a, 0xb5, 0xbb, 0x7c, 0x55, 0xdb,
-  0xee, 0xca, 0x1b, 0x4b, 0xd9, 0xd8, 0x02, 0x0e,
-  0xfd, 0xaa, 0xd7, 0xee, 0x6c, 0xb3, 0x86, 0xfb,
-  0x28, 0x56, 0x0c, 0x1a, 0xab, 0xf8, 0x24, 0xb3,
-  0xf5, 0x51, 0x46, 0xc6, 0x5b, 0xbd, 0x5a, 0xc9,
-  0x26, 0xd9, 0xb5, 0x75, 0xb9, 0xc3, 0x7c, 0x3c,
-  0x48, 0x43, 0x08, 0x5a, 0x3f, 0x6f, 0x4b, 0xfb,
-  0x41, 0x86, 0xc5, 0xad, 0xf1, 0x78, 0xa7, 0x24,
-  0xce, 0x45, 0xe8, 0xa4, 0x5e, 0x33, 0xcb, 0x3b,
-  0x39, 0xd4, 0x67, 0x55, 0x72, 0x63, 0xc2, 0xd6,
-  0x1b, 0x45, 0x29, 0xbb, 0xd8, 0x81, 0x00, 0xcc,
-  0x63, 0xd3, 0xc5, 0x12, 0x73, 0xfe, 0xf6, 0xde,
-  0x6e, 0x41, 0x89, 0x5f, 0xaf, 0x65, 0x5a, 0x9b,
-  0x21, 0x59, 0x5c, 0xc1, 0x0b, 0xc5, 0x7a, 0xbe,
-  0x28, 0xdf, 0x40, 0xf6, 0x2c, 0x8a, 0xc2, 0xa5,
-  0x2b, 0x74, 0xf9, 0x3d, 0x63, 0x13, 0xd8, 0x98,
-  0x71, 0x6f, 0x73, 0xb6, 0x88, 0x0d, 0xb3, 0x66,
-  0x5a, 0x56, 0x22, 0x77, 0x9b, 0x88, 0x08, 0x64,
-  0x2d, 0xff, 0x50, 0x42, 0x0d, 0x35, 0x47, 0x1b,
-  0x93, 0x2d, 0x42, 0x88, 0x50, 0x2f, 0x06, 0xcf,
-  0x29, 0x4a, 0x3e, 0xa5, 0x5d, 0xc4, 0xea, 0xbb,
-  0x03, 0xde, 0xf0, 0x73, 0x2f, 0x51, 0xa8, 0x13,
-  0x11, 0x64, 0x03, 0x14, 0xfb, 0xb3, 0xe1, 0xe2,
-  0x65, 0x18, 0xcd, 0xd9, 0x51, 0x72, 0xf3, 0x72,
-  0xd1, 0x12, 0xa3, 0x42, 0x8c, 0x4d, 0x00, 0x79,
-  0x9f, 0x36, 0x24, 0x8e, 0x95, 0x2a, 0xcc, 0x06,
-  0x02, 0xea, 0xad, 0x2b, 0xaa, 0x43, 0xcf, 0xe5,
-  0xd3, 0x4b, 0x2c, 0x4a, 0x34, 0x76, 0xdb, 0x9b,
-  0x97, 0x80, 0xe1, 0x56, 0xba, 0x6d, 0xe5, 0xf7,
-  0x40, 0x70, 0x3a, 0x05, 0x91, 0xca, 0x8f, 0x9b,
-  0xc1, 0x88, 0x2c, 0x0f, 0x0b, 0xb2, 0x50, 0x42,
-  0x06, 0x2d, 0xbb, 0x98, 0x4b, 0xc6, 0x22, 0x90,
-  0x78, 0xcf, 0xfd, 0xe6, 0x50, 0x60, 0x9d, 0x16,
-  0xda, 0xd1, 0xd2, 0x6f, 0xb3, 0xf9, 0x21, 0xab,
-  0x38, 0xc2, 0x30, 0xd4, 0xb7, 0xea, 0x1d, 0xfa,
-  0xf6, 0xe7, 0x01, 0xc1, 0xde, 0xc0, 0xb3, 0x4f,
-  0x03, 0x0f, 0xe7, 0x40, 0x39, 0x3a, 0x3a, 0xbb,
-  0x08, 0x81, 0x5f, 0x10, 0x10, 0x94, 0x4c, 0x5d,
-  0x3f, 0x9f, 0xd0, 0x34, 0x9d, 0x3e, 0xad, 0x31,
-  0x8f, 0x66, 0xf6, 0xf4, 0x45, 0x2a, 0x9b, 0x78,
-  0xe2, 0x02, 0x3f, 0xbc, 0x3f, 0x2e, 0xfb, 0x01,
-  0xf8, 0x1a, 0x9b, 0xc0, 0xf6, 0xe5, 0xb5, 0x65,
-  0xf8, 0xa2, 0xce, 0x3c, 0x23, 0xb4, 0x25, 0x17,
-  0x2a, 0xb5, 0xa0, 0x60, 0xfd, 0x5f, 0x2f, 0xa5,
-  0x0f, 0xd5, 0x28, 0x6b, 0xf6, 0xf4, 0x3a, 0xe4,
-  0xf2, 0x28, 0x8c, 0xd8, 0xac, 0xe4, 0xdf, 0x51,
-  0x0b, 0x14, 0x6a, 0x32, 0x5e, 0x0b, 0x9d, 0x5f,
-  0xf8, 0x9d, 0x27, 0xfd, 0x36, 0xfb, 0xfa, 0x59,
-  0xe0, 0x33, 0xce, 0xf1, 0x63, 0xb6, 0xd9, 0x6f,
-  0x41, 0xe1, 0x20, 0x15, 0xba, 0x5e, 0x42, 0x57,
-  0xed, 0x09, 0x1a, 0x59, 0xed, 0x1e, 0x8f, 0x4b,
-  0xea, 0x56, 0x94, 0x6f, 0x33, 0xba, 0x2f, 0x14,
-  0x74, 0x9e, 0x08, 0x51, 0x08, 0x8d, 0xbf, 0xf3,
-  0x7d, 0x57, 0x2a, 0xf1, 0x01, 0xf2, 0x59, 0xd2,
-  0xd9, 0xce, 0xe4, 0x97, 0xa4, 0xf8, 0x3f, 0x9c,
-  0x00, 0x6b, 0xa3, 0x1a, 0xfe, 0x82, 0x26, 0xd6,
-  0x26, 0x67, 0xb6, 0xf2, 0xab, 0xad, 0x7c, 0x3d,
-  0x9c, 0x06, 0x34, 0xa3, 0x61, 0x55, 0x29, 0x42,
-  0xe3, 0xac, 0xea, 0x52, 0x4a, 0xc6, 0x1c, 0x32,
-  0x21, 0xa5, 0x69, 0xbf, 0x7f, 0x1a, 0xc6, 0x04,
-  0xaa, 0x92, 0x0e, 0x54, 0x79, 0xac, 0xa5, 0xbb,
-  0xe4, 0x32, 0xc5, 0x2a, 0x38, 0x69, 0x67, 0x91,
-  0x57, 0xf1, 0xfa, 0xa0, 0xe9, 0xa5, 0x43, 0xea,
-  0x9e, 0x6c, 0xe4, 0x1b, 0x72, 0xef, 0x1c, 0x5a,
-  0xac, 0xcc, 0xf7, 0xae, 0x41, 0xcc, 0xa6, 0xcf,
-  0xaa, 0xe5, 0xd5, 0x77, 0xc1, 0xdc, 0x6e, 0x7f,
-  0xb9, 0xad, 0x62, 0xe5, 0x56, 0xf0, 0xd3, 0xca,
-  0x35, 0x1a, 0x55, 0x3f, 0xa0, 0xc1, 0xef, 0x9b,
-  0x6a, 0x59, 0xba, 0x59, 0x35, 0x6f, 0x72, 0xd3,
-  0x48, 0x86, 0xa5, 0x41, 0x4e, 0x25, 0xa3, 0x06,
-  0x0f, 0x55, 0xa6, 0x9b, 0xb3, 0x26, 0x03, 0x8e,
-  0x2d, 0xe6, 0x75, 0x3b, 0x38, 0xd4, 0xe7, 0xfe,
-  0xa3, 0xdd, 0xe5, 0xd9, 0x2a, 0x20, 0x71, 0x29,
-  0x39, 0xec, 0xab, 0xdc, 0xda, 0xa5, 0x47, 0xae,
-  0x59, 0x05, 0xb5, 0x71, 0x2b, 0x0a, 0x84, 0x25,
-  0x51, 0x9f, 0xa9, 0x6d, 0x2f, 0x9b, 0x8a, 0x1b,
-  0x4f, 0xc9, 0xfd, 0xe6, 0x4e, 0x74, 0x3b, 0x5c,
-  0x8b, 0xf3, 0x6e, 0x4a, 0x18, 0xc0, 0x74, 0x3f,
-  0x72, 0xee, 0x48, 0xa7, 0x75, 0xb6, 0x7f, 0x6a,
-  0x2e, 0x49, 0x6a, 0xd3, 0xa1, 0x40, 0xd4, 0x47,
-  0xd8, 0xce, 0x59, 0x2c, 0x43, 0xc5, 0xe5, 0x5d,
-  0xfa, 0x66, 0x3f, 0xfa, 0x86, 0xf5, 0x7c, 0x3d,
-  0x17, 0x32, 0xa2, 0x0f, 0xf1, 0xa5, 0x3d, 0xb4,
-  0x11, 0xf8, 0x6c, 0x96, 0x22, 0x18, 0xb9, 0xe9,
-  0x56, 0xee, 0x15, 0x28, 0x44, 0x84, 0x91, 0x11,
-  0x09, 0xab, 0x75, 0xb6, 0x3d, 0xd9, 0x38, 0xb9,
-  0x6a, 0x10, 0x1c, 0x35, 0x19, 0xb3, 0x89, 0xd9,
-  0x95, 0x16, 0xfa, 0x92, 0x2f, 0x45, 0xdc, 0x3f,
-  0x25, 0x2c, 0xd0, 0x74, 0xd0, 0xc8, 0xf6, 0x9a,
-  0x31, 0x3f, 0xb8, 0x5a, 0x80, 0xd2, 0xc8, 0x39,
-  0x10, 0x04, 0xb1, 0x12, 0xf9, 0x19, 0x5a, 0xe6,
-  0xa0, 0xd1, 0x7d, 0x00, 0xdd, 0xed, 0x2b, 0x49,
-  0xa0, 0x48, 0x07, 0x3c, 0x69, 0x00, 0x34, 0x43,
-  0x5e, 0xc6, 0xf1, 0xa4, 0x12, 0x73, 0x06, 0xc8,
-  0x0e, 0x97, 0x18, 0xdb, 0xd5, 0x82, 0xbd, 0x78,
-  0xf2, 0x3f, 0x5e, 0xa1, 0x5f, 0x88, 0x88, 0x92,
-  0xfe, 0x5f, 0x5b, 0xe9, 0xda, 0x04, 0xe5, 0x04,
-  0xc2, 0x23, 0xf6, 0x95, 0x49, 0x92, 0x40, 0xfd,
-  0x58, 0x31, 0xbd, 0xc8, 0x83, 0xd2, 0xd4, 0x76,
-  0x21, 0x0a, 0x82, 0x40, 0xf0, 0x21, 0x26, 0x69,
-  0x40, 0x19, 0x12, 0xcb, 0x95, 0x37, 0xd1, 0xc6,
-  0x82, 0xbb, 0x56, 0xab, 0x8d, 0x86, 0xcf, 0xb2,
-  0x83, 0xba, 0x43, 0x53, 0xa6, 0x95, 0x7e, 0x52,
-  0xb6, 0x6e, 0xac, 0x8a, 0xa1, 0x29, 0x38, 0x58,
-  0x77, 0xbe, 0xf2, 0x46, 0x77, 0x65, 0x2c, 0xc8,
-  0xa6, 0xac, 0xba, 0x88, 0x8e, 0xc3, 0x74, 0x5c,
-  0x41, 0x70, 0x20, 0x8f, 0xf6, 0x16, 0x87, 0xc3,
-  0xa4, 0xc6, 0xe1, 0x78, 0x97, 0xef, 0x51, 0x87,
-  0x17, 0xea, 0xc8, 0xe9, 0xc5, 0x04, 0x31, 0xe9,
-  0x68, 0x84, 0xde, 0x26, 0x56, 0x3a, 0xf8, 0xfc,
-  0xb3, 0x8a, 0x12, 0x33, 0xe6, 0x57, 0x43, 0x32,
-  0x6f, 0xd1, 0x0d, 0x6a, 0x8d, 0x83, 0x7e, 0x70,
-  0x1c, 0x7a, 0x26, 0xbe, 0x02, 0x94, 0x03, 0x98,
-  0x6e, 0x6b, 0x0c, 0x0e, 0xdb, 0xdc, 0x44, 0x55,
-  0x80, 0xc0, 0x3c, 0x26, 0x33, 0xf0, 0x41, 0xd6,
-  0xdb, 0x97, 0xc3, 0xa5, 0x77, 0xd7, 0x26, 0xf7,
-  0x6e, 0x79, 0x47, 0x67, 0x78, 0xbe, 0x55, 0xc5,
-  0x41, 0x9d, 0x5a, 0xb0, 0x65, 0x6a, 0x0a, 0xd2,
-  0x0f, 0xfd, 0xe0, 0xe7, 0xc3, 0xa5, 0x00, 0xf1,
-  0x5f, 0xfb, 0xb4, 0xc0, 0x30, 0x4e, 0x3d, 0x6d,
-  0x94, 0xb6, 0x83, 0x2f, 0xf6, 0xed, 0x06, 0x25,
-  0xbb, 0xd0, 0x60, 0xaf, 0xea, 0x64, 0x2b, 0x86,
-  0x9b, 0x68, 0x66, 0x79, 0x91, 0x8f, 0x7c, 0x10,
-  0xd5, 0x8e, 0x73, 0xaa, 0x8b, 0x95, 0x67, 0x54,
-  0x52, 0xd1, 0xeb, 0x5d, 0x9e, 0x42, 0x22, 0xf9,
-  0x73, 0xd0, 0x3d, 0x11, 0xc1, 0x09, 0xa1, 0x15,
-  0x33, 0x7f, 0x99, 0x54, 0x28, 0xdf, 0xb7, 0xcb,
-  0x50, 0x8d, 0xff, 0x0f, 0xad, 0xd7, 0xf3, 0x37,
-  0xed, 0x20, 0xf6, 0x82, 0x3a, 0x80, 0xc8, 0xfe,
-  0x91, 0x1a, 0x0d, 0xa0, 0xa0, 0xc9, 0x20, 0x2a,
-  0xa3, 0x76, 0x64, 0x9d, 0x04, 0x4f, 0x5e, 0x83,
-  0x0c, 0x78, 0xf1, 0x82, 0x70, 0x66, 0x47, 0xd6,
-  0x71, 0x50, 0x8d, 0x06, 0x31, 0x89, 0xd4, 0x05,
-  0x4d, 0x4b, 0xde, 0x03, 0x0a, 0x59, 0x46, 0x04,
-  0x81, 0x2d, 0x38, 0x30, 0xd8, 0x74, 0x3f, 0x64,
-  0x18, 0xa1, 0x33, 0x3f, 0x83, 0x1c, 0xc7, 0x8f,
-  0xd6, 0xf8, 0x49, 0x09, 0x7f, 0xfa, 0x19, 0x99,
-  0xd7, 0x30, 0xd8, 0x41, 0x4a, 0xc2, 0x6e, 0x35,
-  0x3d, 0xac, 0xfe, 0xd2, 0xa6, 0xa1, 0xbb, 0x33,
-  0x3c, 0xe3, 0x7c, 0xc0, 0x60, 0x3f, 0x3c, 0xdc,
-  0x5a, 0x02, 0xa5, 0x26, 0x37, 0x94, 0x11, 0xbb,
-  0xf6, 0xb4, 0x91, 0x1c, 0xc8, 0xe1, 0x60, 0x28,
-  0x04, 0x36, 0x15, 0x2b, 0x0f, 0x23, 0x05, 0xe5,
-  0xcc, 0xe3, 0x6c, 0x36, 0x15, 0x98, 0xbf, 0x07,
-  0x81, 0x81, 0xcd, 0xb0, 0x51, 0xe8, 0x3c, 0x6c,
-  0x01, 0x63, 0xcf, 0xc1, 0x88, 0x7f, 0x75, 0xa1,
-  0x70, 0xe3, 0xe6, 0x4c, 0xb1, 0x4d, 0xaa, 0x4b,
-  0x1a, 0x6b, 0x39, 0x02, 0x9d, 0x31, 0xe8, 0x8c,
-  0x08, 0x21, 0x09, 0x9c, 0xf7, 0x9b, 0x1e, 0xb4,
-  0xab, 0x85, 0xb7, 0xf1, 0x9c, 0xe7, 0x50, 0xe4,
-  0xee, 0xf2, 0x0c, 0x00, 0x58, 0xb9, 0xa4, 0xf1,
-  0xbf, 0xcd, 0x62, 0x2a, 0xf8, 0xe6, 0x8e, 0x65,
-  0x94, 0xb5, 0x4e, 0xcb, 0xcc, 0x2c, 0x34, 0x6c,
-  0x44, 0x88, 0x09, 0xd4, 0x68, 0x1e, 0x02, 0x08,
-  0x32, 0xfe, 0x75, 0x58, 0x43, 0x63, 0xc4, 0x9e,
-  0x4d, 0xbf, 0x17, 0xeb, 0x6c, 0x0c, 0x78, 0x78,
-  0xd2, 0x40, 0x60, 0x0e, 0x2e, 0x4d, 0xfb, 0xa0,
-  0xc1, 0xf8, 0xee, 0x56, 0x8a, 0xee, 0xaa, 0x6f,
-  0xc9, 0x29, 0x4e, 0x07, 0x8d, 0xac, 0x1b, 0x96,
-  0x9c, 0x2b, 0x13, 0xe7, 0x78, 0xba, 0xe8, 0x79,
-  0xb6, 0x40, 0x71, 0xdd, 0x34, 0x1b, 0x4c, 0x9e,
-  0x5e, 0xa9, 0x53, 0xba, 0xba, 0xc1, 0xd4, 0x81,
-  0xc0, 0x15, 0x51, 0x50, 0xed, 0xbc, 0xef, 0x24,
-  0x3c, 0x2b, 0xba, 0x39, 0x2a, 0xef, 0x27, 0xa7,
-  0x2f, 0x27, 0x7b, 0x62, 0x3a, 0x6d, 0x70, 0xdf,
-  0x86, 0xcf, 0x16, 0xf0, 0x18, 0x63, 0xf8, 0xd6,
-  0x37, 0xb6, 0x4b, 0x23, 0x6a, 0xdb, 0x6d, 0xbb,
-  0x7f, 0x9c, 0x5b, 0x79, 0x24, 0xe5, 0xe9, 0xae,
-  0x22, 0xa7, 0x6c, 0x3e, 0x4b, 0x36, 0x58, 0xa3,
-  0xd8, 0xcb, 0x15, 0x49, 0x6e, 0xef, 0x3b, 0x11,
-  0xac, 0xb4, 0xd5, 0x8d, 0xd0, 0xa5, 0x56, 0x0e,
-  0x65, 0x07, 0x13, 0x54, 0xff, 0xb3, 0x7f, 0x3e,
-  0xa2, 0xee, 0xf0, 0xac, 0xd0, 0xc9, 0x79, 0x87,
-  0xd5, 0x52, 0xa5, 0x49, 0x65, 0x44, 0x55, 0xaa,
-  0x2c, 0x96, 0x1b, 0xe9, 0x36, 0x1f, 0x5c, 0x54,
-  0xdb, 0x7e, 0x6e, 0x8e, 0x7f, 0x99, 0xd9, 0x24,
-  0x51, 0x67, 0xaf, 0x64, 0x2a, 0xbc, 0xbc, 0xff,
-  0x16, 0xe4, 0x40, 0x42, 0x4f, 0x5a, 0x92, 0x29,
-  0x69, 0x15, 0x6f, 0xbb, 0x16, 0xe1, 0xbb, 0xd5,
-  0x39, 0x38, 0xa0, 0x97, 0xa2, 0x65, 0x15, 0xe9,
-  0xa6, 0x59, 0xec, 0x92, 0xed, 0xd5, 0x1b, 0x79,
-  0x2d, 0x51, 0x2f, 0x56, 0x37, 0xbd, 0x24, 0x36,
-  0x52, 0x43, 0x76, 0x28, 0xeb, 0x6a, 0x24, 0x6f,
-  0x79, 0xd0, 0xe4, 0xaa, 0xf3, 0x27, 0x6a, 0xc8,
-  0x91, 0xa2, 0xa6, 0x8e, 0xab, 0x92, 0xb3, 0xed,
-  0xd0, 0xef, 0x11, 0xb4, 0xa0, 0xab, 0x60, 0xcb,
-  0x3a, 0x52, 0xbd, 0x1a, 0xae, 0xc8, 0xe7, 0x56,
-  0x9c, 0x53, 0x85, 0x8a, 0x77, 0x57, 0xcd, 0xa2,
-  0xe5, 0xe1, 0xb3, 0x67, 0xa0, 0x9f, 0x4c, 0xbc,
-  0xda, 0x39, 0xc2, 0xb9, 0x27, 0x11, 0xc3, 0x7a,
-  0xb7, 0x17, 0xec, 0x1a, 0xc7, 0xf7, 0x3c, 0xd4,
-  0xdf, 0xe6, 0x95, 0xf3, 0x25, 0x37, 0xb5, 0x04,
-  0x50, 0xb7, 0x45, 0xc2, 0x72, 0x49, 0xb9, 0xbe,
-  0xb3, 0xeb, 0x6e, 0x64, 0x8a, 0x6d, 0x80, 0xc1,
-  0x9d, 0xe0, 0xc5, 0xf4, 0xad, 0x86, 0xdb, 0x51,
-  0x2d, 0xbf, 0x68, 0xa9, 0x78, 0x83, 0x22, 0x1b,
-  0xab, 0x9b, 0x28, 0x26, 0x36, 0xac, 0x84, 0xe6,
-  0x98, 0x56, 0xf8, 0x84, 0x05, 0xdb, 0x94, 0x71,
-  0x9d, 0xba, 0xdc, 0x5f, 0xcb, 0x2f, 0xbc, 0xd8,
-  0x8e, 0xed, 0x24, 0x51, 0xd5, 0xfa, 0x4e, 0x2f,
-  0x08, 0x5a, 0xc8, 0x96, 0x5c, 0xad, 0x86, 0x36,
-  0xcd, 0x80, 0x60, 0xb7, 0x67, 0x3f, 0xc5, 0x25,
-  0x45, 0x9d, 0x11, 0x26, 0x20, 0xed, 0xe7, 0x7a,
-  0x7c, 0x4e, 0x3d, 0x51, 0x07, 0x29, 0x33, 0xfd,
-  0xad, 0xa3, 0xc5, 0x02, 0x09, 0x62, 0xd9, 0x3a,
-  0x55, 0x66, 0xd9, 0x16, 0x5e, 0x45, 0xad, 0x5d,
-  0xe6, 0xc7, 0x43, 0xcd, 0x1e, 0x36, 0xdf, 0xcb,
-  0x51, 0x4c, 0xf6, 0x60, 0x7b, 0x3b, 0x14, 0xa3,
-  0x8b, 0xf1, 0x4a, 0x0b, 0x3a, 0x54, 0x46, 0x38,
-  0xa7, 0x14, 0x1a, 0xe1, 0x3a, 0xa6, 0xa4, 0x08,
-  0x5f, 0xf3, 0x3d, 0x6b, 0xf6, 0x5c, 0xc2, 0xc5,
-  0x16, 0xdb, 0x69, 0xb5, 0x30, 0xac, 0x0b, 0xaf,
-  0x56, 0xe1, 0x24, 0x3c, 0x2f, 0x69, 0x33, 0x3b,
-  0xbd, 0xd6, 0x14, 0x28, 0x5b, 0x24, 0x9d, 0x46,
-  0xb5, 0x5e, 0xa0, 0xb2, 0x73, 0x51, 0x0d, 0x04,
-  0x6c, 0x0f, 0x38, 0x97, 0xed, 0xcd, 0xaa, 0x55,
-  0xa3, 0xb5, 0x7e, 0x96, 0x22, 0xc1, 0x16, 0x2d,
-  0xd4, 0x7c, 0xe9, 0xd4, 0xd9, 0xf3, 0x63, 0x86,
-  0xfc, 0xd2, 0x82, 0xdd, 0x44, 0x86, 0xf5, 0x05,
-  0xe5, 0x5f, 0x82, 0xe2, 0x47, 0xb9, 0x69, 0xb5,
-  0x03, 0x4d, 0x31, 0xc0, 0x43, 0xa3, 0xb0, 0xfa,
-  0xcb, 0x6b, 0x09, 0x23, 0x3f, 0x6b, 0x72, 0x28,
-  0x97, 0xf2, 0xaf, 0x9c, 0x9c, 0x1b, 0x48, 0xb4,
-  0x8b, 0x1f, 0x3a, 0x0d, 0x15, 0x2b, 0x82, 0x18,
-  0xf9, 0x96, 0x0a, 0xfc, 0x06, 0xf3, 0x3e, 0x89,
-  0x4c, 0x8a, 0x64, 0xaa, 0x43, 0x84, 0x7d, 0x82,
-  0xe3, 0xa2, 0xc5, 0x62, 0x32, 0x51, 0xda, 0xa1,
-  0xc0, 0xe0, 0xac, 0x73, 0x91, 0x9b, 0xfe, 0x49,
-  0x9a, 0xc7, 0x43, 0xd9, 0x32, 0xd0, 0x2f, 0x2a,
-  0x25, 0xa8, 0x99, 0x22, 0xe5, 0x4d, 0x08, 0xcc,
-  0xa4, 0xf4, 0x6a, 0x34, 0x1f, 0x8f, 0xd8, 0x5f,
-  0x8a, 0x57, 0xad, 0xc8, 0x8d, 0x4f, 0x27, 0x50,
-  0x05, 0x12, 0xb6, 0x83, 0x83, 0x35, 0x82, 0x2d,
-  0x30, 0x89, 0x78, 0x68, 0x5c, 0x09, 0x95, 0xd1,
-  0x90, 0x38, 0x17, 0xb6, 0x88, 0xa0, 0x1c, 0x30,
-  0x0a, 0x6c, 0x94, 0x16, 0x20, 0xb0, 0x0a, 0x8f,
-  0x0c, 0xc9, 0xaa, 0xe6, 0x84, 0x82, 0xff, 0x6a,
-  0x25, 0xc1, 0x1c, 0x1c, 0xbc, 0x05, 0xc1, 0x61,
-  0xeb, 0x63, 0xce, 0x2b, 0x1e, 0x2a, 0x4b, 0x04,
-  0x7c, 0x61, 0x9f, 0x8e, 0x99, 0xfd, 0x49, 0xa0,
-  0x78, 0x43, 0xff, 0xb2, 0xe1, 0x5f, 0x3d, 0xec,
-  0x06, 0xe8, 0x94, 0xbf, 0x67, 0x43, 0xdb, 0xfc,
-  0xf3, 0x7c, 0xed, 0xc3, 0xf8, 0xa5, 0x11, 0xa0,
-  0x58, 0x04, 0x5e, 0xab, 0x54, 0x99, 0x29, 0x53,
-  0x0a, 0x87, 0xf1, 0x20, 0x78, 0xac, 0x18, 0x3d,
-  0x2e, 0x12, 0xc4, 0x86, 0xd1, 0x28, 0xfc, 0x03,
-  0x71, 0x38, 0xf8, 0x15, 0xb1, 0xad, 0x47, 0x03,
-  0xa6, 0xcc, 0x7d, 0x53, 0x16, 0x94, 0x1d, 0x17,
-  0x22, 0xdf, 0xe3, 0xef, 0x89, 0x77, 0xa3, 0xd6,
-  0x87, 0x98, 0x9b, 0xf7, 0x1a, 0x1f, 0xb3, 0xad,
-  0xb0, 0x5c, 0x23, 0x24, 0x4e, 0xca, 0x46, 0x13,
-  0xeb, 0x71, 0xaa, 0x23, 0x46, 0x5a, 0xf8, 0x93,
-  0xf6, 0x37, 0xf7, 0x26, 0x82, 0xb5, 0x3b, 0x7d,
-  0xf4, 0xf5, 0xc9, 0x98, 0x01, 0x65, 0xb5, 0x50,
-  0xf5, 0x4d, 0xcf, 0x36, 0xad, 0xb1, 0xd4, 0xff,
-  0x9b, 0x4c, 0xc7, 0xef, 0x80, 0xcb, 0x0a, 0xd3,
-  0x2b, 0xf3, 0x6c, 0x7f, 0x22, 0xd7, 0x2e, 0x01,
-  0x5f, 0x59, 0xb9, 0x2c, 0xbf, 0xf6, 0xc8, 0xf3,
-  0xd1, 0x85, 0x40, 0x7d, 0x30, 0x06, 0x08, 0x0c,
-  0xb5, 0x78, 0xc0, 0x2a, 0xc4, 0xb4, 0xad, 0x80,
-  0x69, 0x7a, 0x95, 0x69, 0xc7, 0xa9, 0xd4, 0x33,
-  0x57, 0xf1, 0x74, 0x12, 0xfc, 0xd3, 0x4d, 0x62,
-  0x96, 0x94, 0xef, 0x44, 0x81, 0xbd, 0x1b, 0x78,
-  0xc0, 0xb9, 0x20, 0xf8, 0x79, 0x07, 0x89, 0xc4,
-  0x06, 0x87, 0xc9, 0x32, 0xf1, 0xa6, 0x1b, 0xd4,
-  0x81, 0x01, 0x5c, 0x54, 0xad, 0x9f, 0xd0, 0x61,
-  0x04, 0x77, 0xf9, 0x32, 0xcd, 0x69, 0xb4, 0xac,
-  0x78, 0x72, 0x94, 0x40, 0x4d, 0xee, 0xa9, 0xb3,
-  0xc9, 0x98, 0xda, 0xd9, 0x91, 0x8f, 0x2e, 0xa4,
-  0x18, 0x07, 0xd9, 0xc8, 0x03, 0xc9, 0x45, 0x38,
-  0x38, 0x89, 0xff, 0xb3, 0x57, 0x69, 0x46, 0x37,
-  0x37, 0xcd, 0xb5, 0xf5, 0x4c, 0xf7, 0x92, 0xa7,
-  0x48, 0xad, 0xa9, 0x57, 0x93, 0x7b, 0xef, 0xae,
-  0x59, 0xf6, 0xb6, 0x15, 0xca, 0x22, 0x3e, 0x58,
-  0x65, 0x26, 0x4a, 0x39, 0xf0, 0xf4, 0x4a, 0x4a,
-  0xd4, 0xff, 0x8a, 0x94, 0x75, 0x9f, 0x29, 0xf5,
-  0xdf, 0x36, 0xa3, 0x6e, 0x07, 0xbe, 0xec, 0x2d,
-  0xcf, 0xc9, 0xb7, 0xb1, 0x6e, 0xf5, 0xc1, 0x88,
-  0x43, 0xf1, 0x7f, 0x81, 0xc0, 0xa4, 0x04, 0x50,
-  0x6e, 0x16, 0x7c, 0x3f, 0x05, 0x58, 0x30, 0xe4,
-  0x7a, 0x0e, 0x05, 0x58, 0x30, 0x29, 0xc1, 0x8b,
-  0x4b, 0x01, 0x4c, 0x0c, 0xa4, 0x18, 0x41, 0x10,
-  0x41, 0x10, 0x18, 0x6c, 0xa4, 0x3f, 0x02, 0xe0,
-  0xaa, 0x06, 0x0e, 0x41, 0xf0, 0x7f, 0xed, 0x0b,
-  0x69, 0x44, 0xb4, 0xe5, 0xcd, 0x5c, 0x1f, 0xb4,
-  0x3f, 0xd5, 0x7c, 0x6d, 0xa2, 0xf6, 0x8b, 0xc4,
-  0x88, 0x24, 0x2b, 0x4f, 0xac, 0xec, 0xff, 0xc7,
-  0x20, 0x64, 0x78, 0xa9, 0x20, 0x32, 0x96, 0x1b,
-  0x8a, 0xfc, 0xac, 0xaf, 0xf5, 0xac, 0x6f, 0x14,
-  0xe5, 0x6d, 0xa6, 0xcc, 0x45, 0x19, 0x2a, 0xe8,
-  0xd0, 0x12, 0x9f, 0xc1, 0xe9, 0xa0, 0x03, 0xe0,
-  0x52, 0x9a, 0x82, 0x27, 0xb7, 0x7e, 0x3e, 0xbd,
-  0x60, 0xb5, 0xb5, 0x65, 0xcc, 0xf4, 0x42, 0xec,
-  0xbb, 0x3f, 0xf4, 0x89, 0x55, 0xef, 0x41, 0x55,
-  0x14, 0x03, 0x23, 0x65, 0xb5, 0xae, 0x33, 0xdd,
-  0xe1, 0x87, 0x9b, 0xe6, 0xfa, 0x20, 0x27, 0x1f,
-  0x27, 0x98, 0xa2, 0x6d, 0x2e, 0x2f, 0x48, 0x3f,
-  0x51, 0xde, 0xdc, 0x8d, 0xd4, 0xcd, 0xb6, 0x58,
-  0xa5, 0x46, 0xdc, 0x2d, 0xe1, 0x69, 0x67, 0xf8,
-  0x36, 0xa7, 0x87, 0x23, 0xf9, 0x41, 0xe0, 0x60,
-  0x43, 0x05, 0x14, 0x03, 0x05, 0x9d, 0x08, 0x00,
-  0x8a, 0x08, 0xb5, 0x38, 0x2a, 0x80, 0xd6, 0xab,
-  0x10, 0xe8, 0x3c, 0x17, 0xfd, 0x34, 0xb8, 0x15,
-  0xa0, 0xaa, 0x8a, 0xc0, 0xd4, 0x6d, 0x42, 0xea,
-  0x47, 0x0a, 0x03, 0xd0, 0xb1, 0x29, 0xed, 0x06,
-  0xe9, 0x7b, 0x6a, 0x9b, 0x06, 0x62, 0x27, 0xf0,
-  0x28, 0x84, 0x3c, 0x10, 0x01, 0x84, 0xa0, 0x62,
-  0xd5, 0x0d, 0xeb, 0x2c, 0x37, 0x07, 0x9f, 0x57,
-  0x73, 0xc0, 0xc2, 0x00, 0x7e, 0xc0, 0xec, 0x71,
-  0x55, 0x4c, 0x67, 0xc3, 0xfa, 0xcd, 0x4c, 0x38,
-  0xf3, 0x3f, 0x85, 0xd0, 0xc5, 0xba, 0x80, 0xf4,
-  0x4d, 0x3f, 0x56, 0x9b, 0x64, 0x40, 0xc2, 0xf1,
-  0xd6, 0xab, 0xed, 0xca, 0x93, 0x04, 0xb1, 0xf6,
-  0x97, 0xf7, 0x03, 0xbf, 0x52, 0xec, 0x57, 0x53,
-  0xcd, 0xf2, 0x8a, 0x5b, 0xea, 0xd2, 0x9c, 0x51,
-  0xaa, 0x64, 0xe3, 0xd4, 0x08, 0x25, 0xe5, 0xc2,
-  0x56, 0x84, 0x2c, 0x6f, 0xe5, 0xdd, 0x56, 0x24,
-  0x97, 0x24, 0x6f, 0x13, 0xa7, 0x9e, 0xd6, 0x07,
-  0xca, 0xc3, 0xf1, 0xc8, 0xef, 0x32, 0x2b, 0xf5,
-  0x98, 0xab, 0x5a, 0xcc, 0x0f, 0xd9, 0x9f, 0x1f,
-  0x78, 0xae, 0x7f, 0x2e, 0xf0, 0x2c, 0x61, 0x08,
-  0x1e, 0x06, 0x04, 0x10, 0x53, 0x01, 0xe0, 0xfc,
-  0x18, 0xb0, 0x6c, 0x5c, 0xa0, 0x3e, 0x1c, 0xd0,
-  0x3b, 0x40, 0xf9, 0x65, 0x53, 0xd0, 0x61, 0x00,
-  0x1e, 0x0b, 0xfc, 0xf9, 0x41, 0x56, 0x20, 0x88,
-  0x0a, 0x41, 0x80, 0xc7, 0x40, 0xd0, 0xe0, 0x3c,
-  0x07, 0xc1, 0x80, 0x54, 0x46, 0x0c, 0xad, 0x30,
-  0xf0, 0x1e, 0x0a, 0x02, 0xf4, 0xe3, 0xf6, 0x87,
-  0xdc, 0x07, 0x81, 0xff, 0x1c, 0x48, 0x61, 0x5a,
-  0xb4, 0xbe, 0x63, 0x80, 0xaa, 0x50, 0x3f, 0xfb,
-  0x2d, 0x7d, 0x96, 0x67, 0x01, 0x55, 0xd0, 0xf7,
-  0xed, 0x6e, 0x87, 0xd6, 0x95, 0xeb, 0x9e, 0xda,
-  0xb2, 0x0e, 0x1a, 0x0c, 0x6c, 0xa7, 0xaa, 0xe1,
-  0x79, 0x84, 0xd9, 0x98, 0x23, 0x09, 0x6d, 0xf2,
-  0x08, 0xbd, 0x68, 0x70, 0x3c, 0x1f, 0xb2, 0x1e,
-  0x71, 0x48, 0x18, 0xef, 0x95, 0x32, 0xc8, 0x79,
-  0xc5, 0x25, 0x43, 0x72, 0xa4, 0x6f, 0x7a, 0x3a,
-  0xb9, 0x55, 0x27, 0xca, 0x5d, 0x55, 0x5b, 0x2c,
-  0x2f, 0x2e, 0xdf, 0x5c, 0xff, 0x92, 0x25, 0x63,
-  0x7f, 0x35, 0x4e, 0x76, 0x8d, 0xf2, 0x9b, 0x99,
-  0xff, 0x7e, 0xf4, 0xb3, 0xe6, 0x03, 0x10, 0x32,
-  0x70, 0x86, 0x0d, 0x85, 0x6a, 0x3a, 0x24, 0xb0,
-  0x99, 0x6a, 0x06, 0xb8, 0x21, 0x02, 0x18, 0x32,
-  0xe9, 0x18, 0xd0, 0x78, 0x48, 0x0a, 0xd2, 0x83,
-  0x15, 0xb0, 0xba, 0x49, 0x67, 0x0b, 0x19, 0x06,
-  0x41, 0xa1, 0x70, 0xe9, 0x57, 0x52, 0xe8, 0x85,
-  0xf6, 0x1b, 0x55, 0x8a, 0xda, 0x10, 0x68, 0x33,
-  0x09, 0x81, 0xe0, 0x7f, 0xb5, 0x04, 0x49, 0xff,
-  0x08, 0x40, 0xaa, 0x6f, 0xa3, 0xcf, 0xb6, 0xac,
-  0x21, 0x2a, 0x1d, 0xab, 0xf9, 0x6d, 0x2c, 0x6f,
-  0xcd, 0xb4, 0x3e, 0xd4, 0x93, 0xfe, 0xf7, 0xd4,
-  0xb2, 0x20, 0x99, 0xbb, 0xd3, 0x4a, 0x78, 0x88,
-  0x1c, 0x41, 0xa6, 0x83, 0x65, 0xc0, 0x7b, 0xc3,
-  0x81, 0xca, 0x41, 0x21, 0x50, 0x82, 0xde, 0x2a,
-  0x68, 0xb7, 0xc9, 0xbc, 0x1f, 0xab, 0xfa, 0xde,
-  0x55, 0xe2, 0xde, 0x0e, 0x59, 0xff, 0x2a, 0x86,
-  0xb3, 0xbf, 0xd5, 0x15, 0x44, 0x59, 0xe6, 0x6d,
-  0x06, 0x60, 0xab, 0x07, 0x20, 0xa0, 0x95, 0xb0,
-  0x2d, 0x04, 0x11, 0x28, 0xb5, 0x92, 0xbd, 0x68,
-  0x0c, 0x42, 0xde, 0xb6, 0x06, 0x73, 0x5a, 0x2a,
-  0x5c, 0x73, 0x9b, 0xe0, 0xee, 0x58, 0xe0, 0xb8,
-  0x07, 0x40, 0xf8, 0x42, 0x1d, 0xb2, 0x0c, 0x5c,
-  0xc0, 0xf8, 0x7a, 0x98, 0xbd, 0xbf, 0x83, 0x2b,
-  0x03, 0xc5, 0xf1, 0xa5, 0x5f, 0x9f, 0xdc, 0x63,
-  0x2f, 0xfb, 0xac, 0xe6, 0x2e, 0x9b, 0x65, 0x4e,
-  0xd0, 0x18, 0x4e, 0x58, 0xdd, 0xa5, 0xb2, 0x67,
-  0x5a, 0x6c, 0x05, 0x1e, 0x06, 0x60, 0x1b, 0x00,
-  0xf0, 0xec, 0x14, 0x1f, 0x4e, 0x9d, 0x24, 0x56,
-  0xc8, 0x43, 0x64, 0x7e, 0x5a, 0xaf, 0x66, 0x6b,
-  0x6a, 0xb1, 0x84, 0xec, 0xb1, 0xe0, 0x55, 0x6d,
-  0xf5, 0x03, 0x56, 0x70, 0x73, 0x77, 0x3b, 0x7f,
-  0xf5, 0x9b, 0x2d, 0x62, 0x40, 0x18, 0x6a, 0xf5,
-  0x1f, 0xc5, 0xf7, 0xa3, 0x2e, 0x3f, 0x5c, 0x98,
-  0x42, 0x08, 0x21, 0x09, 0x60, 0x78, 0x3f, 0xf8,
-  0x47, 0x43, 0xf6, 0xa9, 0x27, 0x0a, 0x1e, 0x33,
-  0x03, 0xea, 0xfc, 0x08, 0x61, 0x08, 0x7d, 0xa5,
-  0xc9, 0xe6, 0xcd, 0xce, 0x7d, 0x81, 0xfb, 0x43,
-  0xd1, 0xf8, 0x90, 0x3c, 0xaa, 0xaf, 0x53, 0x96,
-  0x42, 0xfa, 0x98, 0xbc, 0x3c, 0x8c, 0x2f, 0xd2,
-  0xc8, 0xa5, 0xaf, 0xa9, 0x93, 0xf9, 0x6b, 0x82,
-  0x58, 0x28, 0xc0, 0xf8, 0xfd, 0x85, 0x4a, 0x95,
-  0x0e, 0x59, 0xfe, 0xee, 0x16, 0xab, 0x6e, 0x30,
-  0xc3, 0x4c, 0x4f, 0xb3, 0xfe, 0x37, 0xfe, 0x4d,
-  0xcf, 0x66, 0x4d, 0x6f, 0x79, 0xfb, 0xc9, 0xc8,
-  0xbf, 0x21, 0xc3, 0x03, 0xdf, 0x84, 0x0a, 0xc0,
-  0xe5, 0x28, 0xf8, 0x0e, 0x8e, 0x83, 0xff, 0xcf,
-  0x27, 0x2f, 0x54, 0xb8, 0xe5, 0x52, 0xae, 0xf9,
-  0xb9, 0x37, 0x1b, 0x97, 0x62, 0x8f, 0x29, 0x96,
-  0xe6, 0xac, 0x6e, 0x1c, 0xb6, 0xde, 0x21, 0xe4,
-  0x34, 0xed, 0x71, 0x9b, 0x69, 0xfe, 0xac, 0x4a,
-  0x4a, 0x07, 0x55, 0x2b, 0x08, 0x42, 0x1a, 0x46,
-  0xe2, 0x51, 0x08, 0x7a, 0x21, 0x7c, 0x0e, 0x68,
-  0x34, 0x11, 0x92, 0xd5, 0x6c, 0xf9, 0xa5, 0x4a,
-  0x75, 0x52, 0x56, 0x04, 0x11, 0xfb, 0x55, 0x16,
-  0xa8, 0xd5, 0x7e, 0xb8, 0x38, 0x93, 0x7f, 0xbb,
-  0xa0, 0xb2, 0x28, 0xd0, 0x33, 0x62, 0x58, 0x94,
-  0x9c, 0x78, 0x3f, 0x48, 0xa8, 0x4a, 0xa2, 0x1a,
-  0x96, 0xb0, 0xb1, 0x52, 0x42, 0xf5, 0x49, 0xfd,
-  0x36, 0x66, 0xea, 0xfe, 0x9e, 0x6f, 0xdb, 0x93,
-  0x79, 0x6a, 0x25, 0xd7, 0xe3, 0xec, 0x03, 0x5b,
-  0x1f, 0x0f, 0x47, 0x63, 0xe1, 0xf4, 0x1d, 0x0f,
-  0x00, 0xe8, 0xf9, 0xaf, 0x26, 0x4e, 0xca, 0x7a,
-  0x94, 0x7a, 0xc1, 0x77, 0xd5, 0x07, 0xdf, 0xd2,
-  0xdf, 0x56, 0x9b, 0xfa, 0x5c, 0x61, 0x99, 0x65,
-  0x6b, 0xc0, 0x65, 0x82, 0xbf, 0xa9, 0xa3, 0x89,
-  0x02, 0xd4, 0xc2, 0x06, 0x0e, 0x80, 0x31, 0xa0,
-  0x78, 0x2f, 0xf9, 0x44, 0x06, 0x18, 0x9b, 0x7e,
-  0xac, 0x1e, 0x0b, 0xfd, 0x9f, 0x82, 0x85, 0x91,
-  0x28, 0x18, 0x38, 0xf7, 0x04, 0x28, 0x23, 0xe8,
-  0x30, 0x18, 0x10, 0x18, 0x51, 0xec, 0xe0, 0x2b,
-  0x27, 0xc5, 0x7d, 0x51, 0xde, 0x75, 0x74, 0x27,
-  0xb5, 0xc1, 0x66, 0xc0, 0x8e, 0x10, 0xcb, 0xd2,
-  0x83, 0x32, 0x21, 0x26, 0x12, 0x07, 0xf1, 0x37,
-  0xbe, 0xaf, 0x52, 0x44, 0xcd, 0x40, 0x6c, 0x12,
-  0xfb, 0xcc, 0xef, 0x03, 0xfb, 0x90, 0x21, 0xa4,
-  0xef, 0x74, 0x18, 0xd2, 0x9b, 0x3c, 0x22, 0x1f,
-  0x14, 0x01, 0xe0, 0x51, 0x62, 0x66, 0x52, 0x40,
-  0x3b, 0xa2, 0x4e, 0x09, 0x5e, 0x05, 0x3f, 0xc7,
-  0xc0, 0xa7, 0xcb, 0x47, 0x20, 0xaa, 0x8c, 0x8e,
-  0x14, 0xf0, 0xb7, 0xa3, 0x80, 0x23, 0xc2, 0xc0,
-  0xe7, 0x87, 0xcd, 0x24, 0x6c, 0x49, 0x03, 0x82,
-  0x18, 0x31, 0x5e, 0x17, 0xc6, 0x9a, 0xbc, 0x60,
-  0x1e, 0x0b, 0xfd, 0xb1, 0x28, 0x10, 0xc2, 0x13,
-  0x5f, 0xa3, 0x75, 0x05, 0x8d, 0x89, 0x25, 0xc5,
-  0x5b, 0xf5, 0x0a, 0x78, 0x05, 0xbe, 0xf2, 0x1a,
-  0xca, 0x86, 0x80, 0xc7, 0x9a, 0x55, 0xe9, 0x33,
-  0xde, 0x2b, 0xfe, 0xff, 0x74, 0x45, 0xdb, 0x77,
-  0x76, 0x95, 0xdf, 0xff, 0x6d, 0xaf, 0x35, 0x8f,
-  0x79, 0x01, 0x64, 0x91, 0x10, 0xcc, 0x55, 0xae,
-  0x68, 0x14, 0x00, 0xcd, 0x0f, 0x19, 0x56, 0x56,
-  0x39, 0xc6, 0x2e, 0x79, 0xa6, 0xb5, 0x70, 0xe6,
-  0x90, 0x6a, 0x0c, 0xb2, 0xa9, 0x3d, 0xde, 0x16,
-  0xb6, 0xdf, 0xf5, 0x44, 0x59, 0x4d, 0xdb, 0xd7,
-  0xc7, 0xd4, 0x06, 0xd0, 0x07, 0x03, 0x97, 0x3f,
-  0xa1, 0xa4, 0x48, 0x81, 0xc7, 0x5a, 0x1b, 0x0f,
-  0x6d, 0x33, 0xa6, 0x2d, 0xf0, 0xe8, 0xb9, 0x8e,
-  0x0e, 0x13, 0x30, 0xd4, 0x35, 0xe6, 0xbd, 0x81,
-  0x91, 0x84, 0x0b, 0x32, 0x2c, 0x2f, 0x09, 0x9d,
-  0x9d, 0x3f, 0xe5, 0x34, 0x11, 0xce, 0x62, 0x19,
-  0xd2, 0x9e, 0x3f, 0x4e, 0x78, 0x0e, 0x25, 0x19,
-  0x11, 0xf5, 0x00, 0x3c, 0x94, 0x23, 0xdc, 0x07,
-  0x23, 0x39, 0x91, 0xa3, 0xe1, 0xe5, 0x02, 0x43,
-  0x4d, 0x3f, 0x51, 0x82, 0xc4, 0x1c, 0x2e, 0xeb,
-  0xcf, 0xc1, 0xf3, 0x0d, 0x27, 0xb9, 0x93, 0x74,
-  0x73, 0x37, 0x6d, 0xd0, 0x33, 0x9e, 0xea, 0x39,
-  0x14, 0xa2, 0xea, 0x22, 0xce, 0x73, 0x88, 0x88,
-  0x54, 0xa8, 0xc4, 0xc2, 0xd5, 0x0b, 0x2c, 0x37,
-  0xe2, 0xdd, 0x88, 0x44, 0xc6, 0xc1, 0x5d, 0x5c,
-  0xae, 0xec, 0xa8, 0xd4, 0x44, 0x1c, 0xaa, 0x3b,
-  0xd5, 0x90, 0x20, 0x9d, 0x43, 0xc3, 0x83, 0x71,
-  0xea, 0x82, 0xf6, 0xc4, 0x0b, 0x1a, 0xff, 0x40,
-  0x87, 0xd8, 0x0f, 0x66, 0xf3, 0xf2, 0x72, 0x6a,
-  0xd6, 0x11, 0xad, 0xef, 0xd9, 0xa0, 0xc1, 0xef,
-  0xe1, 0x59, 0x56, 0x77, 0x95, 0x44, 0x88, 0x44,
-  0x5e, 0xf2, 0x22, 0xea, 0xce, 0x15, 0x26, 0xf6,
-  0x24, 0x9b, 0xb9, 0xb7, 0xa8, 0x54, 0xd6, 0x65,
-  0xbc, 0xe2, 0xd1, 0x6f, 0x4e, 0x45, 0x90, 0x8c,
-  0xce, 0xf6, 0x23, 0x8b, 0xc3, 0x43, 0x5a, 0x9a,
-  0xde, 0xe2, 0x82, 0xd0, 0xfb, 0xed, 0xb2, 0x1e,
-  0x41, 0xc2, 0x05, 0x08, 0x06, 0xd7, 0x54, 0xf1,
-  0x1c, 0x95, 0x71, 0x41, 0x4a, 0xd3, 0x72, 0xc5,
-  0xb9, 0x93, 0x6d, 0xd6, 0xb3, 0xa8, 0xaa, 0xc8,
-  0xed, 0x8b, 0xc5, 0xd6, 0x97, 0x49, 0xd7, 0x9d,
-  0x89, 0xe4, 0x91, 0x69, 0x2c, 0xda, 0xba, 0xd6,
-  0x0d, 0x83, 0xde, 0xc5, 0xc6, 0x26, 0xfa, 0x81,
-  0xe9, 0x56, 0xea, 0x9b, 0x27, 0x36, 0xa3, 0xe7,
-  0x2a, 0xcb, 0x2c, 0x8b, 0xa3, 0x71, 0x99, 0xe5,
-  0x9b, 0xc4, 0x10, 0x33, 0xa1, 0x5c, 0x4d, 0x45,
-  0x62, 0x02, 0xab, 0x93, 0x9f, 0x51, 0x20, 0x77,
-  0xe5, 0x37, 0x72, 0xa0, 0x95, 0x74, 0x5c, 0x5e,
-  0xa9, 0x58, 0x6a, 0x33, 0xfa, 0xbf, 0x0f, 0xf9,
-  0xa9, 0x8b, 0x75, 0xaf, 0x58, 0x5b, 0xcc, 0xfb,
-  0x17, 0x43, 0xd2, 0xae, 0xf9, 0x47, 0xb6, 0x1b,
-  0xde, 0xc5, 0xd1, 0xae, 0x8d, 0xeb, 0x37, 0xe5,
-  0xf3, 0x3e, 0xc2, 0x9f, 0x69, 0x6e, 0xb7, 0xf0,
-  0x21, 0x22, 0x2e, 0x76, 0x49, 0x57, 0x45, 0x56,
-  0x40, 0x8d, 0xe2, 0x54, 0x8a, 0x8b, 0x4b, 0x6c,
-  0x68, 0x70, 0xc2, 0x2f, 0x7b, 0x99, 0x16, 0xef,
-  0x54, 0xc8, 0xa3, 0xa1, 0xea, 0x3e, 0xda, 0xb8,
-  0x56, 0xa5, 0xbc, 0x20, 0xab, 0xa2, 0xaf, 0x27,
-  0xa2, 0xeb, 0xa1, 0x9b, 0x32, 0x4d, 0xa6, 0xf8,
-  0x1c, 0x68, 0x61, 0x45, 0x7a, 0xb3, 0x6b, 0x4d,
-  0x0e, 0x3f, 0xfb, 0xb8, 0x8e, 0x7e, 0xf7, 0x85,
-  0x8b, 0x55, 0x1c, 0xe6, 0x4e, 0x73, 0xbc, 0x8b,
-  0x09, 0x88, 0xfe, 0x37, 0xa5, 0x9d, 0xb6, 0x5b,
-  0x67, 0x38, 0x80, 0xd7, 0x7b, 0xc2, 0x53, 0xae,
-  0x58, 0xb2, 0xd9, 0xb6, 0xae, 0x4b, 0x0d, 0xaf,
-  0x4d, 0x94, 0x3b, 0x5c, 0xfe, 0x9a, 0xb8, 0x90,
-  0x15, 0xbf, 0x56, 0xb6, 0xb7, 0x72, 0x2d, 0x7d,
-  0x65, 0x96, 0x08, 0x90, 0xab, 0xba, 0xa4, 0xd1,
-  0x11, 0x5a, 0x3c, 0xcd, 0x62, 0x59, 0x3e, 0xc4,
-  0xe6, 0xf6, 0xac, 0xa4, 0xae, 0x59, 0xb3, 0xba,
-  0xa7, 0x88, 0xfb, 0x28, 0xde, 0x72, 0x11, 0xd8,
-  0xe3, 0xb2, 0x23, 0x95, 0x05, 0x5a, 0x8c, 0x16,
-  0xea, 0xf0, 0xdc, 0x59, 0x01, 0x3c, 0xff, 0x54,
-  0xe1, 0x65, 0xf5, 0xe5, 0x0f, 0x2d, 0x58, 0x63,
-  0x7b, 0x9c, 0xe3, 0xd9, 0x7a, 0xb1, 0x2f, 0x7b,
-  0x28, 0x4b, 0x13, 0x4d, 0x33, 0x03, 0x86, 0x2f,
-  0xbc, 0x1e, 0xdc, 0x91, 0x1f, 0x7b, 0x79, 0x00,
-  0xae, 0xad, 0xde, 0xf1, 0x18, 0x50, 0x4d, 0x80,
-  0x33, 0x9d, 0xb9, 0xca, 0x50, 0x8f, 0x84, 0xab,
-  0xf0, 0x99, 0x55, 0x73, 0x73, 0xdc, 0x6b, 0x2e,
-  0x7f, 0x9c, 0x9f, 0x11, 0x20, 0x2b, 0xe2, 0x95,
-  0xc9, 0xa1, 0xab, 0x24, 0x93, 0xb0, 0xd1, 0x51,
-  0x52, 0x05, 0xd6, 0x0c, 0x5f, 0x78, 0x4b, 0x4f,
-  0xd4, 0xc4, 0x6a, 0x92, 0xfa, 0x6b, 0x6a, 0x76,
-  0xf4, 0x73, 0x62, 0x8e, 0x6a, 0xca, 0x16, 0x43,
-  0x06, 0xd3, 0xa8, 0xc2, 0x9b, 0xb0, 0x72, 0xca,
-  0xa9, 0xf8, 0xb4, 0x1f, 0xb0, 0xdf, 0xba, 0x49,
-  0xb3, 0x96, 0x0d, 0xd1, 0x2e, 0x68, 0x4e, 0x83,
-  0x10, 0x41, 0xad, 0xb7, 0x36, 0xde, 0xb7, 0xce,
-  0xf0, 0xb7, 0x16, 0x5a, 0xe2, 0xd7, 0x96, 0x0a,
-  0xcb, 0xe2, 0xac, 0xeb, 0x05, 0x57, 0x91, 0x99,
-  0x78, 0x8f, 0x8b, 0xf7, 0x16, 0x5f, 0x90, 0x28,
-  0x5b, 0x6b, 0xa2, 0xee, 0xf7, 0xa0, 0xf5, 0x30,
-  0x01, 0x84, 0xbd, 0x05, 0xe0, 0x3a, 0x1b, 0x04,
-  0xd5, 0x56, 0xd3, 0x61, 0x8c, 0xa0, 0xe0, 0x1e,
-  0x72, 0xa9, 0xf9, 0x10, 0x1f, 0xd3, 0xa3, 0x68,
-  0xca, 0x11, 0x1d, 0x2c, 0xa6, 0x9a, 0x88, 0xae,
-  0x29, 0xe7, 0xaf, 0xfd, 0x3f, 0xc1, 0xce, 0x7b,
-  0xfc, 0x53, 0xec, 0x6f, 0x90, 0x41, 0xcc, 0xb3,
-  0x19, 0xe6, 0x0e, 0x66, 0xa8, 0x73, 0x52, 0xb1,
-  0xa4, 0x20, 0xe4, 0x47, 0x0c, 0xb4, 0xad, 0x9b,
-  0xf6, 0x73, 0xe9, 0xae, 0x7b, 0x2c, 0x2c, 0xf9,
-  0x6c, 0x05, 0x6c, 0x0e, 0x54, 0x41, 0xb5, 0xe8,
-  0xc5, 0x18, 0xa9, 0x4a, 0x81, 0xc2, 0x8a, 0x98,
-  0xaa, 0xf2, 0xce, 0x7f, 0xde, 0xff, 0xaa, 0x36,
-  0x99, 0xf7, 0x99, 0x6b, 0x79, 0x7a, 0x56, 0xc3,
-  0x33, 0x5a, 0xde, 0x6c, 0x9b, 0x14, 0xe5, 0xe6,
-  0xe6, 0x68, 0xdf, 0x23, 0xde, 0xef, 0x57, 0xed,
-  0xb6, 0xdb, 0xd4, 0x3d, 0xb4, 0x96, 0xa1, 0xb4,
-  0x8d, 0x05, 0x24, 0x80, 0xe2, 0x51, 0xaf, 0xe8,
-  0x3f, 0x7c, 0x00, 0x72, 0x13, 0xc6, 0xc2, 0xd0,
-  0x2b, 0x26, 0x8e, 0x74, 0x7c, 0x3c, 0xd6, 0x62,
-  0x8b, 0x15, 0xfc, 0x74, 0x3c, 0xfa, 0x59, 0x73,
-  0x85, 0x97, 0x13, 0xfd, 0x35, 0x57, 0x2b, 0x53,
-  0x24, 0x6a, 0x96, 0xf5, 0xa5, 0x12, 0x7a, 0xe2,
-  0x88, 0x79, 0x54, 0xe9, 0x07, 0x83, 0xf5, 0x10,
-  0x7e, 0x93, 0xc9, 0x7d, 0x2a, 0x9e, 0x37, 0xaa,
-  0xfd, 0x4b, 0x78, 0x37, 0x2d, 0x61, 0xb6, 0x1b,
-  0x29, 0x0f, 0x54, 0x7d, 0x6b, 0xf9, 0xa5, 0x98,
-  0x7a, 0xaf, 0x41, 0x63, 0xd0, 0xc0, 0xeb, 0x19,
-  0x83, 0x81, 0x3a, 0xd9, 0x06, 0x24, 0xaf, 0xa3,
-  0x44, 0xc4, 0x9b, 0xca, 0x37, 0xcc, 0x2c, 0x51,
-  0x22, 0x8a, 0xd6, 0x56, 0x0b, 0x24, 0x92, 0x35,
-  0x58, 0xb0, 0x70, 0x20, 0x4c, 0xc9, 0xe8, 0xc1,
-  0x60, 0xe0, 0xb2, 0x4f, 0x28, 0x51, 0x0f, 0x29,
-  0x31, 0xa9, 0xd8, 0xa9, 0xa4, 0xc9, 0xa6, 0xf3,
-  0xb8, 0x3e, 0x1e, 0x24, 0x2e, 0x9b, 0x73, 0xaa,
-  0x2b, 0x70, 0xb9, 0x86, 0x87, 0x3b, 0x93, 0x7f,
-  0x30, 0xb5, 0x4a, 0x82, 0xdf, 0xa8, 0xe2, 0x9a,
-  0x7c, 0xcf, 0x4f, 0x7e, 0x9b, 0x2b, 0x19, 0x05,
-  0x5a, 0x8c, 0x24, 0x07, 0x12, 0x91, 0xe9, 0x8b,
-  0x44, 0x84, 0x93, 0x47, 0x29, 0xd8, 0x1f, 0x09,
-  0x54, 0x77, 0x36, 0x96, 0x27, 0x06, 0x50, 0x3e,
-  0xf2, 0x59, 0xff, 0x87, 0x6c, 0xfd, 0x2e, 0x35,
-  0x89, 0xef, 0xea, 0x9d, 0x2d, 0xbb, 0xf5, 0x2d,
-  0xaf, 0x2d, 0xbd, 0x78, 0x95, 0x38, 0xe1, 0xb4,
-  0xda, 0xc7, 0xd3, 0x34, 0x3f, 0x53, 0x24, 0xaa,
-  0x93, 0xe3, 0x4c, 0xb1, 0xbf, 0xc1, 0xb5, 0xfb,
-  0x5a, 0xa7, 0x0a, 0xbf, 0x26, 0xaf, 0x2f, 0x2a,
-  0x24, 0x4e, 0x44, 0x4a, 0x49, 0x93, 0x1a, 0xf9,
-  0x6b, 0x79, 0xac, 0xaf, 0xc5, 0x3c, 0xcb, 0xca,
-  0x6e, 0x50, 0x60, 0xa5, 0x3d, 0xf3, 0x78, 0xb3,
-  0x5c, 0x44, 0xa6, 0xfc, 0xd6, 0x8c, 0xba, 0x8c,
-  0x1d, 0x48, 0x06, 0x10, 0x9a, 0x88, 0x10, 0x1e,
-  0xd7, 0xb2, 0xe6, 0xf5, 0xa4, 0xe9, 0x15, 0x09,
-  0x25, 0xed, 0x35, 0x93, 0x75, 0xb6, 0x5a, 0x92,
-  0x22, 0x54, 0xd6, 0x78, 0x93, 0x39, 0xef, 0x01,
-  0x49, 0x92, 0x39, 0x3d, 0x4d, 0xe6, 0x8b, 0xa7,
-  0x8b, 0x92, 0x5b, 0xb3, 0x1a, 0x48, 0x93, 0xcd,
-  0x5e, 0xed, 0xad, 0x7b, 0x22, 0x3d, 0xde, 0xcc,
-  0xdb, 0xb7, 0x7b, 0x6f, 0x24, 0x99, 0x88, 0x0f,
-  0x6f, 0xe1, 0x66, 0x45, 0x3d, 0x02, 0x74, 0xd2,
-  0xc4, 0xa1, 0x57, 0x50, 0x8c, 0x95, 0x11, 0x40,
-  0x2c, 0x45, 0x3c, 0x52, 0x85, 0xfa, 0x6a, 0xb4,
-  0x21, 0x09, 0x0d, 0x72, 0xaa, 0x10, 0x84, 0x85,
-  0x56, 0x7f, 0xcc, 0xe0, 0x80, 0x3a, 0x2e, 0x6a,
-  0xc6, 0x58, 0xe8, 0xe1, 0x9c, 0xbe, 0x6b, 0x38,
-  0xdb, 0x4a, 0x74, 0x70, 0xdc, 0x0f, 0x5a, 0x2d,
-  0xd5, 0x16, 0x29, 0xd3, 0xe5, 0xfc, 0xc3, 0x49,
-  0xb2, 0x34, 0xc3, 0x4d, 0x30, 0xd6, 0x5b, 0x71,
-  0x86, 0x3d, 0x15, 0x7a, 0x5d, 0xbd, 0xfd, 0x9e,
-  0xc9, 0x99, 0x3b, 0x7b, 0xbb, 0x79, 0xdb, 0xb6,
-  0xed, 0x5e, 0x9f, 0x2a, 0x63, 0x5a, 0x2f, 0x25,
-  0x42, 0x14, 0x42, 0x4a, 0x45, 0x13, 0x74, 0xa3,
-  0x87, 0xc4, 0x7b, 0x99, 0xfc, 0xdf, 0x6f, 0xa3,
-  0x7e, 0xfc, 0xb1, 0xbf, 0x7f, 0x33, 0xfe, 0xdf,
-  0x55, 0xae, 0x7f, 0xdf, 0x53, 0x9b, 0x95, 0x0e,
-  0x6f, 0x65, 0x21, 0xba, 0x88, 0x1d, 0xc0, 0x58,
-  0x03, 0x9f, 0x81, 0xcb, 0xd4, 0x60, 0xe2, 0x17,
-  0x18, 0xbe, 0xa6, 0xa2, 0x41, 0x28, 0x74, 0xd1,
-  0x6b, 0x4d, 0x09, 0x43, 0xc5, 0x5e, 0x67, 0x2e,
-  0x2b, 0xf2, 0xa1, 0xe2, 0x65, 0x58, 0xaf, 0x39,
-  0xb1, 0x43, 0x38, 0xc3, 0x59, 0x8c, 0xe7, 0x3f,
-  0xfc, 0xe7, 0xe6, 0xad, 0xfd, 0x82, 0x2b, 0xc5,
-  0xad, 0x7b, 0xde, 0x6a, 0x34, 0xd7, 0xa3, 0x5e,
-  0xcc, 0x99, 0xef, 0x35, 0x26, 0x67, 0xbd, 0x88,
-  0xb3, 0x3d, 0xee, 0x66, 0x64, 0x85, 0x53, 0x24,
-  0xe6, 0x49, 0xc8, 0x79, 0x0f, 0x55, 0xc6, 0x43,
-  0x20, 0x1f, 0x0a, 0x02, 0xad, 0x88, 0x90, 0x84,
-  0x56, 0x94, 0x85, 0x55, 0x1b, 0xe3, 0x0c, 0x7a,
-  0xb7, 0xbe, 0x6b, 0x33, 0x59, 0xd2, 0xd6, 0x77,
-  0xd9, 0x26, 0xb3, 0xfe, 0x70, 0xb5, 0xbb, 0xc9,
-  0x5b, 0xff, 0x39, 0x85, 0xbb, 0xdd, 0x51, 0xc9,
-  0xde, 0x3a, 0x38, 0xb0, 0xcc, 0x1d, 0xc0, 0x4e,
-  0x4c, 0xe3, 0x5b, 0x62, 0x11, 0xae, 0xbe, 0xa8,
-  0x86, 0x2f, 0xce, 0xdd, 0x19, 0x02, 0xc5, 0xee,
-  0xc2, 0x9a, 0x0b, 0x96, 0x95, 0x63, 0x9a, 0xfa,
-  0x83, 0x88, 0x74, 0x07, 0x1f, 0xd1, 0x02, 0x22,
-  0x2a, 0x0c, 0x45, 0xcb, 0x42, 0x64, 0x42, 0x41,
-  0xa7, 0x45, 0x21, 0x44, 0x83, 0x86, 0x03, 0x56,
-  0x80, 0x31, 0x21, 0x7d, 0x59, 0x10, 0x64, 0x19,
-  0x39, 0xd6, 0xe9, 0x1e, 0x9c, 0x5c, 0x44, 0xb1,
-  0x28, 0x39, 0x71, 0x5a, 0x62, 0x78, 0x91, 0x60,
-  0x7f, 0x2f, 0xff, 0xf0, 0x3d, 0x1c, 0x00, 0x60,
-  0xe7, 0x67, 0x74, 0xcb, 0x8c, 0x21, 0x40, 0x2c,
-  0x51, 0x0d, 0x75, 0x88, 0x40, 0x70, 0x38, 0x82,
-  0x01, 0xc6, 0xba, 0x0e, 0x26, 0x68, 0x56, 0x44,
-  0x0e, 0x34, 0xe6, 0x2b, 0x13, 0x69, 0x9a, 0x65,
-  0x85, 0x28, 0x79, 0x10, 0xf0, 0x31, 0x91, 0x61,
-  0x88, 0x54, 0xa2, 0xaf, 0x41, 0xcf, 0xef, 0x7b,
-  0xcb, 0xcb, 0xd9, 0x54, 0xca, 0x22, 0x21, 0x40,
-  0xe2, 0xfa, 0x8a, 0xf2, 0x03, 0x81, 0x72, 0x70,
-  0x41, 0x9a, 0xd5, 0xdc, 0x8d, 0xf2, 0x76, 0x2e,
-  0x55, 0xfb, 0xa8, 0x38, 0x6d, 0x70, 0x74, 0x7a,
-  0x10, 0x54, 0xc5, 0xaa, 0x26, 0xa3, 0x44, 0x0b,
-  0x00, 0x5f, 0x2c, 0xdc, 0xe0, 0x75, 0x11, 0xde,
-  0x44, 0x7c, 0xec, 0x44, 0x75, 0x75, 0x43, 0x9a,
-  0xc5, 0x0f, 0xed, 0xde, 0xed, 0x24, 0xd9, 0x10,
-  0x62, 0xc8, 0xf8, 0x04, 0x56, 0xec, 0x46, 0x42,
-  0x96, 0x15, 0xcb, 0x17, 0x5a, 0xc4, 0x38, 0xb1,
-  0x22, 0xe8, 0xa1, 0x48, 0xc8, 0xe1, 0x92, 0xae,
-  0x09, 0xd1, 0x34, 0xf3, 0x03, 0x9b, 0xd1, 0xb7,
-  0x22, 0x05, 0x89, 0x29, 0x0e, 0xb9, 0x11, 0xf1,
-  0x12, 0x14, 0x01, 0x8c, 0x0c, 0xa9, 0x3c, 0xcc,
-  0x5e, 0x23, 0xec, 0x28, 0x0a, 0x67, 0x57, 0x36,
-  0x0e, 0x28, 0x39, 0x22, 0x11, 0x71, 0xda, 0xbf,
-  0x91, 0x7d, 0xd2, 0x85, 0xd7, 0x0c, 0xc6, 0x01,
-  0x3d, 0x2b, 0xda, 0xcb, 0x52, 0x23, 0x88, 0x56,
-  0xec, 0xe8, 0xc6, 0x20, 0x44, 0x4f, 0x8a, 0x14,
-  0x12, 0x50, 0xc5, 0x12, 0xe4, 0x4c, 0xa4, 0xe7,
-  0x46, 0x9a, 0x66, 0x72, 0x36, 0xde, 0x8e, 0x7e,
-  0xc9, 0x50, 0x14, 0xf4, 0x5a, 0x12, 0x55, 0xa1,
-  0x5d, 0x24, 0x22, 0x82, 0xc9, 0x51, 0xcb, 0xde,
-  0x02, 0xc0, 0xa7, 0xa2, 0x92, 0x35, 0x44, 0x46,
-  0x85, 0x11, 0x28, 0x30, 0x51, 0xa4, 0x43, 0x41,
-  0x85, 0xe0, 0xe0, 0xae, 0xf5, 0x09, 0x06, 0x99,
-  0x2f, 0x31, 0x99, 0x16, 0xc2, 0xc9, 0xc0, 0xd3,
-  0xa3, 0x28, 0x43, 0xda, 0xbf, 0x9b, 0xe8, 0x1d,
-  0xdb, 0xf5, 0xd0, 0x16, 0x60, 0x67, 0x49, 0x10,
-  0xde, 0x9d, 0x9e, 0x14, 0x8c, 0x51, 0x82, 0xc0,
-  0xd0, 0xa9, 0x55, 0x18, 0x5a, 0xd5, 0xb2, 0xd2,
-  0xb9, 0xcd, 0x59, 0x65, 0xcd, 0xd4, 0x08, 0x14,
-  0x41, 0x83, 0x9c, 0xdd, 0x5d, 0xfa, 0x6b, 0x29,
-  0x05, 0xcb, 0x52, 0x32, 0x07, 0x06, 0x24, 0xe6,
-  0xaf, 0xe9, 0x48, 0xa5, 0x45, 0x3a, 0x48, 0x0e,
-  0x20, 0x5e, 0x70, 0x17, 0xba, 0x75, 0x69, 0x48,
-  0x47, 0x1d, 0x36, 0x0e, 0x17, 0x11, 0x6e, 0xea,
-  0x34, 0x63, 0x35, 0x86, 0x92, 0x5b, 0xa6, 0xa9,
-  0x2c, 0xe8, 0x38, 0x16, 0x02, 0xa5, 0x59, 0xd1,
-  0x75, 0x7b, 0xde, 0x70, 0x1f, 0xbe, 0x00, 0x3f,
-  0xfa, 0xfa, 0xce, 0x9a, 0x90, 0x51, 0xe4, 0xea,
-  0x0c, 0x22, 0x99, 0x57, 0x34, 0x4d, 0x57, 0xa3,
-  0x8f, 0x86, 0xca, 0x0f, 0xdb, 0x6d, 0x37, 0x50,
-  0x4a, 0xe5, 0x5b, 0x6a, 0xd8, 0xbf, 0x65, 0xec,
-  0xd7, 0x2b, 0xb5, 0xff, 0x61, 0xc7, 0xe9, 0x7b,
-  0xd3, 0x96, 0xcc, 0x9c, 0x5a, 0xb7, 0xed, 0x41,
-  0x38, 0x73, 0x46, 0x53, 0x75, 0x6b, 0xfd, 0x30,
-  0xd7, 0x84, 0xaf, 0xd3, 0x32, 0x07, 0x95, 0xfc,
-  0x73, 0x5a, 0x1b, 0xf9, 0x42, 0x99, 0x03, 0x8e,
-  0x10, 0xcc, 0xa0, 0xe1, 0xa0, 0xc4, 0x10, 0x8b,
-  0xf7, 0xe3, 0xdc, 0xf0, 0x7d, 0x71, 0x4e, 0x7e,
-  0x5d, 0xb4, 0x36, 0x14, 0x28, 0x83, 0x03, 0x00,
-  0x58, 0x82, 0xc0, 0xfa, 0x7f, 0x39, 0x51, 0x9e,
-  0x89, 0xbb, 0x20, 0xcd, 0x12, 0x01, 0x3d, 0xaf,
-  0x50, 0x83, 0x85, 0xe8, 0x8a, 0x05, 0x29, 0xaf,
-  0x4e, 0xe8, 0x84, 0x31, 0x08, 0x8c, 0x3f, 0xa7,
-  0x22, 0xf5, 0x88, 0xea, 0x83, 0xba, 0x18, 0x0a,
-  0xf4, 0x92, 0xa1, 0x44, 0x0e, 0x44, 0x12, 0x6a,
-  0x0e, 0x90, 0x1c, 0x7a, 0xa0, 0x21, 0xa9, 0xb5,
-  0xd1, 0x83, 0xba, 0x6d, 0x08, 0x4d, 0xdf, 0x97,
-  0x35, 0x22, 0x30, 0x72, 0x03, 0xbf, 0x88, 0xc0,
-  0x72, 0xe0, 0x38, 0x29, 0x9d, 0x34, 0xbd, 0x0a,
-  0x34, 0xdf, 0x91, 0xf0, 0xa4, 0x53, 0x39, 0x09,
-  0x2a, 0x30, 0x73, 0xdf, 0x91, 0xc4, 0x00, 0xe5,
-  0xa7, 0x01, 0x39, 0xf9, 0x11, 0xa0, 0x8a, 0xbe,
-  0x2f, 0xaa, 0x31, 0x90, 0xcc, 0x31, 0x27, 0xfd,
-  0x34, 0xb1, 0xcf, 0x01, 0xfd, 0x7f, 0xff, 0xd2,
-  0x74, 0xa0, 0x1d, 0x4a, 0x4e, 0x59, 0x0e, 0xe9,
-  0xb4, 0x05, 0x00, 0xe3, 0x44, 0xf8, 0x31, 0x05,
-  0xd3, 0x8b, 0x21, 0x7e, 0x5c, 0x1c, 0x03, 0xc1,
-  0x3d, 0x51, 0x14, 0x0a, 0xea, 0x78, 0xa0, 0x31,
-  0x09, 0x64, 0x1c, 0x12, 0xbe, 0x1b, 0x80, 0xe2,
-  0x0c, 0x8b, 0x84, 0x85, 0x20, 0xb0, 0x09, 0x18,
-  0x28, 0xd3, 0xe0, 0xe4, 0x20, 0xe0, 0x4d, 0xf6,
-  0x9a, 0x07, 0x06, 0x4f, 0x60, 0xe4, 0x46, 0xdf,
-  0xc6, 0x22, 0xe0, 0xc0, 0x28, 0xe2, 0x32, 0x0d,
-  0x3f, 0xde, 0x00, 0xe0, 0x92, 0x01, 0x79, 0x54,
-  0x6e, 0xec, 0xba, 0x02, 0x1a, 0x6c, 0xfc, 0x5f,
-  0x8b, 0xc0, 0x77, 0x4f, 0x4a, 0x03, 0x61, 0x1b,
-  0x50, 0x83, 0x84, 0x5f, 0xa3, 0x31, 0x45, 0xc5,
-  0x81, 0xd4, 0xee, 0x9c, 0xda, 0x48, 0x31, 0xe2,
-  0x32, 0x8a, 0xe2, 0xd2, 0x5b, 0xb7, 0x68, 0xcb,
-  0x0d, 0x12, 0xa2, 0x42, 0x14, 0x65, 0xcd, 0x03,
-  0x83, 0x20, 0x9d, 0x0e, 0x0b, 0x82, 0x96, 0xb4,
-  0x64, 0xed, 0x34, 0xf9, 0xb5, 0x0d, 0x80, 0xfd,
-  0xb0, 0x01, 0xd6, 0x62, 0x8d, 0x5d, 0x1d, 0x29,
-  0xa1, 0x80, 0x66, 0x32, 0x7f, 0xe9, 0xb1, 0x33,
-  0x17, 0x1a, 0x87, 0x59, 0x72, 0x0a, 0xba, 0x7a,
-  0x88, 0x92, 0xf1, 0xf8, 0x31, 0x07, 0x40, 0x8f,
-  0x12, 0xa0, 0x45, 0x3a, 0x88, 0x1c, 0x11, 0x30,
-  0x72, 0xe4, 0x5a, 0x83, 0x61, 0x3c, 0x4e, 0xaa,
-  0x00, 0xc9, 0x19, 0xf6, 0xb0, 0x38, 0x07, 0x04,
-  0x93, 0x46, 0x62, 0x66, 0xb0, 0x2c, 0x08, 0xea,
-  0x95, 0xc1, 0x3f, 0x48, 0x99, 0x3a, 0x8e, 0xf4,
-  0xd2, 0xc0, 0xe0, 0xc4, 0x69, 0x34, 0x1e, 0x82,
-  0x00, 0x30, 0x71, 0x4b, 0xdb, 0x0c, 0x45, 0x29,
-  0xda, 0x4d, 0xa7, 0xf9, 0xde, 0x74, 0x5c, 0x0b,
-  0xa4, 0xfc, 0xa6, 0xfc, 0x3d, 0x51, 0xc9, 0xf0,
-  0xf3, 0x88, 0xcd, 0x4e, 0xd3, 0x60, 0xbb, 0xf3,
-  0xaa, 0x17, 0xe4, 0xa2, 0xe0, 0x71, 0xf8, 0x8b,
-  0x5c, 0x86, 0xa8, 0x3b, 0xa7, 0x64, 0x1a, 0x69,
-  0x8e, 0x01, 0x14, 0x49, 0x41, 0x3c, 0x08, 0xd0,
-  0x18, 0x07, 0xb9, 0x1c, 0x4e, 0x25, 0xd4, 0x71,
-  0x80, 0x7d, 0x8f, 0xff, 0x52, 0xdd, 0x36, 0x14,
-  0xd7, 0x4d, 0x38, 0xba, 0x36, 0x5a, 0x18, 0xa9,
-  0xd2, 0x91, 0xda, 0x1f, 0xb5, 0x90, 0xa1, 0x71,
-  0x7f, 0x48, 0x28, 0x19, 0x7a, 0x8c, 0xbc, 0x61,
-  0xc8, 0x12, 0x7e, 0xae, 0x15, 0x60, 0xc8, 0x4d,
-  0xe6, 0xea, 0x20, 0xc0, 0x13, 0x75, 0xe9, 0x52,
-  0xaf, 0x74, 0x3d, 0xd6, 0x6d, 0xa2, 0xba, 0x69,
-  0x32, 0xa4, 0x77, 0x65, 0x3d, 0x2b, 0x50, 0x75,
-  0x05, 0xd5, 0xee, 0x1f, 0x55, 0xca, 0xd1, 0xbf,
-  0x5e, 0x59, 0xbe, 0x06, 0x24, 0xc3, 0xe9, 0xff,
-  0xeb, 0x20, 0x39, 0x41, 0xda, 0x80, 0x75, 0x07,
-  0x0d, 0x56, 0x02, 0xe7, 0xaf, 0xa0, 0xcc, 0x8b,
-  0x4e, 0x65, 0x91, 0x12, 0xc3, 0x49, 0x52, 0xe7,
-  0x59, 0xa5, 0x01, 0x47, 0x2d, 0x06, 0x14, 0x4e,
-  0x6a, 0x3a, 0x76, 0x2e, 0xbf, 0xfe, 0xd7, 0xc1,
-  0x8d, 0xfa, 0xd4, 0x44, 0x27, 0x3e, 0x5a, 0x25,
-  0xb0, 0xc5, 0x51, 0xd3, 0x54, 0xb2, 0xab, 0xf0,
-  0x3c, 0x64, 0x01, 0xad, 0xb7, 0x8b, 0x85, 0x63,
-  0x16, 0x67, 0x95, 0xc0, 0x64, 0x3e, 0xd9, 0x62,
-  0x14, 0x41, 0x29, 0x6f, 0x5b, 0xc5, 0xba, 0x84,
-  0xd0, 0xc4, 0x2b, 0x4d, 0x8a, 0x01, 0xd2, 0xe0,
-  0x0f, 0x76, 0x9a, 0x02, 0x40, 0xed, 0xa1, 0x2e,
-  0x37, 0x7d, 0x8c, 0xe4, 0xf5, 0x90, 0x15, 0xad,
-  0x6b, 0x48, 0x10, 0x29, 0x40, 0xb1, 0x01, 0x1d,
-  0xc3, 0x5c, 0x07, 0x1f, 0x24, 0xab, 0x4a, 0x90,
-  0x14, 0x82, 0xc0, 0x27, 0x8d, 0x44, 0x18, 0x12,
-  0x05, 0x1a, 0x24, 0x1c, 0x34, 0xbf, 0x42, 0xbd,
-  0x3b, 0x15, 0x6d, 0x07, 0x12, 0x0b, 0x9e, 0xac,
-  0x0c, 0x81, 0xcf, 0xf6, 0x03, 0xd0, 0x40, 0x06,
-  0x30, 0x20, 0x61, 0x4e, 0x9d, 0x8c, 0xf8, 0x26,
-  0x84, 0x43, 0x33, 0x74, 0x1c, 0x0b, 0xec, 0xb9,
-  0x36, 0x41, 0x45, 0x5a, 0x28, 0xb9, 0xcd, 0x3f,
-  0x9d, 0x2d, 0x80, 0xe9, 0x01, 0xc2, 0xfa, 0x34,
-  0xde, 0x07, 0x1b, 0x73, 0xc1, 0xb8, 0xcf, 0xa5,
-  0x23, 0x56, 0xd7, 0x41, 0xc8, 0xf8, 0x14, 0xe7,
-  0x2a, 0xf0, 0x52, 0x0e, 0x0a, 0x3c, 0x43, 0x7a,
-  0x8c, 0x4f, 0x89, 0x41, 0xd4, 0x13, 0x7d, 0xa0,
-  0xe0, 0xc8, 0x89, 0xaa, 0x03, 0xd1, 0x3f, 0x3b,
-  0xd2, 0x40, 0x71, 0xd6, 0x37, 0x01, 0xfc, 0x05,
-  0xd3, 0x84, 0x39, 0x09, 0x03, 0x23, 0xa1, 0x1e,
-  0x9e, 0x19, 0x83, 0x06, 0x41, 0x57, 0x07, 0x0c,
-  0x09, 0x4f, 0x63, 0xfc, 0x66, 0xb8, 0x38, 0xf2,
-  0xf0, 0x17, 0x71, 0x3c, 0x32, 0x0a, 0xba, 0x28,
-  0x81, 0x72, 0x40, 0x5c, 0x35, 0xa9, 0x0b, 0x07,
-  0x02, 0x6a, 0x12, 0x11, 0xe9, 0xea, 0x0e, 0x01,
-  0xe0, 0xb8, 0xe8, 0x81, 0xc2, 0x8d, 0x46, 0x42,
-  0x9c, 0x0f, 0x43, 0xff, 0xff, 0x02, 0x76, 0x22,
-  0xa9, 0xcd, 0x07, 0x52, 0x3e, 0x0e, 0x04, 0xea,
-  0xa0, 0xf3, 0xd0, 0x01, 0x83, 0x88, 0x9a, 0xe8,
-  0xd1, 0x92, 0x03, 0x81, 0x3e, 0xf6, 0x54, 0x5d,
-  0x58, 0x4d, 0x17, 0x66, 0xc3, 0x10, 0x5c, 0xf0,
-  0xcc, 0x1c, 0x12, 0x3a, 0xe9, 0x05, 0x80, 0x54,
-  0xc8, 0xc1, 0xd7, 0xa7, 0xaa, 0xf5, 0xd8, 0x6d,
-  0x68, 0x8a, 0xba, 0x39, 0xc4, 0x08, 0xc8, 0x2c,
-  0x07, 0x83, 0x84, 0xf5, 0x79, 0xa8, 0x45, 0xcb,
-  0x82, 0xc3, 0x83, 0x17, 0xa6, 0x48, 0x48, 0x27,
-  0xd3, 0xc2, 0xe1, 0x3f, 0x07, 0x04, 0xcc, 0x65,
-  0xd0, 0xc8, 0x28, 0xc0, 0xe2, 0x40, 0x5c, 0x5b,
-  0x38, 0x0b, 0xba, 0xbf, 0xa5, 0x72, 0x72, 0xca,
-  0x8d, 0x1a, 0x21, 0x75, 0x8b, 0x13, 0xf2, 0x99,
-  0x67, 0x10, 0x51, 0x81, 0x07, 0x15, 0x60, 0x75,
-  0x58, 0x2a, 0xb6, 0x9e, 0xd3, 0xca, 0x54, 0xc5,
-  0x8a, 0x41, 0xce, 0x65, 0x24, 0x4d, 0x15, 0x45,
-  0xd0, 0xc0, 0x5c, 0x0b, 0xcc, 0xb1, 0xb1, 0x8f,
-  0x20, 0x60, 0x13, 0x34, 0xee, 0x14, 0xbf, 0x5e,
-  0x77, 0x4d, 0x03, 0xa0, 0x2c, 0x42, 0x6d, 0x2d,
-  0xa7, 0x97, 0x2f, 0x98, 0xdb, 0x5c, 0x2d, 0xd5,
-  0xd1, 0x77, 0xa8, 0x2e, 0x5e, 0x73, 0x81, 0x2d,
-  0xef, 0xb1, 0xa5, 0x38, 0x38, 0xb9, 0x56, 0xec,
-  0xd6, 0xb7, 0x64, 0x24, 0x41, 0x6a, 0x2a, 0x71,
-  0x3d, 0x04, 0x5a, 0x28, 0xa9, 0x99, 0xd6, 0x49,
-  0x01, 0xc4, 0x16, 0x20, 0xe8, 0xa0, 0xe5, 0x63,
-  0xe8, 0x53, 0xe9, 0x2f, 0x14, 0x03, 0xb8, 0x35,
-  0xa0, 0x44, 0x82, 0x2f, 0xdb, 0xd8, 0x1b, 0xeb,
-  0xd0, 0x3c, 0x58, 0x3d, 0x19, 0x16, 0x1d, 0xd7,
-  0xb5, 0x1b, 0x60, 0x54, 0xaf, 0xfd, 0xb4, 0x38,
-  0xd7, 0x7a, 0xc2, 0xa0, 0x62, 0x49, 0x2a, 0xf5,
-  0x61, 0x33, 0xfa, 0x25, 0xa7, 0xbc, 0x16, 0x27,
-  0x7d, 0xd4, 0x3f, 0x76, 0xba, 0xbf, 0xcc, 0xb3,
-  0x9d, 0xdc, 0xd9, 0xc3, 0xd5, 0x3e, 0xd2, 0x0b,
-  0xfc, 0xb6, 0x58, 0xe8, 0x80, 0x52, 0x06, 0x07,
-  0xb5, 0xfd, 0x15, 0xb1, 0x6e, 0x5e, 0xf4, 0xb3,
-  0x76, 0x0a, 0xb5, 0xea, 0xfe, 0x4f, 0xd9, 0xe1,
-  0xc2, 0x76, 0xbb, 0x02, 0xd9, 0x1e, 0x0f, 0x77,
-  0xab, 0x4f, 0x79, 0xb5, 0x8c, 0xd2, 0xdc, 0x42,
-  0x27, 0xef, 0xf5, 0x4e, 0x60, 0x31, 0xa9, 0x4d,
-  0x54, 0x47, 0xf5, 0xdb, 0x4d, 0x25, 0xec, 0xee,
-  0x7d, 0x56, 0x5b, 0x78, 0x2b, 0xd1, 0x25, 0xc4,
-  0x75, 0x96, 0xf9, 0xc8, 0x08, 0xce, 0xfb, 0x9f,
-  0xe2, 0xf3, 0x1f, 0x6d, 0xb5, 0xb6, 0x21, 0x95,
-  0x01, 0xf4, 0xca, 0x8a, 0x87, 0xbb, 0x20, 0x49,
-  0x53, 0x2e, 0x5c, 0xa9, 0xa8, 0x5e, 0xc3, 0x74,
-  0xb4, 0xa9, 0x96, 0xb4, 0x3b, 0xf8, 0x73, 0x05,
-  0x6b, 0x37, 0x79, 0x4a, 0x78, 0x2f, 0x82, 0x75,
-  0xd3, 0x2b, 0x03, 0x6a, 0xda, 0x54, 0xc4, 0xfd,
-  0xd6, 0xff, 0xef, 0x65, 0xe7, 0x17, 0xba, 0xb5,
-  0x5c, 0xc9, 0xa8, 0x9a, 0x8f, 0x9a, 0x61, 0x8a,
-  0xce, 0xa7, 0xdc, 0xc0, 0x2f, 0xf4, 0x21, 0x9a,
-  0xc6, 0x85, 0x43, 0x2c, 0xe0, 0xca, 0x93, 0x69,
-  0xae, 0x5d, 0x7b, 0xe3, 0x6b, 0x82, 0x71, 0x4a,
-  0x8a, 0x91, 0xf1, 0x28, 0x3a, 0xbd, 0x05, 0xac,
-  0x15, 0x22, 0xea, 0x04, 0x0e, 0xc8, 0xa2, 0xee,
-  0xf4, 0x1c, 0x52, 0x0e, 0x40, 0x15, 0x4d, 0x8b,
-  0x03, 0xa0, 0x0f, 0xe9, 0x1a, 0x0b, 0x43, 0x61,
-  0x85, 0x39, 0xa6, 0x41, 0x78, 0x4b, 0x78, 0x88,
-  0xf6, 0x9c, 0xf5, 0x70, 0x77, 0x02, 0x2c, 0x0f,
-  0x4f, 0x00, 0x18, 0xd2, 0xc7, 0x08, 0x41, 0xc1,
-  0x88, 0x4d, 0x40, 0xc7, 0x99, 0x19, 0x1e, 0x9e,
-  0xf2, 0xd6, 0x02, 0xc7, 0x80, 0xe1, 0x93, 0xf7,
-  0x91, 0x8c, 0x85, 0x73, 0x1a, 0x5c, 0xfc, 0x22,
-  0x74, 0xa7, 0xb4, 0xd8, 0x39, 0x18, 0x4b, 0x97,
-  0x01, 0xe8, 0xc1, 0x3f, 0xa2, 0x07, 0xf5, 0x80,
-  0x0f, 0xf4, 0x13, 0x35, 0x02, 0xad, 0x7d, 0x20,
-  0xc0, 0x1c, 0x14, 0xfa, 0x32, 0xef, 0x41, 0xc3,
-  0x56, 0x19, 0x23, 0x21, 0x62, 0xe7, 0xf2, 0x02,
-  0xeb, 0x4d, 0x83, 0x8a, 0x41, 0xc3, 0x07, 0x30,
-  0x73, 0xf4, 0xea, 0x23, 0x40, 0xe0, 0x9d, 0xae,
-  0x4a, 0x32, 0x05, 0xc4, 0xe9, 0x2f, 0x5d, 0xae,
-  0xc1, 0xc5, 0x34, 0x51, 0x22, 0xad, 0xc0, 0x75,
-  0xbc, 0x07, 0x1e, 0xb3, 0x47, 0xb7, 0x54, 0xf8,
-  0x39, 0xcd, 0x08, 0x3a, 0x80, 0xea, 0x13, 0xb5,
-  0xc1, 0xcb, 0x84, 0xac, 0x9b, 0x29, 0x0a, 0x34,
-  0xfa, 0xe4, 0x83, 0x1a, 0x0e, 0x26, 0x90, 0x72,
-  0xeb, 0x03, 0xa0, 0xd7, 0x23, 0xa1, 0x92, 0xc0,
-  0xb1, 0x39, 0xd1, 0x03, 0x83, 0x32, 0x78, 0x09,
-  0xf5, 0x7f, 0x17, 0x37, 0xd5, 0xa2, 0x31, 0xad,
-  0xa2, 0xe8, 0x48, 0xa3, 0x3e, 0x6f, 0xec, 0x75,
-  0xb6, 0xb3, 0xf2, 0xcb, 0x9a, 0x0e, 0xe0, 0x48,
-  0x36, 0x08, 0x23, 0xe4, 0xa9, 0xd8, 0x5b, 0x6b,
-  0x1b, 0x38, 0xdf, 0xbb, 0xc4, 0x7d, 0x86, 0x53,
-  0x14, 0x44, 0x47, 0xf5, 0xf5, 0xca, 0x32, 0x17,
-  0x86, 0x63, 0x43, 0x09, 0xeb, 0x06, 0x93, 0xfa,
-  0xde, 0x08, 0xb1, 0x0c, 0x5a, 0xf4, 0x26, 0x1b,
-  0xab, 0x12, 0xd5, 0x6e, 0xd2, 0xcc, 0x56, 0xc3,
-  0x1f, 0xa6, 0xcd, 0x10, 0x18, 0x1e, 0x25, 0x65,
-  0xb6, 0xf7, 0x7d, 0x1a, 0x56, 0x95, 0x8b, 0x22,
-  0xdd, 0x18, 0x74, 0xe1, 0x53, 0xb0, 0x6f, 0xc1,
-  0x5e, 0xb9, 0xe1, 0x1e, 0x17, 0x37, 0xe5, 0xbe,
-  0x9f, 0x06, 0xf8, 0xb9, 0x49, 0x09, 0x94, 0xf7,
-  0xfa, 0x88, 0x40, 0xde, 0x0d, 0xe5, 0xa4, 0xab,
-  0x82, 0x4f, 0x48, 0x97, 0x8b, 0x45, 0x17, 0x31,
-  0x4c, 0xd2, 0x81, 0x5a, 0x7b, 0x7d, 0x3a, 0xbb,
-  0x02, 0x07, 0xfa, 0xf3, 0x1b, 0xcb, 0x56, 0xc5,
-  0x0a, 0x62, 0x37, 0x6b, 0xab, 0xff, 0xde, 0x61,
-  0x68, 0x1a, 0x6e, 0xf6, 0xc2, 0xb5, 0x91, 0x20,
-  0x07, 0x05, 0x6a, 0x6e, 0x6e, 0xd8, 0xa3, 0x9c,
-  0x80, 0x3c, 0x4e, 0x8c, 0xc6, 0x96, 0xef, 0x73,
-  0x35, 0x08, 0x26, 0x2a, 0xdb, 0x0c, 0x2f, 0xdb,
-  0x3d, 0xb3, 0x94, 0xf9, 0x72, 0xe4, 0x25, 0xca,
-  0x41, 0xa6, 0x66, 0x83, 0x51, 0xfe, 0xf0, 0xb3,
-  0xd7, 0x0a, 0x40, 0x77, 0x02, 0x7a, 0xa2, 0x18,
-  0x43, 0x66, 0x22, 0xcb, 0x3a, 0x1c, 0x40, 0x70,
-  0x26, 0xa7, 0x02, 0x09, 0x7d, 0x46, 0xd2, 0xab,
-  0x41, 0x83, 0x41, 0x79, 0x1a, 0x30, 0x0f, 0xab,
-  0x06, 0x0e, 0x18, 0xa0, 0xc0, 0x48, 0x23, 0xf2,
-  0x06, 0xd0, 0x64, 0xfd, 0xfe, 0x5c, 0xd7, 0xed,
-  0x2b, 0x53, 0xbb, 0x79, 0x0c, 0x49, 0x71, 0x70,
-  0x37, 0x34, 0x7b, 0x77, 0xab, 0xa3, 0x80, 0xa6,
-  0x89, 0xd7, 0x07, 0x8a, 0x80, 0x24, 0x2d, 0x4f,
-  0x3c, 0xba, 0xe7, 0x4a, 0x35, 0x22, 0x4d, 0x4f,
-  0x8b, 0xef, 0x10, 0x87, 0xda, 0xdc, 0xe2, 0x00,
-  0x21, 0x5f, 0xdb, 0xb4, 0xdc, 0x19, 0xba, 0x11,
-  0x26, 0x9d, 0x53, 0x50, 0x41, 0xad, 0x73, 0x50,
-  0x85, 0x2f, 0x77, 0x50, 0x65, 0xa3, 0x20, 0x71,
-  0x35, 0x71, 0x2e, 0xad, 0x8d, 0x6c, 0x17, 0x06,
-  0x67, 0xaa, 0xdc, 0x5d, 0x6a, 0x6d, 0x49, 0xdd,
-  0x7f, 0x32, 0xae, 0x8e, 0x04, 0x95, 0xb2, 0x71,
-  0x7e, 0x2d, 0x0e, 0xc1, 0x70, 0x7f, 0x35, 0x7f,
-  0x60, 0x73, 0x06, 0x11, 0xf0, 0xa8, 0x7d, 0xb2,
-  0x87, 0xbf, 0x6d, 0x07, 0xa4, 0x0d, 0x0f, 0x99,
-  0xc5, 0x3c, 0xe0, 0x66, 0x0e, 0x9d, 0x3f, 0xa6,
-  0xae, 0xa7, 0x6b, 0x16, 0x47, 0x43, 0x87, 0x3e,
-  0x17, 0xb6, 0x36, 0x68, 0x71, 0x00, 0x8b, 0x37,
-  0x83, 0x08, 0x8c, 0x29, 0x2c, 0xd2, 0x46, 0x98,
-  0x1b, 0x2a, 0xe1, 0x2c, 0x46, 0x31, 0xe0, 0x5b,
-  0x1c, 0x86, 0xb0, 0x67, 0xd1, 0x7b, 0xe5, 0xe1,
-  0xa0, 0xa3, 0x5d, 0x04, 0xc3, 0xe1, 0xeb, 0x50,
-  0x15, 0xbf, 0xfc, 0x8b, 0x66, 0x4a, 0x85, 0x47,
-  0x69, 0x16, 0x62, 0x2a, 0xff, 0xff, 0x7c, 0xa1,
-  0x49, 0x5d, 0xde, 0x44, 0x60, 0xe2, 0x0b, 0xba,
-  0x1a, 0xf2, 0x11, 0x56, 0x36, 0x85, 0x03, 0xe2,
-  0x9f, 0xe4, 0x24, 0x14, 0xeb, 0xdd, 0xd6, 0x2b,
-  0x5c, 0x9b, 0x9c, 0x85, 0x72, 0xae, 0x86, 0x74,
-  0x89, 0x74, 0xfb, 0x6a, 0x0b, 0xee, 0xa3, 0x18,
-  0xae, 0x47, 0x1c, 0xb0, 0xa6, 0x93, 0x44, 0xcb,
-  0xd2, 0x51, 0x33, 0xf5, 0x4a, 0x90, 0x58, 0xba,
-  0xa6, 0x50, 0x48, 0x60, 0xb1, 0x95, 0x4a, 0xc7,
-  0x3c, 0xd6, 0x99, 0x9f, 0x51, 0xec, 0x61, 0x42,
-  0xc8, 0x3b, 0xf6, 0xda, 0xc4, 0x4b, 0x53, 0x4b,
-  0x1c, 0x44, 0x3f, 0x69, 0x2e, 0x79, 0xb6, 0xb6,
-  0x55, 0xa7, 0x62, 0x9c, 0xd5, 0x14, 0xd5, 0xad,
-  0x7f, 0x72, 0x89, 0xa0, 0x0c, 0xa2, 0xea, 0xc2,
-  0x80, 0xd8, 0x3e, 0x11, 0xc4, 0x94, 0x9e, 0x1c,
-  0x31, 0x18, 0x51, 0xde, 0xf0, 0x70, 0x7e, 0xee,
-  0x16, 0x95, 0xa9, 0x2b, 0x0a, 0xa2, 0xeb, 0x25,
-  0xa5, 0x55, 0x11, 0xb1, 0x49, 0xa6, 0xba, 0x4a,
-  0x48, 0x1c, 0x00, 0xf0, 0xa0, 0x88, 0xf5, 0xbc,
-  0xc9, 0x6f, 0x70, 0x3d, 0x93, 0xa7, 0x91, 0xd6,
-  0x3d, 0x03, 0x8f, 0xfe, 0x8b, 0xd6, 0x05, 0xc1,
-  0x76, 0x96, 0x6e, 0x83, 0xce, 0xff, 0xfb, 0xc3,
-  0xda, 0xf0, 0xa1, 0x65, 0x97, 0xa2, 0x8b, 0xbf,
-  0xa5, 0x10, 0x89, 0x02, 0xce, 0x23, 0x2d, 0xb2,
-  0x55, 0x0e, 0x4f, 0x53, 0x78, 0xdf, 0xf7, 0x3d,
-  0xab, 0x14, 0xbf, 0xc8, 0x0a, 0xe8, 0xfd, 0x79,
-  0xb0, 0xa4, 0xa4, 0x1c, 0x41, 0x13, 0x64, 0x46,
-  0x28, 0x4c, 0xb3, 0x24, 0x02, 0xba, 0x58, 0x50,
-  0x14, 0xa7, 0x67, 0x35, 0x7e, 0xf2, 0xa2, 0x7b,
-  0xb6, 0x0c, 0x33, 0xa8, 0x4e, 0xeb, 0xee, 0x74,
-  0xb6, 0x03, 0xb8, 0x0b, 0x01, 0x71, 0x0d, 0x65,
-  0x91, 0x7a, 0x0e, 0x05, 0x8f, 0x68, 0x48, 0x96,
-  0x31, 0xb0, 0x39, 0xcc, 0xd4, 0x41, 0x4c, 0xec,
-  0xfa, 0x22, 0xbc, 0xb5, 0x09, 0x07, 0x36, 0x77,
-  0x8b, 0xe0, 0xaf, 0x5f, 0x58, 0xb1, 0xb9, 0x49,
-  0x4d, 0x3b, 0xca, 0x87, 0xb6, 0x70, 0x92, 0x82,
-  0xf1, 0xe5, 0xe8, 0xdb, 0x7b, 0x65, 0x2c, 0xd8,
-  0xf1, 0x84, 0x08, 0x7f, 0x67, 0xf0, 0x40, 0x69,
-  0x24, 0xd4, 0x6b, 0x53, 0x7c, 0x74, 0x9d, 0xe8,
-  0x88, 0x2b, 0xab, 0xba, 0x49, 0xc4, 0x34, 0x55,
-  0x81, 0x60, 0x0b, 0xb3, 0xc2, 0x30, 0x22, 0xa9,
-  0xee, 0x82, 0x2b, 0x3a, 0x0b, 0x00, 0x5c, 0x6c,
-  0x95, 0x04, 0xe5, 0xef, 0x46, 0x22, 0x74, 0x98,
-  0x52, 0x2a, 0xd7, 0x6f, 0x68, 0x11, 0x85, 0x29,
-  0xfd, 0xbd, 0x28, 0xc8, 0x4f, 0xb6, 0xde, 0x41,
-  0x13, 0x17, 0x46, 0x46, 0xca, 0x3e, 0x69, 0xd5,
-  0x3f, 0xde, 0x02, 0x69, 0x86, 0x47, 0xe3, 0xe6,
-  0x03, 0xb6, 0x7d, 0x00, 0x9f, 0x68, 0xc1, 0x1b,
-  0xd4, 0xd2, 0xf5, 0x7b, 0x2d, 0x6d, 0xb6, 0x74,
-  0x09, 0xff, 0x46, 0x5c, 0x87, 0x15, 0x53, 0xd4,
-  0x1a, 0x30, 0xe0, 0x60, 0x31, 0x0a, 0xf5, 0x03,
-  0x38, 0x49, 0x0e, 0x6b, 0x9d, 0x12, 0x62, 0xaf,
-  0xe1, 0x57, 0xd2, 0xb0, 0xb5, 0x86, 0x0f, 0x36,
-  0x3b, 0x4c, 0xda, 0xcd, 0x46, 0x1b, 0xef, 0x0b,
-  0x46, 0x07, 0xf6, 0x23, 0x41, 0x42, 0x69, 0xcb,
-  0x91, 0x07, 0xaf, 0x78, 0xb9, 0x21, 0x20, 0x9c,
-  0xb5, 0x00, 0x4c, 0x13, 0x35, 0xcf, 0x17, 0x08,
-  0x62, 0x5e, 0xb6, 0x05, 0xb3, 0xd9, 0x28, 0x78,
-  0x0c, 0x2f, 0x21, 0x32, 0x21, 0x30, 0xad, 0x4c,
-  0xb6, 0xa5, 0x56, 0xda, 0xdc, 0x46, 0x4d, 0x3a,
-  0xa6, 0x2d, 0xcb, 0x94, 0x16, 0x26, 0xc1, 0x75,
-  0x0b, 0x8a, 0x6f, 0xf4, 0xaa, 0x0d, 0x9d, 0xae,
-  0xb8, 0xf8, 0x78, 0x3c, 0x5d, 0x4f, 0xd5, 0x35,
-  0x3a, 0x57, 0xd2, 0x97, 0xce, 0x79, 0x80, 0x24,
-  0x0e, 0xed, 0x3e, 0x58, 0x39, 0x90, 0x16, 0x00,
-  0x9d, 0x45, 0x74, 0x65, 0xc0, 0x1c, 0x48, 0x43,
-  0xc4, 0x7d, 0xe6, 0xf4, 0x9b, 0x5e, 0x61, 0x6a,
-  0xeb, 0x74, 0xd2, 0xc0, 0x9a, 0x9b, 0x3b, 0xb3,
-  0x0d, 0x5b, 0xc0, 0x5d, 0x65, 0xba, 0x4a, 0x32,
-  0x19, 0x02, 0xea, 0x7b, 0x21, 0xbb, 0x1f, 0x8c,
-  0xce, 0x77, 0x0a, 0x25, 0x8b, 0x83, 0x81, 0x73,
-  0x41, 0xf7, 0xa1, 0xb1, 0x9b, 0xfe, 0x4f, 0xc1,
-  0x17, 0x51, 0x9b, 0xe1, 0x28, 0x2d, 0xa2, 0x4a,
-  0x4b, 0x4d, 0xbc, 0xad, 0x33, 0x4a, 0x27, 0x10,
-  0xd2, 0x50, 0x1c, 0xb1, 0x36, 0x50, 0x48, 0x65,
-  0x35, 0xf8, 0x88, 0x28, 0x6b, 0x82, 0xc0, 0x1c,
-  0x80, 0xa0, 0xfd, 0x5d, 0x17, 0x78, 0x13, 0xeb,
-  0xcb, 0x5d, 0x85, 0x08, 0x51, 0x92, 0xf4, 0x1c,
-  0xf4, 0xa4, 0xe2, 0x35, 0x9f, 0x08, 0xa9, 0xa4,
-  0x08, 0x05, 0x32, 0x6d, 0x16, 0xf1, 0x7b, 0xc1,
-  0x92, 0xc7, 0xd7, 0x8b, 0x2c, 0x27, 0xdf, 0x4e,
-  0x9a, 0xe6, 0x54, 0x40, 0xe4, 0x21, 0x5a, 0xf9,
-  0xc6, 0x24, 0xef, 0x65, 0x07, 0x2e, 0x2b, 0x4d,
-  0x4f, 0x2a, 0x09, 0x6c, 0xe8, 0xc7, 0x88, 0x05,
-  0xc7, 0x50, 0xb2, 0xde, 0xa2, 0xa1, 0x80, 0x64,
-  0x0b, 0xb3, 0x36, 0xcd, 0x26, 0xde, 0x98, 0x8a,
-  0xe4, 0x84, 0x17, 0x54, 0x2c, 0x54, 0x0e, 0x18,
-  0x38, 0xa6, 0xb5, 0x0a, 0x46, 0x41, 0x2f, 0x1c,
-  0x74, 0x80, 0xee, 0xf1, 0x7e, 0x74, 0x29, 0x8b,
-  0xd4, 0xdd, 0xb5, 0x64, 0x74, 0x17, 0xcf, 0xcf,
-  0xd8, 0x32, 0x34, 0xf9, 0xfc, 0x58, 0x64, 0xb5,
-  0x44, 0x0e, 0x34, 0x41, 0x17, 0x15, 0xeb, 0xe0,
-  0xa3, 0x49, 0x08, 0x3f, 0xe8, 0xc8, 0x8d, 0x5e,
-  0xde, 0xa2, 0xb5, 0x00, 0x3a, 0x05, 0x78, 0xca,
-  0x0a, 0xf5, 0xe5, 0x09, 0xb0, 0x5f, 0xea, 0x33,
-  0x73, 0xce, 0x12, 0xde, 0x89, 0xa2, 0x49, 0x17,
-  0x5a, 0x70, 0x07, 0xc1, 0x3b, 0xf5, 0x4c, 0x58,
-  0xf6, 0xbe, 0x51, 0x49, 0x0f, 0xee, 0x8c, 0x11,
-  0x03, 0x85, 0x5a, 0x29, 0x35, 0xd3, 0x44, 0x4c,
-  0x63, 0x24, 0x0c, 0xc5, 0x2b, 0x2d, 0x9c, 0x46,
-  0x50, 0x28, 0xd3, 0x88, 0xc4, 0x34, 0xbb, 0xb0,
-  0x81, 0x41, 0x3d, 0xcf, 0x22, 0x58, 0x63, 0x43,
-  0x13, 0xd3, 0x70, 0x64, 0x28, 0xc6, 0xcb, 0x90,
-  0x6b, 0x9d, 0xd8, 0x38, 0x74, 0xfe, 0xf8, 0xa5,
-  0x18, 0x0f, 0x08, 0xa3, 0x76, 0x8c, 0xa0, 0xbc,
-  0x85, 0xc8, 0x2f, 0x0a, 0x16, 0x41, 0xc8, 0x3a,
-  0x02, 0xe7, 0x5e, 0x03, 0xd2, 0x49, 0xde, 0x53,
-  0x5c, 0x5c, 0x85, 0xf0, 0xa5, 0x69, 0x10, 0xf4,
-  0x28, 0x65, 0x48, 0x38, 0x52, 0x11, 0x7b, 0x78,
-  0x8b, 0x9d, 0x07, 0x04, 0x53, 0x3b, 0xd4, 0x75,
-  0x41, 0xdd, 0x7c, 0xb1, 0xb4, 0x43, 0x21, 0x33,
-  0xa0, 0xfd, 0xf0, 0x01, 0xee, 0x5e, 0x23, 0xd0,
-  0x1e, 0x4c, 0xef, 0x05, 0xe2, 0xe1, 0x47, 0x8b,
-  0x21, 0x84, 0x1a, 0x7b, 0xa8, 0x14, 0x03, 0x8e,
-  0xb1, 0x5c, 0xf4, 0x92, 0x42, 0x55, 0x86, 0x92,
-  0x69, 0x69, 0x42, 0x5b, 0x6a, 0xf1, 0x01, 0x20,
-  0x4b, 0xa7, 0x0b, 0x03, 0x82, 0x36, 0x8b, 0xa8,
-  0x0d, 0x10, 0xe1, 0x88, 0x38, 0x62, 0x2e, 0x13,
-  0xe0, 0x7a, 0x48, 0x00, 0xc6, 0xb3, 0xbd, 0xe8,
-  0x49, 0xaf, 0xb8, 0xed, 0x3b, 0x10, 0xa2, 0x15,
-  0x4a, 0xd4, 0x30, 0x7e, 0x9c, 0xe9, 0xb0, 0x58,
-  0x92, 0x04, 0x8d, 0x2a, 0xc8, 0xcf, 0xe9, 0xcc,
-  0x8b, 0xa3, 0x0c, 0x89, 0xf5, 0x9c, 0xe5, 0xc5,
-  0x08, 0xca, 0xd4, 0x95, 0x15, 0x21, 0xe2, 0xc8,
-  0xc6, 0x93, 0xc2, 0x40, 0x70, 0x62, 0xf7, 0x20,
-  0x39, 0x60, 0xaa, 0x5a, 0x48, 0x2e, 0x22, 0xd3,
-  0x47, 0x26, 0x2c, 0xb8, 0xc8, 0x88, 0xaf, 0x11,
-  0xf0, 0x32, 0x07, 0x02, 0x6c, 0xf1, 0x0f, 0x38,
-  0x84, 0x1d, 0x5d, 0x96, 0x07, 0x70, 0x1c, 0x2b,
-  0xb9, 0xc2, 0x50, 0x9b, 0x4e, 0x45, 0xe3, 0x25,
-  0x8f, 0xee, 0x14, 0x72, 0x2c, 0x68, 0x29, 0x80,
-  0x46, 0x58, 0xa1, 0x11, 0x20, 0x38, 0x9b, 0x70,
-  0x90, 0x1c, 0x2e, 0x0c, 0x84, 0xcc, 0x7e, 0x27,
-  0x2a, 0x16, 0x07, 0x0a, 0x1a, 0x88, 0x0f, 0x41,
-  0xff, 0xf8, 0x61, 0x44, 0xd8, 0x60, 0x18, 0x85,
-  0x53, 0x03, 0x20, 0x73, 0xa2, 0x07, 0x6b, 0xee,
-  0x92, 0xc7, 0x4f, 0x0d, 0xf6, 0xf0, 0x17, 0x1a,
-  0x59, 0xde, 0x9b, 0x28, 0x07, 0x04, 0xda, 0xca,
-  0x2b, 0x6a, 0x37, 0x58, 0x6b, 0xaf, 0x83, 0x13,
-  0x60, 0xe7, 0x6e, 0xc4, 0x48, 0x21, 0x0e, 0x58,
-  0x92, 0x83, 0x82, 0x78, 0x8b, 0x23, 0x58, 0xd9,
-  0x0d, 0x24, 0x7d, 0xb9, 0x2c, 0x07, 0x2c, 0x0e,
-  0x42, 0x09, 0x98, 0xb0, 0xd8, 0x4d, 0x23, 0x10,
-  0x70, 0xa7, 0x73, 0x86, 0xc6, 0x0b, 0x04, 0x9f,
-  0xfb, 0x56, 0x29, 0x07, 0x23, 0x8f, 0x98, 0x0e,
-  0x8f, 0x63, 0x0a, 0x50, 0x76, 0x29, 0x28, 0x26,
-  0x3c, 0x5f, 0x02, 0xfb, 0x51, 0x9b, 0xb0, 0x61,
-  0xc0, 0x70, 0xbc, 0x17, 0x29, 0xc0, 0xcc, 0x1d,
-  0x08, 0x62, 0xca, 0x72, 0xf0, 0xa4, 0xfd, 0x5d,
-  0x2c, 0x58, 0xd5, 0x5c, 0x1c, 0x2a, 0x4e, 0xf7,
-  0x0a, 0x01, 0xfa, 0xff, 0xff, 0xd5, 0x09, 0xa8,
-  0x8c, 0x1c, 0x30, 0x25, 0x09, 0xd3, 0xd9, 0x30,
-  0xd3, 0xdb, 0x94, 0x13, 0x74, 0xc8, 0x71, 0x1a,
-  0x21, 0x87, 0x43, 0x10, 0x89, 0x5a, 0x6b, 0x91,
-  0xd5, 0x66, 0xa0, 0xb0, 0x1c, 0x30, 0x58, 0x64,
-  0x15, 0xfe, 0x36, 0x04, 0x7b, 0x4d, 0x23, 0x07,
-  0x3a, 0xf1, 0x0a, 0xc2, 0x7d, 0x3b, 0xa1, 0x91,
-  0xa4, 0x62, 0x96, 0xb1, 0xae, 0x83, 0xf6, 0xc0,
-  0x07, 0xae, 0x6c, 0x11, 0x45, 0xf4, 0x1c, 0x35,
-  0x6a, 0x28, 0x39, 0x60, 0x71, 0x1b, 0xf4, 0x39,
-  0x44, 0x41, 0xae, 0xf1, 0x07, 0x01, 0xd4, 0x89,
-  0xf6, 0x94, 0x1f, 0x7d, 0xab, 0x1b, 0x20, 0xdb,
-  0x22, 0x1e, 0xa2, 0x07, 0x09, 0x8b, 0xe3, 0xf4,
-  0xda, 0x82, 0x8c, 0x25, 0x01, 0xc0, 0xe2, 0x36,
-  0x59, 0xa0, 0xe2, 0x42, 0x82, 0x64, 0x78, 0xb0,
-  0x66, 0x0e, 0x59, 0xdd, 0x63, 0x65, 0x0b, 0x02,
-  0x6a, 0x8c, 0xc2, 0xad, 0x7a, 0x90, 0xa3, 0xa0,
-  0xbd, 0xda, 0x53, 0xd9, 0xd5, 0x82, 0x4f, 0x2c,
-  0x37, 0xd8, 0x50, 0x8c, 0xa0, 0x2a, 0x70, 0x5e,
-  0x47, 0x4a, 0xa9, 0x28, 0xaf, 0x4f, 0x58, 0x88,
-  0x31, 0x29, 0x19, 0x76, 0x8c, 0xc8, 0xbf, 0x0d,
-  0xc1, 0x56, 0xe7, 0x0a, 0x05, 0xe5, 0x20, 0xe8,
-  0xe6, 0xb0, 0x3b, 0xb7, 0xa0, 0xe1, 0x80, 0xaa,
-  0xa0, 0x23, 0xd7, 0x74, 0xd5, 0x01, 0xfc, 0x19,
-  0x85, 0x13, 0x01, 0xc1, 0x91, 0x1b, 0xec, 0x28,
-  0x80, 0xb1, 0xe2, 0xc7, 0x6a, 0x74, 0x07, 0x2c,
-  0x31, 0x15, 0xd8, 0xbd, 0xb7, 0x82, 0xe2, 0x1d,
-  0x3c, 0xa2, 0x83, 0x97, 0x09, 0x3a, 0xc0, 0xb1,
-  0x34, 0x50, 0x0b, 0x87, 0x6c, 0xc8, 0xa7, 0x6e,
-  0x64, 0x37, 0xb7, 0x91, 0x1f, 0x09, 0x0a, 0x38,
-  0x34, 0x8c, 0x97, 0x80, 0xe5, 0x8d, 0x94, 0x0a,
-  0xd6, 0xe9, 0x24, 0x18, 0xae, 0x34, 0xd7, 0xd2,
-  0x94, 0x20, 0x36, 0x34, 0x7c, 0x29, 0xe9, 0xb0,
-  0x71, 0x3e, 0xe2, 0x08, 0x69, 0xde, 0x14, 0x8b,
-  0xca, 0x01, 0x32, 0x67, 0x64, 0x43, 0x85, 0x07,
-  0xf4, 0xdf, 0x04, 0xdb, 0x88, 0x38, 0xb0, 0xbc,
-  0x32, 0x44, 0x14, 0x4f, 0x10, 0xa8, 0x34, 0x89,
-  0x10, 0x38, 0x28, 0x7c, 0xe2, 0x0a, 0x0e, 0x17,
-  0x04, 0xae, 0xfd, 0x78, 0x5d, 0x12, 0xdc, 0xde,
-  0x73, 0x9c, 0x17, 0x85, 0x2f, 0x79, 0xc5, 0xbb,
-  0x2c, 0x21, 0x6b, 0x92, 0x14, 0x92, 0x9f, 0x9e,
-  0x0c, 0xd6, 0x20, 0x99, 0x28, 0xae, 0x27, 0x22,
-  0x6d, 0xd9, 0xc4, 0x41, 0x99, 0xfd, 0x71, 0x42,
-  0x25, 0x8a, 0x41, 0xd2, 0x1c, 0x60, 0xe3, 0xfa,
-  0x14, 0x70, 0xa4, 0x8a, 0xaf, 0xa5, 0xd1, 0x90,
-  0x26, 0x42, 0x2e, 0x53, 0x42, 0xe8, 0x0e, 0x0a,
-  0x37, 0x27, 0x69, 0x29, 0x21, 0x41, 0x3c, 0xf6,
-  0xf2, 0x21, 0xe5, 0x07, 0x48, 0x7a, 0x49, 0xd0,
-  0x5c, 0xe9, 0xc9, 0x25, 0x0c, 0xa7, 0x02, 0xa9,
-  0x9d, 0x17, 0x8c, 0x85, 0xdd, 0x05, 0xf6, 0x83,
-  0x31, 0x8f, 0x41, 0xc2, 0xa8, 0x46, 0x0e, 0xa0,
-  0xe0, 0x5f, 0x3c, 0x19, 0xd1, 0x4e, 0x9e, 0x40,
-  0x89, 0x60, 0x5e, 0xcf, 0x60, 0x38, 0x07, 0xd4,
-  0x20, 0xba, 0x7c, 0x28, 0xe8, 0x38, 0x62, 0xe9,
-  0x25, 0xe1, 0xa1, 0x90, 0x38, 0x9a, 0xac, 0x45,
-  0xaf, 0xa5, 0x8b, 0x21, 0xea, 0x23, 0x60, 0xe7,
-  0x68, 0x8c, 0xa3, 0x81, 0x4c, 0xc3, 0x74, 0xd7,
-  0x03, 0x22, 0x3e, 0xb8, 0xb8, 0x26, 0x64, 0x24,
-  0xa4, 0xa7, 0xb4, 0xe6, 0x14, 0x12, 0x05, 0x52,
-  0x0f, 0x45, 0x00, 0x19, 0xfc, 0x0e, 0x0a, 0x34,
-  0x19, 0x03, 0x81, 0x7f, 0x8d, 0x34, 0xf7, 0x02,
-  0x39, 0x8b, 0x8b, 0x90, 0x04, 0x52, 0x14, 0xb8,
-  0xb8, 0x2c, 0x42, 0x58, 0x0b, 0x98, 0x9e, 0x51,
-  0xc0, 0xc5, 0x68, 0x11, 0xe8, 0x03, 0x81, 0xc0,
-  0xbf, 0x66, 0x81, 0xd5, 0xd2, 0xb9, 0x41, 0x27,
-  0x02, 0x63, 0x11, 0xa3, 0x3f, 0x57, 0x9e, 0x73,
-  0xbc, 0xb1, 0x09, 0x4f, 0x08, 0x37, 0x30, 0x94,
-  0xe6, 0x93, 0x8b, 0xa3, 0x36, 0x6e, 0x00, 0xe1,
-  0xae, 0xa8, 0x91, 0x83, 0x8d, 0x12, 0x85, 0x4a,
-  0x8a, 0x1b, 0x27, 0xd3, 0xd3, 0x88, 0xc3, 0x07,
-  0xcc, 0x80, 0xe0, 0x5c, 0xcc, 0xea, 0xc1, 0x90,
-  0x2c, 0x5d, 0x3c, 0xa0, 0xe0, 0x9e, 0xad, 0x62,
-  0x37, 0xc5, 0xe2, 0xa1, 0x40, 0x84, 0x2b, 0x82,
-  0xb0, 0x5d, 0x3e, 0x73, 0xbd, 0x07, 0x0b, 0xc2,
-  0x77, 0x16, 0x25, 0x17, 0x70, 0xd8, 0x38, 0x69,
-  0x08, 0xb4, 0xcb, 0x0e, 0x05, 0x14, 0x38, 0x27,
-  0x48, 0xaa, 0xa1, 0x85, 0x10, 0x07, 0xa3, 0x3d,
-  0x54, 0x66, 0x18, 0x03, 0x8f, 0x1b, 0x3a, 0x4a,
-  0x27, 0xd7, 0xbb, 0x01, 0xd0, 0xfe, 0xea, 0xf3,
-  0xa6, 0xf8, 0x43, 0x86, 0x10, 0x1c, 0x76, 0x86,
-  0x34, 0x62, 0x4a, 0x0b, 0xc4, 0xb9, 0xd3, 0x4e,
-  0xd7, 0xf9, 0xa0, 0xb1, 0x24, 0x14, 0x50, 0xcf,
-  0x86, 0x81, 0x3d, 0xe5, 0x42, 0xb7, 0x68, 0x2e,
-  0xf4, 0x92, 0x14, 0x44, 0x63, 0x2e, 0x1d, 0x7e,
-  0xaf, 0x42, 0x6d, 0x7f, 0x64, 0x29, 0x0a, 0xb5,
-  0xec, 0x40, 0x0e, 0x04, 0xef, 0xbd, 0xe7, 0x56,
-  0x40, 0x0b, 0x0a, 0x79, 0x8c, 0x7b, 0xc0, 0xa7,
-  0x3d, 0xaf, 0x94, 0xde, 0x21, 0x45, 0xc0, 0xc0,
-  0x17, 0x33, 0x31, 0x0a, 0xcb, 0x92, 0x03, 0x8f,
-  0xb5, 0xd0, 0xf7, 0x9d, 0x3b, 0x56, 0x61, 0x21,
-  0x25, 0x19, 0x82, 0xee, 0xf3, 0x92, 0xa3, 0x76,
-  0xbd, 0xe7, 0xf6, 0x76, 0xf6, 0xe4, 0xc0, 0x29,
-  0x81, 0xb5, 0xd0, 0x70, 0xad, 0xff, 0x3c, 0xba,
-  0xd3, 0x6d, 0x96, 0xf5, 0x10, 0x2f, 0xe3, 0xb3,
-  0x05, 0xc4, 0x53, 0xdb, 0x61, 0x20, 0x3a, 0x9f,
-  0x9d, 0x35, 0xca, 0x4f, 0xa6, 0xe2, 0x90, 0x72,
-  0xdd, 0x09, 0x21, 0x70, 0x7e, 0xe8, 0x00, 0xf2,
-  0xe0, 0x3d, 0x60, 0x1d, 0x42, 0x5d, 0x20, 0x6d,
-  0x82, 0xb6, 0xea, 0xe8, 0x04, 0xda, 0xfa, 0x48,
-  0x8b, 0xb0, 0x96, 0xa0, 0x07, 0x2c, 0x4f, 0xed,
-  0xbc, 0x5b, 0xa0, 0xe9, 0x05, 0x0f, 0x3a, 0x4a,
-  0x82, 0x0a, 0xfe, 0x62, 0x13, 0xb1, 0x79, 0xde,
-  0x8b, 0x88, 0x34, 0xe5, 0x1a, 0x01, 0x70, 0x57,
-  0x2b, 0x82, 0xc3, 0x91, 0x72, 0x1a, 0xad, 0x62,
-  0x0e, 0x83, 0x89, 0x57, 0x81, 0x27, 0x50, 0x2f,
-  0x07, 0x3f, 0x07, 0x23, 0x3f, 0x17, 0xfc, 0xc4,
-  0x1d, 0xda, 0x18, 0x11, 0x3b, 0x6f, 0x50, 0x62,
-  0xc2, 0xf4, 0x40, 0x9d, 0xbc, 0x52, 0x88, 0x5c,
-  0x2b, 0x77, 0x28, 0x6e, 0xb9, 0x20, 0x2e, 0xad,
-  0x42, 0x68, 0x9f, 0x5e, 0x64, 0xbd, 0x36, 0x53,
-  0x0a, 0x4a, 0x46, 0x8d, 0x64, 0x2b, 0x22, 0x3b,
-  0xa6, 0xf5, 0x06, 0x76, 0x12, 0x89, 0xba, 0xc3,
-  0x24, 0x23, 0x10, 0xc0, 0x87, 0x92, 0xf0, 0xe6,
-  0xbe, 0x2b, 0x88, 0x6d, 0x34, 0x18, 0x1f, 0x95,
-  0x89, 0x01, 0x7b, 0xed, 0x07, 0x20, 0x0c, 0x44,
-  0xdb, 0x69, 0xae, 0x12, 0x20, 0x20, 0x8b, 0x40,
-  0x9e, 0x2c, 0x4f, 0x10, 0x9b, 0x5c, 0x24, 0x79,
-  0x78, 0x85, 0x12, 0x31, 0x98, 0x56, 0xf6, 0xde,
-  0xa2, 0xb4, 0x66, 0x43, 0x54, 0xa9, 0x76, 0xbc,
-  0xf0, 0x1c, 0x45, 0xba, 0x1a, 0x21, 0x28, 0x07,
-  0x3f, 0x81, 0x1e, 0x83, 0x06, 0x5d, 0x0c, 0x89,
-  0xa7, 0x94, 0x93, 0x80, 0xbd, 0xe9, 0xa0, 0xc3,
-  0xa0, 0x3c, 0xee, 0x9c, 0xf2, 0x12, 0x03, 0x85,
-  0x4f, 0x80, 0xea, 0x7a, 0xa2, 0xc8, 0x10, 0xae,
-  0x8c, 0x82, 0x46, 0x28, 0xc1, 0xc2, 0xf0, 0x77,
-  0x48, 0x69, 0xae, 0x48, 0x2b, 0xab, 0xe4, 0x0b,
-  0x5e, 0xa3, 0x91, 0x61, 0x5e, 0x5c, 0xda, 0x34,
-  0x44, 0xbd, 0xa4, 0x0d, 0x7e, 0x50, 0x73, 0xba,
-  0xf4, 0x1f, 0xbf, 0xff, 0xff, 0x6a, 0x20, 0xa6,
-  0x27, 0xf9, 0xc0, 0x7a, 0x0f, 0xff, 0xcf, 0xf5,
-  0xd1, 0xae, 0x15, 0x65, 0x28, 0x90, 0x84, 0xd3,
-  0x0a, 0x2f, 0x06, 0x00, 0xe2, 0x3f, 0x83, 0x4d,
-  0x3f, 0x10, 0xac, 0x52, 0x0e, 0x3b, 0x81, 0xd1,
-  0x7e, 0x06, 0x01, 0x14, 0x82, 0x3a, 0x04, 0x02,
-  0xe4, 0x76, 0x1e, 0xe0, 0xe0, 0x5d, 0x52, 0x95,
-  0xdd, 0xa7, 0xb8, 0x0b, 0x14, 0x00, 0xe0, 0xc8,
-  0xeb, 0x58, 0xd8, 0xc4, 0x30, 0x21, 0xe0, 0xf4,
-  0x30, 0x01, 0x84, 0xf4, 0x31, 0x18, 0x02, 0x7a,
-  0x94, 0x2c, 0x15, 0xc4, 0xda, 0xc4, 0x78, 0x62,
-  0x32, 0x8b, 0x42, 0x45, 0x81, 0xc5, 0x24, 0x71,
-  0x01, 0x74, 0xe0, 0xc8, 0x90, 0x1c, 0x6c, 0x94,
-  0x4d, 0x48, 0xb4, 0xf4, 0x37, 0x0d, 0x03, 0x89,
-  0x0f, 0x38, 0x67, 0x60, 0x3f, 0xbc, 0x00, 0x6c,
-  0x5e, 0x0e, 0x41, 0x4d, 0x85, 0x76, 0x02, 0xef,
-  0x5e, 0x41, 0xcb, 0xd0, 0x70, 0x64, 0x85, 0x62,
-  0x79, 0xd1, 0x80, 0xb8, 0x1c, 0x27, 0x70, 0x1f,
-  0xdf, 0xff, 0xf7, 0x20, 0xa3, 0x25, 0x22, 0xd3,
-  0x8b, 0x9e, 0x02, 0x1e, 0x5c, 0x1c, 0x11, 0xae,
-  0xa3, 0x3a, 0xb7, 0xb2, 0x8b, 0xab, 0xe0, 0xb1,
-  0x12, 0xf0, 0x1c, 0x2e, 0x0a, 0x12, 0xbc, 0x95,
-  0x0f, 0x6a, 0x09, 0x2f, 0x45, 0xeb, 0x40, 0x1c,
-  0x43, 0xcd, 0x59, 0x0b, 0xe2, 0x6a, 0x5f, 0x43,
-  0x4a, 0x09, 0x54, 0xd3, 0x62, 0x9f, 0x65, 0x88,
-  0x94, 0x8c, 0xaa, 0xc2, 0xfa, 0xfe, 0x55, 0x2c,
-  0xe7, 0x82, 0xad, 0x6d, 0x41, 0xcc, 0x19, 0x22,
-  0xe0, 0xa7, 0x31, 0x53, 0x91, 0x03, 0xf5, 0x17,
-  0xfe, 0x2e, 0x29, 0x26, 0x4c, 0xb1, 0xb9, 0x2f,
-  0x5b, 0x80, 0x8c, 0xb8, 0x61, 0x41, 0x77, 0x41,
-  0xef, 0x11, 0xd4, 0x06, 0x86, 0x24, 0x5e, 0x44,
-  0x2b, 0x8c, 0xd1, 0x14, 0x93, 0x32, 0xfc, 0x5b,
-  0x51, 0x0a, 0xb4, 0xe5, 0x64, 0x3c, 0xb4, 0xd8,
-  0x39, 0x18, 0x51, 0x48, 0x41, 0xcb, 0x70, 0x9f,
-  0x70, 0x32, 0x40, 0x15, 0x4a, 0x88, 0x0e, 0x46,
-  0x19, 0x84, 0x70, 0xd2, 0xe7, 0xf5, 0xe7, 0x81,
-  0xaa, 0xe7, 0xdf, 0xe8, 0x69, 0x25, 0x36, 0x48,
-  0x0e, 0x42, 0x14, 0x4d, 0xa6, 0xf2, 0x92, 0xac,
-  0x49, 0xd2, 0x66, 0x85, 0x01, 0x28, 0xb8, 0x13,
-  0x19, 0x6b, 0x78, 0x2e, 0x7e, 0xbf, 0xf8, 0x13,
-  0xee, 0x50, 0x71, 0xcf, 0x20, 0x7f, 0x20, 0x30,
-  0x2c, 0x34, 0x13, 0x5b, 0xb2, 0x31, 0x8a, 0xe2,
-  0xf7, 0x34, 0x83, 0x31, 0xa6, 0xbe, 0x99, 0x56,
-  0x1b, 0x6b, 0xb4, 0xa8, 0xf9, 0xca, 0x31, 0x1a,
-  0x39, 0x50, 0x2c, 0x0e, 0x90, 0x1c, 0x73, 0xdc,
-  0x9d, 0x5d, 0x6e, 0x22, 0xa6, 0x90, 0x9e, 0x5a,
-  0xb2, 0x0e, 0x13, 0x45, 0xe7, 0xb3, 0xa0, 0xc4,
-  0xcf, 0xbd, 0x43, 0x4d, 0x83, 0x06, 0x50, 0xe5,
-  0x81, 0x6e, 0x00, 0xee, 0x00, 0xe8, 0xe9, 0xb8,
-  0x52, 0x41, 0xec, 0x1b, 0x51, 0x75, 0x80, 0x99,
-  0x57, 0xd1, 0x75, 0xd0, 0x94, 0x12, 0x0b, 0x89,
-  0xfc, 0x17, 0x44, 0x25, 0x20, 0xb9, 0x53, 0x79,
-  0x67, 0x3b, 0xf5, 0x22, 0x26, 0x69, 0x25, 0x42,
-  0xe5, 0x71, 0x9c, 0xa1, 0xd0, 0x31, 0x5f, 0x6c,
-  0x9b, 0x56, 0x35, 0x41, 0x71, 0x0b, 0x64, 0xe0,
-  0x8a, 0x2b, 0xd3, 0xd7, 0x41, 0x63, 0x00, 0x79,
-  0xdd, 0xd9, 0x2a, 0xe8, 0x51, 0x10, 0x40, 0x22,
-  0x7d, 0x0b, 0x3b, 0xe2, 0x45, 0xe8, 0xbf, 0x54,
-  0xf4, 0x60, 0xb0, 0xa5, 0x29, 0xe5, 0x11, 0x0d,
-  0x29, 0xab, 0xde, 0xa2, 0x45, 0x20, 0x2f, 0xea,
-  0xc8, 0xfa, 0x2e, 0x7e, 0x9c, 0x95, 0x12, 0x84,
-  0xae, 0x23, 0x07, 0x09, 0x93, 0x24, 0x09, 0x38,
-  0x3b, 0x86, 0x81, 0x35, 0x84, 0xda, 0xfb, 0x92,
-  0x2f, 0x10, 0x83, 0x82, 0x2e, 0xba, 0x10, 0xc8,
-  0xa4, 0x22, 0xdd, 0x07, 0x0d, 0x1f, 0x0d, 0xd9,
-  0xd0, 0x4d, 0xd7, 0x21, 0xd7, 0x98, 0x03, 0x81,
-  0x60, 0x7d, 0xd5, 0xe7, 0x21, 0x42, 0xe7, 0xe6,
-  0xa0, 0xab, 0x83, 0x82, 0x7d, 0xc8, 0x32, 0xe5,
-  0x07, 0x3e, 0x14, 0x9d, 0xd3, 0xf3, 0xa4, 0xa3,
-  0x10, 0xca, 0x83, 0x8e, 0xa6, 0xb1, 0x4a, 0xc4,
-  0xed, 0x74, 0x7d, 0x07, 0x02, 0xeb, 0xc3, 0x17,
-  0x9c, 0xa8, 0xc2, 0x4a, 0x9f, 0x5c, 0x5c, 0x69,
-  0x01, 0x36, 0x9d, 0xa4, 0xa0, 0xf3, 0xff, 0xff,
-  0xa0, 0x39, 0x32, 0x52, 0x45, 0x91, 0x2f, 0xc0,
-  0x9f, 0x06, 0x60, 0xe2, 0x5a, 0x77, 0x0a, 0x3f,
-  0x89, 0x24, 0x28, 0x5c, 0x22, 0xac, 0xc5, 0xf8,
-  0xb7, 0x6c, 0x40, 0x33, 0x7d, 0x58, 0x89, 0x72,
-  0x69, 0xea, 0xc0, 0xe1, 0x91, 0x1f, 0x57, 0xd9,
-  0x99, 0x27, 0x17, 0x47, 0x7a, 0x88, 0x26, 0xdb,
-  0xa6, 0xe5, 0xe4, 0x01, 0xe2, 0xa9, 0x0c, 0x05,
-  0x3b, 0x90, 0xda, 0x3e, 0x2c, 0x2b, 0x7e, 0x77,
-  0xa4, 0x7a, 0x73, 0xc8, 0x1c, 0x59, 0x0a, 0x41,
-  0x3f, 0x16, 0x61, 0x47, 0x01, 0xc4, 0xb3, 0x80,
-  0xba, 0xd3, 0x4d, 0x86, 0x21, 0x80, 0x52, 0xfa,
-  0x48, 0x8d, 0x10, 0xc4, 0x17, 0xd2, 0xf5, 0x14,
-  0x0a, 0xe2, 0x7d, 0x46, 0x54, 0x4b, 0x0c, 0x0d,
-  0x05, 0x58, 0xb0, 0x95, 0x4f, 0x50, 0x83, 0x91,
-  0x05, 0x39, 0x10, 0x39, 0x10, 0x38, 0x8f, 0x1b,
-  0xbc, 0x85, 0x01, 0x88, 0xd3, 0xb4, 0x13, 0xb5,
-  0xe5, 0x74, 0x4b, 0x03, 0x91, 0x10, 0x31, 0x8c,
-  0x0a, 0x25, 0x72, 0x5b, 0x06, 0x70, 0x9e, 0x51,
-  0x53, 0x55, 0x19, 0x28, 0x38, 0xa0, 0x8f, 0x83,
-  0x64, 0x21, 0x5e, 0xbb, 0x19, 0xcd, 0x18, 0x06,
-  0x20, 0xe3, 0xf3, 0x16, 0xe8, 0x38, 0x22, 0xd0,
-  0x12, 0x62, 0xac, 0x6c, 0x1d, 0x11, 0x9d, 0xbd,
-  0x28, 0x84, 0xfa, 0xfa, 0x95, 0x77, 0xa0, 0x3a,
-  0x86, 0x48, 0xa9, 0xa0, 0x8e, 0x2c, 0x50, 0x8f,
-  0xbc, 0x01, 0xc0, 0xb0, 0x05, 0xcc, 0xd5, 0x90,
-  0x41, 0x70, 0x4e, 0x9a, 0xeb, 0x22, 0x07, 0x14,
-  0x82, 0xeb, 0xe0, 0x9f, 0x4e, 0x2c, 0x07, 0xea,
-  0x80, 0x0d, 0x12, 0xc2, 0x81, 0x98, 0x38, 0x56,
-  0x99, 0x60, 0x38, 0x27, 0xa5, 0x00, 0xf3, 0xff,
-  0xff, 0x91, 0x99, 0x54, 0x8c, 0x4d, 0x9f, 0xab,
-  0xdd, 0x51, 0x57, 0x5c, 0x90, 0x60, 0xb1, 0xef,
-  0xca, 0x2b, 0xc0, 0xe2, 0x2a, 0x58, 0x94, 0xf1,
-  0x4a, 0x22, 0xc8, 0x5d, 0xdf, 0x50, 0x49, 0x46,
-  0x68, 0xc6, 0x51, 0xd1, 0x7b, 0x03, 0x00, 0x4d,
-  0xa5, 0x14, 0x1d, 0x51, 0x05, 0x4f, 0x8b, 0x76,
-  0x86, 0x6b, 0x03, 0x81, 0x3b, 0xd3, 0xb5, 0x1a,
-  0xa7, 0xb6, 0xce, 0x20, 0x9c, 0x5e, 0x2c, 0x6c,
-  0x86, 0x79, 0xc3, 0x64, 0x9d, 0x3f, 0xb8, 0x6c,
-  0x1c, 0x42, 0xd6, 0x5a, 0x76, 0x0a, 0x2a, 0x32,
-  0x3d, 0x77, 0x79, 0xc4, 0x16, 0x12, 0xd0, 0xa7,
-  0x41, 0x80, 0xaf, 0x76, 0x20, 0xec, 0x07, 0x05,
-  0x1f, 0x11, 0x85, 0x1c, 0xa8, 0x02, 0x8d, 0x7c,
-  0x0e, 0x21, 0x75, 0x4f, 0x60, 0x3a, 0xa2, 0x27,
-  0x9d, 0x06, 0x0c, 0x8d, 0x0a, 0xd9, 0x22, 0xf5,
-  0x4d, 0x07, 0x50, 0x4c, 0xed, 0xe2, 0x30, 0xcc,
-  0x07, 0xbb, 0x4f, 0x0c, 0xd1, 0x14, 0x83, 0x83,
-  0x3e, 0x0d, 0x67, 0x94, 0x62, 0x0e, 0x17, 0xf5,
-  0x00, 0xd1, 0xf0, 0x1c, 0xfd, 0x62, 0x04, 0x24,
-  0x18, 0x51, 0x53, 0xfc, 0x28, 0x07, 0x0d, 0x77,
-  0x03, 0x31, 0x5e, 0x51, 0xc8, 0x0e, 0x0a, 0xda,
-  0xd5, 0x0f, 0x16, 0x58, 0x1d, 0xc0, 0x71, 0xc6,
-  0x8b, 0x22, 0xc4, 0x66, 0xc2, 0x3d, 0x77, 0x6c,
-  0xd2, 0x47, 0x65, 0x15, 0x0f, 0x41, 0xc3, 0x31,
-  0x3f, 0xec, 0x36, 0x0b, 0xc7, 0x3b, 0x57, 0x44,
-  0x52, 0x6e, 0x8a, 0xa7, 0x37, 0x95, 0x6a, 0x09,
-  0x95, 0x37, 0xc4, 0x3c, 0x81, 0x98, 0x3a, 0x04,
-  0x9f, 0x8b, 0x1a, 0x19, 0x83, 0x83, 0x11, 0x35,
-  0x03, 0x90, 0x50, 0x72, 0x12, 0x39, 0xb0, 0xdf,
-  0x41, 0xc4, 0x71, 0x4a, 0x12, 0x6d, 0x3e, 0x58,
-  0xb8, 0xc9, 0x08, 0x2c, 0x20, 0x38, 0xf7, 0x58,
-  0xd7, 0x41, 0xc1, 0x3d, 0x70, 0x33, 0x05, 0xd4,
-  0xa8, 0x58, 0x1c, 0x18, 0xc8, 0x14, 0x77, 0xa2,
-  0xa8, 0xbf, 0xcb, 0x51, 0x83, 0x8e, 0xc5, 0x29,
-  0x5c, 0x17, 0x9e, 0xa0, 0x25, 0x44, 0x28, 0x9a,
-  0x2f, 0xa8, 0x43, 0x0a, 0x7a, 0xd8, 0x8f, 0xb6,
-  0x82, 0x66, 0x9f, 0x5e, 0x0c, 0x0d, 0x03, 0x97,
-  0x42, 0x8c, 0xf4, 0xf0, 0xda, 0x21, 0x3e, 0x47,
-  0xc3, 0x64, 0xcc, 0x66, 0x0e, 0x1a, 0x51, 0x5d,
-  0x5d, 0x3b, 0x8a, 0x0a, 0x0a, 0x62, 0x3e, 0x72,
-  0x3d, 0xdf, 0x83, 0x90, 0xa0, 0x05, 0xf7, 0xde,
-  0x45, 0xb8, 0x33, 0xe2, 0xc0, 0xb0, 0x19, 0x91,
-  0x3c, 0xef, 0x43, 0x75, 0xa2, 0x33, 0x6b, 0xf0,
-  0x33, 0x7e, 0x56, 0x28, 0xd3, 0xab, 0xd4, 0x52,
-  0x90, 0xfe, 0x21, 0x40, 0x52, 0xe8, 0x9e, 0xe7,
-  0x22, 0x00, 0xd5, 0x4d, 0x06, 0x09, 0xe7, 0x90,
-  0x16, 0x3c, 0xe1, 0x42, 0x10, 0xc0, 0x69, 0x10,
-  0x71, 0xd1, 0x3d, 0x27, 0x79, 0x08, 0xda, 0x81,
-  0x9a, 0x30, 0x72, 0x30, 0x4d, 0x72, 0x2e, 0x83,
-  0x9c, 0x07, 0x06, 0x42, 0xbd, 0xcb, 0xd2, 0x2e,
-  0x74, 0x51, 0xa7, 0xd4, 0x53, 0x70, 0x63, 0xc0,
-  0x70, 0x49, 0xb9, 0x06, 0x66, 0xd0, 0x02, 0xc4,
-  0x17, 0x9b, 0x84, 0x88, 0xc3, 0x30, 0x70, 0x55,
-  0xb8, 0x0e, 0x5c, 0x1c, 0x32, 0x09, 0x90, 0xe5,
-  0x5e, 0x6d, 0x01, 0xc4, 0x7d, 0x0a, 0xfd, 0x46,
-  0x48, 0x48, 0xb3, 0xb7, 0x06, 0x4b, 0x8c, 0x10,
-  0x03, 0x9f, 0xba, 0x2e, 0x46, 0x19, 0xbe, 0xf5,
-  0x1a, 0xc7, 0xb4, 0xe0, 0x65, 0x02, 0x7c, 0x30,
-  0x0c, 0x4d, 0x8a, 0x5f, 0x0d, 0x45, 0xca, 0x28,
-  0x4b, 0x2b, 0x03, 0xa0, 0x30, 0x2c, 0x42, 0x5c,
-  0xe6, 0x9e, 0x28, 0x82, 0xe0, 0x5c, 0xbe, 0xa3,
-  0x96, 0x06, 0x61, 0x2c, 0x40, 0x1d, 0xd2, 0x17,
-  0xc5, 0xc1, 0xc3, 0x5e, 0xce, 0x1a, 0xe0, 0xaf,
-  0x4f, 0x0c, 0xba, 0x19, 0x06, 0x40, 0x3c, 0x6b,
-  0xe7, 0x57, 0x58, 0xd4, 0x07, 0x1b, 0x14, 0x27,
-  0xce, 0x92, 0xc2, 0x94, 0x60, 0xbe, 0x60, 0xe0,
-  0x9f, 0x44, 0x85, 0xfa, 0xf8, 0xd8, 0x64, 0xa3,
-  0x80, 0x39, 0x10, 0x55, 0xed, 0x18, 0x9b, 0x0b,
-  0x32, 0x20, 0x58, 0x02, 0xe7, 0x1b, 0x21, 0xbd,
-  0x9d, 0xe9, 0x50, 0x26, 0xe9, 0xba, 0x1f, 0xa2,
-  0xee, 0x14, 0x2e, 0x03, 0xc8, 0xdd, 0x10, 0x4d,
-  0x66, 0x8c, 0xe9, 0x48, 0x2e, 0x51, 0xe0, 0x26,
-  0xa9, 0xc6, 0x43, 0x9c, 0x92, 0x20, 0x04, 0xd2,
-  0xd7, 0x43, 0x27, 0x01, 0x7d, 0xa7, 0x65, 0x7c,
-  0x0e, 0xb0, 0x11, 0xc2, 0x5b, 0xbf, 0x51, 0x57,
-  0xc0, 0x46, 0xb1, 0x71, 0x97, 0x5d, 0x62, 0x06,
-  0x68, 0xdf, 0xba, 0x6c, 0xad, 0x18, 0xc8, 0xe4,
-  0x28, 0xcc, 0x1b, 0x7b, 0x85, 0x10, 0x31, 0x3f,
-  0x41, 0xc8, 0x88, 0xb4, 0xde, 0x7f, 0x7e, 0x0c,
-  0x05, 0x3e, 0xb9, 0xb5, 0x10, 0x6b, 0x2a, 0x1b,
-  0xe7, 0x54, 0xe6, 0x12, 0x8d, 0xe8, 0x38, 0x62,
-  0x7b, 0xd2, 0x45, 0xe8, 0x51, 0xf8, 0x8d, 0x71,
-  0x78, 0x38, 0x62, 0x13, 0xb2, 0xfd, 0x09, 0x62,
-  0x6c, 0x0d, 0x60, 0x32, 0x1f, 0xb7, 0xfa, 0x53,
-  0xc8, 0x50, 0xb7, 0x06, 0x92, 0xa3, 0x32, 0xad,
-  0x38, 0x0e, 0x28, 0x3d, 0x27, 0x9f, 0x20, 0x63,
-  0xd7, 0xcb, 0xd4, 0x72, 0xf0, 0x90, 0x83, 0x5f,
-  0x5d, 0x18, 0x92, 0xa3, 0x0d, 0xd7, 0x3d, 0xaa,
-  0x91, 0x95, 0xe9, 0x48, 0xd1, 0xf4, 0x1f, 0xc2,
-  0x00, 0x3f, 0x6c, 0x44, 0xba, 0x00, 0x70, 0x72,
-  0x7e, 0x70, 0x57, 0x53, 0x64, 0x92, 0x0c, 0xcd,
-  0x92, 0x02, 0xeb, 0xae, 0x50, 0x2a, 0xca, 0x0a,
-  0x45, 0xc0, 0x3c, 0x1c, 0xee, 0x18, 0x03, 0x90,
-  0x84, 0x54, 0x35, 0xe8, 0x49, 0xa7, 0x35, 0x12,
-  0x00, 0x1c, 0x2e, 0x07, 0x3b, 0x49, 0x01, 0xdd,
-  0x19, 0x83, 0x90, 0x89, 0xa7, 0x85, 0x05, 0x01,
-  0x1b, 0x17, 0x14, 0x03, 0xb8, 0x0b, 0xe6, 0xc2,
-  0x9e, 0x94, 0x9c, 0xd3, 0xa0, 0x70, 0x66, 0x43,
-  0x3c, 0x07, 0x05, 0x49, 0x74, 0xd5, 0xe0, 0xc0,
-  0x07, 0xae, 0xea, 0x5f, 0xa6, 0xc1, 0xc3, 0x05,
-  0x85, 0xc2, 0xb8, 0xa4, 0x90, 0x2b, 0x89, 0xb8,
-  0x0e, 0x42, 0x12, 0x34, 0x46, 0x81, 0xc4, 0xa2,
-  0x96, 0xb8, 0x64, 0x6e, 0x02, 0xe7, 0xa3, 0x40,
-  0x32, 0x07, 0x40, 0x5c, 0x3d, 0xed, 0x5f, 0xa1,
-  0x55, 0x4b, 0xf9, 0x60, 0x70, 0xa2, 0x11, 0xf4,
-  0x32, 0x73, 0xe5, 0x29, 0x0c, 0x01, 0xc5, 0x03,
-  0x5b, 0x57, 0x20, 0x89, 0xd8, 0x39, 0x00, 0x39,
-  0x71, 0x80, 0xd1, 0x8c, 0x49, 0x3a, 0x09, 0xf0,
-  0xa2, 0x23, 0x07, 0x02, 0xfa, 0x54, 0x78, 0x94,
-  0x31, 0x13, 0xac, 0x2a, 0x15, 0xd5, 0xe1, 0x17,
-  0x51, 0x03, 0xa5, 0x3b, 0xa1, 0x2a, 0x37, 0xed,
-  0xd2, 0xa2, 0x52, 0x42, 0x8a, 0xb1, 0xa2, 0x83,
-  0xb2, 0xa4, 0xa2, 0x4a, 0x50, 0x8f, 0xa1, 0x80,
-  0x55, 0x29, 0xd8, 0x9e, 0x50, 0x87, 0xa7, 0x31,
-  0x50, 0x3b, 0x92, 0x0c, 0x0f, 0xf1, 0x99, 0x48,
-  0x38, 0x07, 0x22, 0x24, 0x3f, 0xc1, 0xcb, 0x83,
-  0x81, 0x60, 0x35, 0xc1, 0x75, 0x13, 0xf1, 0x74,
-  0x43, 0x12, 0x51, 0x98, 0x47, 0x84, 0x52, 0x81,
-  0x82, 0xc0, 0xe1, 0xac, 0x74, 0x16, 0x04, 0xa1,
-  0x81, 0xe6, 0x04, 0x83, 0x20, 0x89, 0xd6, 0x42,
-  0x7f, 0x4d, 0xd1, 0x81, 0x48, 0xa1, 0x46, 0x3f,
-  0x8c, 0xc5, 0x33, 0x9b, 0xe4, 0x1b, 0x9d, 0x5c,
-  0x63, 0x90, 0x1c, 0x83, 0xae, 0xc8, 0x51, 0x06,
-  0x50, 0x32, 0xa0, 0xbf, 0x2d, 0xc0, 0x71, 0x20,
-  0x38, 0x5c, 0x4a, 0xef, 0xa7, 0xb4, 0xd0, 0xb8,
-  0x4b, 0x45, 0xc2, 0xf0, 0x4e, 0x65, 0x21, 0x3f,
-  0x34, 0x8c, 0x1c, 0x4a, 0x0e, 0xeb, 0xe4, 0xa0,
-  0x1d, 0x46, 0x01, 0x5c, 0xe8, 0x9f, 0x5f, 0x14,
-  0xa2, 0x37, 0x49, 0x44, 0xcf, 0x9c, 0x18, 0x92,
-  0xa3, 0x07, 0x09, 0xe6, 0x1b, 0x09, 0x2b, 0x83,
-  0x10, 0x4c, 0xe2, 0x35, 0x9d, 0x13, 0x92, 0x80,
-  0x70, 0x66, 0x35, 0x6b, 0x77, 0x84, 0x6c, 0x64,
-  0xb9, 0xa5, 0x96, 0x13, 0xee, 0x0c, 0x41, 0xc8,
-  0xfa, 0x13, 0xb5, 0x9d, 0x25, 0x0a, 0x75, 0xde,
-  0x50, 0x70, 0x2f, 0xa7, 0x56, 0x37, 0x61, 0xb2,
-  0x42, 0x40, 0xae, 0x68, 0xcc, 0xa5, 0x07, 0x42,
-  0x4d, 0x0d, 0xad, 0xca, 0x0b, 0xd5, 0xa3, 0x21,
-  0x36, 0x9e, 0x8a, 0x22, 0xfd, 0x05, 0x88, 0x38,
-  0x82, 0x4a, 0x28, 0xc1, 0x6e, 0x92, 0xad, 0x43,
-  0x17, 0x4a, 0x34, 0x60, 0xfe, 0x10, 0x01, 0xe3,
-  0x75, 0x6e, 0x03, 0x82, 0x4b, 0xdc, 0xa2, 0xbd,
-  0x77, 0x28, 0x3b, 0xab, 0x77, 0x85, 0x21, 0x3c,
-  0xc1, 0x9b, 0x9c, 0xb6, 0x76, 0xdb, 0x67, 0x78,
-  0xb6, 0x5e, 0x21, 0x92, 0xde, 0x11, 0x4a, 0x20,
-  0x74, 0x08, 0xa4, 0xa1, 0xb8, 0xd3, 0x5e, 0x68,
-  0xd6, 0x57, 0x85, 0x01, 0x89, 0x0c, 0x5e, 0xa0,
-  0x07, 0x1a, 0x07, 0x09, 0xf7, 0x11, 0x02, 0xeb,
-  0x07, 0x1e, 0xd3, 0x46, 0xad, 0x11, 0x94, 0x74,
-  0x1d, 0xd7, 0x29, 0xc3, 0x62, 0xf7, 0x24, 0x1f,
-  0x7c, 0x18, 0x38, 0xf8, 0x30, 0xc2, 0x86, 0x12,
-  0x03, 0x9f, 0xea, 0x66, 0xc1, 0x83, 0x86, 0xc6,
-  0x5e, 0xa0, 0x39, 0xce, 0x51, 0x44, 0xda, 0xf8,
-  0x5f, 0x01, 0xc3, 0x4f, 0x61, 0xb5, 0xe8, 0x62,
-  0x8c, 0xa0, 0x17, 0x57, 0x75, 0x0f, 0x36, 0xf1,
-  0x65, 0xc8, 0x1c, 0x02, 0x53, 0xab, 0xd0, 0x58,
-  0xba, 0xf6, 0x44, 0x00, 0x9d, 0xaf, 0x48, 0x22,
-  0x38, 0x85, 0x09, 0x48, 0x45, 0xe5, 0x28, 0x1a,
-  0xfb, 0x20, 0x6f, 0x38, 0x32, 0x14, 0x54, 0xb4,
-  0x63, 0xd0, 0x70, 0xd6, 0x82, 0xef, 0x5d, 0xd1,
-  0x9f, 0x56, 0x3d, 0xc6, 0x1c, 0xe2, 0x11, 0x5b,
-  0x46, 0x6a, 0xfd, 0x6e, 0x04, 0xad, 0x62, 0x8c,
-  0x07, 0x00, 0xe2, 0x32, 0xf8, 0x1c, 0xf0, 0x51,
-  0x57, 0xc0, 0xe0, 0x1c, 0x2a, 0xf1, 0x07, 0x09,
-  0xb0, 0xbe, 0x03, 0xb8, 0x09, 0xfd, 0x62, 0x8b,
-  0x45, 0xe1, 0x5d, 0x07, 0x2c, 0xb0, 0x4f, 0x17,
-  0xf4, 0x95, 0x00, 0x26, 0xc9, 0x4a, 0x18, 0x13,
-  0xe2, 0xb4, 0x6b, 0xd0, 0xb1, 0xd4, 0x11, 0x69,
-  0x69, 0xc2, 0xc8, 0x75, 0xf2, 0xc0, 0xe4, 0x64,
-  0x1d, 0x71, 0x80, 0xb8, 0x4c, 0xc6, 0x36, 0x3b,
-  0x64, 0x90, 0x38, 0xb3, 0x56, 0x18, 0x65, 0x08,
-  0x8c, 0x46, 0xb9, 0xfa, 0xbf, 0x0c, 0xaa, 0xc1,
-  0x26, 0x90, 0x1e, 0x8f, 0xff, 0xf2, 0x36, 0xba,
-  0x34, 0x56, 0x54, 0x2b, 0x03, 0x90, 0x9e, 0x9a,
-  0x31, 0x44, 0x18, 0x11, 0xfb, 0xc8, 0x13, 0x6b,
-  0xe9, 0x61, 0x24, 0xc4, 0x68, 0x85, 0x33, 0x25,
-  0x29, 0xa1, 0x15, 0x5d, 0xa4, 0xb2, 0xda, 0x15,
-  0x7e, 0x62, 0x35, 0x96, 0x20, 0xf3, 0xa4, 0x51,
-  0x79, 0xb0, 0xa5, 0x1f, 0x20, 0xc7, 0x80, 0x9b,
-  0xed, 0x24, 0xe2, 0x11, 0xab, 0xe8, 0xcb, 0xa1,
-  0x54, 0xcc, 0x44, 0x8b, 0x66, 0x76, 0x3a, 0x62,
-  0x20, 0x4f, 0xd7, 0xe2, 0x29, 0xbe, 0x92, 0x93,
-  0xb5, 0x90, 0x03, 0xba, 0x27, 0x7d, 0xb0, 0x39,
-  0x2b, 0xea, 0x31, 0x9f, 0x02, 0x7f, 0x78, 0x50,
-  0x80, 0x30, 0x3f, 0x68, 0x38, 0x90, 0x5e, 0x73,
-  0x5f, 0x4e, 0xc5, 0x83, 0x80, 0x58, 0x53, 0x64,
-  0x0e, 0xf5, 0x75, 0xea, 0xfd, 0x28, 0x01, 0xc2,
-  0x7d, 0x25, 0x24, 0x18, 0x21, 0x26, 0x63, 0x2e,
-  0x14, 0x03, 0x89, 0xb0, 0x4b, 0xd7, 0xcb, 0x40,
-  0x1c, 0x0e, 0x27, 0xf1, 0x0a, 0x25, 0x08, 0xf8,
-  0x0b, 0x00, 0x96, 0x57, 0x24, 0xb4, 0x1c, 0xbb,
-  0xf2, 0xc8, 0x90, 0x13, 0xdb, 0xc5, 0xf8, 0x0b,
-  0x8d, 0x77, 0x68, 0xc5, 0x12, 0x15, 0xd6, 0x58,
-  0x1c, 0x41, 0x0a, 0x24, 0x17, 0x74, 0x99, 0x86,
-  0x6e, 0x7b, 0x56, 0x5b, 0x8a, 0x1e, 0xb3, 0xa8,
-  0xcf, 0x6b, 0xb5, 0x34, 0x66, 0x18, 0x0c, 0x90,
-  0x0c, 0x0f, 0x6e, 0x12, 0x2e, 0x50, 0x30, 0x15,
-  0xb8, 0xa5, 0x61, 0xbd, 0xe7, 0x21, 0x0b, 0x51,
-  0x94, 0xd4, 0xe7, 0x03, 0x00, 0x75, 0x0a, 0xfb,
-  0xce, 0x9c, 0xab, 0xb2, 0x94, 0x48, 0x17, 0x0c,
-  0x02, 0x67, 0xc1, 0x91, 0x45, 0xa6, 0xc1, 0x3e,
-  0x49, 0x62, 0x34, 0x41, 0x33, 0xb4, 0x67, 0xd1,
-  0x5c, 0x9d, 0xe2, 0xe7, 0x62, 0xee, 0x55, 0x08,
-  0x81, 0xdc, 0x42, 0x0e, 0x21, 0x85, 0xe4, 0xef,
-  0x00, 0x78, 0x39, 0x18, 0x55, 0x2b, 0x92, 0xde,
-  0xf4, 0xd1, 0x48, 0x2e, 0x7c, 0x90, 0x91, 0x6e,
-  0x83, 0x84, 0xee, 0x4b, 0x16, 0x14, 0x55, 0xf5,
-  0x45, 0x10, 0x03, 0x9c, 0xe7, 0x0d, 0xf4, 0x90,
-  0x64, 0x0b, 0x17, 0xcd, 0x84, 0x96, 0x4a, 0xbc,
-  0x09, 0x37, 0x4a, 0x3a, 0x0f, 0x3d, 0x00, 0x19,
-  0x34, 0x74, 0x5f, 0x59, 0x41, 0x18, 0x17, 0x33,
-  0x95, 0x75, 0xe7, 0x14, 0x80, 0xee, 0x84, 0xcc,
-  0xae, 0x12, 0x80, 0xf2, 0x0d, 0xa4, 0x9d, 0xc9,
-  0x00, 0x79, 0x03, 0x3b, 0x5f, 0x5b, 0xc4, 0x3d,
-  0x82, 0xf0, 0x71, 0xf9, 0xb3, 0x88, 0xfb, 0xd0,
-  0x72, 0x09, 0xd1, 0xa4, 0xe2, 0xc8, 0x33, 0x7a,
-  0x8d, 0x00, 0x39, 0x08, 0x2e, 0xb5, 0xc0, 0xd4,
-  0xd7, 0x68, 0x38, 0x17, 0x5a, 0x33, 0xfa, 0xf3,
-  0x38, 0x83, 0x8b, 0x12, 0x21, 0x39, 0x2b, 0x94,
-  0xf5, 0x18, 0x38, 0x33, 0x21, 0x9b, 0x41, 0xf1,
-  0xe0, 0x07, 0xd2, 0x52, 0x59, 0x11, 0x92, 0x92,
-  0x2f, 0x41, 0xc4, 0x3d, 0x5e, 0x1e, 0xd3, 0x95,
-  0xc0, 0x71, 0x0c, 0x7a, 0xc5, 0x38, 0x8c, 0x6e,
-  0xed, 0x31, 0xb0, 0xe2, 0x82, 0x35, 0x09, 0x27,
-  0x3d, 0xaa, 0x72, 0xdc, 0x43, 0x04, 0x47, 0xc5,
-  0xa9, 0xb0, 0x9b, 0x7f
-};
diff --git a/contrib/apps/shell/shell.c b/contrib/apps/shell/shell.c
deleted file mode 100644
index a6a359cb..00000000
--- a/contrib/apps/shell/shell.c
+++ /dev/null
@@ -1,1277 +0,0 @@
-/*
- * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-
-#include "shell.h"
-
-#include "lwip/opt.h"
-
-#if LWIP_NETCONN && LWIP_TCP
-
-#include <string.h>
-#include <stdio.h>
-
-#include "lwip/mem.h"
-#include "lwip/debug.h"
-#include "lwip/def.h"
-#include "lwip/api.h"
-#include "lwip/stats.h"
-
-#if LWIP_SOCKET
-#include "lwip/errno.h"
-#include "lwip/if_api.h"
-#endif
-
-#ifdef WIN32
-#define NEWLINE "\r\n"
-#else /* WIN32 */
-#define NEWLINE "\n"
-#endif /* WIN32 */
-
-/** Define this to 1 if you want to echo back all received characters
- * (e.g. so they are displayed on a remote telnet)
- */
-#ifndef SHELL_ECHO
-#define SHELL_ECHO 0
-#endif
-
-#define BUFSIZE             1024
-static unsigned char buffer[BUFSIZE];
-
-struct command {
-  struct netconn *conn;
-  s8_t (* exec)(struct command *);
-  u8_t nargs;
-  char *args[10];
-};
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <limits.h>
-
-#define ESUCCESS 0
-#define ESYNTAX -1
-#define ETOOFEW -2
-#define ETOOMANY -3
-#define ECLOSED -4
-
-#define NCONNS 10
-static struct netconn *conns[NCONNS];
-
-/* help_msg is split into 3 strings to prevent exceeding the C89 maximum length of 509 per string */
-static char help_msg1[] = "Available commands:"NEWLINE"\
-open [IP address] [TCP port]: opens a TCP connection to the specified address."NEWLINE"\
-lstn [TCP port]: sets up a server on the specified port."NEWLINE"\
-acpt [connection #]: waits for an incoming connection request."NEWLINE"\
-send [connection #] [message]: sends a message on a TCP connection."NEWLINE"\
-udpc [local UDP port] [IP address] [remote port]: opens a UDP \"connection\"."NEWLINE"\
-udpl [local UDP port] [IP address] [remote port]: opens a UDP-Lite \"connection\"."NEWLINE"";
-static char help_msg2[] = "udpn [local UDP port] [IP address] [remote port]: opens a UDP \"connection\" without checksums."NEWLINE"\
-udpb [local port] [remote port]: opens a UDP broadcast \"connection\"."NEWLINE"\
-usnd [connection #] [message]: sends a message on a UDP connection."NEWLINE"\
-recv [connection #]: recieves data on a TCP or UDP connection."NEWLINE"\
-clos [connection #]: closes a TCP or UDP connection."NEWLINE"\
-stat: prints out lwIP statistics."NEWLINE"\
-idxtoname [index]: outputs interface name from index."NEWLINE"\
-nametoidx [name]: outputs interface index from name."NEWLINE;
-static char help_msg3[] =
-"gethostnm [name]: outputs IP address of host."NEWLINE"\
-quit: quits"NEWLINE"";
-
-#if LWIP_STATS
-static char padding_10spaces[] = "          ";
-
-#define PROTOCOL_STATS (LINK_STATS && ETHARP_STATS && IPFRAG_STATS && IP_STATS && ICMP_STATS && UDP_STATS && TCP_STATS)
-
-#if PROTOCOL_STATS
-static const char* shell_stat_proto_names[] = {
-#if LINK_STATS
-  "LINK      ",
-#endif
-#if ETHARP_STATS
-  "ETHARP    ",
-#endif
-#if IPFRAG_STATS
-  "IP_FRAG   ",
-#endif
-#if IP_STATS
-  "IP        ",
-#endif
-#if ICMP_STATS
-  "ICMP      ",
-#endif
-#if UDP_STATS
-  "UDP       ",
-#endif
-#if TCP_STATS
-  "TCP       ",
-#endif
-  "last"
-};
-
-static struct stats_proto* shell_stat_proto_stats[] = {
-#if LINK_STATS
-  &lwip_stats.link,
-#endif
-#if ETHARP_STATS
-  &lwip_stats.etharp,
-#endif
-#if IPFRAG_STATS
-  &lwip_stats.ip_frag,
-#endif
-#if IP_STATS
-  &lwip_stats.ip,
-#endif
-#if ICMP_STATS
-  &lwip_stats.icmp,
-#endif
-#if UDP_STATS
-  &lwip_stats.udp,
-#endif
-#if TCP_STATS
-  &lwip_stats.tcp,
-#endif
-};
-const size_t num_protostats = sizeof(shell_stat_proto_stats)/sizeof(struct stats_proto*);
-
-static const char *stat_msgs_proto[] = {
-  " * transmitted ",
-  "           * received ",
-  "             forwarded ",
-  "           * dropped ",
-  "           * checksum errors ",
-  "           * length errors ",
-  "           * memory errors ",
-  "             routing errors ",
-  "             protocol errors ",
-  "             option errors ",
-  "           * misc errors ",
-  "             cache hits "
-};
-#endif /* PROTOCOL_STATS */
-#endif /* LWIP_STATS */
-
-/*-----------------------------------------------------------------------------------*/
-static void
-sendstr(const char *str, struct netconn *conn)
-{
-  netconn_write(conn, (const void *)str, strlen(str), NETCONN_NOCOPY);
-}
-/*-----------------------------------------------------------------------------------*/
-static s8_t
-com_open(struct command *com)
-{
-  ip_addr_t ipaddr;
-  u16_t port;
-  int i;
-  err_t err;
-  long tmp;
-
-  if (ipaddr_aton(com->args[0], &ipaddr) == -1) {
-    sendstr(strerror(errno), com->conn);
-    return ESYNTAX;
-  }
-  tmp = strtol(com->args[1], NULL, 10);
-  if((tmp < 0) || (tmp > 0xffff)) {
-    sendstr("Invalid port number."NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-  port = (u16_t)tmp;
-
-  /* Find the first unused connection in conns. */
-  for(i = 0; i < NCONNS && conns[i] != NULL; i++);
-
-  if (i == NCONNS) {
-    sendstr("No more connections available, sorry."NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-
-  sendstr("Opening connection to ", com->conn);
-  netconn_write(com->conn, com->args[0], strlen(com->args[0]), NETCONN_COPY);
-  sendstr(":", com->conn);
-  netconn_write(com->conn, com->args[1], strlen(com->args[1]), NETCONN_COPY);
-  sendstr(NEWLINE, com->conn);
-
-  conns[i] = netconn_new(NETCONN_TCP);
-  if (conns[i] == NULL) {
-    sendstr("Could not create connection identifier (out of memory)."NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-  err = netconn_connect(conns[i], &ipaddr, port);
-  if (err != ERR_OK) {
-    fprintf(stderr, "error %s"NEWLINE, lwip_strerr(err));
-    sendstr("Could not connect to remote host: ", com->conn);
-#ifdef LWIP_DEBUG
-    sendstr(lwip_strerr(err), com->conn);
-#else
-    sendstr("(debugging must be turned on for error message to appear)", com->conn);
-#endif /* LWIP_DEBUG */
-    sendstr(NEWLINE, com->conn);
-    netconn_delete(conns[i]);
-    conns[i] = NULL;
-    return ESUCCESS;
-  }
-
-  sendstr("Opened connection, connection identifier is ", com->conn);
-  snprintf((char *)buffer, sizeof(buffer), "%d"NEWLINE, i);
-  netconn_write(com->conn, buffer, strlen((const char *)buffer), NETCONN_COPY);
-
-  return ESUCCESS;
-}
-/*-----------------------------------------------------------------------------------*/
-static s8_t
-com_lstn(struct command *com)
-{
-  u16_t port;
-  int i;
-  err_t err;
-  long tmp;
-
-  tmp = strtol(com->args[0], NULL, 10);
-  if((tmp < 0) || (tmp > 0xffff)) {
-    sendstr("Invalid port number."NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-  port = (u16_t)tmp;
-
-  /* Find the first unused connection in conns. */
-  for(i = 0; i < NCONNS && conns[i] != NULL; i++);
-
-  if (i == NCONNS) {
-    sendstr("No more connections available, sorry."NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-
-  sendstr("Opening a listening connection on port ", com->conn);
-  netconn_write(com->conn, com->args[0], strlen(com->args[0]), NETCONN_COPY);
-  sendstr(NEWLINE, com->conn);
-
-  conns[i] = netconn_new(NETCONN_TCP);
-  if (conns[i] == NULL) {
-    sendstr("Could not create connection identifier (out of memory)."NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-
-  err = netconn_bind(conns[i], IP_ADDR_ANY, port);
-  if (err != ERR_OK) {
-    netconn_delete(conns[i]);
-    conns[i] = NULL;
-    sendstr("Could not bind: ", com->conn);
-#ifdef LWIP_DEBUG
-    sendstr(lwip_strerr(err), com->conn);
-#else
-    sendstr("(debugging must be turned on for error message to appear)", com->conn);
-#endif /* LWIP_DEBUG */
-    sendstr(NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-
-  err = netconn_listen(conns[i]);
-  if (err != ERR_OK) {
-    netconn_delete(conns[i]);
-    conns[i] = NULL;
-    sendstr("Could not listen: ", com->conn);
-#ifdef LWIP_DEBUG
-    sendstr(lwip_strerr(err), com->conn);
-#else
-    sendstr("(debugging must be turned on for error message to appear)", com->conn);
-#endif /* LWIP_DEBUG */
-    sendstr(NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-
-  sendstr("Opened connection, connection identifier is ", com->conn);
-  snprintf((char *)buffer, sizeof(buffer), "%d"NEWLINE, i);
-  netconn_write(com->conn, buffer, strlen((const char *)buffer), NETCONN_COPY);
-
-  return ESUCCESS;
-}
-/*-----------------------------------------------------------------------------------*/
-/*-----------------------------------------------------------------------------------*/
-static s8_t
-com_clos(struct command *com)
-{
-  int i;
-  err_t err;
-
-  i = strtol(com->args[0], NULL, 10);
-
-  if (i > NCONNS) {
-    sendstr("Connection identifier too high."NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-  if (conns[i] == NULL) {
-    sendstr("Connection identifier not in use."NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-
-  err = netconn_close(conns[i]);
-  if (err != ERR_OK) {
-    sendstr("Could not close connection: ", com->conn);
-#ifdef LWIP_DEBUG
-    sendstr(lwip_strerr(err), com->conn);
-#else
-    sendstr("(debugging must be turned on for error message to appear)", com->conn);
-#endif /* LWIP_DEBUG */
-    sendstr(NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-
-  sendstr("Connection closed."NEWLINE, com->conn);
-  netconn_delete(conns[i]);
-  conns[i] = NULL;
-  return ESUCCESS;
-}
-/*-----------------------------------------------------------------------------------*/
-static s8_t
-com_acpt(struct command *com)
-{
-  int i, j;
-  err_t err;
-
-  /* Find the first unused connection in conns. */
-  for(j = 0; j < NCONNS && conns[j] != NULL; j++);
-
-  if (j == NCONNS) {
-    sendstr("No more connections available, sorry."NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-
-  i = strtol(com->args[0], NULL, 10);
-
-  if (i > NCONNS) {
-    sendstr("Connection identifier too high."NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-  if (conns[i] == NULL) {
-    sendstr("Connection identifier not in use."NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-
-  err = netconn_accept(conns[i], &conns[j]);
-
-  if (err != ERR_OK) {
-    sendstr("Could not accept connection: ", com->conn);
-#ifdef LWIP_DEBUG
-    sendstr(lwip_strerr(err), com->conn);
-#else
-    sendstr("(debugging must be turned on for error message to appear)", com->conn);
-#endif /* LWIP_DEBUG */
-    sendstr(NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-
-  sendstr("Accepted connection, connection identifier for new connection is ", com->conn);
-  snprintf((char *)buffer, sizeof(buffer), "%d"NEWLINE, j);
-  netconn_write(com->conn, buffer, strlen((const char *)buffer), NETCONN_COPY);
-
-  return ESUCCESS;
-}
-/*-----------------------------------------------------------------------------------*/
-#if LWIP_STATS
-static void
-com_stat_write_mem(struct netconn *conn, struct stats_mem *elem, int i)
-{
-  u16_t len;
-  char buf[100];
-  size_t slen;
-
-#ifdef LWIP_DEBUG
-  LWIP_UNUSED_ARG(i);
-  slen = strlen(elem->name);
-  netconn_write(conn, elem->name, slen, NETCONN_COPY);
-#else /*  LWIP_DEBUG */
-  len = (u16_t)sprintf(buf, "%d", i);
-  slen = strlen(buf);
-  netconn_write(conn, buf, slen, NETCONN_COPY);
-#endif /*  LWIP_DEBUG */
-  if(slen < 10) {
-    netconn_write(conn, padding_10spaces, 10-slen, NETCONN_COPY);
-  }
-
-  len = (u16_t)sprintf(buf, " * available %"MEM_SIZE_F NEWLINE, elem->avail);
-  netconn_write(conn, buf, len, NETCONN_COPY);
-  len = (u16_t)sprintf(buf, "           * used %"MEM_SIZE_F NEWLINE, elem->used);
-  netconn_write(conn, buf, len, NETCONN_COPY);
-  len = (u16_t)sprintf(buf, "           * high water mark %"MEM_SIZE_F NEWLINE, elem->max);
-  netconn_write(conn, buf, len, NETCONN_COPY);
-  len = (u16_t)sprintf(buf, "           * errors %"STAT_COUNTER_F NEWLINE, elem->err);
-  netconn_write(conn, buf, len, NETCONN_COPY);
-  len = (u16_t)sprintf(buf, "           * illegal %"STAT_COUNTER_F NEWLINE, elem->illegal);
-  netconn_write(conn, buf, len, NETCONN_COPY);
-}
-static void
-com_stat_write_sys(struct netconn *conn, struct stats_syselem *elem, const char *name)
-{
-  u16_t len;
-  char buf[100];
-  size_t slen = strlen(name);
-
-  netconn_write(conn, name, slen, NETCONN_COPY);
-  if(slen < 10) {
-    netconn_write(conn, padding_10spaces, 10-slen, NETCONN_COPY);
-  }
-
-  len = (u16_t)sprintf(buf, " * used %"STAT_COUNTER_F NEWLINE, elem->used);
-  netconn_write(conn, buf, len, NETCONN_COPY);
-  len = (u16_t)sprintf(buf, "           * high water mark %"STAT_COUNTER_F NEWLINE, elem->max);
-  netconn_write(conn, buf, len, NETCONN_COPY);
-  len = (u16_t)sprintf(buf, "           * errors %"STAT_COUNTER_F NEWLINE, elem->err);
-  netconn_write(conn, buf, len, NETCONN_COPY);
-}
-static s8_t
-com_stat(struct command *com)
-{
-#if PROTOCOL_STATS || MEMP_STATS
-  size_t i;
-#endif /* PROTOCOL_STATS || MEMP_STATS */
-#if PROTOCOL_STATS
-  size_t k;
-  char buf[100];
-  u16_t len;
-
-  /* protocol stats, @todo: add IGMP */
-  for(i = 0; i < num_protostats; i++) {
-    size_t s = sizeof(struct stats_proto)/sizeof(STAT_COUNTER);
-    STAT_COUNTER *c = &shell_stat_proto_stats[i]->xmit;
-    LWIP_ASSERT("stats not in sync", s == sizeof(stat_msgs_proto)/sizeof(char*));
-    netconn_write(com->conn, shell_stat_proto_names[i], strlen(shell_stat_proto_names[i]), NETCONN_COPY);
-    for(k = 0; k < s; k++) {
-      len = (u16_t)sprintf(buf, "%s%"STAT_COUNTER_F NEWLINE, stat_msgs_proto[k], c[k]);
-      netconn_write(com->conn, buf, len, NETCONN_COPY);
-    }
-  }
-#endif /* PROTOCOL_STATS */
-#if MEM_STATS
-  com_stat_write_mem(com->conn, &lwip_stats.mem, -1);
-#endif /* MEM_STATS */
-#if MEMP_STATS
-  for(i = 0; i < MEMP_MAX; i++) {
-    com_stat_write_mem(com->conn, lwip_stats.memp[i], -1);
-  }
-#endif /* MEMP_STATS */
-#if SYS_STATS
-  com_stat_write_sys(com->conn, &lwip_stats.sys.sem,   "SEM       ");
-  com_stat_write_sys(com->conn, &lwip_stats.sys.mutex, "MUTEX     ");
-  com_stat_write_sys(com->conn, &lwip_stats.sys.mbox,  "MBOX      ");
-#endif /* SYS_STATS */
-
-  return ESUCCESS;
-}
-#endif
-/*-----------------------------------------------------------------------------------*/
-static s8_t
-com_send(struct command *com)
-{
-  int i;
-  err_t err;
-  size_t len;
-
-  i = strtol(com->args[0], NULL, 10);
-
-  if (i > NCONNS) {
-    sendstr("Connection identifier too high."NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-
-  if (conns[i] == NULL) {
-    sendstr("Connection identifier not in use."NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-
-  len = strlen(com->args[1]);
-  com->args[1][len] = '\r';
-  com->args[1][len + 1] = '\n';
-  com->args[1][len + 2] = 0;
-
-  err = netconn_write(conns[i], com->args[1], len + 3, NETCONN_COPY);
-  if (err != ERR_OK) {
-    sendstr("Could not send data: ", com->conn);
-#ifdef LWIP_DEBUG
-    sendstr(lwip_strerr(err), com->conn);
-#else
-    sendstr("(debugging must be turned on for error message to appear)", com->conn);
-#endif /* LWIP_DEBUG */
-    sendstr(NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-
-  sendstr("Data enqueued for sending."NEWLINE, com->conn);
-  return ESUCCESS;
-}
-/*-----------------------------------------------------------------------------------*/
-static s8_t
-com_recv(struct command *com)
-{
-  int i;
-  err_t err;
-  struct netbuf *buf;
-  u16_t len;
-
-  i = strtol(com->args[0], NULL, 10);
-
-  if (i > NCONNS) {
-    sendstr("Connection identifier too high."NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-
-  if (conns[i] == NULL) {
-    sendstr("Connection identifier not in use."NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-
-  err = netconn_recv(conns[i], &buf);
-  if (err == ERR_OK) {
-
-    netbuf_copy(buf, buffer, BUFSIZE);
-    len = netbuf_len(buf);
-    sendstr("Reading from connection:"NEWLINE, com->conn);
-    netconn_write(com->conn, buffer, len, NETCONN_COPY);
-    netbuf_delete(buf);
-  } else {
-    sendstr("EOF."NEWLINE, com->conn);
-  }
-  err = netconn_err(conns[i]);
-  if (err != ERR_OK) {
-    sendstr("Could not receive data: ", com->conn);
-#ifdef LWIP_DEBUG
-    sendstr(lwip_strerr(err), com->conn);
-#else
-    sendstr("(debugging must be turned on for error message to appear)", com->conn);
-#endif /* LWIP_DEBUG */
-    sendstr(NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-  return ESUCCESS;
-}
-/*-----------------------------------------------------------------------------------*/
-static s8_t
-com_udpc(struct command *com)
-{
-  ip_addr_t ipaddr;
-  u16_t lport, rport;
-  int i;
-  err_t err;
-  long tmp;
-
-  tmp = strtol(com->args[0], NULL, 10);
-  if((tmp < 0) || (tmp > 0xffff)) {
-    sendstr("Invalid port number."NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-  lport = (u16_t)tmp;
-  if (ipaddr_aton(com->args[1], &ipaddr) == -1) {
-    sendstr(strerror(errno), com->conn);
-    return ESYNTAX;
-  }
-  tmp = strtol(com->args[2], NULL, 10);
-  if((tmp < 0) || (tmp > 0xffff)) {
-    sendstr("Invalid port number."NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-  rport = (u16_t)tmp;
-
-  /* Find the first unused connection in conns. */
-  for(i = 0; i < NCONNS && conns[i] != NULL; i++);
-
-  if (i == NCONNS) {
-    sendstr("No more connections available, sorry."NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-
-  sendstr("Setting up UDP connection from port ", com->conn);
-  netconn_write(com->conn, com->args[0], strlen(com->args[0]), NETCONN_COPY);
-  sendstr(" to ", com->conn);
-  netconn_write(com->conn, com->args[1], strlen(com->args[1]), NETCONN_COPY);
-  sendstr(":", com->conn);
-  netconn_write(com->conn, com->args[2], strlen(com->args[2]), NETCONN_COPY);
-  sendstr(NEWLINE, com->conn);
-
-  conns[i] = netconn_new(NETCONN_UDP);
-  if (conns[i] == NULL) {
-    sendstr("Could not create connection identifier (out of memory)."NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-
-  err = netconn_connect(conns[i], &ipaddr, rport);
-  if (err != ERR_OK) {
-    netconn_delete(conns[i]);
-    conns[i] = NULL;
-    sendstr("Could not connect to remote host: ", com->conn);
-#ifdef LWIP_DEBUG
-    sendstr(lwip_strerr(err), com->conn);
-#else
-    sendstr("(debugging must be turned on for error message to appear)", com->conn);
-#endif /* LWIP_DEBUG */
-    sendstr(NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-
-  err = netconn_bind(conns[i], IP_ADDR_ANY, lport);
-  if (err != ERR_OK) {
-    netconn_delete(conns[i]);
-    conns[i] = NULL;
-    sendstr("Could not bind: ", com->conn);
-#ifdef LWIP_DEBUG
-    sendstr(lwip_strerr(err), com->conn);
-#else
-    sendstr("(debugging must be turned on for error message to appear)", com->conn);
-#endif /* LWIP_DEBUG */
-    sendstr(NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-
-  sendstr("Connection set up, connection identifier is ", com->conn);
-  snprintf((char *)buffer, sizeof(buffer), "%d"NEWLINE, i);
-  netconn_write(com->conn, buffer, strlen((const char *)buffer), NETCONN_COPY);
-
-  return ESUCCESS;
-}
-/*-----------------------------------------------------------------------------------*/
-static s8_t
-com_udpl(struct command *com)
-{
-  ip_addr_t ipaddr;
-  u16_t lport, rport;
-  int i;
-  err_t err;
-  long tmp;
-
-  tmp = strtol(com->args[0], NULL, 10);
-  if((tmp < 0) || (tmp > 0xffff)) {
-    sendstr("Invalid port number."NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-  lport = (u16_t)tmp;
-  if (ipaddr_aton(com->args[1], &ipaddr) == -1) {
-    sendstr(strerror(errno), com->conn);
-    return ESYNTAX;
-  }
-  tmp = strtol(com->args[2], NULL, 10);
-  if((tmp < 0) || (tmp > 0xffff)) {
-    sendstr("Invalid port number."NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-  rport = (u16_t)tmp;
-
-  /* Find the first unused connection in conns. */
-  for(i = 0; i < NCONNS && conns[i] != NULL; i++);
-
-  if (i == NCONNS) {
-    sendstr("No more connections available, sorry."NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-
-  sendstr("Setting up UDP-Lite connection from port ", com->conn);
-  netconn_write(com->conn, com->args[0], strlen(com->args[0]), NETCONN_COPY);
-  sendstr(" to ", com->conn);
-  netconn_write(com->conn, com->args[1], strlen(com->args[1]), NETCONN_COPY);
-  sendstr(":", com->conn);
-  netconn_write(com->conn, com->args[2], strlen(com->args[2]), NETCONN_COPY);
-  sendstr(NEWLINE, com->conn);
-
-  conns[i] = netconn_new(NETCONN_UDPLITE);
-  if (conns[i] == NULL) {
-    sendstr("Could not create connection identifier (out of memory)."NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-
-  err = netconn_connect(conns[i], &ipaddr, rport);
-  if (err != ERR_OK) {
-    netconn_delete(conns[i]);
-    conns[i] = NULL;
-    sendstr("Could not connect to remote host: ", com->conn);
-#ifdef LWIP_DEBUG
-    sendstr(lwip_strerr(err), com->conn);
-#else
-    sendstr("(debugging must be turned on for error message to appear)", com->conn);
-#endif /* LWIP_DEBUG */
-    sendstr(NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-
-  err = netconn_bind(conns[i], IP_ADDR_ANY, lport);
-  if (err != ERR_OK) {
-    netconn_delete(conns[i]);
-    conns[i] = NULL;
-    sendstr("Could not bind: ", com->conn);
-#ifdef LWIP_DEBUG
-    sendstr(lwip_strerr(err), com->conn);
-#else
-    sendstr("(debugging must be turned on for error message to appear)", com->conn);
-#endif /* LWIP_DEBUG */
-    sendstr(NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-
-  sendstr("Connection set up, connection identifier is ", com->conn);
-  snprintf((char *)buffer, sizeof(buffer), "%d"NEWLINE, i);
-  netconn_write(com->conn, buffer, strlen((const char *)buffer), NETCONN_COPY);
-
-  return ESUCCESS;
-}
-/*-----------------------------------------------------------------------------------*/
-static s8_t
-com_udpn(struct command *com)
-{
-  ip_addr_t ipaddr;
-  u16_t lport, rport;
-  int i;
-  err_t err;
-  long tmp;
-
-  tmp = strtol(com->args[0], NULL, 10);
-  if((tmp < 0) || (tmp > 0xffff)) {
-    sendstr("Invalid port number."NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-  lport = (u16_t)tmp;
-  if (ipaddr_aton(com->args[1], &ipaddr) == -1) {
-    sendstr(strerror(errno), com->conn);
-    return ESYNTAX;
-  }
-  tmp = strtol(com->args[2], NULL, 10);
-  if((tmp < 0) || (tmp > 0xffff)) {
-    sendstr("Invalid port number."NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-  rport = (u16_t)tmp;
-
-  /* Find the first unused connection in conns. */
-  for(i = 0; i < NCONNS && conns[i] != NULL; i++);
-
-  if (i == NCONNS) {
-    sendstr("No more connections available, sorry."NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-
-  sendstr("Setting up UDP connection without checksums from port ", com->conn);
-  netconn_write(com->conn, com->args[0], strlen(com->args[0]), NETCONN_COPY);
-  sendstr(" to ", com->conn);
-  netconn_write(com->conn, com->args[1], strlen(com->args[1]), NETCONN_COPY);
-  sendstr(":", com->conn);
-  netconn_write(com->conn, com->args[2], strlen(com->args[2]), NETCONN_COPY);
-  sendstr(NEWLINE, com->conn);
-
-  conns[i] = netconn_new(NETCONN_UDPNOCHKSUM);
-  if (conns[i] == NULL) {
-    sendstr("Could not create connection identifier (out of memory)."NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-
-  err = netconn_connect(conns[i], &ipaddr, rport);
-  if (err != ERR_OK) {
-    netconn_delete(conns[i]);
-    conns[i] = NULL;
-    sendstr("Could not connect to remote host: ", com->conn);
-#ifdef LWIP_DEBUG
-    sendstr(lwip_strerr(err), com->conn);
-#else
-    sendstr("(debugging must be turned on for error message to appear)", com->conn);
-#endif /* LWIP_DEBUG */
-    sendstr(NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-
-  err = netconn_bind(conns[i], IP_ADDR_ANY, lport);
-  if (err != ERR_OK) {
-    netconn_delete(conns[i]);
-    conns[i] = NULL;
-    sendstr("Could not bind: ", com->conn);
-#ifdef LWIP_DEBUG
-    sendstr(lwip_strerr(err), com->conn);
-#else
-    sendstr("(debugging must be turned on for error message to appear)", com->conn);
-#endif /* LWIP_DEBUG */
-    sendstr(NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-
-  sendstr("Connection set up, connection identifier is ", com->conn);
-  snprintf((char *)buffer, sizeof(buffer), "%d"NEWLINE, i);
-  netconn_write(com->conn, buffer, strlen((const char *)buffer), NETCONN_COPY);
-
-  return ESUCCESS;
-}
-/*-----------------------------------------------------------------------------------*/
-static s8_t
-com_udpb(struct command *com)
-{
-  ip_addr_t ipaddr;
-#if LWIP_IPV4
-  u16_t lport;
-#endif /* LWIP_IPV4 */
-  u16_t rport;
-  int i;
-  err_t err;
-  long tmp;
-
-  tmp = strtol(com->args[0], NULL, 10);
-  if((tmp < 0) || (tmp > 0xffff)) {
-    sendstr("Invalid port number."NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-#if LWIP_IPV4
-  lport = (u16_t)tmp;
-#endif /* LWIP_IPV4 */
-  if (ipaddr_aton(com->args[1], &ipaddr) == -1) {
-    sendstr(strerror(errno), com->conn);
-    return ESYNTAX;
-  }
-  tmp = strtol(com->args[2], NULL, 10);
-  if((tmp < 0) || (tmp > 0xffff)) {
-    sendstr("Invalid port number."NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-  rport = (u16_t)tmp;
-
-  /* Find the first unused connection in conns. */
-  for(i = 0; i < NCONNS && conns[i] != NULL; i++);
-
-  if (i == NCONNS) {
-    sendstr("No more connections available, sorry."NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-
-  sendstr("Setting up UDP broadcast connection from port ", com->conn);
-  netconn_write(com->conn, com->args[0], strlen(com->args[0]), NETCONN_COPY);
-  sendstr(" to ", com->conn);
-  netconn_write(com->conn, com->args[1], strlen(com->args[1]), NETCONN_COPY);
-  sendstr(NEWLINE, com->conn);
-
-  conns[i] = netconn_new(NETCONN_UDP);
-  if (conns[i] == NULL) {
-    sendstr("Could not create connection identifier (out of memory)."NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-
-  err = netconn_connect(conns[i], &ipaddr, rport);
-  if (err != ERR_OK) {
-    netconn_delete(conns[i]);
-    conns[i] = NULL;
-    sendstr("Could not connect to remote host: ", com->conn);
-#ifdef LWIP_DEBUG
-    sendstr(lwip_strerr(err), com->conn);
-#else
-    sendstr("(debugging must be turned on for error message to appear)", com->conn);
-#endif /* LWIP_DEBUG */
-    sendstr(NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-
-#if LWIP_IPV4
-  if (IP_IS_V6_VAL(ipaddr)) {
-    err = netconn_bind(conns[i], &ip_addr_broadcast, lport);
-    if (err != ERR_OK) {
-      netconn_delete(conns[i]);
-      conns[i] = NULL;
-      sendstr("Could not bind: ", com->conn);
-#ifdef LWIP_DEBUG
-      sendstr(lwip_strerr(err), com->conn);
-#else
-      sendstr("(debugging must be turned on for error message to appear)", com->conn);
-#endif /* LWIP_DEBUG */
-      sendstr(NEWLINE, com->conn);
-      return ESUCCESS;
-    }
-  }
-#endif /* LWIP_IPV4 */
-
-  sendstr("Connection set up, connection identifier is ", com->conn);
-  snprintf((char *)buffer, sizeof(buffer), "%d"NEWLINE, i);
-  netconn_write(com->conn, buffer, strlen((const char *)buffer), NETCONN_COPY);
-
-  return ESUCCESS;
-}
-/*-----------------------------------------------------------------------------------*/
-static s8_t
-com_usnd(struct command *com)
-{
-  long i;
-  err_t err;
-  struct netbuf *buf;
-  char *mem;
-  u16_t len;
-  size_t tmp;
-
-  i = strtol(com->args[0], NULL, 10);
-
-  if (i > NCONNS) {
-    sendstr("Connection identifier too high."NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-
-  if (conns[i] == NULL) {
-    sendstr("Connection identifier not in use."NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-  tmp = strlen(com->args[1]) + 1;
-  if (tmp > 0xffff) {
-    sendstr("Invalid length."NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-  len = (u16_t)tmp;
-
-  buf = netbuf_new();
-  mem = (char *)netbuf_alloc(buf, len);
-  if (mem == NULL) {
-    sendstr("Could not allocate memory for sending."NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-  strncpy(mem, com->args[1], len);
-  err = netconn_send(conns[i], buf);
-  netbuf_delete(buf);
-  if (err != ERR_OK) {
-    sendstr("Could not send data: ", com->conn);
-#ifdef LWIP_DEBUG
-    sendstr(lwip_strerr(err), com->conn);
-#else
-    sendstr("(debugging must be turned on for error message to appear)", com->conn);
-#endif /* LWIP_DEBUG */
-    sendstr(NEWLINE, com->conn);
-    return ESUCCESS;
-  }
-
-  sendstr("Data sent."NEWLINE, com->conn);
-  return ESUCCESS;
-}
-/*-----------------------------------------------------------------------------------*/
-#if LWIP_SOCKET
-/*-----------------------------------------------------------------------------------*/
-static s8_t
-com_idxtoname(struct command *com)
-{
-  long i = strtol(com->args[0], NULL, 10);
-
-  if (lwip_if_indextoname((unsigned int)i, (char *)buffer)) {
-    netconn_write(com->conn, buffer, strlen((const char *)buffer), NETCONN_COPY);
-    sendstr(NEWLINE, com->conn);
-  } else {
-    snprintf((char *)buffer, sizeof(buffer), "if_indextoname() failed: %d"NEWLINE, errno);
-    netconn_write(com->conn, buffer, strlen((const char *)buffer), NETCONN_COPY);
-  }
-  return ESUCCESS;
-}
-/*-----------------------------------------------------------------------------------*/
-static s8_t
-com_nametoidx(struct command *com)
-{
-  unsigned int idx = lwip_if_nametoindex(com->args[0]);
-
-  if (idx) {
-    snprintf((char *)buffer, sizeof(buffer), "%u"NEWLINE, idx);
-    netconn_write(com->conn, buffer, strlen((const char *)buffer), NETCONN_COPY);
-  } else {
-    sendstr("No interface found"NEWLINE, com->conn);
-  }
-  return ESUCCESS;
-}
-#endif /* LWIP_SOCKET */
-/*-----------------------------------------------------------------------------------*/
-#if LWIP_DNS
-static s8_t
-com_gethostbyname(struct command *com)
-{
-  ip_addr_t addr;
-  err_t err = netconn_gethostbyname(com->args[0], &addr);
-
-  if (err == ERR_OK) {
-    if (ipaddr_ntoa_r(&addr, (char *)buffer, sizeof(buffer))) {
-      sendstr("Host found: ", com->conn);
-      sendstr((char *)buffer, com->conn);
-      sendstr(NEWLINE, com->conn);
-    } else {
-        sendstr("ipaddr_ntoa_r failed", com->conn);
-    }
-  } else {
-    sendstr("No host found"NEWLINE, com->conn);
-  }
-  return ESUCCESS;
-}
-#endif /* LWIP_DNS */
-/*-----------------------------------------------------------------------------------*/
-static s8_t
-com_help(struct command *com)
-{
-  sendstr(help_msg1, com->conn);
-  sendstr(help_msg2, com->conn);
-  sendstr(help_msg3, com->conn);
-  return ESUCCESS;
-}
-/*-----------------------------------------------------------------------------------*/
-static s8_t
-parse_command(struct command *com, u32_t len)
-{
-  u16_t i;
-  u16_t bufp;
-
-  if (strncmp((const char *)buffer, "open", 4) == 0) {
-    com->exec = com_open;
-    com->nargs = 2;
-  } else if (strncmp((const char *)buffer, "lstn", 4) == 0) {
-    com->exec = com_lstn;
-    com->nargs = 1;
-  } else if (strncmp((const char *)buffer, "acpt", 4) == 0) {
-    com->exec = com_acpt;
-    com->nargs = 1;
-  } else if (strncmp((const char *)buffer, "clos", 4) == 0) {
-    com->exec = com_clos;
-    com->nargs = 1;
-#if LWIP_STATS
-  } else if (strncmp((const char *)buffer, "stat", 4) == 0) {
-    com->exec = com_stat;
-    com->nargs = 0;
-#endif
-  } else if (strncmp((const char *)buffer, "send", 4) == 0) {
-    com->exec = com_send;
-    com->nargs = 2;
-  } else if (strncmp((const char *)buffer, "recv", 4) == 0) {
-    com->exec = com_recv;
-    com->nargs = 1;
-  } else if (strncmp((const char *)buffer, "udpc", 4) == 0) {
-    com->exec = com_udpc;
-    com->nargs = 3;
-  } else if (strncmp((const char *)buffer, "udpb", 4) == 0) {
-    com->exec = com_udpb;
-    com->nargs = 2;
-  } else if (strncmp((const char *)buffer, "udpl", 4) == 0) {
-    com->exec = com_udpl;
-    com->nargs = 3;
-  } else if (strncmp((const char *)buffer, "udpn", 4) == 0) {
-    com->exec = com_udpn;
-    com->nargs = 3;
-  } else if (strncmp((const char *)buffer, "usnd", 4) == 0) {
-    com->exec = com_usnd;
-    com->nargs = 2;
-#if LWIP_SOCKET
-  } else if (strncmp((const char *)buffer, "idxtoname", 9) == 0) {
-    com->exec = com_idxtoname;
-    com->nargs = 1;
-  } else if (strncmp((const char *)buffer, "nametoidx", 9) == 0) {
-    com->exec = com_nametoidx;
-    com->nargs = 1;
-#endif /* LWIP_SOCKET */
-#if LWIP_DNS
-  } else if (strncmp((const char *)buffer, "gethostnm", 9) == 0) {
-    com->exec = com_gethostbyname;
-    com->nargs = 1;
-#endif /* LWIP_DNS */
-  } else if (strncmp((const char *)buffer, "help", 4) == 0) {
-    com->exec = com_help;
-    com->nargs = 0;
-  } else if (strncmp((const char *)buffer, "quit", 4) == 0) {
-    printf("quit"NEWLINE);
-    return ECLOSED;
-  } else {
-    return ESYNTAX;
-  }
-
-  if (com->nargs == 0) {
-    return ESUCCESS;
-  }
-  bufp = 0;
-  for(; bufp < len && buffer[bufp] != ' '; bufp++);
-  for(i = 0; i < 10; i++) {
-    for(; bufp < len && buffer[bufp] == ' '; bufp++);
-    if (buffer[bufp] == '\r' ||
-       buffer[bufp] == '\n') {
-      buffer[bufp] = 0;
-      if (i < com->nargs - 1) {
-        return ETOOFEW;
-      }
-      if (i > com->nargs - 1) {
-        return ETOOMANY;
-      }
-      break;
-    }
-    if (bufp > len) {
-      return ETOOFEW;
-    }
-    com->args[i] = (char *)&buffer[bufp];
-    for(; bufp < len && buffer[bufp] != ' ' && buffer[bufp] != '\r' &&
-      buffer[bufp] != '\n'; bufp++) {
-      if (buffer[bufp] == '\\') {
-        buffer[bufp] = ' ';
-      }
-    }
-    if (bufp > len) {
-      return ESYNTAX;
-    }
-    buffer[bufp] = 0;
-    bufp++;
-    if (i == com->nargs - 1) {
-      break;
-    }
-
-  }
-
-  return ESUCCESS;
-}
-/*-----------------------------------------------------------------------------------*/
-static void
-shell_error(s8_t err, struct netconn *conn)
-{
-  switch (err) {
-  case ESYNTAX:
-    sendstr("## Syntax error"NEWLINE, conn);
-    break;
-  case ETOOFEW:
-    sendstr("## Too few arguments to command given"NEWLINE, conn);
-    break;
-  case ETOOMANY:
-    sendstr("## Too many arguments to command given"NEWLINE, conn);
-    break;
-  case ECLOSED:
-    sendstr("## Connection closed"NEWLINE, conn);
-    break;
-  default:
-    /* unknown error, don't assert here */
-    break;
-  }
-}
-/*-----------------------------------------------------------------------------------*/
-static void
-prompt(struct netconn *conn)
-{
-  sendstr("> ", conn);
-}
-/*-----------------------------------------------------------------------------------*/
-static void
-shell_main(struct netconn *conn)
-{
-  struct pbuf *p;
-  u16_t len = 0, cur_len;
-  struct command com;
-  s8_t err;
-  int i;
-  err_t ret;
-#if SHELL_ECHO
-  void *echomem;
-#endif /* SHELL_ECHO */
-
-  do {
-    ret = netconn_recv_tcp_pbuf(conn, &p);
-    if (ret == ERR_OK) {
-      pbuf_copy_partial(p, &buffer[len], (u16_t)(BUFSIZE - len), 0);
-      cur_len = p->tot_len;
-      len = (u16_t)(len + cur_len);
-      if ((len < cur_len) || (len > BUFSIZE)) {
-        len = BUFSIZE;
-      }
-#if SHELL_ECHO
-      echomem = mem_malloc(cur_len);
-      if (echomem != NULL) {
-        pbuf_copy_partial(p, echomem, cur_len, 0);
-        netconn_write(conn, echomem, cur_len, NETCONN_COPY);
-        mem_free(echomem);
-      }
-#endif /* SHELL_ECHO */
-      pbuf_free(p);
-      if (((len > 0) && ((buffer[len-1] == '\r') || (buffer[len-1] == '\n'))) ||
-          (len >= BUFSIZE)) {
-        if (buffer[0] != 0xff &&
-           buffer[1] != 0xfe) {
-          err = parse_command(&com, len);
-          if (err == ESUCCESS) {
-            com.conn = conn;
-            err = com.exec(&com);
-          }
-          if (err == ECLOSED) {
-            printf("Closed"NEWLINE);
-            shell_error(err, conn);
-            goto close;
-          }
-          if (err != ESUCCESS) {
-            shell_error(err, conn);
-          }
-        } else {
-          sendstr(NEWLINE NEWLINE
-                  "lwIP simple interactive shell."NEWLINE
-                  "(c) Copyright 2001, Swedish Institute of Computer Science."NEWLINE
-                  "Written by Adam Dunkels."NEWLINE
-                  "For help, try the \"help\" command."NEWLINE, conn);
-        }
-        if (ret == ERR_OK) {
-          prompt(conn);
-        }
-        len = 0;
-      }
-    }
-  } while (ret == ERR_OK);
-  printf("err %s"NEWLINE, lwip_strerr(ret));
-
-close:
-  netconn_close(conn);
-
-  for(i = 0; i < NCONNS; i++) {
-    if (conns[i] != NULL) {
-      netconn_delete(conns[i]);
-    }
-    conns[i] = NULL;
-  }
-}
-/*-----------------------------------------------------------------------------------*/
-static void
-shell_thread(void *arg)
-{
-  struct netconn *conn, *newconn;
-  err_t err;
-  LWIP_UNUSED_ARG(arg);
-
-#if LWIP_IPV6
-  conn = netconn_new(NETCONN_TCP_IPV6);
-  LWIP_ERROR("shell: invalid conn", (conn != NULL), return;);
-  err = netconn_bind(conn, IP6_ADDR_ANY, 23);
-#else /* LWIP_IPV6 */
-  conn = netconn_new(NETCONN_TCP);
-  LWIP_ERROR("shell: invalid conn", (conn != NULL), return;);
-  err = netconn_bind(conn, IP_ADDR_ANY, 23);
-#endif /* LWIP_IPV6 */
-  LWIP_ERROR("shell: netconn_bind failed", (err == ERR_OK), netconn_delete(conn); return;);
-  err = netconn_listen(conn);
-  LWIP_ERROR("shell: netconn_listen failed", (err == ERR_OK), netconn_delete(conn); return;);
-
-  while (1) {
-    err = netconn_accept(conn, &newconn);
-    if (err == ERR_OK) {
-      shell_main(newconn);
-      netconn_delete(newconn);
-    }
-  }
-}
-/*-----------------------------------------------------------------------------------*/
-void
-shell_init(void)
-{
-  sys_thread_new("shell_thread", shell_thread, NULL, DEFAULT_THREAD_STACKSIZE, DEFAULT_THREAD_PRIO);
-}
-
-#endif /* LWIP_NETCONN && LWIP_TCP */
diff --git a/contrib/apps/shell/shell.h b/contrib/apps/shell/shell.h
deleted file mode 100644
index 1ba9d192..00000000
--- a/contrib/apps/shell/shell.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-#ifndef LWIP_SHELL_H
-#define LWIP_SHELL_H
-
-void shell_init(void);
-
-#endif /* LWIP_SHELL_H */
diff --git a/contrib/apps/socket_examples/socket_examples.c b/contrib/apps/socket_examples/socket_examples.c
deleted file mode 100644
index e7af5ee3..00000000
--- a/contrib/apps/socket_examples/socket_examples.c
+++ /dev/null
@@ -1,680 +0,0 @@
-
-#include "socket_examples.h"
-
-#include "lwip/opt.h"
-
-#if LWIP_SOCKET && (LWIP_IPV4 || LWIP_IPV6)
-
-#include "lwip/sockets.h"
-#include "lwip/sys.h"
-
-#include <string.h>
-#include <stdio.h>
-
-#ifndef SOCK_TARGET_HOST4
-#define SOCK_TARGET_HOST4  "192.168.0.1"
-#endif
-
-#ifndef SOCK_TARGET_HOST6
-#define SOCK_TARGET_HOST6  "FE80::12:34FF:FE56:78AB"
-#endif
-
-#ifndef SOCK_TARGET_PORT
-#define SOCK_TARGET_PORT  80
-#endif
-
-#ifndef SOCK_TARGET_MAXHTTPPAGESIZE
-#define SOCK_TARGET_MAXHTTPPAGESIZE 1024
-#endif
-
-#ifndef SOCKET_EXAMPLES_RUN_PARALLEL
-#define SOCKET_EXAMPLES_RUN_PARALLEL 0
-#endif
-
-const u8_t cmpbuf[8] = {0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab};
-
-/* a helper struct to ensure memory before/after fd_set is not touched */
-typedef struct _xx
-{
-  u8_t buf1[8];
-  fd_set readset;
-  u8_t buf2[8];
-  fd_set writeset;
-  u8_t buf3[8];
-  fd_set errset;
-  u8_t buf4[8];
-} fdsets;
-
-#define INIT_FDSETS(sets) do { \
-  memset((sets)->buf1, 0xab, 8); \
-  memset((sets)->buf2, 0xab, 8); \
-  memset((sets)->buf3, 0xab, 8); \
-  memset((sets)->buf4, 0xab, 8); \
-}while(0)
-
-#define CHECK_FDSETS(sets) do { \
-  LWIP_ASSERT("buf1 fail", !memcmp((sets)->buf1, cmpbuf, 8)); \
-  LWIP_ASSERT("buf2 fail", !memcmp((sets)->buf2, cmpbuf, 8)); \
-  LWIP_ASSERT("buf3 fail", !memcmp((sets)->buf3, cmpbuf, 8)); \
-  LWIP_ASSERT("buf4 fail", !memcmp((sets)->buf4, cmpbuf, 8)); \
-}while(0)
-
-static ip_addr_t dstaddr;
-
-/** This is an example function that tests
-    blocking- and nonblocking connect. */
-static void
-sockex_nonblocking_connect(void *arg)
-{
-#if LWIP_SOCKET_SELECT
-  int s;
-  int ret;
-  int opt;
-#if LWIP_IPV6
-  struct sockaddr_in6 addr;
-#else /* LWIP_IPV6 */
-  struct sockaddr_in addr;
-#endif /* LWIP_IPV6 */
-  fdsets sets;
-  struct timeval tv;
-  u32_t ticks_a, ticks_b;
-  int err;
-  const ip_addr_t *ipaddr = (const ip_addr_t*)arg;
-  struct pollfd fds;
-  INIT_FDSETS(&sets);
-
-  /* set up address to connect to */
-  memset(&addr, 0, sizeof(addr));
-#if LWIP_IPV6
-  addr.sin6_len = sizeof(addr);
-  addr.sin6_family = AF_INET6;
-  addr.sin6_port = PP_HTONS(SOCK_TARGET_PORT);
-  inet6_addr_from_ip6addr(&addr.sin6_addr, ip_2_ip6(ipaddr));
-#else /* LWIP_IPV6 */
-  addr.sin_len = sizeof(addr);
-  addr.sin_family = AF_INET;
-  addr.sin_port = PP_HTONS(SOCK_TARGET_PORT);
-  inet_addr_from_ip4addr(&addr.sin_addr, ip_2_ip4(ipaddr));
-#endif /* LWIP_IPV6 */
-
-  /* first try blocking: */
-
-  /* create the socket */
-#if LWIP_IPV6
-  s = lwip_socket(AF_INET6, SOCK_STREAM, 0);
-#else /* LWIP_IPV6 */
-  s = lwip_socket(AF_INET, SOCK_STREAM, 0);
-#endif /* LWIP_IPV6 */
-  LWIP_ASSERT("s >= 0", s >= 0);
-
-  /* connect */
-  ret = lwip_connect(s, (struct sockaddr*)&addr, sizeof(addr));
-  /* should succeed */
-  LWIP_ASSERT("ret == 0", ret == 0);
-
-  /* write something */
-  ret = lwip_write(s, "test", 4);
-  LWIP_ASSERT("ret == 4", ret == 4);
-
-  /* close */
-  ret = lwip_close(s);
-  LWIP_ASSERT("ret == 0", ret == 0);
-
-  /* now try nonblocking and close before being connected */
-
-  /* create the socket */
-#if LWIP_IPV6
-  s = lwip_socket(AF_INET6, SOCK_STREAM, 0);
-#else /* LWIP_IPV6 */
-  s = lwip_socket(AF_INET, SOCK_STREAM, 0);
-#endif /* LWIP_IPV6 */
-  LWIP_ASSERT("s >= 0", s >= 0);
-  /* nonblocking */
-  opt = lwip_fcntl(s, F_GETFL, 0);
-  LWIP_ASSERT("ret != -1", ret != -1);
-  opt |= O_NONBLOCK;
-  ret = lwip_fcntl(s, F_SETFL, opt);
-  LWIP_ASSERT("ret != -1", ret != -1);
-  /* connect */
-  ret = lwip_connect(s, (struct sockaddr*)&addr, sizeof(addr));
-  /* should have an error: "inprogress" */
-  LWIP_ASSERT("ret == -1", ret == -1);
-  err = errno;
-  LWIP_ASSERT("errno == EINPROGRESS", err == EINPROGRESS);
-  /* close */
-  ret = lwip_close(s);
-  LWIP_ASSERT("ret == 0", ret == 0);
-  /* try to close again, should fail with EBADF */
-  ret = lwip_close(s);
-  LWIP_ASSERT("ret == -1", ret == -1);
-  err = errno;
-  LWIP_ASSERT("errno == EBADF", err == EBADF);
-  printf("closing socket in nonblocking connect succeeded\n");
-
-  /* now try nonblocking, connect should succeed:
-     this test only works if it is fast enough, i.e. no breakpoints, please! */
-
-  /* create the socket */
-#if LWIP_IPV6
-  s = lwip_socket(AF_INET6, SOCK_STREAM, 0);
-#else /* LWIP_IPV6 */
-  s = lwip_socket(AF_INET, SOCK_STREAM, 0);
-#endif /* LWIP_IPV6 */
-  LWIP_ASSERT("s >= 0", s >= 0);
-
-  /* nonblocking */
-  opt = 1;
-  ret = lwip_ioctl(s, FIONBIO, &opt);
-  LWIP_ASSERT("ret == 0", ret == 0);
-
-  /* connect */
-  ret = lwip_connect(s, (struct sockaddr*)&addr, sizeof(addr));
-  /* should have an error: "inprogress" */
-  LWIP_ASSERT("ret == -1", ret == -1);
-  err = errno;
-  LWIP_ASSERT("errno == EINPROGRESS", err == EINPROGRESS);
-
-  /* write should fail, too */
-  ret = lwip_write(s, "test", 4);
-  LWIP_ASSERT("ret == -1", ret == -1);
-  err = errno;
-  LWIP_ASSERT("errno == EINPROGRESS", err == EINPROGRESS);
-
-  CHECK_FDSETS(&sets);
-  FD_ZERO(&sets.readset);
-  CHECK_FDSETS(&sets);
-  FD_SET(s, &sets.readset);
-  CHECK_FDSETS(&sets);
-  FD_ZERO(&sets.writeset);
-  CHECK_FDSETS(&sets);
-  FD_SET(s, &sets.writeset);
-  CHECK_FDSETS(&sets);
-  FD_ZERO(&sets.errset);
-  CHECK_FDSETS(&sets);
-  FD_SET(s, &sets.errset);
-  CHECK_FDSETS(&sets);
-  tv.tv_sec = 0;
-  tv.tv_usec = 0;
-  /* select without waiting should fail */
-  ret = lwip_select(s + 1, &sets.readset, &sets.writeset, &sets.errset, &tv);
-  CHECK_FDSETS(&sets);
-  LWIP_ASSERT("ret == 0", ret == 0);
-  LWIP_ASSERT("!FD_ISSET(s, &writeset)", !FD_ISSET(s, &sets.writeset));
-  LWIP_ASSERT("!FD_ISSET(s, &readset)", !FD_ISSET(s, &sets.readset));
-  LWIP_ASSERT("!FD_ISSET(s, &errset)", !FD_ISSET(s, &sets.errset));
-
-  fds.fd = s;
-  fds.events = POLLIN|POLLOUT;
-  fds.revents = 0;
-  ret = lwip_poll(&fds, 1, 0);
-  LWIP_ASSERT("ret == 0", ret == 0);
-  LWIP_ASSERT("fds.revents == 0", fds.revents == 0);
-
-  FD_ZERO(&sets.readset);
-  FD_SET(s, &sets.readset);
-  FD_ZERO(&sets.writeset);
-  FD_SET(s, &sets.writeset);
-  FD_ZERO(&sets.errset);
-  FD_SET(s, &sets.errset);
-  ticks_a = sys_now();
-  /* select with waiting should succeed */
-  ret = lwip_select(s + 1, &sets.readset, &sets.writeset, &sets.errset, NULL);
-  ticks_b = sys_now();
-  LWIP_ASSERT("ret == 1", ret == 1);
-  LWIP_ASSERT("FD_ISSET(s, &writeset)", FD_ISSET(s, &sets.writeset));
-  LWIP_ASSERT("!FD_ISSET(s, &readset)", !FD_ISSET(s, &sets.readset));
-  LWIP_ASSERT("!FD_ISSET(s, &errset)", !FD_ISSET(s, &sets.errset));
-
-  fds.fd = s;
-  fds.events = POLLIN|POLLOUT;
-  fds.revents = 0;
-  ret = lwip_poll(&fds, 1, 0);
-  LWIP_ASSERT("ret == 1", ret == 1);
-  LWIP_ASSERT("fds.revents & POLLOUT", fds.revents & POLLOUT);
-
-  /* now write should succeed */
-  ret = lwip_write(s, "test", 4);
-  LWIP_ASSERT("ret == 4", ret == 4);
-
-  /* close */
-  ret = lwip_close(s);
-  LWIP_ASSERT("ret == 0", ret == 0);
-
-  printf("select() needed %d ticks to return writable\n", (int)(ticks_b - ticks_a));
-
-
-  /* now try nonblocking to invalid address:
-     this test only works if it is fast enough, i.e. no breakpoints, please! */
-
-  /* create the socket */
-#if LWIP_IPV6
-  s = lwip_socket(AF_INET6, SOCK_STREAM, 0);
-#else /* LWIP_IPV6 */
-  s = lwip_socket(AF_INET, SOCK_STREAM, 0);
-#endif /* LWIP_IPV6 */
-  LWIP_ASSERT("s >= 0", s >= 0);
-
-  /* nonblocking */
-  opt = 1;
-  ret = lwip_ioctl(s, FIONBIO, &opt);
-  LWIP_ASSERT("ret == 0", ret == 0);
-
-#if LWIP_IPV6
-  addr.sin6_addr.un.u8_addr[0]++; /* this should result in an invalid address */
-#else /* LWIP_IPV6 */
-  addr.sin_addr.s_addr++; /* this should result in an invalid address */
-#endif /* LWIP_IPV6 */
-
-  /* connect */
-  ret = lwip_connect(s, (struct sockaddr*)&addr, sizeof(addr));
-  /* should have an error: "inprogress" */
-  LWIP_ASSERT("ret == -1", ret == -1);
-  err = errno;
-  LWIP_ASSERT("errno == EINPROGRESS", err == EINPROGRESS);
-
-  /* write should fail, too */
-  ret = lwip_write(s, "test", 4);
-  LWIP_ASSERT("ret == -1", ret == -1);
-  err = errno;
-  LWIP_ASSERT("errno == EINPROGRESS", err == EINPROGRESS);
-  LWIP_UNUSED_ARG(err);
-
-  FD_ZERO(&sets.readset);
-  FD_SET(s, &sets.readset);
-  FD_ZERO(&sets.writeset);
-  FD_SET(s, &sets.writeset);
-  FD_ZERO(&sets.errset);
-  FD_SET(s, &sets.errset);
-  tv.tv_sec = 0;
-  tv.tv_usec = 0;
-  /* select without waiting should fail */
-  ret = lwip_select(s + 1, &sets.readset, &sets.writeset, &sets.errset, &tv);
-  LWIP_ASSERT("ret == 0", ret == 0);
-
-  FD_ZERO(&sets.readset);
-  FD_SET(s, &sets.readset);
-  FD_ZERO(&sets.writeset);
-  FD_SET(s, &sets.writeset);
-  FD_ZERO(&sets.errset);
-  FD_SET(s, &sets.errset);
-  ticks_a = sys_now();
-  /* select with waiting should eventually succeed and return errset! */
-  ret = lwip_select(s + 1, &sets.readset, &sets.writeset, &sets.errset, NULL);
-  ticks_b = sys_now();
-  LWIP_ASSERT("ret > 0", ret > 0);
-  LWIP_ASSERT("FD_ISSET(s, &errset)", FD_ISSET(s, &sets.errset));
-  /*LWIP_ASSERT("!FD_ISSET(s, &readset)", !FD_ISSET(s, &sets.readset));
-  LWIP_ASSERT("!FD_ISSET(s, &writeset)", !FD_ISSET(s, &sets.writeset));*/
-
-  /* close */
-  ret = lwip_close(s);
-  LWIP_ASSERT("ret == 0", ret == 0);
-  LWIP_UNUSED_ARG(ret);
-
-  printf("select() needed %d ticks to return error\n", (int)(ticks_b - ticks_a));
-  printf("sockex_nonblocking_connect finished successfully\n");
-#else
-  LWIP_UNUSED_ARG(arg);
-#endif
-}
-
-/** This is an example function that tests
-    the recv function (timeout etc.). */
-static void
-sockex_testrecv(void *arg)
-{
-  int s;
-  int ret;
-  int err;
-#if LWIP_SO_SNDRCVTIMEO_NONSTANDARD
-  int opt, opt2;
-#else
-  struct timeval opt, opt2;
-#endif
-  socklen_t opt2size;
-#if LWIP_IPV6
-  struct sockaddr_in6 addr;
-#else /* LWIP_IPV6 */
-  struct sockaddr_in addr;
-#endif /* LWIP_IPV6 */
-  size_t len;
-  char rxbuf[SOCK_TARGET_MAXHTTPPAGESIZE];
-#if LWIP_SOCKET_SELECT
-  fd_set readset;
-  fd_set errset;
-  struct timeval tv;
-#endif
-  const ip_addr_t *ipaddr = (const ip_addr_t*)arg;
-
-  /* set up address to connect to */
-  memset(&addr, 0, sizeof(addr));
-#if LWIP_IPV6
-  addr.sin6_len = sizeof(addr);
-  addr.sin6_family = AF_INET6;
-  addr.sin6_port = PP_HTONS(SOCK_TARGET_PORT);
-  inet6_addr_from_ip6addr(&addr.sin6_addr, ip_2_ip6(ipaddr));
-#else /* LWIP_IPV6 */
-  addr.sin_len = sizeof(addr);
-  addr.sin_family = AF_INET;
-  addr.sin_port = PP_HTONS(SOCK_TARGET_PORT);
-  inet_addr_from_ip4addr(&addr.sin_addr, ip_2_ip4(ipaddr));
-#endif /* LWIP_IPV6 */
-
-  /* first try blocking: */
-
-  /* create the socket */
-#if LWIP_IPV6
-  s = lwip_socket(AF_INET6, SOCK_STREAM, 0);
-#else /* LWIP_IPV6 */
-  s = lwip_socket(AF_INET, SOCK_STREAM, 0);
-#endif /* LWIP_IPV6 */
-  LWIP_ASSERT("s >= 0", s >= 0);
-
-  /* connect */
-  ret = lwip_connect(s, (struct sockaddr*)&addr, sizeof(addr));
-  /* should succeed */
-  LWIP_ASSERT("ret == 0", ret == 0);
-
-  /* set recv timeout (100 ms) */
-#if LWIP_SO_SNDRCVTIMEO_NONSTANDARD
-  opt = 100;
-#else
-  opt.tv_sec = 0;
-  opt.tv_usec = 100 * 1000;
-#endif
-  ret = lwip_setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &opt, sizeof(opt));
-  LWIP_ASSERT("ret == 0", ret == 0);
-#if LWIP_SO_SNDRCVTIMEO_NONSTANDARD
-  opt2 = 0;
-#else
-  opt2.tv_sec = 0;
-  opt2.tv_usec = 0;
-#endif
-  opt2size = sizeof(opt2);
-  ret = lwip_getsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &opt2, &opt2size);
-  LWIP_ASSERT("ret == 0", ret == 0);
-  LWIP_ASSERT("opt2size == sizeof(opt2)", opt2size == sizeof(opt2));
-#if LWIP_SO_SNDRCVTIMEO_NONSTANDARD
-  LWIP_ASSERT("opt == opt2", opt == opt2);
-#else
-  LWIP_ASSERT("opt == opt2", opt.tv_sec == opt2.tv_sec);
-  LWIP_ASSERT("opt == opt2", opt.tv_usec == opt2.tv_usec);
-#endif
-
-  /* write the start of a GET request */
-#define SNDSTR1 "G"
-  len = strlen(SNDSTR1);
-  ret = lwip_write(s, SNDSTR1, len);
-  LWIP_ASSERT("ret == len", ret == (int)len);
-
-  /* should time out if the other side is a good HTTP server */
-  ret = lwip_read(s, rxbuf, 1);
-  LWIP_ASSERT("ret == -1", ret == -1);
-  err = errno;
-  LWIP_ASSERT("errno == EAGAIN", err == EAGAIN);
-  LWIP_UNUSED_ARG(err);
-
-  /* write the rest of a GET request */
-#define SNDSTR2 "ET / HTTP_1.1\r\n\r\n"
-  len = strlen(SNDSTR2);
-  ret = lwip_write(s, SNDSTR2, len);
-  LWIP_ASSERT("ret == len", ret == (int)len);
-
-  /* wait a while: should be enough for the server to send a response */
-  sys_msleep(1000);
-
-  /* should not time out but receive a response */
-  ret = lwip_read(s, rxbuf, SOCK_TARGET_MAXHTTPPAGESIZE);
-  LWIP_ASSERT("ret > 0", ret > 0);
-
-#if LWIP_SOCKET_SELECT
-  /* now select should directly return because the socket is readable */
-  FD_ZERO(&readset);
-  FD_ZERO(&errset);
-  FD_SET(s, &readset);
-  FD_SET(s, &errset);
-  tv.tv_sec = 10;
-  tv.tv_usec = 0;
-  ret = lwip_select(s + 1, &readset, NULL, &errset, &tv);
-  LWIP_ASSERT("ret == 1", ret == 1);
-  LWIP_ASSERT("!FD_ISSET(s, &errset)", !FD_ISSET(s, &errset));
-  LWIP_ASSERT("FD_ISSET(s, &readset)", FD_ISSET(s, &readset));
-#endif
-
-  /* should not time out but receive a response */
-  ret = lwip_read(s, rxbuf, SOCK_TARGET_MAXHTTPPAGESIZE);
-  /* might receive a second packet for HTTP/1.1 servers */
-  if (ret > 0) {
-    /* should return 0: closed */
-    ret = lwip_read(s, rxbuf, SOCK_TARGET_MAXHTTPPAGESIZE);
-    LWIP_ASSERT("ret == 0", ret == 0);
-  }
-
-  /* close */
-  ret = lwip_close(s);
-  LWIP_ASSERT("ret == 0", ret == 0);
-  LWIP_UNUSED_ARG(ret);
-
-  printf("sockex_testrecv finished successfully\n");
-}
-
-#if LWIP_SOCKET_SELECT
-/** helper struct for the 2 functions below (multithreaded: thread-argument) */
-struct sockex_select_helper {
-  int socket;
-  int wait_read;
-  int expect_read;
-  int wait_write;
-  int expect_write;
-  int wait_err;
-  int expect_err;
-  int wait_ms;
-  sys_sem_t sem;
-};
-
-/** helper thread to wait for socket events using select */
-static void
-sockex_select_waiter(void *arg)
-{
-  struct sockex_select_helper *helper = (struct sockex_select_helper *)arg;
-  int ret;
-  fd_set readset;
-  fd_set writeset;
-  fd_set errset;
-  struct timeval tv;
-
-  LWIP_ASSERT("helper != NULL", helper != NULL);
-
-  FD_ZERO(&readset);
-  FD_ZERO(&writeset);
-  FD_ZERO(&errset);
-  if (helper->wait_read) {
-    FD_SET(helper->socket, &readset);
-  }
-  if (helper->wait_write) {
-    FD_SET(helper->socket, &writeset);
-  }
-  if (helper->wait_err) {
-    FD_SET(helper->socket, &errset);
-  }
-
-  tv.tv_sec = helper->wait_ms / 1000;
-  tv.tv_usec = (helper->wait_ms % 1000) * 1000;
-
-  ret = lwip_select(helper->socket, &readset, &writeset, &errset, &tv);
-  if (helper->expect_read || helper->expect_write || helper->expect_err) {
-    LWIP_ASSERT("ret > 0", ret > 0);
-  } else {
-    LWIP_ASSERT("ret == 0", ret == 0);
-  }
-  LWIP_UNUSED_ARG(ret);
-  if (helper->expect_read) {
-    LWIP_ASSERT("FD_ISSET(helper->socket, &readset)", FD_ISSET(helper->socket, &readset));
-  } else {
-    LWIP_ASSERT("!FD_ISSET(helper->socket, &readset)", !FD_ISSET(helper->socket, &readset));
-  }
-  if (helper->expect_write) {
-    LWIP_ASSERT("FD_ISSET(helper->socket, &writeset)", FD_ISSET(helper->socket, &writeset));
-  } else {
-    LWIP_ASSERT("!FD_ISSET(helper->socket, &writeset)", !FD_ISSET(helper->socket, &writeset));
-  }
-  if (helper->expect_err) {
-    LWIP_ASSERT("FD_ISSET(helper->socket, &errset)", FD_ISSET(helper->socket, &errset));
-  } else {
-    LWIP_ASSERT("!FD_ISSET(helper->socket, &errset)", !FD_ISSET(helper->socket, &errset));
-  }
-  sys_sem_signal(&helper->sem);
-}
-
-/** This is an example function that tests
-    more than one thread being active in select. */
-static void
-sockex_testtwoselects(void *arg)
-{
-  int s1;
-  int s2;
-  int ret;
-#if LWIP_IPV6
-  struct sockaddr_in6 addr;
-#else /* LWIP_IPV6 */
-  struct sockaddr_in addr;
-#endif /* LWIP_IPV6 */
-  size_t len;
-  err_t lwiperr;
-  struct sockex_select_helper h1, h2, h3, h4;
-  const ip_addr_t *ipaddr = (const ip_addr_t*)arg;
-
-  /* set up address to connect to */
-  memset(&addr, 0, sizeof(addr));
-#if LWIP_IPV6
-  addr.sin6_len = sizeof(addr);
-  addr.sin6_family = AF_INET6;
-  addr.sin6_port = PP_HTONS(SOCK_TARGET_PORT);
-  inet6_addr_from_ip6addr(&addr.sin6_addr, ip_2_ip6(ipaddr));
-#else /* LWIP_IPV6 */
-  addr.sin_len = sizeof(addr);
-  addr.sin_family = AF_INET;
-  addr.sin_port = PP_HTONS(SOCK_TARGET_PORT);
-  inet_addr_from_ip4addr(&addr.sin_addr, ip_2_ip4(ipaddr));
-#endif /* LWIP_IPV6 */
-
-  /* create the sockets */
-#if LWIP_IPV6
-  s1 = lwip_socket(AF_INET6, SOCK_STREAM, 0);
-  s2 = lwip_socket(AF_INET6, SOCK_STREAM, 0);
-#else /* LWIP_IPV6 */
-  s1 = lwip_socket(AF_INET, SOCK_STREAM, 0);
-  s2 = lwip_socket(AF_INET, SOCK_STREAM, 0);
-#endif /* LWIP_IPV6 */
-  LWIP_ASSERT("s1 >= 0", s1 >= 0);
-  LWIP_ASSERT("s2 >= 0", s2 >= 0);
-
-  /* connect, should succeed */
-  ret = lwip_connect(s1, (struct sockaddr*)&addr, sizeof(addr));
-  LWIP_ASSERT("ret == 0", ret == 0);
-  ret = lwip_connect(s2, (struct sockaddr*)&addr, sizeof(addr));
-  LWIP_ASSERT("ret == 0", ret == 0);
-
-  /* write the start of a GET request */
-#define SNDSTR1 "G"
-  len = strlen(SNDSTR1);
-  ret = lwip_write(s1, SNDSTR1, len);
-  LWIP_ASSERT("ret == len", ret == (int)len);
-  ret = lwip_write(s2, SNDSTR1, len);
-  LWIP_ASSERT("ret == len", ret == (int)len);
-  LWIP_UNUSED_ARG(ret);
-
-  h1.wait_read  = 1;
-  h1.wait_write = 1;
-  h1.wait_err   = 1;
-  h1.expect_read  = 0;
-  h1.expect_write = 0;
-  h1.expect_err   = 0;
-  lwiperr = sys_sem_new(&h1.sem, 0);
-  LWIP_ASSERT("lwiperr == ERR_OK", lwiperr == ERR_OK);
-  h1.socket = s1;
-  h1.wait_ms = 500;
-
-  h2 = h1;
-  lwiperr = sys_sem_new(&h2.sem, 0);
-  LWIP_ASSERT("lwiperr == ERR_OK", lwiperr == ERR_OK);
-  h2.socket = s2;
-  h2.wait_ms = 1000;
-
-  h3 = h1;
-  lwiperr = sys_sem_new(&h3.sem, 0);
-  LWIP_ASSERT("lwiperr == ERR_OK", lwiperr == ERR_OK);
-  h3.socket = s2;
-  h3.wait_ms = 1500;
-
-  h4 = h1;
-  lwiperr = sys_sem_new(&h4.sem, 0);
-  LWIP_ASSERT("lwiperr == ERR_OK", lwiperr == ERR_OK);
-  LWIP_UNUSED_ARG(lwiperr);
-  h4.socket = s2;
-  h4.wait_ms = 2000;
-
-  /* select: all sockets should time out if the other side is a good HTTP server */
-
-  sys_thread_new("sockex_select_waiter1", sockex_select_waiter, &h2, 0, 0);
-  sys_msleep(100);
-  sys_thread_new("sockex_select_waiter2", sockex_select_waiter, &h1, 0, 0);
-  sys_msleep(100);
-  sys_thread_new("sockex_select_waiter2", sockex_select_waiter, &h4, 0, 0);
-  sys_msleep(100);
-  sys_thread_new("sockex_select_waiter2", sockex_select_waiter, &h3, 0, 0);
-
-  sys_sem_wait(&h1.sem);
-  sys_sem_wait(&h2.sem);
-  sys_sem_wait(&h3.sem);
-  sys_sem_wait(&h4.sem);
-
-  /* close */
-  ret = lwip_close(s1);
-  LWIP_ASSERT("ret == 0", ret == 0);
-  ret = lwip_close(s2);
-  LWIP_ASSERT("ret == 0", ret == 0);
-
-  printf("sockex_testtwoselects finished successfully\n");
-}
-#else
-static void
-sockex_testtwoselects(void *arg)
-{
-  LWIP_UNUSED_ARG(arg);
-}
-#endif
-
-#if !SOCKET_EXAMPLES_RUN_PARALLEL
-static void
-socket_example_test(void* arg)
-{
-  sys_msleep(1000);
-  sockex_nonblocking_connect(arg);
-  sockex_testrecv(arg);
-  sockex_testtwoselects(arg);
-  printf("all tests done, thread ending\n");
-}
-#endif
-
-void socket_examples_init(void)
-{
-  int addr_ok;
-#if LWIP_IPV6
-  IP_SET_TYPE_VAL(dstaddr, IPADDR_TYPE_V6);
-  addr_ok = ip6addr_aton(SOCK_TARGET_HOST6, ip_2_ip6(&dstaddr));
-#else /* LWIP_IPV6 */
-  IP_SET_TYPE_VAL(dstaddr, IPADDR_TYPE_V4);
-  addr_ok = ip4addr_aton(SOCK_TARGET_HOST4, ip_2_ip4(&dstaddr));
-#endif /* LWIP_IPV6 */
-  LWIP_ASSERT("invalid address", addr_ok);
-#if SOCKET_EXAMPLES_RUN_PARALLEL
-  sys_thread_new("sockex_nonblocking_connect", sockex_nonblocking_connect, &dstaddr, 0, 0);
-  sys_thread_new("sockex_testrecv", sockex_testrecv, &dstaddr, 0, 0);
-  sys_thread_new("sockex_testtwoselects", sockex_testtwoselects, &dstaddr, 0, 0);
-#else
-  sys_thread_new("socket_example_test", socket_example_test, &dstaddr, 0, 0);
-#endif
-}
-
-#endif /* LWIP_SOCKET */
diff --git a/contrib/apps/socket_examples/socket_examples.h b/contrib/apps/socket_examples/socket_examples.h
deleted file mode 100644
index 354d03ad..00000000
--- a/contrib/apps/socket_examples/socket_examples.h
+++ /dev/null
@@ -1,6 +0,0 @@
-#ifndef LWIP_SOCKET_EXAMPLES_H
-#define LWIP_SOCKET_EXAMPLES_H
-
-void socket_examples_init(void);
-
-#endif /* LWIP_SOCKET_EXAMPLES_H */
diff --git a/contrib/apps/tcpecho/tcpecho.c b/contrib/apps/tcpecho/tcpecho.c
deleted file mode 100644
index 8fe13596..00000000
--- a/contrib/apps/tcpecho/tcpecho.c
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-#include "tcpecho.h"
-
-#include "lwip/opt.h"
-
-#if LWIP_NETCONN
-
-#include "lwip/sys.h"
-#include "lwip/api.h"
-/*-----------------------------------------------------------------------------------*/
-static void
-tcpecho_thread(void *arg)
-{
-  struct netconn *conn, *newconn;
-  err_t err;
-  LWIP_UNUSED_ARG(arg);
-
-  /* Create a new connection identifier. */
-  /* Bind connection to well known port number 7. */
-#if LWIP_IPV6
-  conn = netconn_new(NETCONN_TCP_IPV6);
-  netconn_bind(conn, IP6_ADDR_ANY, 7);
-#else /* LWIP_IPV6 */
-  conn = netconn_new(NETCONN_TCP);
-  netconn_bind(conn, IP_ADDR_ANY, 7);
-#endif /* LWIP_IPV6 */
-  LWIP_ERROR("tcpecho: invalid conn", (conn != NULL), return;);
-
-  /* Tell connection to go into listening mode. */
-  netconn_listen(conn);
-
-  while (1) {
-
-    /* Grab new connection. */
-    err = netconn_accept(conn, &newconn);
-    /*printf("accepted new connection %p\n", newconn);*/
-    /* Process the new connection. */
-    if (err == ERR_OK) {
-      struct netbuf *buf;
-      void *data;
-      u16_t len;
-
-      while ((err = netconn_recv(newconn, &buf)) == ERR_OK) {
-        /*printf("Recved\n");*/
-        do {
-             netbuf_data(buf, &data, &len);
-             err = netconn_write(newconn, data, len, NETCONN_COPY);
-#if 0
-            if (err != ERR_OK) {
-              printf("tcpecho: netconn_write: error \"%s\"\n", lwip_strerr(err));
-            }
-#endif
-        } while (netbuf_next(buf) >= 0);
-        netbuf_delete(buf);
-      }
-      /*printf("Got EOF, looping\n");*/
-      /* Close connection and discard connection identifier. */
-      netconn_close(newconn);
-      netconn_delete(newconn);
-    }
-  }
-}
-/*-----------------------------------------------------------------------------------*/
-void
-tcpecho_init(void)
-{
-  sys_thread_new("tcpecho_thread", tcpecho_thread, NULL, DEFAULT_THREAD_STACKSIZE, DEFAULT_THREAD_PRIO);
-}
-/*-----------------------------------------------------------------------------------*/
-
-#endif /* LWIP_NETCONN */
diff --git a/contrib/apps/tcpecho/tcpecho.h b/contrib/apps/tcpecho/tcpecho.h
deleted file mode 100644
index b27c50f2..00000000
--- a/contrib/apps/tcpecho/tcpecho.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-
-#ifndef LWIP_TCPECHO_H
-#define LWIP_TCPECHO_H
-
-void tcpecho_init(void);
-
-#endif /* LWIP_TCPECHO_H */
diff --git a/contrib/apps/tcpecho_raw/tcpecho_raw.c b/contrib/apps/tcpecho_raw/tcpecho_raw.c
deleted file mode 100644
index 016a7031..00000000
--- a/contrib/apps/tcpecho_raw/tcpecho_raw.c
+++ /dev/null
@@ -1,301 +0,0 @@
-/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of and a contribution to the lwIP TCP/IP stack.
- *
- * Credits go to Adam Dunkels (and the current maintainers) of this software.
- *
- * Christiaan Simons rewrote this file to get a more stable echo example.
- */
-
-/**
- * @file
- * TCP echo server example using raw API.
- *
- * Echos all bytes sent by connecting client,
- * and passively closes when client is done.
- *
- */
-
-#include "lwip/opt.h"
-#include "lwip/debug.h"
-#include "lwip/stats.h"
-#include "lwip/tcp.h"
-#include "tcpecho_raw.h"
-
-#if LWIP_TCP && LWIP_CALLBACK_API
-
-static struct tcp_pcb *tcpecho_raw_pcb;
-
-enum tcpecho_raw_states
-{
-  ES_NONE = 0,
-  ES_ACCEPTED,
-  ES_RECEIVED,
-  ES_CLOSING
-};
-
-struct tcpecho_raw_state
-{
-  u8_t state;
-  u8_t retries;
-  struct tcp_pcb *pcb;
-  /* pbuf (chain) to recycle */
-  struct pbuf *p;
-};
-
-static void
-tcpecho_raw_free(struct tcpecho_raw_state *es)
-{
-  if (es != NULL) {
-    if (es->p) {
-      /* free the buffer chain if present */
-      pbuf_free(es->p);
-    }
-
-    mem_free(es);
-  }
-}
-
-static void
-tcpecho_raw_close(struct tcp_pcb *tpcb, struct tcpecho_raw_state *es)
-{
-  tcp_arg(tpcb, NULL);
-  tcp_sent(tpcb, NULL);
-  tcp_recv(tpcb, NULL);
-  tcp_err(tpcb, NULL);
-  tcp_poll(tpcb, NULL, 0);
-
-  tcpecho_raw_free(es);
-
-  tcp_close(tpcb);
-}
-
-static void
-tcpecho_raw_send(struct tcp_pcb *tpcb, struct tcpecho_raw_state *es)
-{
-  struct pbuf *ptr;
-  err_t wr_err = ERR_OK;
-
-  while ((wr_err == ERR_OK) &&
-         (es->p != NULL) &&
-         (es->p->len <= tcp_sndbuf(tpcb))) {
-    ptr = es->p;
-
-    /* enqueue data for transmission */
-    wr_err = tcp_write(tpcb, ptr->payload, ptr->len, 1);
-    if (wr_err == ERR_OK) {
-      u16_t plen;
-
-      plen = ptr->len;
-      /* continue with next pbuf in chain (if any) */
-      es->p = ptr->next;
-      if(es->p != NULL) {
-        /* new reference! */
-        pbuf_ref(es->p);
-      }
-      /* chop first pbuf from chain */
-      pbuf_free(ptr);
-      /* we can read more data now */
-      tcp_recved(tpcb, plen);
-    } else if(wr_err == ERR_MEM) {
-      /* we are low on memory, try later / harder, defer to poll */
-      es->p = ptr;
-    } else {
-      /* other problem ?? */
-    }
-  }
-}
-
-static void
-tcpecho_raw_error(void *arg, err_t err)
-{
-  struct tcpecho_raw_state *es;
-
-  LWIP_UNUSED_ARG(err);
-
-  es = (struct tcpecho_raw_state *)arg;
-
-  tcpecho_raw_free(es);
-}
-
-static err_t
-tcpecho_raw_poll(void *arg, struct tcp_pcb *tpcb)
-{
-  err_t ret_err;
-  struct tcpecho_raw_state *es;
-
-  es = (struct tcpecho_raw_state *)arg;
-  if (es != NULL) {
-    if (es->p != NULL) {
-      /* there is a remaining pbuf (chain)  */
-      tcpecho_raw_send(tpcb, es);
-    } else {
-      /* no remaining pbuf (chain)  */
-      if(es->state == ES_CLOSING) {
-        tcpecho_raw_close(tpcb, es);
-      }
-    }
-    ret_err = ERR_OK;
-  } else {
-    /* nothing to be done */
-    tcp_abort(tpcb);
-    ret_err = ERR_ABRT;
-  }
-  return ret_err;
-}
-
-static err_t
-tcpecho_raw_sent(void *arg, struct tcp_pcb *tpcb, u16_t len)
-{
-  struct tcpecho_raw_state *es;
-
-  LWIP_UNUSED_ARG(len);
-
-  es = (struct tcpecho_raw_state *)arg;
-  es->retries = 0;
-
-  if(es->p != NULL) {
-    /* still got pbufs to send */
-    tcp_sent(tpcb, tcpecho_raw_sent);
-    tcpecho_raw_send(tpcb, es);
-  } else {
-    /* no more pbufs to send */
-    if(es->state == ES_CLOSING) {
-      tcpecho_raw_close(tpcb, es);
-    }
-  }
-  return ERR_OK;
-}
-
-static err_t
-tcpecho_raw_recv(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err)
-{
-  struct tcpecho_raw_state *es;
-  err_t ret_err;
-
-  LWIP_ASSERT("arg != NULL",arg != NULL);
-  es = (struct tcpecho_raw_state *)arg;
-  if (p == NULL) {
-    /* remote host closed connection */
-    es->state = ES_CLOSING;
-    if(es->p == NULL) {
-      /* we're done sending, close it */
-      tcpecho_raw_close(tpcb, es);
-    } else {
-      /* we're not done yet */
-      tcpecho_raw_send(tpcb, es);
-    }
-    ret_err = ERR_OK;
-  } else if(err != ERR_OK) {
-    /* cleanup, for unknown reason */
-    LWIP_ASSERT("no pbuf expected here", p == NULL);
-    ret_err = err;
-  }
-  else if(es->state == ES_ACCEPTED) {
-    /* first data chunk in p->payload */
-    es->state = ES_RECEIVED;
-    /* store reference to incoming pbuf (chain) */
-    es->p = p;
-    tcpecho_raw_send(tpcb, es);
-    ret_err = ERR_OK;
-  } else if (es->state == ES_RECEIVED) {
-    /* read some more data */
-    if(es->p == NULL) {
-      es->p = p;
-      tcpecho_raw_send(tpcb, es);
-    } else {
-      struct pbuf *ptr;
-
-      /* chain pbufs to the end of what we recv'ed previously  */
-      ptr = es->p;
-      pbuf_cat(ptr,p);
-    }
-    ret_err = ERR_OK;
-  } else {
-    /* unkown es->state, trash data  */
-    tcp_recved(tpcb, p->tot_len);
-    pbuf_free(p);
-    ret_err = ERR_OK;
-  }
-  return ret_err;
-}
-
-static err_t
-tcpecho_raw_accept(void *arg, struct tcp_pcb *newpcb, err_t err)
-{
-  err_t ret_err;
-  struct tcpecho_raw_state *es;
-
-  LWIP_UNUSED_ARG(arg);
-  if ((err != ERR_OK) || (newpcb == NULL)) {
-    return ERR_VAL;
-  }
-
-  /* Unless this pcb should have NORMAL priority, set its priority now.
-     When running out of pcbs, low priority pcbs can be aborted to create
-     new pcbs of higher priority. */
-  tcp_setprio(newpcb, TCP_PRIO_MIN);
-
-  es = (struct tcpecho_raw_state *)mem_malloc(sizeof(struct tcpecho_raw_state));
-  if (es != NULL) {
-    es->state = ES_ACCEPTED;
-    es->pcb = newpcb;
-    es->retries = 0;
-    es->p = NULL;
-    /* pass newly allocated es to our callbacks */
-    tcp_arg(newpcb, es);
-    tcp_recv(newpcb, tcpecho_raw_recv);
-    tcp_err(newpcb, tcpecho_raw_error);
-    tcp_poll(newpcb, tcpecho_raw_poll, 0);
-    tcp_sent(newpcb, tcpecho_raw_sent);
-    ret_err = ERR_OK;
-  } else {
-    ret_err = ERR_MEM;
-  }
-  return ret_err;
-}
-
-void
-tcpecho_raw_init(void)
-{
-  tcpecho_raw_pcb = tcp_new_ip_type(IPADDR_TYPE_ANY);
-  if (tcpecho_raw_pcb != NULL) {
-    err_t err;
-
-    err = tcp_bind(tcpecho_raw_pcb, IP_ANY_TYPE, 7);
-    if (err == ERR_OK) {
-      tcpecho_raw_pcb = tcp_listen(tcpecho_raw_pcb);
-      tcp_accept(tcpecho_raw_pcb, tcpecho_raw_accept);
-    } else {
-      /* abort? output diagnostic? */
-    }
-  } else {
-    /* abort? output diagnostic? */
-  }
-}
-
-#endif /* LWIP_TCP && LWIP_CALLBACK_API */
diff --git a/contrib/apps/tcpecho_raw/tcpecho_raw.h b/contrib/apps/tcpecho_raw/tcpecho_raw.h
deleted file mode 100644
index d1e3b33d..00000000
--- a/contrib/apps/tcpecho_raw/tcpecho_raw.h
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- */
-#ifndef LWIP_TCPECHO_RAW_H
-#define LWIP_TCPECHO_RAW_H
-
-void tcpecho_raw_init(void);
-
-#endif /* LWIP_TCPECHO_RAW_H */
diff --git a/contrib/apps/udpecho/udpecho.c b/contrib/apps/udpecho/udpecho.c
deleted file mode 100644
index b68301e3..00000000
--- a/contrib/apps/udpecho/udpecho.c
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-
-#include "udpecho.h"
-
-#include "lwip/opt.h"
-
-#if LWIP_NETCONN
-
-#include "lwip/api.h"
-#include "lwip/sys.h"
-
-/*-----------------------------------------------------------------------------------*/
-static void
-udpecho_thread(void *arg)
-{
-  struct netconn *conn;
-  struct netbuf *buf;
-  char buffer[4096];
-  err_t err;
-  LWIP_UNUSED_ARG(arg);
-
-#if LWIP_IPV6
-  conn = netconn_new(NETCONN_UDP_IPV6);
-  LWIP_ERROR("udpecho: invalid conn", (conn != NULL), return;);
-  netconn_bind(conn, IP6_ADDR_ANY, 7);
-#else /* LWIP_IPV6 */
-  conn = netconn_new(NETCONN_UDP);
-  LWIP_ERROR("udpecho: invalid conn", (conn != NULL), return;);
-  netconn_bind(conn, IP_ADDR_ANY, 7);
-#endif /* LWIP_IPV6 */
-
-  while (1) {
-    err = netconn_recv(conn, &buf);
-    if (err == ERR_OK) {
-      /*  no need netconn_connect here, since the netbuf contains the address */
-      if(netbuf_copy(buf, buffer, sizeof(buffer)) != buf->p->tot_len) {
-        LWIP_DEBUGF(LWIP_DBG_ON, ("netbuf_copy failed\n"));
-      } else {
-        buffer[buf->p->tot_len] = '\0';
-        err = netconn_send(conn, buf);
-        if(err != ERR_OK) {
-          LWIP_DEBUGF(LWIP_DBG_ON, ("netconn_send failed: %d\n", (int)err));
-        } else {
-          LWIP_DEBUGF(LWIP_DBG_ON, ("got %s\n", buffer));
-        }
-      }
-      netbuf_delete(buf);
-    }
-  }
-}
-/*-----------------------------------------------------------------------------------*/
-void
-udpecho_init(void)
-{
-  sys_thread_new("udpecho_thread", udpecho_thread, NULL, DEFAULT_THREAD_STACKSIZE, DEFAULT_THREAD_PRIO);
-}
-
-#endif /* LWIP_NETCONN */
diff --git a/contrib/apps/udpecho/udpecho.h b/contrib/apps/udpecho/udpecho.h
deleted file mode 100644
index c4389112..00000000
--- a/contrib/apps/udpecho/udpecho.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-#ifndef LWIP_UDPECHO_H
-#define LWIP_UDPECHO_H
-
-void udpecho_init(void);
-
-#endif /* LWIP_UDPECHO_H */
diff --git a/contrib/apps/udpecho_raw/udpecho_raw.c b/contrib/apps/udpecho_raw/udpecho_raw.c
deleted file mode 100644
index 43c9f0b1..00000000
--- a/contrib/apps/udpecho_raw/udpecho_raw.c
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- * Copyright (c) 2016 Stephan Linz <linz@li-pro.net>, Li-Pro.Net
- * All rights reserved.
- *
- * Based on examples provided by
- * Iwan Budi Kusnanto <ibk@labhijau.net> (https://gist.github.com/iwanbk/1399729)
- * Juri Haberland <juri@sapienti-sat.org> (https://lists.gnu.org/archive/html/lwip-users/2007-06/msg00078.html)
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of and a contribution to the lwIP TCP/IP stack.
- *
- * Credits go to Adam Dunkels (and the current maintainers) of this software.
- *
- * Stephan Linz rewrote this file to get a basic echo example.
- */
-
-/**
- * @file
- * UDP echo server example using raw API.
- *
- * Echos all bytes sent by connecting client,
- * and passively closes when client is done.
- *
- */
-
-#include "lwip/opt.h"
-#include "lwip/debug.h"
-#include "lwip/stats.h"
-#include "lwip/udp.h"
-#include "udpecho_raw.h"
-
-#if LWIP_UDP
-
-static struct udp_pcb *udpecho_raw_pcb;
-
-static void
-udpecho_raw_recv(void *arg, struct udp_pcb *upcb, struct pbuf *p,
-                 const ip_addr_t *addr, u16_t port)
-{
-  LWIP_UNUSED_ARG(arg);
-  if (p != NULL) {
-    /* send received packet back to sender */
-    udp_sendto(upcb, p, addr, port);
-    /* free the pbuf */
-    pbuf_free(p);
-  }
-}
-
-void
-udpecho_raw_init(void)
-{
-  udpecho_raw_pcb = udp_new_ip_type(IPADDR_TYPE_ANY);
-  if (udpecho_raw_pcb != NULL) {
-    err_t err;
-
-    err = udp_bind(udpecho_raw_pcb, IP_ANY_TYPE, 7);
-    if (err == ERR_OK) {
-      udp_recv(udpecho_raw_pcb, udpecho_raw_recv, NULL);
-    } else {
-      /* abort? output diagnostic? */
-    }
-  } else {
-    /* abort? output diagnostic? */
-  }
-}
-
-#endif /* LWIP_UDP */
diff --git a/contrib/apps/udpecho_raw/udpecho_raw.h b/contrib/apps/udpecho_raw/udpecho_raw.h
deleted file mode 100644
index 4a98b740..00000000
--- a/contrib/apps/udpecho_raw/udpecho_raw.h
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (c) 2016 Stephan Linz <linz@li-pro.net>, Li-Pro.Net
- * All rights reserved.
- *
- * Based on examples provided by
- * Iwan Budi Kusnanto <ibk@labhijau.net> (https://gist.github.com/iwanbk/1399729)
- * Juri Haberland <juri@sapienti-sat.org> (https://lists.gnu.org/archive/html/lwip-users/2007-06/msg00078.html)
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- */
-#ifndef LWIP_UDPECHO_RAW_H
-#define LWIP_UDPECHO_RAW_H
-
-void udpecho_raw_init(void);
-
-#endif /* LWIP_UDPECHO_RAW_H */
diff --git a/contrib/examples/ethernetif/ethernetif.c b/contrib/examples/ethernetif/ethernetif.c
deleted file mode 100644
index 79763e8b..00000000
--- a/contrib/examples/ethernetif/ethernetif.c
+++ /dev/null
@@ -1,337 +0,0 @@
-/**
- * @file
- * Ethernet Interface Skeleton
- *
- */
-
-/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-
-/*
- * This file is a skeleton for developing Ethernet network interface
- * drivers for lwIP. Add code to the low_level functions and do a
- * search-and-replace for the word "ethernetif" to replace it with
- * something that better describes your network interface.
- */
-
-#include "lwip/opt.h"
-
-#if 0 /* don't build, this is only a skeleton, see previous comment */
-
-#include "lwip/def.h"
-#include "lwip/mem.h"
-#include "lwip/pbuf.h"
-#include "lwip/stats.h"
-#include "lwip/snmp.h"
-#include "lwip/ethip6.h"
-#include "lwip/etharp.h"
-#include "netif/ppp/pppoe.h"
-
-/* Define those to better describe your network interface. */
-#define IFNAME0 'e'
-#define IFNAME1 'n'
-
-/**
- * Helper struct to hold private data used to operate your ethernet interface.
- * Keeping the ethernet address of the MAC in this struct is not necessary
- * as it is already kept in the struct netif.
- * But this is only an example, anyway...
- */
-struct ethernetif {
-  struct eth_addr *ethaddr;
-  /* Add whatever per-interface state that is needed here. */
-};
-
-/* Forward declarations. */
-static void  ethernetif_input(struct netif *netif);
-
-/**
- * In this function, the hardware should be initialized.
- * Called from ethernetif_init().
- *
- * @param netif the already initialized lwip network interface structure
- *        for this ethernetif
- */
-static void
-low_level_init(struct netif *netif)
-{
-  struct ethernetif *ethernetif = netif->state;
-
-  /* set MAC hardware address length */
-  netif->hwaddr_len = ETHARP_HWADDR_LEN;
-
-  /* set MAC hardware address */
-  netif->hwaddr[0] = ;
-  ...
-  netif->hwaddr[5] = ;
-
-  /* maximum transfer unit */
-  netif->mtu = 1500;
-
-  /* device capabilities */
-  /* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */
-  netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP;
-
-#if LWIP_IPV6 && LWIP_IPV6_MLD
-  /*
-   * For hardware/netifs that implement MAC filtering.
-   * All-nodes link-local is handled by default, so we must let the hardware know
-   * to allow multicast packets in.
-   * Should set mld_mac_filter previously. */
-  if (netif->mld_mac_filter != NULL) {
-    ip6_addr_t ip6_allnodes_ll;
-    ip6_addr_set_allnodes_linklocal(&ip6_allnodes_ll);
-    netif->mld_mac_filter(netif, &ip6_allnodes_ll, NETIF_ADD_MAC_FILTER);
-  }
-#endif /* LWIP_IPV6 && LWIP_IPV6_MLD */
-
-  /* Do whatever else is needed to initialize interface. */
-}
-
-/**
- * This function should do the actual transmission of the packet. The packet is
- * contained in the pbuf that is passed to the function. This pbuf
- * might be chained.
- *
- * @param netif the lwip network interface structure for this ethernetif
- * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)
- * @return ERR_OK if the packet could be sent
- *         an err_t value if the packet couldn't be sent
- *
- * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
- *       strange results. You might consider waiting for space in the DMA queue
- *       to become available since the stack doesn't retry to send a packet
- *       dropped because of memory failure (except for the TCP timers).
- */
-
-static err_t
-low_level_output(struct netif *netif, struct pbuf *p)
-{
-  struct ethernetif *ethernetif = netif->state;
-  struct pbuf *q;
-
-  initiate transfer();
-
-#if ETH_PAD_SIZE
-  pbuf_remove_header(p, ETH_PAD_SIZE); /* drop the padding word */
-#endif
-
-  for (q = p; q != NULL; q = q->next) {
-    /* Send the data from the pbuf to the interface, one pbuf at a
-       time. The size of the data in each pbuf is kept in the ->len
-       variable. */
-    send data from(q->payload, q->len);
-  }
-
-  signal that packet should be sent();
-
-  MIB2_STATS_NETIF_ADD(netif, ifoutoctets, p->tot_len);
-  if (((u8_t *)p->payload)[0] & 1) {
-    /* broadcast or multicast packet*/
-    MIB2_STATS_NETIF_INC(netif, ifoutnucastpkts);
-  } else {
-    /* unicast packet */
-    MIB2_STATS_NETIF_INC(netif, ifoutucastpkts);
-  }
-  /* increase ifoutdiscards or ifouterrors on error */
-
-#if ETH_PAD_SIZE
-  pbuf_add_header(p, ETH_PAD_SIZE); /* reclaim the padding word */
-#endif
-
-  LINK_STATS_INC(link.xmit);
-
-  return ERR_OK;
-}
-
-/**
- * Should allocate a pbuf and transfer the bytes of the incoming
- * packet from the interface into the pbuf.
- *
- * @param netif the lwip network interface structure for this ethernetif
- * @return a pbuf filled with the received packet (including MAC header)
- *         NULL on memory error
- */
-static struct pbuf *
-low_level_input(struct netif *netif)
-{
-  struct ethernetif *ethernetif = netif->state;
-  struct pbuf *p, *q;
-  u16_t len;
-
-  /* Obtain the size of the packet and put it into the "len"
-     variable. */
-  len = ;
-
-#if ETH_PAD_SIZE
-  len += ETH_PAD_SIZE; /* allow room for Ethernet padding */
-#endif
-
-  /* We allocate a pbuf chain of pbufs from the pool. */
-  p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
-
-  if (p != NULL) {
-
-#if ETH_PAD_SIZE
-    pbuf_remove_header(p, ETH_PAD_SIZE); /* drop the padding word */
-#endif
-
-    /* We iterate over the pbuf chain until we have read the entire
-     * packet into the pbuf. */
-    for (q = p; q != NULL; q = q->next) {
-      /* Read enough bytes to fill this pbuf in the chain. The
-       * available data in the pbuf is given by the q->len
-       * variable.
-       * This does not necessarily have to be a memcpy, you can also preallocate
-       * pbufs for a DMA-enabled MAC and after receiving truncate it to the
-       * actually received size. In this case, ensure the tot_len member of the
-       * pbuf is the sum of the chained pbuf len members.
-       */
-      read data into(q->payload, q->len);
-    }
-    acknowledge that packet has been read();
-
-    MIB2_STATS_NETIF_ADD(netif, ifinoctets, p->tot_len);
-    if (((u8_t *)p->payload)[0] & 1) {
-      /* broadcast or multicast packet*/
-      MIB2_STATS_NETIF_INC(netif, ifinnucastpkts);
-    } else {
-      /* unicast packet*/
-      MIB2_STATS_NETIF_INC(netif, ifinucastpkts);
-    }
-#if ETH_PAD_SIZE
-    pbuf_add_header(p, ETH_PAD_SIZE); /* reclaim the padding word */
-#endif
-
-    LINK_STATS_INC(link.recv);
-  } else {
-    drop packet();
-    LINK_STATS_INC(link.memerr);
-    LINK_STATS_INC(link.drop);
-    MIB2_STATS_NETIF_INC(netif, ifindiscards);
-  }
-
-  return p;
-}
-
-/**
- * This function should be called when a packet is ready to be read
- * from the interface. It uses the function low_level_input() that
- * should handle the actual reception of bytes from the network
- * interface. Then the type of the received packet is determined and
- * the appropriate input function is called.
- *
- * @param netif the lwip network interface structure for this ethernetif
- */
-static void
-ethernetif_input(struct netif *netif)
-{
-  struct ethernetif *ethernetif;
-  struct eth_hdr *ethhdr;
-  struct pbuf *p;
-
-  ethernetif = netif->state;
-
-  /* move received packet into a new pbuf */
-  p = low_level_input(netif);
-  /* if no packet could be read, silently ignore this */
-  if (p != NULL) {
-    /* pass all packets to ethernet_input, which decides what packets it supports */
-    if (netif->input(p, netif) != ERR_OK) {
-      LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_input: IP input error\n"));
-      pbuf_free(p);
-      p = NULL;
-    }
-  }
-}
-
-/**
- * Should be called at the beginning of the program to set up the
- * network interface. It calls the function low_level_init() to do the
- * actual setup of the hardware.
- *
- * This function should be passed as a parameter to netif_add().
- *
- * @param netif the lwip network interface structure for this ethernetif
- * @return ERR_OK if the loopif is initialized
- *         ERR_MEM if private data couldn't be allocated
- *         any other err_t on error
- */
-err_t
-ethernetif_init(struct netif *netif)
-{
-  struct ethernetif *ethernetif;
-
-  LWIP_ASSERT("netif != NULL", (netif != NULL));
-
-  ethernetif = mem_malloc(sizeof(struct ethernetif));
-  if (ethernetif == NULL) {
-    LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_init: out of memory\n"));
-    return ERR_MEM;
-  }
-
-#if LWIP_NETIF_HOSTNAME
-  /* Initialize interface hostname */
-  netif->hostname = "lwip";
-#endif /* LWIP_NETIF_HOSTNAME */
-
-  /*
-   * Initialize the snmp variables and counters inside the struct netif.
-   * The last argument should be replaced with your link speed, in units
-   * of bits per second.
-   */
-  MIB2_INIT_NETIF(netif, snmp_ifType_ethernet_csmacd, LINK_SPEED_OF_YOUR_NETIF_IN_BPS);
-
-  netif->state = ethernetif;
-  netif->name[0] = IFNAME0;
-  netif->name[1] = IFNAME1;
-  /* We directly use etharp_output() here to save a function call.
-   * You can instead declare your own function an call etharp_output()
-   * from it if you have to do some checks before sending (e.g. if link
-   * is available...) */
-#if LWIP_IPV4
-  netif->output = etharp_output;
-#endif /* LWIP_IPV4 */
-#if LWIP_IPV6
-  netif->output_ip6 = ethip6_output;
-#endif /* LWIP_IPV6 */
-  netif->linkoutput = low_level_output;
-
-  ethernetif->ethaddr = (struct eth_addr *) & (netif->hwaddr[0]);
-
-  /* initialize the hardware */
-  low_level_init(netif);
-
-  return ERR_OK;
-}
-
-#endif /* 0 */
diff --git a/contrib/examples/example_app/default_netif.h b/contrib/examples/example_app/default_netif.h
deleted file mode 100644
index 1a64f02e..00000000
--- a/contrib/examples/example_app/default_netif.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-
-#ifndef LWIP_DEFAULT_NETIF_H
-#define LWIP_DEFAULT_NETIF_H
-
-#include "lwip/ip_addr.h"
-
-#if LWIP_IPV4
-void init_default_netif(const ip4_addr_t *ipaddr, const ip4_addr_t *netmask, const ip4_addr_t *gw);
-#else
-void init_default_netif(void);
-#endif
-
-void default_netif_poll(void);
-void default_netif_shutdown(void);
-
-#endif
diff --git a/contrib/examples/example_app/lwipcfg.h.example b/contrib/examples/example_app/lwipcfg.h.example
deleted file mode 100644
index a7517130..00000000
--- a/contrib/examples/example_app/lwipcfg.h.example
+++ /dev/null
@@ -1,77 +0,0 @@
-/**
- * Additional settings for the win32 port.
- * Copy this to lwipcfg_msvc.h and make the config changes you need.
- */
-
-/* configuration for this port */
-#define PPP_USERNAME  "Admin"
-#define PPP_PASSWORD  "pass"
-
-/** Define this to the index of the windows network adapter to use */
-#define PACKET_LIB_ADAPTER_NR         1
-/** Define this to the GUID of the windows network adapter to use
- * or NOT define this if you want PACKET_LIB_ADAPTER_NR to be used */ 
-/*#define PACKET_LIB_ADAPTER_GUID       "00000000-0000-0000-0000-000000000000"*/
-/*#define PACKET_LIB_GET_ADAPTER_NETADDRESS(addr) IP4_ADDR((addr), 192,168,1,0)*/
-/*#define PACKET_LIB_QUIET*/
-
-/* If these 2 are not defined, the corresponding config setting is used */
-/* #define USE_DHCP    0 */
-/* #define USE_AUTOIP  0 */
-
-/* #define USE_PCAPIF 1 */
-#define LWIP_PORT_INIT_IPADDR(addr)   IP4_ADDR((addr), 192,168,1,200)
-#define LWIP_PORT_INIT_GW(addr)       IP4_ADDR((addr), 192,168,1,1)
-#define LWIP_PORT_INIT_NETMASK(addr)  IP4_ADDR((addr), 255,255,255,0)
-
-/* remember to change this MAC address to suit your needs!
-   the last octet will be increased by netif->num for each netif */
-#define LWIP_MAC_ADDR_BASE            {0x00,0x01,0x02,0x03,0x04,0x05}
-
-/* #define USE_SLIPIF 0 */
-/* #define SIO_USE_COMPORT 0 */
-#ifdef USE_SLIPIF
-#if USE_SLIPIF
-#define LWIP_PORT_INIT_SLIP1_IPADDR(addr)   IP4_ADDR((addr), 192, 168,   2, 2)
-#define LWIP_PORT_INIT_SLIP1_GW(addr)       IP4_ADDR((addr), 192, 168,   2, 1)
-#define LWIP_PORT_INIT_SLIP1_NETMASK(addr)  IP4_ADDR((addr), 255, 255, 255, 0)
-#if USE_SLIPIF > 1
-#define LWIP_PORT_INIT_SLIP2_IPADDR(addr)   IP4_ADDR((addr), 192, 168,   2, 1)
-#define LWIP_PORT_INIT_SLIP2_GW(addr)       IP4_ADDR((addr), 0,     0,   0, 0)
-#define LWIP_PORT_INIT_SLIP2_NETMASK(addr)  IP4_ADDR((addr), 255, 255, 255, 0)*/
-#endif /* USE_SLIPIF > 1 */
-#endif /* USE_SLIPIF */
-#endif /* USE_SLIPIF */
-
-/* configuration for applications */
-
-#define LWIP_CHARGEN_APP              0
-#define LWIP_DNS_APP                  0
-#define LWIP_HTTPD_APP                0
-/* Set this to 1 to use the netconn http server,
- * otherwise the raw api server will be used. */
-/*#define LWIP_HTTPD_APP_NETCONN     */
-#define LWIP_NETBIOS_APP              0
-#define LWIP_NETIO_APP                0
-#define LWIP_MDNS_APP                 0
-#define LWIP_MQTT_APP                 0
-#define LWIP_PING_APP                 0
-#define LWIP_RTP_APP                  0
-#define LWIP_SHELL_APP                0
-#define LWIP_SNMP_APP                 0
-#define LWIP_SNTP_APP                 0
-#define LWIP_SOCKET_EXAMPLES_APP      0
-#define LWIP_TCPECHO_APP              0
-/* Set this to 1 to use the netconn tcpecho server,
- * otherwise the raw api server will be used. */
-/*#define LWIP_TCPECHO_APP_NETCONN   */
-#define LWIP_TFTP_APP                 0
-#define LWIP_TFTP_CLIENT_APP          0
-#define LWIP_UDPECHO_APP              0
-#define LWIP_LWIPERF_APP              0
-
-/*#define USE_DHCP    1*/
-/*#define USE_AUTOIP  1*/
-
-/* define this to your custom application-init function */
-/* #define LWIP_APP_INIT my_app_init() */
diff --git a/contrib/examples/example_app/lwipcfg.h.travis b/contrib/examples/example_app/lwipcfg.h.travis
deleted file mode 100644
index d5df939d..00000000
--- a/contrib/examples/example_app/lwipcfg.h.travis
+++ /dev/null
@@ -1,73 +0,0 @@
-/**
- * Additional settings for the win32 port.
- * Copy this to lwipcfg_msvc.h and make the config changes you need.
- */
-
-/* configuration for this port */
-#define PPP_USERNAME  "Admin"
-#define PPP_PASSWORD  "pass"
-
-/** Define this to the index of the windows network adapter to use */
-#define PACKET_LIB_ADAPTER_NR         1
-/** Define this to the GUID of the windows network adapter to use
- * or NOT define this if you want PACKET_LIB_ADAPTER_NR to be used */
-/*#define PACKET_LIB_ADAPTER_GUID       "00000000-0000-0000-0000-000000000000"*/
-/*#define PACKET_LIB_GET_ADAPTER_NETADDRESS(addr) IP4_ADDR((addr), 192,168,1,0)*/
-/*#define PACKET_LIB_QUIET*/
-
-/* #define USE_PCAPIF 1 */
-#define LWIP_PORT_INIT_IPADDR(addr)   IP4_ADDR((addr), 192,168,1,200)
-#define LWIP_PORT_INIT_GW(addr)       IP4_ADDR((addr), 192,168,1,1)
-#define LWIP_PORT_INIT_NETMASK(addr)  IP4_ADDR((addr), 255,255,255,0)
-
-/* remember to change this MAC address to suit your needs!
-   the last octet will be increased by netif->num for each netif */
-#define LWIP_MAC_ADDR_BASE            {0x00,0x01,0x02,0x03,0x04,0x05}
-
-/* #define USE_SLIPIF 0 */
-/* #define SIO_USE_COMPORT 0 */
-#ifdef USE_SLIPIF
-#if USE_SLIPIF
-#define LWIP_PORT_INIT_SLIP1_IPADDR(addr)   IP4_ADDR((addr), 192, 168,   2, 2)
-#define LWIP_PORT_INIT_SLIP1_GW(addr)       IP4_ADDR((addr), 192, 168,   2, 1)
-#define LWIP_PORT_INIT_SLIP1_NETMASK(addr)  IP4_ADDR((addr), 255, 255, 255, 0)
-#if USE_SLIPIF > 1
-#define LWIP_PORT_INIT_SLIP2_IPADDR(addr)   IP4_ADDR((addr), 192, 168,   2, 1)
-#define LWIP_PORT_INIT_SLIP2_GW(addr)       IP4_ADDR((addr), 0,     0,   0, 0)
-#define LWIP_PORT_INIT_SLIP2_NETMASK(addr)  IP4_ADDR((addr), 255, 255, 255, 0)*/
-#endif /* USE_SLIPIF > 1 */
-#endif /* USE_SLIPIF */
-#endif /* USE_SLIPIF */
-
-/* configuration for applications */
-
-#define LWIP_CHARGEN_APP              1
-#define LWIP_DNS_APP                  1
-#define LWIP_HTTPD_APP                LWIP_TCP
-/* Set this to 1 to use the netconn http server,
- * otherwise the raw api server will be used. */
-/*#define LWIP_HTTPD_APP_NETCONN     */
-#define LWIP_NETBIOS_APP              LWIP_IPV4 && LWIP_UDP
-#define LWIP_NETIO_APP                1
-#define LWIP_MDNS_APP                 LWIP_UDP
-#define LWIP_MQTT_APP                 LWIP_TCP
-#define LWIP_PING_APP                 1
-#define LWIP_RTP_APP                  1
-#define LWIP_SHELL_APP                LWIP_TCP
-#define LWIP_SNMP_APP                 LWIP_UDP
-#define LWIP_SNTP_APP                 LWIP_UDP
-#define LWIP_SOCKET_EXAMPLES_APP      1
-#define LWIP_TCPECHO_APP              LWIP_TCP
-/* Set this to 1 to use the netconn tcpecho server,
- * otherwise the raw api server will be used. */
-/*#define LWIP_TCPECHO_APP_NETCONN   */
-#define LWIP_TFTP_APP                 LWIP_UDP
-#define LWIP_TFTP_CLIENT_APP          LWIP_UDP
-#define LWIP_UDPECHO_APP              LWIP_UDP
-#define LWIP_LWIPERF_APP              LWIP_TCP
-
-#define USE_DHCP                      LWIP_DHCP
-#define USE_AUTOIP                    LWIP_AUTOIP
-
-/* define this to your custom application-init function */
-/* #define LWIP_APP_INIT my_app_init() */
diff --git a/contrib/examples/example_app/lwipopts.h b/contrib/examples/example_app/lwipopts.h
deleted file mode 100644
index 664027c5..00000000
--- a/contrib/examples/example_app/lwipopts.h
+++ /dev/null
@@ -1,335 +0,0 @@
-/*
- * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-#ifndef LWIP_LWIPOPTS_H
-#define LWIP_LWIPOPTS_H
-
-#ifdef LWIP_OPTTEST_FILE
-#include "lwipopts_test.h"
-#else /* LWIP_OPTTEST_FILE */
-
-#define LWIP_IPV4                  1
-#define LWIP_IPV6                  1
-
-#define NO_SYS                     0
-#define LWIP_SOCKET                (NO_SYS==0)
-#define LWIP_NETCONN               (NO_SYS==0)
-#define LWIP_NETIF_API             (NO_SYS==0)
-
-#define LWIP_IGMP                  LWIP_IPV4
-#define LWIP_ICMP                  LWIP_IPV4
-
-#define LWIP_SNMP                  LWIP_UDP
-#define MIB2_STATS                 LWIP_SNMP
-#ifdef LWIP_HAVE_MBEDTLS
-#define LWIP_SNMP_V3               (LWIP_SNMP)
-#endif
-
-#define LWIP_DNS                   LWIP_UDP
-#define LWIP_MDNS_RESPONDER        LWIP_UDP
-
-#define LWIP_NUM_NETIF_CLIENT_DATA (LWIP_MDNS_RESPONDER)
-
-#define LWIP_HAVE_LOOPIF           1
-#define LWIP_NETIF_LOOPBACK        1
-#define LWIP_LOOPBACK_MAX_PBUFS    10
-
-#define TCP_LISTEN_BACKLOG         1
-
-#define LWIP_COMPAT_SOCKETS        1
-#define LWIP_SO_RCVTIMEO           1
-#define LWIP_SO_RCVBUF             1
-
-#define LWIP_TCPIP_CORE_LOCKING    1
-
-#define LWIP_NETIF_LINK_CALLBACK        1
-#define LWIP_NETIF_STATUS_CALLBACK      1
-#define LWIP_NETIF_EXT_STATUS_CALLBACK  1
-
-#ifdef LWIP_DEBUG
-
-#define LWIP_DBG_MIN_LEVEL         0
-#define PPP_DEBUG                  LWIP_DBG_OFF
-#define MEM_DEBUG                  LWIP_DBG_OFF
-#define MEMP_DEBUG                 LWIP_DBG_OFF
-#define PBUF_DEBUG                 LWIP_DBG_OFF
-#define API_LIB_DEBUG              LWIP_DBG_OFF
-#define API_MSG_DEBUG              LWIP_DBG_OFF
-#define TCPIP_DEBUG                LWIP_DBG_OFF
-#define NETIF_DEBUG                LWIP_DBG_OFF
-#define SOCKETS_DEBUG              LWIP_DBG_OFF
-#define DNS_DEBUG                  LWIP_DBG_OFF
-#define AUTOIP_DEBUG               LWIP_DBG_OFF
-#define DHCP_DEBUG                 LWIP_DBG_OFF
-#define IP_DEBUG                   LWIP_DBG_OFF
-#define IP_REASS_DEBUG             LWIP_DBG_OFF
-#define ICMP_DEBUG                 LWIP_DBG_OFF
-#define IGMP_DEBUG                 LWIP_DBG_OFF
-#define UDP_DEBUG                  LWIP_DBG_OFF
-#define TCP_DEBUG                  LWIP_DBG_OFF
-#define TCP_INPUT_DEBUG            LWIP_DBG_OFF
-#define TCP_OUTPUT_DEBUG           LWIP_DBG_OFF
-#define TCP_RTO_DEBUG              LWIP_DBG_OFF
-#define TCP_CWND_DEBUG             LWIP_DBG_OFF
-#define TCP_WND_DEBUG              LWIP_DBG_OFF
-#define TCP_FR_DEBUG               LWIP_DBG_OFF
-#define TCP_QLEN_DEBUG             LWIP_DBG_OFF
-#define TCP_RST_DEBUG              LWIP_DBG_OFF
-#endif
-
-#define LWIP_DBG_TYPES_ON         (LWIP_DBG_ON|LWIP_DBG_TRACE|LWIP_DBG_STATE|LWIP_DBG_FRESH|LWIP_DBG_HALT)
-
-
-/* ---------- Memory options ---------- */
-/* MEM_ALIGNMENT: should be set to the alignment of the CPU for which
-   lwIP is compiled. 4 byte alignment -> define MEM_ALIGNMENT to 4, 2
-   byte alignment -> define MEM_ALIGNMENT to 2. */
-/* MSVC port: intel processors don't need 4-byte alignment,
-   but are faster that way! */
-#define MEM_ALIGNMENT           4U
-
-/* MEM_SIZE: the size of the heap memory. If the application will send
-a lot of data that needs to be copied, this should be set high. */
-#define MEM_SIZE               10240
-
-/* MEMP_NUM_PBUF: the number of memp struct pbufs. If the application
-   sends a lot of data out of ROM (or other static memory), this
-   should be set high. */
-#define MEMP_NUM_PBUF           16
-/* MEMP_NUM_RAW_PCB: the number of UDP protocol control blocks. One
-   per active RAW "connection". */
-#define MEMP_NUM_RAW_PCB        3
-/* MEMP_NUM_UDP_PCB: the number of UDP protocol control blocks. One
-   per active UDP "connection". */
-#define MEMP_NUM_UDP_PCB        8
-/* MEMP_NUM_TCP_PCB: the number of simulatenously active TCP
-   connections. */
-#define MEMP_NUM_TCP_PCB        5
-/* MEMP_NUM_TCP_PCB_LISTEN: the number of listening TCP
-   connections. */
-#define MEMP_NUM_TCP_PCB_LISTEN 8
-/* MEMP_NUM_TCP_SEG: the number of simultaneously queued TCP
-   segments. */
-#define MEMP_NUM_TCP_SEG        16
-/* MEMP_NUM_SYS_TIMEOUT: the number of simulateously active
-   timeouts. */
-#define MEMP_NUM_SYS_TIMEOUT    17
-
-/* The following four are used only with the sequential API and can be
-   set to 0 if the application only will use the raw API. */
-/* MEMP_NUM_NETBUF: the number of struct netbufs. */
-#define MEMP_NUM_NETBUF         2
-/* MEMP_NUM_NETCONN: the number of struct netconns. */
-#define MEMP_NUM_NETCONN        12
-/* MEMP_NUM_TCPIP_MSG_*: the number of struct tcpip_msg, which is used
-   for sequential API communication and incoming packets. Used in
-   src/api/tcpip.c. */
-#define MEMP_NUM_TCPIP_MSG_API   16
-#define MEMP_NUM_TCPIP_MSG_INPKT 16
-
-
-/* ---------- Pbuf options ---------- */
-/* PBUF_POOL_SIZE: the number of buffers in the pbuf pool. */
-#define PBUF_POOL_SIZE          120
-
-/* PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. */
-#define PBUF_POOL_BUFSIZE       256
-
-/** SYS_LIGHTWEIGHT_PROT
- * define SYS_LIGHTWEIGHT_PROT in lwipopts.h if you want inter-task protection
- * for certain critical regions during buffer allocation, deallocation and memory
- * allocation and deallocation.
- */
-#define SYS_LIGHTWEIGHT_PROT    (NO_SYS==0)
-
-
-/* ---------- TCP options ---------- */
-#define LWIP_TCP                1
-#define TCP_TTL                 255
-
-#define LWIP_ALTCP              (LWIP_TCP)
-#ifdef LWIP_HAVE_MBEDTLS
-#define LWIP_ALTCP_TLS          (LWIP_TCP)
-#define LWIP_ALTCP_TLS_MBEDTLS  (LWIP_TCP)
-#endif
-
-
-/* Controls if TCP should queue segments that arrive out of
-   order. Define to 0 if your device is low on memory. */
-#define TCP_QUEUE_OOSEQ         1
-
-/* TCP Maximum segment size. */
-#define TCP_MSS                 1024
-
-/* TCP sender buffer space (bytes). */
-#define TCP_SND_BUF             2048
-
-/* TCP sender buffer space (pbufs). This must be at least = 2 *
-   TCP_SND_BUF/TCP_MSS for things to work. */
-#define TCP_SND_QUEUELEN       (4 * TCP_SND_BUF/TCP_MSS)
-
-/* TCP writable space (bytes). This must be less than or equal
-   to TCP_SND_BUF. It is the amount of space which must be
-   available in the tcp snd_buf for select to return writable */
-#define TCP_SNDLOWAT           (TCP_SND_BUF/2)
-
-/* TCP receive window. */
-#define TCP_WND                 (20 * 1024)
-
-/* Maximum number of retransmissions of data segments. */
-#define TCP_MAXRTX              12
-
-/* Maximum number of retransmissions of SYN segments. */
-#define TCP_SYNMAXRTX           4
-
-
-/* ---------- ARP options ---------- */
-#define LWIP_ARP                1
-#define ARP_TABLE_SIZE          10
-#define ARP_QUEUEING            1
-
-
-/* ---------- IP options ---------- */
-/* Define IP_FORWARD to 1 if you wish to have the ability to forward
-   IP packets across network interfaces. If you are going to run lwIP
-   on a device with only one network interface, define this to 0. */
-#define IP_FORWARD              1
-
-/* IP reassembly and segmentation.These are orthogonal even
- * if they both deal with IP fragments */
-#define IP_REASSEMBLY           1
-#define IP_REASS_MAX_PBUFS      (10 * ((1500 + PBUF_POOL_BUFSIZE - 1) / PBUF_POOL_BUFSIZE))
-#define MEMP_NUM_REASSDATA      IP_REASS_MAX_PBUFS
-#define IP_FRAG                 1
-#define IPV6_FRAG_COPYHEADER    1
-
-/* ---------- ICMP options ---------- */
-#define ICMP_TTL                255
-
-
-/* ---------- DHCP options ---------- */
-/* Define LWIP_DHCP to 1 if you want DHCP configuration of
-   interfaces. */
-#define LWIP_DHCP               LWIP_UDP
-
-/* 1 if you want to do an ARP check on the offered address
-   (recommended). */
-#define DHCP_DOES_ARP_CHECK    (LWIP_DHCP)
-
-
-/* ---------- AUTOIP options ------- */
-#define LWIP_AUTOIP            (LWIP_DHCP)
-#define LWIP_DHCP_AUTOIP_COOP  (LWIP_DHCP && LWIP_AUTOIP)
-
-
-/* ---------- UDP options ---------- */
-#define LWIP_UDP                1
-#define LWIP_UDPLITE            LWIP_UDP
-#define UDP_TTL                 255
-
-
-/* ---------- RAW options ---------- */
-#define LWIP_RAW                1
-
-
-/* ---------- Statistics options ---------- */
-
-#define LWIP_STATS              1
-#define LWIP_STATS_DISPLAY      1
-
-#if LWIP_STATS
-#define LINK_STATS              1
-#define IP_STATS                1
-#define ICMP_STATS              1
-#define IGMP_STATS              1
-#define IPFRAG_STATS            1
-#define UDP_STATS               1
-#define TCP_STATS               1
-#define MEM_STATS               1
-#define MEMP_STATS              1
-#define PBUF_STATS              1
-#define SYS_STATS               1
-#endif /* LWIP_STATS */
-
-/* ---------- NETBIOS options ---------- */
-#define LWIP_NETBIOS_RESPOND_NAME_QUERY 1
-
-/* ---------- PPP options ---------- */
-
-#define PPP_SUPPORT             1      /* Set > 0 for PPP */
-
-#if PPP_SUPPORT
-
-#define NUM_PPP                 1      /* Max PPP sessions. */
-
-
-/* Select modules to enable.  Ideally these would be set in the makefile but
- * we're limited by the command line length so you need to modify the settings
- * in this file.
- */
-#define PPPOE_SUPPORT           1
-#define PPPOS_SUPPORT           1
-
-#define PAP_SUPPORT             1      /* Set > 0 for PAP. */
-#define CHAP_SUPPORT            1      /* Set > 0 for CHAP. */
-#define MSCHAP_SUPPORT          0      /* Set > 0 for MSCHAP */
-#define CBCP_SUPPORT            0      /* Set > 0 for CBCP (NOT FUNCTIONAL!) */
-#define CCP_SUPPORT             0      /* Set > 0 for CCP */
-#define VJ_SUPPORT              1      /* Set > 0 for VJ header compression. */
-#define MD5_SUPPORT             1      /* Set > 0 for MD5 (see also CHAP) */
-
-#endif /* PPP_SUPPORT */
-
-#endif /* LWIP_OPTTEST_FILE */
-
-/* The following defines must be done even in OPTTEST mode: */
-
-#if !defined(NO_SYS) || !NO_SYS /* default is 0 */
-void sys_check_core_locking(void);
-#define LWIP_ASSERT_CORE_LOCKED()  sys_check_core_locking()
-void sys_mark_tcpip_thread(void);
-#define LWIP_MARK_TCPIP_THREAD()   sys_mark_tcpip_thread()
-
-#if !defined(LWIP_TCPIP_CORE_LOCKING) || LWIP_TCPIP_CORE_LOCKING /* default is 1 */
-void sys_lock_tcpip_core(void);
-#define LOCK_TCPIP_CORE()          sys_lock_tcpip_core()
-void sys_unlock_tcpip_core(void);
-#define UNLOCK_TCPIP_CORE()        sys_unlock_tcpip_core()
-#endif
-#endif
-
-#ifndef LWIP_PLATFORM_ASSERT
-/* Define LWIP_PLATFORM_ASSERT to something to catch missing stdio.h includes */
-void lwip_example_app_platform_assert(const char *msg, int line, const char *file);
-#define LWIP_PLATFORM_ASSERT(x) lwip_example_app_platform_assert(x, __LINE__, __FILE__)
-#endif
-
-#endif /* LWIP_LWIPOPTS_H */
diff --git a/contrib/examples/example_app/lwippools.h b/contrib/examples/example_app/lwippools.h
deleted file mode 100644
index f58aa598..00000000
--- a/contrib/examples/example_app/lwippools.h
+++ /dev/null
@@ -1,20 +0,0 @@
-/* OPTIONAL: Pools to replace heap allocation
- * Optional: Pools can be used instead of the heap for mem_malloc. If
- * so, these should be defined here, in increasing order according to
- * the pool element size.
- *
- * LWIP_MALLOC_MEMPOOL(number_elements, element_size)
- */
-#if MEM_USE_POOLS
-LWIP_MALLOC_MEMPOOL_START
-LWIP_MALLOC_MEMPOOL(100, 256)
-LWIP_MALLOC_MEMPOOL(50, 512)
-LWIP_MALLOC_MEMPOOL(20, 1024)
-LWIP_MALLOC_MEMPOOL(20, 1536)
-LWIP_MALLOC_MEMPOOL_END
-#endif /* MEM_USE_POOLS */
-
-/* Optional: Your custom pools can go here if you would like to use
- * lwIP's memory pools for anything else.
- */
-LWIP_MEMPOOL(SYS_MBOX, 22, 100, "SYS_MBOX")
diff --git a/contrib/examples/example_app/ppp_settings.h b/contrib/examples/example_app/ppp_settings.h
deleted file mode 100644
index 7b3ee1aa..00000000
--- a/contrib/examples/example_app/ppp_settings.h
+++ /dev/null
@@ -1,6 +0,0 @@
-#ifdef _MSC_VER
-#pragma warning (disable: 4242) /* PPP only: conversion from 'x' to 'y', possible loss of data */
-#pragma warning (disable: 4244) /* PPP only: conversion from 'x' to 'y', possible loss of data (again?) */
-#pragma warning (disable: 4310) /* PPP only: cast truncates constant value */
-#pragma warning (disable: 4706) /* PPP only: assignment within conditional expression */
-#endif /* MSC_VER  */
diff --git a/contrib/examples/example_app/test.c b/contrib/examples/example_app/test.c
deleted file mode 100644
index 510fd3ae..00000000
--- a/contrib/examples/example_app/test.c
+++ /dev/null
@@ -1,772 +0,0 @@
-/*
- * Copyright (c) 2001,2002 Florian Schulze.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the authors nor the names of the contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- * test.c - This file is part of lwIP test
- *
- */
-
-/* C runtime includes */
-#include <stdio.h>
-#include <stdarg.h>
-#include <stdlib.h>
-#include <time.h>
-#include <string.h>
-
-/* lwIP core includes */
-#include "lwip/opt.h"
-
-#include "lwip/sys.h"
-#include "lwip/timeouts.h"
-#include "lwip/debug.h"
-#include "lwip/stats.h"
-#include "lwip/init.h"
-#include "lwip/tcpip.h"
-#include "lwip/netif.h"
-#include "lwip/api.h"
-
-#include "lwip/tcp.h"
-#include "lwip/udp.h"
-#include "lwip/dns.h"
-#include "lwip/dhcp.h"
-#include "lwip/autoip.h"
-
-/* lwIP netif includes */
-#include "lwip/etharp.h"
-#include "netif/ethernet.h"
-
-/* applications includes */
-#include "lwip/apps/netbiosns.h"
-#include "lwip/apps/httpd.h"
-#include "apps/httpserver/httpserver-netconn.h"
-#include "apps/netio/netio.h"
-#include "apps/ping/ping.h"
-#include "apps/rtp/rtp.h"
-#include "apps/chargen/chargen.h"
-#include "apps/shell/shell.h"
-#include "apps/tcpecho/tcpecho.h"
-#include "apps/udpecho/udpecho.h"
-#include "apps/tcpecho_raw/tcpecho_raw.h"
-#include "apps/socket_examples/socket_examples.h"
-
-#include "examples/lwiperf/lwiperf_example.h"
-#include "examples/mdns/mdns_example.h"
-#include "examples/snmp/snmp_example.h"
-#include "examples/tftp/tftp_example.h"
-#include "examples/sntp/sntp_example.h"
-#include "examples/mqtt/mqtt_example.h"
-
-#include "examples/httpd/cgi_example/cgi_example.h"
-#include "examples/httpd/fs_example/fs_example.h"
-#include "examples/httpd/ssi_example/ssi_example.h"
-
-#include "default_netif.h"
-
-#if NO_SYS
-/* ... then we need information about the timer intervals: */
-#include "lwip/ip4_frag.h"
-#include "lwip/igmp.h"
-#endif /* NO_SYS */
-
-#include "netif/ppp/ppp_opts.h"
-#if PPP_SUPPORT
-/* PPP includes */
-#include "lwip/sio.h"
-#include "netif/ppp/pppapi.h"
-#include "netif/ppp/pppos.h"
-#include "netif/ppp/pppoe.h"
-#if !NO_SYS && !LWIP_PPP_API
-#error With NO_SYS==0, LWIP_PPP_API==1 is required.
-#endif
-#endif /* PPP_SUPPORT */
-
-/* include the port-dependent configuration */
-#include "lwipcfg.h"
-
-#ifndef LWIP_EXAMPLE_APP_ABORT
-#define LWIP_EXAMPLE_APP_ABORT() 0
-#endif
-
-/** Define this to 1 to enable a port-specific ethernet interface as default interface. */
-#ifndef USE_DEFAULT_ETH_NETIF
-#define USE_DEFAULT_ETH_NETIF 1
-#endif
-
-/** Define this to 1 to enable a PPP interface. */
-#ifndef USE_PPP
-#define USE_PPP 0
-#endif
-
-/** Define this to 1 or 2 to support 1 or 2 SLIP interfaces. */
-#ifndef USE_SLIPIF
-#define USE_SLIPIF 0
-#endif
-
-/** Use an ethernet adapter? Default to enabled if port-specific ethernet netif or PPPoE are used. */
-#ifndef USE_ETHERNET
-#define USE_ETHERNET  (USE_DEFAULT_ETH_NETIF || PPPOE_SUPPORT)
-#endif
-
-/** Use an ethernet adapter for TCP/IP? By default only if port-specific ethernet netif is used. */
-#ifndef USE_ETHERNET_TCPIP
-#define USE_ETHERNET_TCPIP  (USE_DEFAULT_ETH_NETIF)
-#endif
-
-#if USE_SLIPIF
-#include <netif/slipif.h>
-#endif /* USE_SLIPIF */
-
-#ifndef USE_DHCP
-#define USE_DHCP    LWIP_DHCP
-#endif
-#ifndef USE_AUTOIP
-#define USE_AUTOIP  LWIP_AUTOIP
-#endif
-
-/* globales variables for netifs */
-#if USE_ETHERNET
-#if LWIP_DHCP
-/* dhcp struct for the ethernet netif */
-struct dhcp netif_dhcp;
-#endif /* LWIP_DHCP */
-#if LWIP_AUTOIP
-/* autoip struct for the ethernet netif */
-struct autoip netif_autoip;
-#endif /* LWIP_AUTOIP */
-#endif /* USE_ETHERNET */
-#if USE_PPP
-/* THE PPP PCB */
-ppp_pcb *ppp;
-/* THE PPP interface */
-struct netif ppp_netif;
-/* THE PPP descriptor */
-u8_t sio_idx = 0;
-sio_fd_t ppp_sio;
-#endif /* USE_PPP */
-#if USE_SLIPIF
-struct netif slipif1;
-#if USE_SLIPIF > 1
-struct netif slipif2;
-#endif /* USE_SLIPIF > 1 */
-#endif /* USE_SLIPIF */
-
-
-#if USE_PPP
-static void
-pppLinkStatusCallback(ppp_pcb *pcb, int errCode, void *ctx)
-{
-  struct netif *pppif = ppp_netif(pcb);
-  LWIP_UNUSED_ARG(ctx);
-
-  switch(errCode) {
-    case PPPERR_NONE: {             /* No error. */
-      printf("pppLinkStatusCallback: PPPERR_NONE\n");
-#if LWIP_IPV4
-      printf("   our_ipaddr  = %s\n", ip4addr_ntoa(netif_ip4_addr(pppif)));
-      printf("   his_ipaddr  = %s\n", ip4addr_ntoa(netif_ip4_gw(pppif)));
-      printf("   netmask     = %s\n", ip4addr_ntoa(netif_ip4_netmask(pppif)));
-#endif /* LWIP_IPV4 */
-#if LWIP_DNS
-      printf("   dns1        = %s\n", ipaddr_ntoa(dns_getserver(0)));
-      printf("   dns2        = %s\n", ipaddr_ntoa(dns_getserver(1)));
-#endif /* LWIP_DNS */
-#if PPP_IPV6_SUPPORT
-      printf("   our6_ipaddr = %s\n", ip6addr_ntoa(netif_ip6_addr(pppif, 0)));
-#endif /* PPP_IPV6_SUPPORT */
-      break;
-    }
-    case PPPERR_PARAM: {           /* Invalid parameter. */
-      printf("pppLinkStatusCallback: PPPERR_PARAM\n");
-      break;
-    }
-    case PPPERR_OPEN: {            /* Unable to open PPP session. */
-      printf("pppLinkStatusCallback: PPPERR_OPEN\n");
-      break;
-    }
-    case PPPERR_DEVICE: {          /* Invalid I/O device for PPP. */
-      printf("pppLinkStatusCallback: PPPERR_DEVICE\n");
-      break;
-    }
-    case PPPERR_ALLOC: {           /* Unable to allocate resources. */
-      printf("pppLinkStatusCallback: PPPERR_ALLOC\n");
-      break;
-    }
-    case PPPERR_USER: {            /* User interrupt. */
-      printf("pppLinkStatusCallback: PPPERR_USER\n");
-      break;
-    }
-    case PPPERR_CONNECT: {         /* Connection lost. */
-      printf("pppLinkStatusCallback: PPPERR_CONNECT\n");
-      break;
-    }
-    case PPPERR_AUTHFAIL: {        /* Failed authentication challenge. */
-      printf("pppLinkStatusCallback: PPPERR_AUTHFAIL\n");
-      break;
-    }
-    case PPPERR_PROTOCOL: {        /* Failed to meet protocol. */
-      printf("pppLinkStatusCallback: PPPERR_PROTOCOL\n");
-      break;
-    }
-    case PPPERR_PEERDEAD: {        /* Connection timeout */
-      printf("pppLinkStatusCallback: PPPERR_PEERDEAD\n");
-      break;
-    }
-    case PPPERR_IDLETIMEOUT: {     /* Idle Timeout */
-      printf("pppLinkStatusCallback: PPPERR_IDLETIMEOUT\n");
-      break;
-    }
-    case PPPERR_CONNECTTIME: {     /* Max connect time reached */
-      printf("pppLinkStatusCallback: PPPERR_CONNECTTIME\n");
-      break;
-    }
-    case PPPERR_LOOPBACK: {        /* Loopback detected */
-      printf("pppLinkStatusCallback: PPPERR_LOOPBACK\n");
-      break;
-    }
-    default: {
-      printf("pppLinkStatusCallback: unknown errCode %d\n", errCode);
-      break;
-    }
-  }
-}
-
-#if PPPOS_SUPPORT
-static u32_t
-ppp_output_cb(ppp_pcb *pcb, u8_t *data, u32_t len, void *ctx)
-{
-  LWIP_UNUSED_ARG(pcb);
-  LWIP_UNUSED_ARG(ctx);
-  return sio_write(ppp_sio, data, len);
-}
-#endif /* PPPOS_SUPPORT */
-#endif /* USE_PPP */
-
-#if LWIP_NETIF_STATUS_CALLBACK
-static void
-status_callback(struct netif *state_netif)
-{
-  if (netif_is_up(state_netif)) {
-#if LWIP_IPV4
-    printf("status_callback==UP, local interface IP is %s\n", ip4addr_ntoa(netif_ip4_addr(state_netif)));
-#else
-    printf("status_callback==UP\n");
-#endif
-  } else {
-    printf("status_callback==DOWN\n");
-  }
-}
-#endif /* LWIP_NETIF_STATUS_CALLBACK */
-
-#if LWIP_NETIF_LINK_CALLBACK
-static void
-link_callback(struct netif *state_netif)
-{
-  if (netif_is_link_up(state_netif)) {
-    printf("link_callback==UP\n");
-  } else {
-    printf("link_callback==DOWN\n");
-  }
-}
-#endif /* LWIP_NETIF_LINK_CALLBACK */
-
-/* This function initializes all network interfaces */
-static void
-test_netif_init(void)
-{
-#if LWIP_IPV4 && USE_ETHERNET
-  ip4_addr_t ipaddr, netmask, gw;
-#endif /* LWIP_IPV4 && USE_ETHERNET */
-#if USE_SLIPIF
-  u8_t num_slip1 = 0;
-#if LWIP_IPV4
-  ip4_addr_t ipaddr_slip1, netmask_slip1, gw_slip1;
-#endif
-#if USE_SLIPIF > 1
-  u8_t num_slip2 = 1;
-#if LWIP_IPV4
-  ip4_addr_t ipaddr_slip2, netmask_slip2, gw_slip2;
-#endif
-#endif /* USE_SLIPIF > 1 */
-#endif /* USE_SLIPIF */
-#if USE_DHCP || USE_AUTOIP
-  err_t err;
-#endif
-
-#if USE_PPP
-  const char *username = NULL, *password = NULL;
-#ifdef PPP_USERNAME
-  username = PPP_USERNAME;
-#endif
-#ifdef PPP_PASSWORD
-  password = PPP_PASSWORD;
-#endif
-  printf("ppp_connect: COM%d\n", (int)sio_idx);
-#if PPPOS_SUPPORT
-  ppp_sio = sio_open(sio_idx);
-  if (ppp_sio == NULL) {
-    printf("sio_open error\n");
-  } else {
-    ppp = pppos_create(&ppp_netif, ppp_output_cb, pppLinkStatusCallback, NULL);
-    if (ppp == NULL) {
-      printf("pppos_create error\n");
-    } else {
-      ppp_set_auth(ppp, PPPAUTHTYPE_ANY, username, password);
-      ppp_connect(ppp, 0);
-    }
-  }
-#endif /* PPPOS_SUPPORT */
-#endif  /* USE_PPP */
-
-#if USE_ETHERNET
-#if LWIP_IPV4
-  ip4_addr_set_zero(&gw);
-  ip4_addr_set_zero(&ipaddr);
-  ip4_addr_set_zero(&netmask);
-#if USE_ETHERNET_TCPIP
-#if USE_DHCP
-  printf("Starting lwIP, local interface IP is dhcp-enabled\n");
-#elif USE_AUTOIP
-  printf("Starting lwIP, local interface IP is autoip-enabled\n");
-#else /* USE_DHCP */
-  LWIP_PORT_INIT_GW(&gw);
-  LWIP_PORT_INIT_IPADDR(&ipaddr);
-  LWIP_PORT_INIT_NETMASK(&netmask);
-  printf("Starting lwIP, local interface IP is %s\n", ip4addr_ntoa(&ipaddr));
-#endif /* USE_DHCP */
-#endif /* USE_ETHERNET_TCPIP */
-#else /* LWIP_IPV4 */
-  printf("Starting lwIP, IPv4 disable\n");
-#endif /* LWIP_IPV4 */
-
-#if LWIP_IPV4
-  init_default_netif(&ipaddr, &netmask, &gw);
-#else
-  init_default_netif();
-#endif
-#if LWIP_IPV6
-  netif_create_ip6_linklocal_address(netif_default, 1);
-#if LWIP_IPV6_AUTOCONFIG
-  netif_default->ip6_autoconfig_enabled = 1;
-#endif
-  printf("ip6 linklocal address: %s\n", ip6addr_ntoa(netif_ip6_addr(netif_default, 0)));
-#endif /* LWIP_IPV6 */
-#if LWIP_NETIF_STATUS_CALLBACK
-  netif_set_status_callback(netif_default, status_callback);
-#endif /* LWIP_NETIF_STATUS_CALLBACK */
-#if LWIP_NETIF_LINK_CALLBACK
-  netif_set_link_callback(netif_default, link_callback);
-#endif /* LWIP_NETIF_LINK_CALLBACK */
-
-#if USE_ETHERNET_TCPIP
-#if LWIP_AUTOIP
-  autoip_set_struct(netif_default, &netif_autoip);
-#endif /* LWIP_AUTOIP */
-#if LWIP_DHCP
-  dhcp_set_struct(netif_default, &netif_dhcp);
-#endif /* LWIP_DHCP */
-  netif_set_up(netif_default);
-#if USE_DHCP
-  err = dhcp_start(netif_default);
-  LWIP_ASSERT("dhcp_start failed", err == ERR_OK);
-#elif USE_AUTOIP
-  err = autoip_start(netif_default);
-  LWIP_ASSERT("autoip_start failed", err == ERR_OK);
-#endif /* USE_DHCP */
-#else /* USE_ETHERNET_TCPIP */
-  /* Use ethernet for PPPoE only */
-  netif.flags &= ~(NETIF_FLAG_ETHARP | NETIF_FLAG_IGMP); /* no ARP */
-  netif.flags |= NETIF_FLAG_ETHERNET; /* but pure ethernet */
-#endif /* USE_ETHERNET_TCPIP */
-
-#if USE_PPP && PPPOE_SUPPORT
-  /* start PPPoE after ethernet netif is added! */
-  ppp = pppoe_create(&ppp_netif, netif_default, NULL, NULL, pppLinkStatusCallback, NULL);
-  if (ppp == NULL) {
-    printf("pppoe_create error\n");
-  } else {
-    ppp_set_auth(ppp, PPPAUTHTYPE_ANY, username, password);
-    ppp_connect(ppp, 0);
-  }
-#endif /* USE_PPP && PPPOE_SUPPORT */
-
-#endif /* USE_ETHERNET */
-#if USE_SLIPIF
-#if LWIP_IPV4
-#define SLIP1_ADDRS &ipaddr_slip1, &netmask_slip1, &gw_slip1,
-  LWIP_PORT_INIT_SLIP1_IPADDR(&ipaddr_slip1);
-  LWIP_PORT_INIT_SLIP1_GW(&gw_slip1);
-  LWIP_PORT_INIT_SLIP1_NETMASK(&netmask_slip1);
-  printf("Starting lwIP slipif, local interface IP is %s\n", ip4addr_ntoa(&ipaddr_slip1));
-#else
-#define SLIP1_ADDRS
-  printf("Starting lwIP slipif\n");
-#endif
-#if defined(SIO_USE_COMPORT) && SIO_USE_COMPORT
-  num_slip1++; /* COM ports cannot be 0-based */
-#endif
-  netif_add(&slipif1, SLIP1_ADDRS &num_slip1, slipif_init, ip_input);
-#if !USE_ETHERNET
-  netif_set_default(&slipif1);
-#endif /* !USE_ETHERNET */
-#if LWIP_IPV6
-  netif_create_ip6_linklocal_address(&slipif1, 1);
-  printf("SLIP ip6 linklocal address: %s\n", ip6addr_ntoa(netif_ip6_addr(&slipif1, 0)));
-#endif /* LWIP_IPV6 */
-#if LWIP_NETIF_STATUS_CALLBACK
-  netif_set_status_callback(&slipif1, status_callback);
-#endif /* LWIP_NETIF_STATUS_CALLBACK */
-#if LWIP_NETIF_LINK_CALLBACK
-  netif_set_link_callback(&slipif1, link_callback);
-#endif /* LWIP_NETIF_LINK_CALLBACK */
-  netif_set_up(&slipif1);
-
-#if USE_SLIPIF > 1
-#if LWIP_IPV4
-#define SLIP2_ADDRS &ipaddr_slip2, &netmask_slip2, &gw_slip2,
-  LWIP_PORT_INIT_SLIP2_IPADDR(&ipaddr_slip2);
-  LWIP_PORT_INIT_SLIP2_GW(&gw_slip2);
-  LWIP_PORT_INIT_SLIP2_NETMASK(&netmask_slip2);
-  printf("Starting lwIP SLIP if #2, local interface IP is %s\n", ip4addr_ntoa(&ipaddr_slip2));
-#else
-#define SLIP2_ADDRS
-  printf("Starting lwIP SLIP if #2\n");
-#endif
-#if defined(SIO_USE_COMPORT) && SIO_USE_COMPORT
-  num_slip2++; /* COM ports cannot be 0-based */
-#endif
-  netif_add(&slipif2, SLIP2_ADDRS &num_slip2, slipif_init, ip_input);
-#if LWIP_IPV6
-  netif_create_ip6_linklocal_address(&slipif1, 1);
-  printf("SLIP2 ip6 linklocal address: ");
-  ip6_addr_debug_print(0xFFFFFFFF & ~LWIP_DBG_HALT, netif_ip6_addr(&slipif2, 0));
-  printf("\n");
-#endif /* LWIP_IPV6 */
-#if LWIP_NETIF_STATUS_CALLBACK
-  netif_set_status_callback(&slipif2, status_callback);
-#endif /* LWIP_NETIF_STATUS_CALLBACK */
-#if LWIP_NETIF_LINK_CALLBACK
-  netif_set_link_callback(&slipif2, link_callback);
-#endif /* LWIP_NETIF_LINK_CALLBACK */
-  netif_set_up(&slipif2);
-#endif /* USE_SLIPIF > 1*/
-#endif /* USE_SLIPIF */
-}
-
-#if LWIP_DNS_APP && LWIP_DNS
-static void
-dns_found(const char *name, const ip_addr_t *addr, void *arg)
-{
-  LWIP_UNUSED_ARG(arg);
-  printf("%s: %s\n", name, addr ? ipaddr_ntoa(addr) : "<not found>");
-}
-
-static void
-dns_dorequest(void *arg)
-{
-  const char* dnsname = "3com.com";
-  ip_addr_t dnsresp;
-  LWIP_UNUSED_ARG(arg);
-
-  if (dns_gethostbyname(dnsname, &dnsresp, dns_found, 0) == ERR_OK) {
-    dns_found(dnsname, &dnsresp, 0);
-  }
-}
-#endif /* LWIP_DNS_APP && LWIP_DNS */
-
-/* This function initializes applications */
-static void
-apps_init(void)
-{
-#if LWIP_DNS_APP && LWIP_DNS
-  /* wait until the netif is up (for dhcp, autoip or ppp) */
-  sys_timeout(5000, dns_dorequest, NULL);
-#endif /* LWIP_DNS_APP && LWIP_DNS */
-
-#if LWIP_CHARGEN_APP && LWIP_SOCKET
-  chargen_init();
-#endif /* LWIP_CHARGEN_APP && LWIP_SOCKET */
-
-#if LWIP_PING_APP && LWIP_RAW && LWIP_ICMP
-  ping_init(&netif_default->gw);
-#endif /* LWIP_PING_APP && LWIP_RAW && LWIP_ICMP */
-
-#if LWIP_NETBIOS_APP && LWIP_UDP
-  netbiosns_init();
-#ifndef NETBIOS_LWIP_NAME
-#if LWIP_NETIF_HOSTNAME
-  netbiosns_set_name(netif_default->hostname);
-#else
-  netbiosns_set_name("NETBIOSLWIPDEV");
-#endif
-#endif
-#endif /* LWIP_NETBIOS_APP && LWIP_UDP */
-
-#if LWIP_HTTPD_APP && LWIP_TCP
-#ifdef LWIP_HTTPD_APP_NETCONN
-  http_server_netconn_init();
-#else /* LWIP_HTTPD_APP_NETCONN */
-#if defined(LWIP_HTTPD_EXAMPLE_CUSTOMFILES) && LWIP_HTTPD_EXAMPLE_CUSTOMFILES && defined(LWIP_HTTPD_EXAMPLE_CUSTOMFILES_ROOTDIR)
-  fs_ex_init(LWIP_HTTPD_EXAMPLE_CUSTOMFILES_ROOTDIR);
-#endif
-  httpd_init();
-#if defined(LWIP_HTTPD_EXAMPLE_SSI_SIMPLE) && LWIP_HTTPD_EXAMPLE_SSI_SIMPLE
-  ssi_ex_init();
-#endif
-#if defined(LWIP_HTTPD_EXAMPLE_CGI_SIMPLE) && LWIP_HTTPD_EXAMPLE_CGI_SIMPLE
-  cgi_ex_init();
-#endif
-#endif /* LWIP_HTTPD_APP_NETCONN */
-#endif /* LWIP_HTTPD_APP && LWIP_TCP */
-
-#if LWIP_NETIO_APP && LWIP_TCP
-  netio_init();
-#endif /* LWIP_NETIO_APP && LWIP_TCP */
-
-#if LWIP_RTP_APP && LWIP_SOCKET && LWIP_IGMP
-  rtp_init();
-#endif /* LWIP_RTP_APP && LWIP_SOCKET && LWIP_IGMP */
-
-#if LWIP_SHELL_APP && LWIP_NETCONN
-  shell_init();
-#endif /* LWIP_SHELL_APP && LWIP_NETCONN */
-#if LWIP_TCPECHO_APP
-#if LWIP_NETCONN && defined(LWIP_TCPECHO_APP_NETCONN)
-  tcpecho_init();
-#else /* LWIP_NETCONN && defined(LWIP_TCPECHO_APP_NETCONN) */
-  tcpecho_raw_init();
-#endif
-#endif /* LWIP_TCPECHO_APP && LWIP_NETCONN */
-#if LWIP_UDPECHO_APP && LWIP_NETCONN
-  udpecho_init();
-#endif /* LWIP_UDPECHO_APP && LWIP_NETCONN */
-#if LWIP_SOCKET_EXAMPLES_APP && LWIP_SOCKET
-  socket_examples_init();
-#endif /* LWIP_SOCKET_EXAMPLES_APP && LWIP_SOCKET */
-#if LWIP_MDNS_APP
-  mdns_example_init();
-#endif
-#if LWIP_SNMP_APP
-  snmp_example_init();
-#endif
-#if LWIP_SNTP_APP
-  sntp_example_init();
-#endif
-#if LWIP_TFTP_APP
-  tftp_example_init_server();
-#endif
-#if LWIP_TFTP_CLIENT_APP
-  tftp_example_init_client();
-#endif
-#if LWIP_LWIPERF_APP
-  lwiperf_example_init();
-#endif
-#if LWIP_MQTT_APP
-  mqtt_example_init();
-#endif
-
-#ifdef LWIP_APP_INIT
-  LWIP_APP_INIT();
-#endif
-}
-
-/* This function initializes this lwIP test. When NO_SYS=1, this is done in
- * the main_loop context (there is no other one), when NO_SYS=0, this is done
- * in the tcpip_thread context */
-static void
-test_init(void * arg)
-{ /* remove compiler warning */
-#if NO_SYS
-  LWIP_UNUSED_ARG(arg);
-#else /* NO_SYS */
-  sys_sem_t *init_sem;
-  LWIP_ASSERT("arg != NULL", arg != NULL);
-  init_sem = (sys_sem_t*)arg;
-#endif /* NO_SYS */
-
-  /* init randomizer again (seed per thread) */
-  srand((unsigned int)time(0));
-
-  /* init network interfaces */
-  test_netif_init();
-
-  /* init apps */
-  apps_init();
-
-#if !NO_SYS
-  sys_sem_signal(init_sem);
-#endif /* !NO_SYS */
-}
-
-/* This is somewhat different to other ports: we have a main loop here:
- * a dedicated task that waits for packets to arrive. This would normally be
- * done from interrupt context with embedded hardware, but we don't get an
- * interrupt in windows for that :-) */
-static void
-main_loop(void)
-{
-#if !NO_SYS
-  err_t err;
-  sys_sem_t init_sem;
-#endif /* NO_SYS */
-#if USE_PPP
-#if !USE_ETHERNET
-  int count;
-  u8_t rxbuf[1024];
-#endif
-  volatile int callClosePpp = 0;
-#endif /* USE_PPP */
-
-  /* initialize lwIP stack, network interfaces and applications */
-#if NO_SYS
-  lwip_init();
-  test_init(NULL);
-#else /* NO_SYS */
-  err = sys_sem_new(&init_sem, 0);
-  LWIP_ASSERT("failed to create init_sem", err == ERR_OK);
-  LWIP_UNUSED_ARG(err);
-  tcpip_init(test_init, &init_sem);
-  /* we have to wait for initialization to finish before
-   * calling update_adapter()! */
-  sys_sem_wait(&init_sem);
-  sys_sem_free(&init_sem);
-#endif /* NO_SYS */
-
-#if (LWIP_SOCKET || LWIP_NETCONN) && LWIP_NETCONN_SEM_PER_THREAD
-  netconn_thread_init();
-#endif
-
-  /* MAIN LOOP for driver update (and timers if NO_SYS) */
-  while (!LWIP_EXAMPLE_APP_ABORT()) {
-#if NO_SYS
-    /* handle timers (already done in tcpip.c when NO_SYS=0) */
-    sys_check_timeouts();
-#endif /* NO_SYS */
-
-#if USE_ETHERNET
-    default_netif_poll();
-#else /* USE_ETHERNET */
-    /* try to read characters from serial line and pass them to PPPoS */
-    count = sio_read(ppp_sio, (u8_t*)rxbuf, 1024);
-    if(count > 0) {
-      pppos_input(ppp, rxbuf, count);
-    } else {
-      /* nothing received, give other tasks a chance to run */
-      sys_msleep(1);
-    }
-
-#endif /* USE_ETHERNET */
-#if USE_SLIPIF
-    slipif_poll(&slipif1);
-#if USE_SLIPIF > 1
-    slipif_poll(&slipif2);
-#endif /* USE_SLIPIF > 1 */
-#endif /* USE_SLIPIF */
-#if ENABLE_LOOPBACK && !LWIP_NETIF_LOOPBACK_MULTITHREADING
-    /* check for loopback packets on all netifs */
-    netif_poll_all();
-#endif /* ENABLE_LOOPBACK && !LWIP_NETIF_LOOPBACK_MULTITHREADING */
-#if USE_PPP
-    {
-    int do_hup = 0;
-    if(do_hup) {
-      ppp_close(ppp, 1);
-      do_hup = 0;
-    }
-    }
-    if(callClosePpp && ppp) {
-      /* make sure to disconnect PPP before stopping the program... */
-      callClosePpp = 0;
-#if NO_SYS
-      ppp_close(ppp, 0);
-#else
-      pppapi_close(ppp, 0);
-#endif
-      ppp = NULL;
-    }
-#endif /* USE_PPP */
-  }
-
-#if USE_PPP
-    if(ppp) {
-      u32_t started;
-      printf("Closing PPP connection...\n");
-      /* make sure to disconnect PPP before stopping the program... */
-#if NO_SYS
-      ppp_close(ppp, 0);
-#else
-      pppapi_close(ppp, 0);
-#endif
-      ppp = NULL;
-      /* Wait for some time to let PPP finish... */
-      started = sys_now();
-      do
-      {
-#if USE_ETHERNET
-        default_netif_poll();
-#endif
-        /* @todo: need a better check here: only wait until PPP is down */
-      } while(sys_now() - started < 5000);
-    }
-#endif /* USE_PPP */
-#if (LWIP_SOCKET || LWIP_NETCONN) && LWIP_NETCONN_SEM_PER_THREAD
-  netconn_thread_cleanup();
-#endif
-#if USE_ETHERNET
-  default_netif_shutdown();
-#endif /* USE_ETHERNET */
-}
-
-#if USE_PPP && PPPOS_SUPPORT
-int main(int argc, char **argv)
-#else /* USE_PPP && PPPOS_SUPPORT */
-int main(void)
-#endif /* USE_PPP && PPPOS_SUPPORT */
-{
-#if USE_PPP && PPPOS_SUPPORT
-  if(argc > 1) {
-    sio_idx = (u8_t)atoi(argv[1]);
-  }
-  printf("Using serial port %d for PPP\n", sio_idx);
-#endif /* USE_PPP && PPPOS_SUPPORT */
-  /* no stdio-buffering, please! */
-  setvbuf(stdout, NULL,_IONBF, 0);
-
-  main_loop();
-
-  return 0;
-}
-
-/* This function is only required to prevent arch.h including stdio.h
- * (which it does if LWIP_PLATFORM_ASSERT is undefined)
- */
-void lwip_example_app_platform_assert(const char *msg, int line, const char *file)
-{
-  printf("Assertion \"%s\" failed at line %d in %s\n", msg, line, file);
-  fflush(NULL);
-  abort();
-}
diff --git a/contrib/examples/example_app/test_configs/opt_default.h b/contrib/examples/example_app/test_configs/opt_default.h
deleted file mode 100644
index 67b69d20..00000000
--- a/contrib/examples/example_app/test_configs/opt_default.h
+++ /dev/null
@@ -1,295 +0,0 @@
-/* test an lwipopts.h file with default contents */
-#define NO_SYS                          0
-#define NO_SYS_NO_TIMERS                0
-#define LWIP_TIMERS                     1
-#define LWIP_TIMERS_CUSTOM              0
-#define LWIP_MPU_COMPATIBLE             0
-#define LWIP_TCPIP_CORE_LOCKING         1
-#define LWIP_TCPIP_CORE_LOCKING_INPUT   0
-#define SYS_LIGHTWEIGHT_PROT            1
-#define MEM_LIBC_MALLOC                 0
-#define MEMP_MEM_MALLOC                 0
-#define MEMP_MEM_INIT                   0
-#define MEM_ALIGNMENT                   1
-#define MEM_SIZE                        1600
-#define MEMP_OVERFLOW_CHECK             0
-#define MEMP_SANITY_CHECK               0
-#define MEM_OVERFLOW_CHECK              0
-#define MEM_SANITY_CHECK                0
-#define MEM_USE_POOLS                   0
-#define MEM_USE_POOLS_TRY_BIGGER_POOL   0
-#define MEMP_USE_CUSTOM_POOLS           0
-#define LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT 0
-/*#define MEMP_NUM_PBUF                   16
-#define MEMP_NUM_RAW_PCB                4
-#define MEMP_NUM_UDP_PCB                4
-#define MEMP_NUM_TCP_PCB                5
-#define MEMP_NUM_TCP_PCB_LISTEN         8
-#define MEMP_NUM_TCP_SEG                16
-#define MEMP_NUM_ALTCP_PCB              MEMP_NUM_TCP_PCB
-#define MEMP_NUM_REASSDATA              5
-#define MEMP_NUM_FRAG_PBUF              15
-#define MEMP_NUM_ARP_QUEUE              30
-#define MEMP_NUM_IGMP_GROUP             8
-#define MEMP_NUM_SYS_TIMEOUT            (LWIP_NUM_SYS_TIMEOUT_INTERNAL + 2)
-#define MEMP_NUM_NETBUF                 2
-#define MEMP_NUM_NETCONN                4
-#define MEMP_NUM_SELECT_CB              4
-#define MEMP_NUM_TCPIP_MSG_API          8
-#define MEMP_NUM_TCPIP_MSG_INPKT        8
-#define MEMP_NUM_NETDB                  1
-#define MEMP_NUM_LOCALHOSTLIST          1
-#define PBUF_POOL_SIZE                  16
-#define MEMP_NUM_API_MSG                MEMP_NUM_TCPIP_MSG_API
-#define MEMP_NUM_DNS_API_MSG            MEMP_NUM_TCPIP_MSG_API
-#define MEMP_NUM_SOCKET_SETGETSOCKOPT_DATA MEMP_NUM_TCPIP_MSG_API
-#define MEMP_NUM_NETIFAPI_MSG           MEMP_NUM_TCPIP_MSG_API*/
-#define LWIP_ARP                        1
-#define ARP_TABLE_SIZE                  10
-#define ARP_MAXAGE                      300
-#define ARP_QUEUEING                    0
-#define ARP_QUEUE_LEN                   3
-#define ETHARP_SUPPORT_VLAN             0
-#define LWIP_ETHERNET                   LWIP_ARP
-#define ETH_PAD_SIZE                    0
-#define ETHARP_SUPPORT_STATIC_ENTRIES   0
-#define ETHARP_TABLE_MATCH_NETIF        !LWIP_SINGLE_NETIF
-#define LWIP_IPV4                       1
-#define IP_FORWARD                      0
-#define IP_REASSEMBLY                   1
-#define IP_FRAG                         1
-#define IP_OPTIONS_ALLOWED              1
-#define IP_REASS_MAXAGE                 15
-#define IP_REASS_MAX_PBUFS              10
-#define IP_DEFAULT_TTL                  255
-#define IP_SOF_BROADCAST                0
-#define IP_SOF_BROADCAST_RECV           0
-#define IP_FORWARD_ALLOW_TX_ON_RX_NETIF 0
-#define LWIP_ICMP                       1
-#define ICMP_TTL                        (IP_DEFAULT_TTL)
-#define LWIP_BROADCAST_PING             0
-#define LWIP_MULTICAST_PING             0
-#define LWIP_RAW                        0
-#define RAW_TTL                         (IP_DEFAULT_TTL)
-#define LWIP_DHCP                       1
-#define LWIP_DHCP_CHECK_LINK_UP         0
-#define LWIP_DHCP_BOOTP_FILE            0
-#define LWIP_DHCP_GET_NTP_SRV           0
-#define LWIP_DHCP_MAX_NTP_SERVERS       1
-#define LWIP_DHCP_MAX_DNS_SERVERS       DNS_MAX_SERVERS
-#define LWIP_AUTOIP                     0
-#define LWIP_DHCP_AUTOIP_COOP           0
-#define LWIP_DHCP_AUTOIP_COOP_TRIES     9
-#define LWIP_MIB2_CALLBACKS             0
-#define LWIP_MULTICAST_TX_OPTIONS       ((LWIP_IGMP || LWIP_IPV6_MLD) && (LWIP_UDP || LWIP_RAW))
-#define LWIP_IGMP                       0
-#define LWIP_DNS                        0
-#define DNS_TABLE_SIZE                  4
-#define DNS_MAX_NAME_LENGTH             256
-#define DNS_MAX_SERVERS                 2
-#define DNS_MAX_RETRIES                 4
-#define DNS_DOES_NAME_CHECK             1
-#define LWIP_DNS_SECURE (LWIP_DNS_SECURE_RAND_XID | LWIP_DNS_SECURE_NO_MULTIPLE_OUTSTANDING | LWIP_DNS_SECURE_RAND_SRC_PORT)
-#define DNS_LOCAL_HOSTLIST              0
-#define DNS_LOCAL_HOSTLIST_IS_DYNAMIC   0
-#define LWIP_DNS_SUPPORT_MDNS_QUERIES   0
-#define LWIP_UDP                        1
-#define LWIP_UDPLITE                    0
-#define UDP_TTL                         (IP_DEFAULT_TTL)
-#define LWIP_NETBUF_RECVINFO            0
-#define LWIP_TCP                        1
-#define TCP_TTL                         (IP_DEFAULT_TTL)
-#define TCP_WND                         (4 * TCP_MSS)
-#define TCP_MAXRTX                      12
-#define TCP_SYNMAXRTX                   6
-#define TCP_QUEUE_OOSEQ                 (LWIP_TCP)
-#define LWIP_TCP_SACK_OUT               0
-#define LWIP_TCP_MAX_SACK_NUM           4
-#define TCP_MSS                         536
-#define TCP_CALCULATE_EFF_SEND_MSS      1
-#define TCP_SND_BUF                     (2 * TCP_MSS)
-#define TCP_SND_QUEUELEN                ((4 * (TCP_SND_BUF) + (TCP_MSS - 1))/(TCP_MSS))
-#define TCP_SNDLOWAT                    LWIP_MIN(LWIP_MAX(((TCP_SND_BUF)/2), (2 * TCP_MSS) + 1), (TCP_SND_BUF) - 1)
-#define TCP_SNDQUEUELOWAT               LWIP_MAX(((TCP_SND_QUEUELEN)/2), 5)
-#define TCP_OOSEQ_MAX_BYTES             0
-#define TCP_OOSEQ_BYTES_LIMIT(pcb)      TCP_OOSEQ_MAX_BYTES
-#define TCP_OOSEQ_MAX_PBUFS             0
-#define TCP_OOSEQ_PBUFS_LIMIT(pcb)      TCP_OOSEQ_MAX_PBUFS
-#define TCP_LISTEN_BACKLOG              0
-#define TCP_DEFAULT_LISTEN_BACKLOG      0xff
-#define TCP_OVERSIZE                    TCP_MSS
-#define LWIP_TCP_TIMESTAMPS             0
-#define TCP_WND_UPDATE_THRESHOLD        LWIP_MIN((TCP_WND / 4), (TCP_MSS * 4))
-#define LWIP_EVENT_API                  0
-#define LWIP_CALLBACK_API               1
-#define LWIP_WND_SCALE                  0
-#define TCP_RCV_SCALE                   0
-#define LWIP_TCP_PCB_NUM_EXT_ARGS       0
-#define LWIP_ALTCP                      0
-#define LWIP_ALTCP_TLS                  0
-#define PBUF_LINK_HLEN                  (14 + ETH_PAD_SIZE)
-#define PBUF_LINK_ENCAPSULATION_HLEN    0
-#define PBUF_POOL_BUFSIZE               LWIP_MEM_ALIGN_SIZE(TCP_MSS+40+PBUF_LINK_ENCAPSULATION_HLEN+PBUF_LINK_HLEN)
-#define LWIP_PBUF_REF_T                 u8_t
-#define LWIP_SINGLE_NETIF               0
-#define LWIP_NETIF_HOSTNAME             0
-#define LWIP_NETIF_API                  0
-#define LWIP_NETIF_STATUS_CALLBACK      0
-#define LWIP_NETIF_EXT_STATUS_CALLBACK  0
-#define LWIP_NETIF_LINK_CALLBACK        0
-#define LWIP_NETIF_REMOVE_CALLBACK      0
-#define LWIP_NETIF_HWADDRHINT           0
-#define LWIP_NETIF_TX_SINGLE_PBUF       0
-#define LWIP_NUM_NETIF_CLIENT_DATA      0
-#define LWIP_HAVE_LOOPIF                (LWIP_NETIF_LOOPBACK && !LWIP_SINGLE_NETIF)
-#define LWIP_LOOPIF_MULTICAST           0
-#define LWIP_NETIF_LOOPBACK             0
-#define LWIP_LOOPBACK_MAX_PBUFS         0
-#define LWIP_NETIF_LOOPBACK_MULTITHREADING    (!NO_SYS)
-/*#define TCPIP_THREAD_NAME               "tcpip_thread"
-#define TCPIP_THREAD_STACKSIZE          0
-#define TCPIP_THREAD_PRIO               1
-#define TCPIP_MBOX_SIZE                 0
-#define LWIP_TCPIP_THREAD_ALIVE()
-#define SLIPIF_THREAD_NAME              "slipif_loop"
-#define SLIPIF_THREAD_STACKSIZE         0
-#define SLIPIF_THREAD_PRIO              1
-#define DEFAULT_THREAD_NAME             "lwIP"
-#define DEFAULT_THREAD_STACKSIZE        0
-#define DEFAULT_THREAD_PRIO             1
-#define DEFAULT_RAW_RECVMBOX_SIZE       0
-#define DEFAULT_UDP_RECVMBOX_SIZE       0
-#define DEFAULT_TCP_RECVMBOX_SIZE       0
-#define DEFAULT_ACCEPTMBOX_SIZE         0*/
-#define LWIP_NETCONN                    1
-#define LWIP_TCPIP_TIMEOUT              0
-#define LWIP_NETCONN_SEM_PER_THREAD     0
-#define LWIP_NETCONN_FULLDUPLEX         0
-#define LWIP_SOCKET                     1
-#define LWIP_COMPAT_SOCKETS             1 /* 0..2 */
-#define LWIP_POSIX_SOCKETS_IO_NAMES     1
-#define LWIP_SOCKET_OFFSET              0
-#define LWIP_TCP_KEEPALIVE              0
-#define LWIP_SO_SNDTIMEO                0
-#define LWIP_SO_RCVTIMEO                0
-#define LWIP_SO_SNDRCVTIMEO_NONSTANDARD 0
-#define LWIP_SO_RCVBUF                  0
-#define LWIP_SO_LINGER                  0
-#define RECV_BUFSIZE_DEFAULT            INT_MAX
-#define LWIP_TCP_CLOSE_TIMEOUT_MS_DEFAULT 20000
-#define SO_REUSE                        0
-#define SO_REUSE_RXTOALL                0
-#define LWIP_FIONREAD_LINUXMODE         0
-#define LWIP_SOCKET_SELECT              1
-#define LWIP_SOCKET_POLL                1
-#define LWIP_STATS                      1
-#define LWIP_STATS_DISPLAY              0
-#define LINK_STATS                      1
-#define ETHARP_STATS                    (LWIP_ARP)
-#define IP_STATS                        1
-#define IPFRAG_STATS                    (IP_REASSEMBLY || IP_FRAG)
-#define ICMP_STATS                      1
-#define IGMP_STATS                      (LWIP_IGMP)
-#define UDP_STATS                       (LWIP_UDP)
-#define TCP_STATS                       (LWIP_TCP)
-#define MEM_STATS                       ((MEM_LIBC_MALLOC == 0) && (MEM_USE_POOLS == 0))
-#define MEMP_STATS                      (MEMP_MEM_MALLOC == 0)
-#define SYS_STATS                       (NO_SYS == 0)
-#define IP6_STATS                       (LWIP_IPV6)
-#define ICMP6_STATS                     (LWIP_IPV6 && LWIP_ICMP6)
-#define IP6_FRAG_STATS                  (LWIP_IPV6 && (LWIP_IPV6_FRAG || LWIP_IPV6_REASS))
-#define MLD6_STATS                      (LWIP_IPV6 && LWIP_IPV6_MLD)
-#define ND6_STATS                       (LWIP_IPV6)
-#define MIB2_STATS                      0
-#define LWIP_CHECKSUM_CTRL_PER_NETIF    0
-#define CHECKSUM_GEN_IP                 1
-#define CHECKSUM_GEN_UDP                1
-#define CHECKSUM_GEN_TCP                1
-#define CHECKSUM_GEN_ICMP               1
-#define CHECKSUM_GEN_ICMP6              1
-#define CHECKSUM_CHECK_IP               1
-#define CHECKSUM_CHECK_UDP              1
-#define CHECKSUM_CHECK_TCP              1
-#define CHECKSUM_CHECK_ICMP             1
-#define CHECKSUM_CHECK_ICMP6            1
-#define LWIP_CHECKSUM_ON_COPY           0
-#define LWIP_IPV6                       0
-#define IPV6_REASS_MAXAGE               60
-#define LWIP_IPV6_SCOPES                (LWIP_IPV6 && !LWIP_SINGLE_NETIF)
-#define LWIP_IPV6_SCOPES_DEBUG          0
-#define LWIP_IPV6_NUM_ADDRESSES         3
-#define LWIP_IPV6_FORWARD               0
-#define LWIP_IPV6_FRAG                  1
-#define LWIP_IPV6_REASS                 (LWIP_IPV6)
-#define LWIP_IPV6_SEND_ROUTER_SOLICIT   1
-#define LWIP_IPV6_AUTOCONFIG            (LWIP_IPV6)
-#define LWIP_IPV6_ADDRESS_LIFETIMES     (LWIP_IPV6_AUTOCONFIG)
-#define LWIP_IPV6_DUP_DETECT_ATTEMPTS   1
-#define LWIP_ICMP6                      (LWIP_IPV6)
-#define LWIP_ICMP6_DATASIZE             8
-#define LWIP_ICMP6_HL                   255
-#define LWIP_IPV6_MLD                   (LWIP_IPV6)
-#define MEMP_NUM_MLD6_GROUP             4
-#define LWIP_ND6_QUEUEING               (LWIP_IPV6)
-#define MEMP_NUM_ND6_QUEUE              20
-#define LWIP_ND6_NUM_NEIGHBORS          10
-#define LWIP_ND6_NUM_DESTINATIONS       10
-#define LWIP_ND6_NUM_PREFIXES           5
-#define LWIP_ND6_NUM_ROUTERS            3
-#define LWIP_ND6_MAX_MULTICAST_SOLICIT  3
-#define LWIP_ND6_MAX_UNICAST_SOLICIT    3
-#define LWIP_ND6_MAX_ANYCAST_DELAY_TIME 1000
-#define LWIP_ND6_MAX_NEIGHBOR_ADVERTISEMENT  3
-#define LWIP_ND6_REACHABLE_TIME         30000
-#define LWIP_ND6_RETRANS_TIMER          1000
-#define LWIP_ND6_DELAY_FIRST_PROBE_TIME 5000
-#define LWIP_ND6_ALLOW_RA_UPDATES       1
-#define LWIP_ND6_TCP_REACHABILITY_HINTS 1
-#define LWIP_ND6_RDNSS_MAX_DNS_SERVERS  0
-#define LWIP_IPV6_DHCP6                 0
-#define LWIP_IPV6_DHCP6_STATEFUL        0
-#define LWIP_IPV6_DHCP6_STATELESS       LWIP_IPV6_DHCP6
-#define LWIP_DHCP6_GET_NTP_SRV          0
-#define LWIP_DHCP6_MAX_NTP_SERVERS      1
-#define LWIP_DHCP6_MAX_DNS_SERVERS      DNS_MAX_SERVERS
-
-/* TODO: check hooks */
-
-#define LWIP_DBG_MIN_LEVEL              LWIP_DBG_LEVEL_ALL
-#define LWIP_DBG_TYPES_ON               LWIP_DBG_ON
-#define ETHARP_DEBUG                    LWIP_DBG_OFF
-#define NETIF_DEBUG                     LWIP_DBG_OFF
-#define PBUF_DEBUG                      LWIP_DBG_OFF
-#define API_LIB_DEBUG                   LWIP_DBG_OFF
-#define API_MSG_DEBUG                   LWIP_DBG_OFF
-#define SOCKETS_DEBUG                   LWIP_DBG_OFF
-#define ICMP_DEBUG                      LWIP_DBG_OFF
-#define IGMP_DEBUG                      LWIP_DBG_OFF
-#define INET_DEBUG                      LWIP_DBG_OFF
-#define IP_DEBUG                        LWIP_DBG_OFF
-#define IP_REASS_DEBUG                  LWIP_DBG_OFF
-#define RAW_DEBUG                       LWIP_DBG_OFF
-#define MEM_DEBUG                       LWIP_DBG_OFF
-#define MEMP_DEBUG                      LWIP_DBG_OFF
-#define SYS_DEBUG                       LWIP_DBG_OFF
-#define TIMERS_DEBUG                    LWIP_DBG_OFF
-#define TCP_DEBUG                       LWIP_DBG_OFF
-#define TCP_INPUT_DEBUG                 LWIP_DBG_OFF
-#define TCP_FR_DEBUG                    LWIP_DBG_OFF
-#define TCP_RTO_DEBUG                   LWIP_DBG_OFF
-#define TCP_CWND_DEBUG                  LWIP_DBG_OFF
-#define TCP_WND_DEBUG                   LWIP_DBG_OFF
-#define TCP_OUTPUT_DEBUG                LWIP_DBG_OFF
-#define TCP_RST_DEBUG                   LWIP_DBG_OFF
-#define TCP_QLEN_DEBUG                  LWIP_DBG_OFF
-#define UDP_DEBUG                       LWIP_DBG_OFF
-#define TCPIP_DEBUG                     LWIP_DBG_OFF
-#define SLIP_DEBUG                      LWIP_DBG_OFF
-#define DHCP_DEBUG                      LWIP_DBG_OFF
-#define AUTOIP_DEBUG                    LWIP_DBG_OFF
-#define DNS_DEBUG                       LWIP_DBG_OFF
-#define IP6_DEBUG                       LWIP_DBG_OFF
-#define DHCP6_DEBUG                     LWIP_DBG_OFF
-#define LWIP_TESTMODE                   0
-
-#define LWIP_PERF                       0
diff --git a/contrib/examples/example_app/test_configs/opt_dualstack.h b/contrib/examples/example_app/test_configs/opt_dualstack.h
deleted file mode 100644
index 4caf490d..00000000
--- a/contrib/examples/example_app/test_configs/opt_dualstack.h
+++ /dev/null
@@ -1,295 +0,0 @@
-/* test an lwipopts.h file with default contents */
-#define NO_SYS                          0
-#define NO_SYS_NO_TIMERS                0
-#define LWIP_TIMERS                     1
-#define LWIP_TIMERS_CUSTOM              0
-#define LWIP_MPU_COMPATIBLE             0
-#define LWIP_TCPIP_CORE_LOCKING         1
-#define LWIP_TCPIP_CORE_LOCKING_INPUT   0
-#define SYS_LIGHTWEIGHT_PROT            1
-#define MEM_LIBC_MALLOC                 0
-#define MEMP_MEM_MALLOC                 0
-#define MEMP_MEM_INIT                   0
-#define MEM_ALIGNMENT                   1
-#define MEM_SIZE                        1600
-#define MEMP_OVERFLOW_CHECK             0
-#define MEMP_SANITY_CHECK               0
-#define MEM_OVERFLOW_CHECK              0
-#define MEM_SANITY_CHECK                0
-#define MEM_USE_POOLS                   0
-#define MEM_USE_POOLS_TRY_BIGGER_POOL   0
-#define MEMP_USE_CUSTOM_POOLS           0
-#define LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT 0
-/*#define MEMP_NUM_PBUF                   16
-#define MEMP_NUM_RAW_PCB                4
-#define MEMP_NUM_UDP_PCB                4
-#define MEMP_NUM_TCP_PCB                5
-#define MEMP_NUM_TCP_PCB_LISTEN         8
-#define MEMP_NUM_TCP_SEG                16
-#define MEMP_NUM_ALTCP_PCB              MEMP_NUM_TCP_PCB
-#define MEMP_NUM_REASSDATA              5
-#define MEMP_NUM_FRAG_PBUF              15
-#define MEMP_NUM_ARP_QUEUE              30
-#define MEMP_NUM_IGMP_GROUP             8
-#define MEMP_NUM_SYS_TIMEOUT            (LWIP_NUM_SYS_TIMEOUT_INTERNAL + 2)
-#define MEMP_NUM_NETBUF                 2
-#define MEMP_NUM_NETCONN                4
-#define MEMP_NUM_SELECT_CB              4
-#define MEMP_NUM_TCPIP_MSG_API          8
-#define MEMP_NUM_TCPIP_MSG_INPKT        8
-#define MEMP_NUM_NETDB                  1
-#define MEMP_NUM_LOCALHOSTLIST          1
-#define PBUF_POOL_SIZE                  16
-#define MEMP_NUM_API_MSG                MEMP_NUM_TCPIP_MSG_API
-#define MEMP_NUM_DNS_API_MSG            MEMP_NUM_TCPIP_MSG_API
-#define MEMP_NUM_SOCKET_SETGETSOCKOPT_DATA MEMP_NUM_TCPIP_MSG_API
-#define MEMP_NUM_NETIFAPI_MSG           MEMP_NUM_TCPIP_MSG_API*/
-#define LWIP_ARP                        1
-#define ARP_TABLE_SIZE                  10
-#define ARP_MAXAGE                      300
-#define ARP_QUEUEING                    0
-#define ARP_QUEUE_LEN                   3
-#define ETHARP_SUPPORT_VLAN             0
-#define LWIP_ETHERNET                   LWIP_ARP
-#define ETH_PAD_SIZE                    0
-#define ETHARP_SUPPORT_STATIC_ENTRIES   0
-#define ETHARP_TABLE_MATCH_NETIF        !LWIP_SINGLE_NETIF
-#define LWIP_IPV4                       1
-#define IP_FORWARD                      0
-#define IP_REASSEMBLY                   1
-#define IP_FRAG                         1
-#define IP_OPTIONS_ALLOWED              1
-#define IP_REASS_MAXAGE                 15
-#define IP_REASS_MAX_PBUFS              10
-#define IP_DEFAULT_TTL                  255
-#define IP_SOF_BROADCAST                0
-#define IP_SOF_BROADCAST_RECV           0
-#define IP_FORWARD_ALLOW_TX_ON_RX_NETIF 0
-#define LWIP_ICMP                       1
-#define ICMP_TTL                        (IP_DEFAULT_TTL)
-#define LWIP_BROADCAST_PING             0
-#define LWIP_MULTICAST_PING             0
-#define LWIP_RAW                        0
-#define RAW_TTL                         (IP_DEFAULT_TTL)
-#define LWIP_DHCP                       LWIP_UDP
-#define LWIP_DHCP_CHECK_LINK_UP         0
-#define LWIP_DHCP_BOOTP_FILE            0
-#define LWIP_DHCP_GET_NTP_SRV           0
-#define LWIP_DHCP_MAX_NTP_SERVERS       1
-#define LWIP_DHCP_MAX_DNS_SERVERS       DNS_MAX_SERVERS
-#define LWIP_AUTOIP                     0
-#define LWIP_DHCP_AUTOIP_COOP           0
-#define LWIP_DHCP_AUTOIP_COOP_TRIES     9
-#define LWIP_MIB2_CALLBACKS             0
-#define LWIP_MULTICAST_TX_OPTIONS       ((LWIP_IGMP || LWIP_IPV6_MLD) && (LWIP_UDP || LWIP_RAW))
-#define LWIP_IGMP                       0
-#define LWIP_DNS                        0
-#define DNS_TABLE_SIZE                  4
-#define DNS_MAX_NAME_LENGTH             256
-#define DNS_MAX_SERVERS                 2
-#define DNS_MAX_RETRIES                 4
-#define DNS_DOES_NAME_CHECK             1
-#define LWIP_DNS_SECURE (LWIP_DNS_SECURE_RAND_XID | LWIP_DNS_SECURE_NO_MULTIPLE_OUTSTANDING | LWIP_DNS_SECURE_RAND_SRC_PORT)
-#define DNS_LOCAL_HOSTLIST              0
-#define DNS_LOCAL_HOSTLIST_IS_DYNAMIC   0
-#define LWIP_DNS_SUPPORT_MDNS_QUERIES   0
-#define LWIP_UDP                        1
-#define LWIP_UDPLITE                    0
-#define UDP_TTL                         (IP_DEFAULT_TTL)
-#define LWIP_NETBUF_RECVINFO            0
-#define LWIP_TCP                        1
-#define TCP_TTL                         (IP_DEFAULT_TTL)
-#define TCP_WND                         (4 * TCP_MSS)
-#define TCP_MAXRTX                      12
-#define TCP_SYNMAXRTX                   6
-#define TCP_QUEUE_OOSEQ                 (LWIP_TCP)
-#define LWIP_TCP_SACK_OUT               0
-#define LWIP_TCP_MAX_SACK_NUM           4
-#define TCP_MSS                         536
-#define TCP_CALCULATE_EFF_SEND_MSS      1
-#define TCP_SND_BUF                     (2 * TCP_MSS)
-#define TCP_SND_QUEUELEN                ((4 * (TCP_SND_BUF) + (TCP_MSS - 1))/(TCP_MSS))
-#define TCP_SNDLOWAT                    LWIP_MIN(LWIP_MAX(((TCP_SND_BUF)/2), (2 * TCP_MSS) + 1), (TCP_SND_BUF) - 1)
-#define TCP_SNDQUEUELOWAT               LWIP_MAX(((TCP_SND_QUEUELEN)/2), 5)
-#define TCP_OOSEQ_MAX_BYTES             0
-#define TCP_OOSEQ_BYTES_LIMIT(pcb)      TCP_OOSEQ_MAX_BYTES
-#define TCP_OOSEQ_MAX_PBUFS             0
-#define TCP_OOSEQ_PBUFS_LIMIT(pcb)      TCP_OOSEQ_MAX_PBUFS
-#define TCP_LISTEN_BACKLOG              0
-#define TCP_DEFAULT_LISTEN_BACKLOG      0xff
-#define TCP_OVERSIZE                    TCP_MSS
-#define LWIP_TCP_TIMESTAMPS             0
-#define TCP_WND_UPDATE_THRESHOLD        LWIP_MIN((TCP_WND / 4), (TCP_MSS * 4))
-#define LWIP_EVENT_API                  0
-#define LWIP_CALLBACK_API               1
-#define LWIP_WND_SCALE                  0
-#define TCP_RCV_SCALE                   0
-#define LWIP_TCP_PCB_NUM_EXT_ARGS       0
-#define LWIP_ALTCP                      0
-#define LWIP_ALTCP_TLS                  0
-#define PBUF_LINK_HLEN                  (14 + ETH_PAD_SIZE)
-#define PBUF_LINK_ENCAPSULATION_HLEN    0
-#define PBUF_POOL_BUFSIZE               LWIP_MEM_ALIGN_SIZE(TCP_MSS+40+PBUF_LINK_ENCAPSULATION_HLEN+PBUF_LINK_HLEN)
-#define LWIP_PBUF_REF_T                 u8_t
-#define LWIP_SINGLE_NETIF               0
-#define LWIP_NETIF_HOSTNAME             0
-#define LWIP_NETIF_API                  0
-#define LWIP_NETIF_STATUS_CALLBACK      0
-#define LWIP_NETIF_EXT_STATUS_CALLBACK  0
-#define LWIP_NETIF_LINK_CALLBACK        0
-#define LWIP_NETIF_REMOVE_CALLBACK      0
-#define LWIP_NETIF_HWADDRHINT           0
-#define LWIP_NETIF_TX_SINGLE_PBUF       0
-#define LWIP_NUM_NETIF_CLIENT_DATA      0
-#define LWIP_HAVE_LOOPIF                (LWIP_NETIF_LOOPBACK && !LWIP_SINGLE_NETIF)
-#define LWIP_LOOPIF_MULTICAST           0
-#define LWIP_NETIF_LOOPBACK             0
-#define LWIP_LOOPBACK_MAX_PBUFS         0
-#define LWIP_NETIF_LOOPBACK_MULTITHREADING    (!NO_SYS)
-/*#define TCPIP_THREAD_NAME               "tcpip_thread"
-#define TCPIP_THREAD_STACKSIZE          0
-#define TCPIP_THREAD_PRIO               1
-#define TCPIP_MBOX_SIZE                 0
-#define LWIP_TCPIP_THREAD_ALIVE()
-#define SLIPIF_THREAD_NAME              "slipif_loop"
-#define SLIPIF_THREAD_STACKSIZE         0
-#define SLIPIF_THREAD_PRIO              1
-#define DEFAULT_THREAD_NAME             "lwIP"
-#define DEFAULT_THREAD_STACKSIZE        0
-#define DEFAULT_THREAD_PRIO             1
-#define DEFAULT_RAW_RECVMBOX_SIZE       0
-#define DEFAULT_UDP_RECVMBOX_SIZE       0
-#define DEFAULT_TCP_RECVMBOX_SIZE       0
-#define DEFAULT_ACCEPTMBOX_SIZE         0*/
-#define LWIP_NETCONN                    1
-#define LWIP_TCPIP_TIMEOUT              0
-#define LWIP_NETCONN_SEM_PER_THREAD     0
-#define LWIP_NETCONN_FULLDUPLEX         0
-#define LWIP_SOCKET                     1
-#define LWIP_COMPAT_SOCKETS             1 /* 0..2 */
-#define LWIP_POSIX_SOCKETS_IO_NAMES     1
-#define LWIP_SOCKET_OFFSET              0
-#define LWIP_TCP_KEEPALIVE              0
-#define LWIP_SO_SNDTIMEO                0
-#define LWIP_SO_RCVTIMEO                0
-#define LWIP_SO_SNDRCVTIMEO_NONSTANDARD 0
-#define LWIP_SO_RCVBUF                  0
-#define LWIP_SO_LINGER                  0
-#define RECV_BUFSIZE_DEFAULT            INT_MAX
-#define LWIP_TCP_CLOSE_TIMEOUT_MS_DEFAULT 20000
-#define SO_REUSE                        0
-#define SO_REUSE_RXTOALL                0
-#define LWIP_FIONREAD_LINUXMODE         0
-#define LWIP_SOCKET_SELECT              1
-#define LWIP_SOCKET_POLL                1
-#define LWIP_STATS                      1
-#define LWIP_STATS_DISPLAY              0
-#define LINK_STATS                      1
-#define ETHARP_STATS                    (LWIP_ARP)
-#define IP_STATS                        1
-#define IPFRAG_STATS                    (IP_REASSEMBLY || IP_FRAG)
-#define ICMP_STATS                      1
-#define IGMP_STATS                      (LWIP_IGMP)
-#define UDP_STATS                       (LWIP_UDP)
-#define TCP_STATS                       (LWIP_TCP)
-#define MEM_STATS                       ((MEM_LIBC_MALLOC == 0) && (MEM_USE_POOLS == 0))
-#define MEMP_STATS                      (MEMP_MEM_MALLOC == 0)
-#define SYS_STATS                       (NO_SYS == 0)
-#define IP6_STATS                       (LWIP_IPV6)
-#define ICMP6_STATS                     (LWIP_IPV6 && LWIP_ICMP6)
-#define IP6_FRAG_STATS                  (LWIP_IPV6 && (LWIP_IPV6_FRAG || LWIP_IPV6_REASS))
-#define MLD6_STATS                      (LWIP_IPV6 && LWIP_IPV6_MLD)
-#define ND6_STATS                       (LWIP_IPV6)
-#define MIB2_STATS                      0
-#define LWIP_CHECKSUM_CTRL_PER_NETIF    0
-#define CHECKSUM_GEN_IP                 1
-#define CHECKSUM_GEN_UDP                1
-#define CHECKSUM_GEN_TCP                1
-#define CHECKSUM_GEN_ICMP               1
-#define CHECKSUM_GEN_ICMP6              1
-#define CHECKSUM_CHECK_IP               1
-#define CHECKSUM_CHECK_UDP              1
-#define CHECKSUM_CHECK_TCP              1
-#define CHECKSUM_CHECK_ICMP             1
-#define CHECKSUM_CHECK_ICMP6            1
-#define LWIP_CHECKSUM_ON_COPY           0
-#define LWIP_IPV6                       1
-#define IPV6_REASS_MAXAGE               60
-#define LWIP_IPV6_SCOPES                (LWIP_IPV6 && !LWIP_SINGLE_NETIF)
-#define LWIP_IPV6_SCOPES_DEBUG          0
-#define LWIP_IPV6_NUM_ADDRESSES         3
-#define LWIP_IPV6_FORWARD               0
-#define LWIP_IPV6_FRAG                  1
-#define LWIP_IPV6_REASS                 (LWIP_IPV6)
-#define LWIP_IPV6_SEND_ROUTER_SOLICIT   1
-#define LWIP_IPV6_AUTOCONFIG            (LWIP_IPV6)
-#define LWIP_IPV6_ADDRESS_LIFETIMES     (LWIP_IPV6_AUTOCONFIG)
-#define LWIP_IPV6_DUP_DETECT_ATTEMPTS   1
-#define LWIP_ICMP6                      (LWIP_IPV6)
-#define LWIP_ICMP6_DATASIZE             8
-#define LWIP_ICMP6_HL                   255
-#define LWIP_IPV6_MLD                   (LWIP_IPV6)
-#define MEMP_NUM_MLD6_GROUP             4
-#define LWIP_ND6_QUEUEING               (LWIP_IPV6)
-#define MEMP_NUM_ND6_QUEUE              20
-#define LWIP_ND6_NUM_NEIGHBORS          10
-#define LWIP_ND6_NUM_DESTINATIONS       10
-#define LWIP_ND6_NUM_PREFIXES           5
-#define LWIP_ND6_NUM_ROUTERS            3
-#define LWIP_ND6_MAX_MULTICAST_SOLICIT  3
-#define LWIP_ND6_MAX_UNICAST_SOLICIT    3
-#define LWIP_ND6_MAX_ANYCAST_DELAY_TIME 1000
-#define LWIP_ND6_MAX_NEIGHBOR_ADVERTISEMENT  3
-#define LWIP_ND6_REACHABLE_TIME         30000
-#define LWIP_ND6_RETRANS_TIMER          1000
-#define LWIP_ND6_DELAY_FIRST_PROBE_TIME 5000
-#define LWIP_ND6_ALLOW_RA_UPDATES       1
-#define LWIP_ND6_TCP_REACHABILITY_HINTS 1
-#define LWIP_ND6_RDNSS_MAX_DNS_SERVERS  0
-#define LWIP_IPV6_DHCP6                 0
-#define LWIP_IPV6_DHCP6_STATEFUL        0
-#define LWIP_IPV6_DHCP6_STATELESS       LWIP_IPV6_DHCP6
-#define LWIP_DHCP6_GET_NTP_SRV          0
-#define LWIP_DHCP6_MAX_NTP_SERVERS      1
-#define LWIP_DHCP6_MAX_DNS_SERVERS      DNS_MAX_SERVERS
-
-/* TODO: check hooks */
-
-#define LWIP_DBG_MIN_LEVEL              LWIP_DBG_LEVEL_ALL
-#define LWIP_DBG_TYPES_ON               LWIP_DBG_ON
-#define ETHARP_DEBUG                    LWIP_DBG_OFF
-#define NETIF_DEBUG                     LWIP_DBG_OFF
-#define PBUF_DEBUG                      LWIP_DBG_OFF
-#define API_LIB_DEBUG                   LWIP_DBG_OFF
-#define API_MSG_DEBUG                   LWIP_DBG_OFF
-#define SOCKETS_DEBUG                   LWIP_DBG_OFF
-#define ICMP_DEBUG                      LWIP_DBG_OFF
-#define IGMP_DEBUG                      LWIP_DBG_OFF
-#define INET_DEBUG                      LWIP_DBG_OFF
-#define IP_DEBUG                        LWIP_DBG_OFF
-#define IP_REASS_DEBUG                  LWIP_DBG_OFF
-#define RAW_DEBUG                       LWIP_DBG_OFF
-#define MEM_DEBUG                       LWIP_DBG_OFF
-#define MEMP_DEBUG                      LWIP_DBG_OFF
-#define SYS_DEBUG                       LWIP_DBG_OFF
-#define TIMERS_DEBUG                    LWIP_DBG_OFF
-#define TCP_DEBUG                       LWIP_DBG_OFF
-#define TCP_INPUT_DEBUG                 LWIP_DBG_OFF
-#define TCP_FR_DEBUG                    LWIP_DBG_OFF
-#define TCP_RTO_DEBUG                   LWIP_DBG_OFF
-#define TCP_CWND_DEBUG                  LWIP_DBG_OFF
-#define TCP_WND_DEBUG                   LWIP_DBG_OFF
-#define TCP_OUTPUT_DEBUG                LWIP_DBG_OFF
-#define TCP_RST_DEBUG                   LWIP_DBG_OFF
-#define TCP_QLEN_DEBUG                  LWIP_DBG_OFF
-#define UDP_DEBUG                       LWIP_DBG_OFF
-#define TCPIP_DEBUG                     LWIP_DBG_OFF
-#define SLIP_DEBUG                      LWIP_DBG_OFF
-#define DHCP_DEBUG                      LWIP_DBG_OFF
-#define AUTOIP_DEBUG                    LWIP_DBG_OFF
-#define DNS_DEBUG                       LWIP_DBG_OFF
-#define IP6_DEBUG                       LWIP_DBG_OFF
-#define DHCP6_DEBUG                     LWIP_DBG_OFF
-#define LWIP_TESTMODE                   0
-
-#define LWIP_PERF                       0
diff --git a/contrib/examples/example_app/test_configs/opt_ipv4only.h b/contrib/examples/example_app/test_configs/opt_ipv4only.h
deleted file mode 100644
index 82ba4671..00000000
--- a/contrib/examples/example_app/test_configs/opt_ipv4only.h
+++ /dev/null
@@ -1,295 +0,0 @@
-/* test an lwipopts.h file with default contents */
-#define NO_SYS                          0
-#define NO_SYS_NO_TIMERS                0
-#define LWIP_TIMERS                     1
-#define LWIP_TIMERS_CUSTOM              0
-#define LWIP_MPU_COMPATIBLE             0
-#define LWIP_TCPIP_CORE_LOCKING         1
-#define LWIP_TCPIP_CORE_LOCKING_INPUT   0
-#define SYS_LIGHTWEIGHT_PROT            1
-#define MEM_LIBC_MALLOC                 0
-#define MEMP_MEM_MALLOC                 0
-#define MEMP_MEM_INIT                   0
-#define MEM_ALIGNMENT                   1
-#define MEM_SIZE                        1600
-#define MEMP_OVERFLOW_CHECK             0
-#define MEMP_SANITY_CHECK               0
-#define MEM_OVERFLOW_CHECK              0
-#define MEM_SANITY_CHECK                0
-#define MEM_USE_POOLS                   0
-#define MEM_USE_POOLS_TRY_BIGGER_POOL   0
-#define MEMP_USE_CUSTOM_POOLS           0
-#define LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT 0
-/*#define MEMP_NUM_PBUF                   16
-#define MEMP_NUM_RAW_PCB                4
-#define MEMP_NUM_UDP_PCB                4
-#define MEMP_NUM_TCP_PCB                5
-#define MEMP_NUM_TCP_PCB_LISTEN         8
-#define MEMP_NUM_TCP_SEG                16
-#define MEMP_NUM_ALTCP_PCB              MEMP_NUM_TCP_PCB
-#define MEMP_NUM_REASSDATA              5
-#define MEMP_NUM_FRAG_PBUF              15
-#define MEMP_NUM_ARP_QUEUE              30
-#define MEMP_NUM_IGMP_GROUP             8
-#define MEMP_NUM_SYS_TIMEOUT            (LWIP_NUM_SYS_TIMEOUT_INTERNAL + 2)
-#define MEMP_NUM_NETBUF                 2
-#define MEMP_NUM_NETCONN                4
-#define MEMP_NUM_SELECT_CB              4
-#define MEMP_NUM_TCPIP_MSG_API          8
-#define MEMP_NUM_TCPIP_MSG_INPKT        8
-#define MEMP_NUM_NETDB                  1
-#define MEMP_NUM_LOCALHOSTLIST          1
-#define PBUF_POOL_SIZE                  16
-#define MEMP_NUM_API_MSG                MEMP_NUM_TCPIP_MSG_API
-#define MEMP_NUM_DNS_API_MSG            MEMP_NUM_TCPIP_MSG_API
-#define MEMP_NUM_SOCKET_SETGETSOCKOPT_DATA MEMP_NUM_TCPIP_MSG_API
-#define MEMP_NUM_NETIFAPI_MSG           MEMP_NUM_TCPIP_MSG_API*/
-#define LWIP_ARP                        1
-#define ARP_TABLE_SIZE                  10
-#define ARP_MAXAGE                      300
-#define ARP_QUEUEING                    0
-#define ARP_QUEUE_LEN                   3
-#define ETHARP_SUPPORT_VLAN             0
-#define LWIP_ETHERNET                   LWIP_ARP
-#define ETH_PAD_SIZE                    0
-#define ETHARP_SUPPORT_STATIC_ENTRIES   0
-#define ETHARP_TABLE_MATCH_NETIF        !LWIP_SINGLE_NETIF
-#define LWIP_IPV4                       1
-#define IP_FORWARD                      0
-#define IP_REASSEMBLY                   1
-#define IP_FRAG                         1
-#define IP_OPTIONS_ALLOWED              1
-#define IP_REASS_MAXAGE                 15
-#define IP_REASS_MAX_PBUFS              10
-#define IP_DEFAULT_TTL                  255
-#define IP_SOF_BROADCAST                0
-#define IP_SOF_BROADCAST_RECV           0
-#define IP_FORWARD_ALLOW_TX_ON_RX_NETIF 0
-#define LWIP_ICMP                       1
-#define ICMP_TTL                        (IP_DEFAULT_TTL)
-#define LWIP_BROADCAST_PING             0
-#define LWIP_MULTICAST_PING             0
-#define LWIP_RAW                        0
-#define RAW_TTL                         (IP_DEFAULT_TTL)
-#define LWIP_DHCP                       LWIP_UDP
-#define LWIP_DHCP_CHECK_LINK_UP         0
-#define LWIP_DHCP_BOOTP_FILE            0
-#define LWIP_DHCP_GET_NTP_SRV           0
-#define LWIP_DHCP_MAX_NTP_SERVERS       1
-#define LWIP_DHCP_MAX_DNS_SERVERS       DNS_MAX_SERVERS
-#define LWIP_AUTOIP                     0
-#define LWIP_DHCP_AUTOIP_COOP           0
-#define LWIP_DHCP_AUTOIP_COOP_TRIES     9
-#define LWIP_MIB2_CALLBACKS             0
-#define LWIP_MULTICAST_TX_OPTIONS       ((LWIP_IGMP || LWIP_IPV6_MLD) && (LWIP_UDP || LWIP_RAW))
-#define LWIP_IGMP                       0
-#define LWIP_DNS                        0
-#define DNS_TABLE_SIZE                  4
-#define DNS_MAX_NAME_LENGTH             256
-#define DNS_MAX_SERVERS                 2
-#define DNS_MAX_RETRIES                 4
-#define DNS_DOES_NAME_CHECK             1
-#define LWIP_DNS_SECURE (LWIP_DNS_SECURE_RAND_XID | LWIP_DNS_SECURE_NO_MULTIPLE_OUTSTANDING | LWIP_DNS_SECURE_RAND_SRC_PORT)
-#define DNS_LOCAL_HOSTLIST              0
-#define DNS_LOCAL_HOSTLIST_IS_DYNAMIC   0
-#define LWIP_DNS_SUPPORT_MDNS_QUERIES   0
-#define LWIP_UDP                        1
-#define LWIP_UDPLITE                    0
-#define UDP_TTL                         (IP_DEFAULT_TTL)
-#define LWIP_NETBUF_RECVINFO            0
-#define LWIP_TCP                        1
-#define TCP_TTL                         (IP_DEFAULT_TTL)
-#define TCP_WND                         (4 * TCP_MSS)
-#define TCP_MAXRTX                      12
-#define TCP_SYNMAXRTX                   6
-#define TCP_QUEUE_OOSEQ                 (LWIP_TCP)
-#define LWIP_TCP_SACK_OUT               0
-#define LWIP_TCP_MAX_SACK_NUM           4
-#define TCP_MSS                         536
-#define TCP_CALCULATE_EFF_SEND_MSS      1
-#define TCP_SND_BUF                     (2 * TCP_MSS)
-#define TCP_SND_QUEUELEN                ((4 * (TCP_SND_BUF) + (TCP_MSS - 1))/(TCP_MSS))
-#define TCP_SNDLOWAT                    LWIP_MIN(LWIP_MAX(((TCP_SND_BUF)/2), (2 * TCP_MSS) + 1), (TCP_SND_BUF) - 1)
-#define TCP_SNDQUEUELOWAT               LWIP_MAX(((TCP_SND_QUEUELEN)/2), 5)
-#define TCP_OOSEQ_MAX_BYTES             0
-#define TCP_OOSEQ_BYTES_LIMIT(pcb)      TCP_OOSEQ_MAX_BYTES
-#define TCP_OOSEQ_MAX_PBUFS             0
-#define TCP_OOSEQ_PBUFS_LIMIT(pcb)      TCP_OOSEQ_MAX_PBUFS
-#define TCP_LISTEN_BACKLOG              0
-#define TCP_DEFAULT_LISTEN_BACKLOG      0xff
-#define TCP_OVERSIZE                    TCP_MSS
-#define LWIP_TCP_TIMESTAMPS             0
-#define TCP_WND_UPDATE_THRESHOLD        LWIP_MIN((TCP_WND / 4), (TCP_MSS * 4))
-#define LWIP_EVENT_API                  0
-#define LWIP_CALLBACK_API               1
-#define LWIP_WND_SCALE                  0
-#define TCP_RCV_SCALE                   0
-#define LWIP_TCP_PCB_NUM_EXT_ARGS       0
-#define LWIP_ALTCP                      0
-#define LWIP_ALTCP_TLS                  0
-#define PBUF_LINK_HLEN                  (14 + ETH_PAD_SIZE)
-#define PBUF_LINK_ENCAPSULATION_HLEN    0
-#define PBUF_POOL_BUFSIZE               LWIP_MEM_ALIGN_SIZE(TCP_MSS+40+PBUF_LINK_ENCAPSULATION_HLEN+PBUF_LINK_HLEN)
-#define LWIP_PBUF_REF_T                 u8_t
-#define LWIP_SINGLE_NETIF               0
-#define LWIP_NETIF_HOSTNAME             0
-#define LWIP_NETIF_API                  0
-#define LWIP_NETIF_STATUS_CALLBACK      0
-#define LWIP_NETIF_EXT_STATUS_CALLBACK  0
-#define LWIP_NETIF_LINK_CALLBACK        0
-#define LWIP_NETIF_REMOVE_CALLBACK      0
-#define LWIP_NETIF_HWADDRHINT           0
-#define LWIP_NETIF_TX_SINGLE_PBUF       0
-#define LWIP_NUM_NETIF_CLIENT_DATA      0
-#define LWIP_HAVE_LOOPIF                (LWIP_NETIF_LOOPBACK && !LWIP_SINGLE_NETIF)
-#define LWIP_LOOPIF_MULTICAST           0
-#define LWIP_NETIF_LOOPBACK             0
-#define LWIP_LOOPBACK_MAX_PBUFS         0
-#define LWIP_NETIF_LOOPBACK_MULTITHREADING    (!NO_SYS)
-/*#define TCPIP_THREAD_NAME               "tcpip_thread"
-#define TCPIP_THREAD_STACKSIZE          0
-#define TCPIP_THREAD_PRIO               1
-#define TCPIP_MBOX_SIZE                 0
-#define LWIP_TCPIP_THREAD_ALIVE()
-#define SLIPIF_THREAD_NAME              "slipif_loop"
-#define SLIPIF_THREAD_STACKSIZE         0
-#define SLIPIF_THREAD_PRIO              1
-#define DEFAULT_THREAD_NAME             "lwIP"
-#define DEFAULT_THREAD_STACKSIZE        0
-#define DEFAULT_THREAD_PRIO             1
-#define DEFAULT_RAW_RECVMBOX_SIZE       0
-#define DEFAULT_UDP_RECVMBOX_SIZE       0
-#define DEFAULT_TCP_RECVMBOX_SIZE       0
-#define DEFAULT_ACCEPTMBOX_SIZE         0*/
-#define LWIP_NETCONN                    1
-#define LWIP_TCPIP_TIMEOUT              0
-#define LWIP_NETCONN_SEM_PER_THREAD     0
-#define LWIP_NETCONN_FULLDUPLEX         0
-#define LWIP_SOCKET                     1
-#define LWIP_COMPAT_SOCKETS             1 /* 0..2 */
-#define LWIP_POSIX_SOCKETS_IO_NAMES     1
-#define LWIP_SOCKET_OFFSET              0
-#define LWIP_TCP_KEEPALIVE              0
-#define LWIP_SO_SNDTIMEO                0
-#define LWIP_SO_RCVTIMEO                0
-#define LWIP_SO_SNDRCVTIMEO_NONSTANDARD 0
-#define LWIP_SO_RCVBUF                  0
-#define LWIP_SO_LINGER                  0
-#define RECV_BUFSIZE_DEFAULT            INT_MAX
-#define LWIP_TCP_CLOSE_TIMEOUT_MS_DEFAULT 20000
-#define SO_REUSE                        0
-#define SO_REUSE_RXTOALL                0
-#define LWIP_FIONREAD_LINUXMODE         0
-#define LWIP_SOCKET_SELECT              1
-#define LWIP_SOCKET_POLL                1
-#define LWIP_STATS                      1
-#define LWIP_STATS_DISPLAY              0
-#define LINK_STATS                      1
-#define ETHARP_STATS                    (LWIP_ARP)
-#define IP_STATS                        1
-#define IPFRAG_STATS                    (IP_REASSEMBLY || IP_FRAG)
-#define ICMP_STATS                      1
-#define IGMP_STATS                      (LWIP_IGMP)
-#define UDP_STATS                       (LWIP_UDP)
-#define TCP_STATS                       (LWIP_TCP)
-#define MEM_STATS                       ((MEM_LIBC_MALLOC == 0) && (MEM_USE_POOLS == 0))
-#define MEMP_STATS                      (MEMP_MEM_MALLOC == 0)
-#define SYS_STATS                       (NO_SYS == 0)
-#define IP6_STATS                       (LWIP_IPV6)
-#define ICMP6_STATS                     (LWIP_IPV6 && LWIP_ICMP6)
-#define IP6_FRAG_STATS                  (LWIP_IPV6 && (LWIP_IPV6_FRAG || LWIP_IPV6_REASS))
-#define MLD6_STATS                      (LWIP_IPV6 && LWIP_IPV6_MLD)
-#define ND6_STATS                       (LWIP_IPV6)
-#define MIB2_STATS                      0
-#define LWIP_CHECKSUM_CTRL_PER_NETIF    0
-#define CHECKSUM_GEN_IP                 1
-#define CHECKSUM_GEN_UDP                1
-#define CHECKSUM_GEN_TCP                1
-#define CHECKSUM_GEN_ICMP               1
-#define CHECKSUM_GEN_ICMP6              1
-#define CHECKSUM_CHECK_IP               1
-#define CHECKSUM_CHECK_UDP              1
-#define CHECKSUM_CHECK_TCP              1
-#define CHECKSUM_CHECK_ICMP             1
-#define CHECKSUM_CHECK_ICMP6            1
-#define LWIP_CHECKSUM_ON_COPY           0
-#define LWIP_IPV6                       0
-#define IPV6_REASS_MAXAGE               60
-#define LWIP_IPV6_SCOPES                (LWIP_IPV6 && !LWIP_SINGLE_NETIF)
-#define LWIP_IPV6_SCOPES_DEBUG          0
-#define LWIP_IPV6_NUM_ADDRESSES         3
-#define LWIP_IPV6_FORWARD               0
-#define LWIP_IPV6_FRAG                  1
-#define LWIP_IPV6_REASS                 (LWIP_IPV6)
-#define LWIP_IPV6_SEND_ROUTER_SOLICIT   1
-#define LWIP_IPV6_AUTOCONFIG            (LWIP_IPV6)
-#define LWIP_IPV6_ADDRESS_LIFETIMES     (LWIP_IPV6_AUTOCONFIG)
-#define LWIP_IPV6_DUP_DETECT_ATTEMPTS   1
-#define LWIP_ICMP6                      (LWIP_IPV6)
-#define LWIP_ICMP6_DATASIZE             8
-#define LWIP_ICMP6_HL                   255
-#define LWIP_IPV6_MLD                   (LWIP_IPV6)
-#define MEMP_NUM_MLD6_GROUP             4
-#define LWIP_ND6_QUEUEING               (LWIP_IPV6)
-#define MEMP_NUM_ND6_QUEUE              20
-#define LWIP_ND6_NUM_NEIGHBORS          10
-#define LWIP_ND6_NUM_DESTINATIONS       10
-#define LWIP_ND6_NUM_PREFIXES           5
-#define LWIP_ND6_NUM_ROUTERS            3
-#define LWIP_ND6_MAX_MULTICAST_SOLICIT  3
-#define LWIP_ND6_MAX_UNICAST_SOLICIT    3
-#define LWIP_ND6_MAX_ANYCAST_DELAY_TIME 1000
-#define LWIP_ND6_MAX_NEIGHBOR_ADVERTISEMENT  3
-#define LWIP_ND6_REACHABLE_TIME         30000
-#define LWIP_ND6_RETRANS_TIMER          1000
-#define LWIP_ND6_DELAY_FIRST_PROBE_TIME 5000
-#define LWIP_ND6_ALLOW_RA_UPDATES       1
-#define LWIP_ND6_TCP_REACHABILITY_HINTS 1
-#define LWIP_ND6_RDNSS_MAX_DNS_SERVERS  0
-#define LWIP_IPV6_DHCP6                 0
-#define LWIP_IPV6_DHCP6_STATEFUL        0
-#define LWIP_IPV6_DHCP6_STATELESS       LWIP_IPV6_DHCP6
-#define LWIP_DHCP6_GET_NTP_SRV          0
-#define LWIP_DHCP6_MAX_NTP_SERVERS      1
-#define LWIP_DHCP6_MAX_DNS_SERVERS      DNS_MAX_SERVERS
-
-/* TODO: check hooks */
-
-#define LWIP_DBG_MIN_LEVEL              LWIP_DBG_LEVEL_ALL
-#define LWIP_DBG_TYPES_ON               LWIP_DBG_ON
-#define ETHARP_DEBUG                    LWIP_DBG_OFF
-#define NETIF_DEBUG                     LWIP_DBG_OFF
-#define PBUF_DEBUG                      LWIP_DBG_OFF
-#define API_LIB_DEBUG                   LWIP_DBG_OFF
-#define API_MSG_DEBUG                   LWIP_DBG_OFF
-#define SOCKETS_DEBUG                   LWIP_DBG_OFF
-#define ICMP_DEBUG                      LWIP_DBG_OFF
-#define IGMP_DEBUG                      LWIP_DBG_OFF
-#define INET_DEBUG                      LWIP_DBG_OFF
-#define IP_DEBUG                        LWIP_DBG_OFF
-#define IP_REASS_DEBUG                  LWIP_DBG_OFF
-#define RAW_DEBUG                       LWIP_DBG_OFF
-#define MEM_DEBUG                       LWIP_DBG_OFF
-#define MEMP_DEBUG                      LWIP_DBG_OFF
-#define SYS_DEBUG                       LWIP_DBG_OFF
-#define TIMERS_DEBUG                    LWIP_DBG_OFF
-#define TCP_DEBUG                       LWIP_DBG_OFF
-#define TCP_INPUT_DEBUG                 LWIP_DBG_OFF
-#define TCP_FR_DEBUG                    LWIP_DBG_OFF
-#define TCP_RTO_DEBUG                   LWIP_DBG_OFF
-#define TCP_CWND_DEBUG                  LWIP_DBG_OFF
-#define TCP_WND_DEBUG                   LWIP_DBG_OFF
-#define TCP_OUTPUT_DEBUG                LWIP_DBG_OFF
-#define TCP_RST_DEBUG                   LWIP_DBG_OFF
-#define TCP_QLEN_DEBUG                  LWIP_DBG_OFF
-#define UDP_DEBUG                       LWIP_DBG_OFF
-#define TCPIP_DEBUG                     LWIP_DBG_OFF
-#define SLIP_DEBUG                      LWIP_DBG_OFF
-#define DHCP_DEBUG                      LWIP_DBG_OFF
-#define AUTOIP_DEBUG                    LWIP_DBG_OFF
-#define DNS_DEBUG                       LWIP_DBG_OFF
-#define IP6_DEBUG                       LWIP_DBG_OFF
-#define DHCP6_DEBUG                     LWIP_DBG_OFF
-#define LWIP_TESTMODE                   0
-
-#define LWIP_PERF                       0
diff --git a/contrib/examples/example_app/test_configs/opt_ipv6only.h b/contrib/examples/example_app/test_configs/opt_ipv6only.h
deleted file mode 100644
index b3cb1e04..00000000
--- a/contrib/examples/example_app/test_configs/opt_ipv6only.h
+++ /dev/null
@@ -1,295 +0,0 @@
-/* test an lwipopts.h file with default contents */
-#define NO_SYS                          0
-#define NO_SYS_NO_TIMERS                0
-#define LWIP_TIMERS                     1
-#define LWIP_TIMERS_CUSTOM              0
-#define LWIP_MPU_COMPATIBLE             0
-#define LWIP_TCPIP_CORE_LOCKING         1
-#define LWIP_TCPIP_CORE_LOCKING_INPUT   0
-#define SYS_LIGHTWEIGHT_PROT            1
-#define MEM_LIBC_MALLOC                 0
-#define MEMP_MEM_MALLOC                 0
-#define MEMP_MEM_INIT                   0
-#define MEM_ALIGNMENT                   1
-#define MEM_SIZE                        1600
-#define MEMP_OVERFLOW_CHECK             0
-#define MEMP_SANITY_CHECK               0
-#define MEM_OVERFLOW_CHECK              0
-#define MEM_SANITY_CHECK                0
-#define MEM_USE_POOLS                   0
-#define MEM_USE_POOLS_TRY_BIGGER_POOL   0
-#define MEMP_USE_CUSTOM_POOLS           0
-#define LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT 0
-/*#define MEMP_NUM_PBUF                   16
-#define MEMP_NUM_RAW_PCB                4
-#define MEMP_NUM_UDP_PCB                4
-#define MEMP_NUM_TCP_PCB                5
-#define MEMP_NUM_TCP_PCB_LISTEN         8
-#define MEMP_NUM_TCP_SEG                16
-#define MEMP_NUM_ALTCP_PCB              MEMP_NUM_TCP_PCB
-#define MEMP_NUM_REASSDATA              5
-#define MEMP_NUM_FRAG_PBUF              15
-#define MEMP_NUM_ARP_QUEUE              30
-#define MEMP_NUM_IGMP_GROUP             8
-#define MEMP_NUM_SYS_TIMEOUT            (LWIP_NUM_SYS_TIMEOUT_INTERNAL + 2)
-#define MEMP_NUM_NETBUF                 2
-#define MEMP_NUM_NETCONN                4
-#define MEMP_NUM_SELECT_CB              4
-#define MEMP_NUM_TCPIP_MSG_API          8
-#define MEMP_NUM_TCPIP_MSG_INPKT        8
-#define MEMP_NUM_NETDB                  1
-#define MEMP_NUM_LOCALHOSTLIST          1
-#define PBUF_POOL_SIZE                  16
-#define MEMP_NUM_API_MSG                MEMP_NUM_TCPIP_MSG_API
-#define MEMP_NUM_DNS_API_MSG            MEMP_NUM_TCPIP_MSG_API
-#define MEMP_NUM_SOCKET_SETGETSOCKOPT_DATA MEMP_NUM_TCPIP_MSG_API
-#define MEMP_NUM_NETIFAPI_MSG           MEMP_NUM_TCPIP_MSG_API*/
-#define LWIP_ARP                        1
-#define ARP_TABLE_SIZE                  10
-#define ARP_MAXAGE                      300
-#define ARP_QUEUEING                    0
-#define ARP_QUEUE_LEN                   3
-#define ETHARP_SUPPORT_VLAN             0
-#define LWIP_ETHERNET                   LWIP_ARP
-#define ETH_PAD_SIZE                    0
-#define ETHARP_SUPPORT_STATIC_ENTRIES   0
-#define ETHARP_TABLE_MATCH_NETIF        !LWIP_SINGLE_NETIF
-#define LWIP_IPV4                       0
-#define IP_FORWARD                      0
-#define IP_REASSEMBLY                   1
-#define IP_FRAG                         1
-#define IP_OPTIONS_ALLOWED              1
-#define IP_REASS_MAXAGE                 15
-#define IP_REASS_MAX_PBUFS              10
-#define IP_DEFAULT_TTL                  255
-#define IP_SOF_BROADCAST                0
-#define IP_SOF_BROADCAST_RECV           0
-#define IP_FORWARD_ALLOW_TX_ON_RX_NETIF 0
-#define LWIP_ICMP                       1
-#define ICMP_TTL                        (IP_DEFAULT_TTL)
-#define LWIP_BROADCAST_PING             0
-#define LWIP_MULTICAST_PING             0
-#define LWIP_RAW                        0
-#define RAW_TTL                         (IP_DEFAULT_TTL)
-#define LWIP_DHCP                       0
-#define LWIP_DHCP_CHECK_LINK_UP         0
-#define LWIP_DHCP_BOOTP_FILE            0
-#define LWIP_DHCP_GET_NTP_SRV           0
-#define LWIP_DHCP_MAX_NTP_SERVERS       1
-#define LWIP_DHCP_MAX_DNS_SERVERS       DNS_MAX_SERVERS
-#define LWIP_AUTOIP                     0
-#define LWIP_DHCP_AUTOIP_COOP           0
-#define LWIP_DHCP_AUTOIP_COOP_TRIES     9
-#define LWIP_MIB2_CALLBACKS             0
-#define LWIP_MULTICAST_TX_OPTIONS       ((LWIP_IGMP || LWIP_IPV6_MLD) && (LWIP_UDP || LWIP_RAW))
-#define LWIP_IGMP                       0
-#define LWIP_DNS                        0
-#define DNS_TABLE_SIZE                  4
-#define DNS_MAX_NAME_LENGTH             256
-#define DNS_MAX_SERVERS                 2
-#define DNS_MAX_RETRIES                 4
-#define DNS_DOES_NAME_CHECK             1
-#define LWIP_DNS_SECURE (LWIP_DNS_SECURE_RAND_XID | LWIP_DNS_SECURE_NO_MULTIPLE_OUTSTANDING | LWIP_DNS_SECURE_RAND_SRC_PORT)
-#define DNS_LOCAL_HOSTLIST              0
-#define DNS_LOCAL_HOSTLIST_IS_DYNAMIC   0
-#define LWIP_DNS_SUPPORT_MDNS_QUERIES   0
-#define LWIP_UDP                        1
-#define LWIP_UDPLITE                    0
-#define UDP_TTL                         (IP_DEFAULT_TTL)
-#define LWIP_NETBUF_RECVINFO            0
-#define LWIP_TCP                        1
-#define TCP_TTL                         (IP_DEFAULT_TTL)
-#define TCP_WND                         (4 * TCP_MSS)
-#define TCP_MAXRTX                      12
-#define TCP_SYNMAXRTX                   6
-#define TCP_QUEUE_OOSEQ                 (LWIP_TCP)
-#define LWIP_TCP_SACK_OUT               0
-#define LWIP_TCP_MAX_SACK_NUM           4
-#define TCP_MSS                         536
-#define TCP_CALCULATE_EFF_SEND_MSS      1
-#define TCP_SND_BUF                     (2 * TCP_MSS)
-#define TCP_SND_QUEUELEN                ((4 * (TCP_SND_BUF) + (TCP_MSS - 1))/(TCP_MSS))
-#define TCP_SNDLOWAT                    LWIP_MIN(LWIP_MAX(((TCP_SND_BUF)/2), (2 * TCP_MSS) + 1), (TCP_SND_BUF) - 1)
-#define TCP_SNDQUEUELOWAT               LWIP_MAX(((TCP_SND_QUEUELEN)/2), 5)
-#define TCP_OOSEQ_MAX_BYTES             0
-#define TCP_OOSEQ_BYTES_LIMIT(pcb)      TCP_OOSEQ_MAX_BYTES
-#define TCP_OOSEQ_MAX_PBUFS             0
-#define TCP_OOSEQ_PBUFS_LIMIT(pcb)      TCP_OOSEQ_MAX_PBUFS
-#define TCP_LISTEN_BACKLOG              0
-#define TCP_DEFAULT_LISTEN_BACKLOG      0xff
-#define TCP_OVERSIZE                    TCP_MSS
-#define LWIP_TCP_TIMESTAMPS             0
-#define TCP_WND_UPDATE_THRESHOLD        LWIP_MIN((TCP_WND / 4), (TCP_MSS * 4))
-#define LWIP_EVENT_API                  0
-#define LWIP_CALLBACK_API               1
-#define LWIP_WND_SCALE                  0
-#define TCP_RCV_SCALE                   0
-#define LWIP_TCP_PCB_NUM_EXT_ARGS       0
-#define LWIP_ALTCP                      0
-#define LWIP_ALTCP_TLS                  0
-#define PBUF_LINK_HLEN                  (14 + ETH_PAD_SIZE)
-#define PBUF_LINK_ENCAPSULATION_HLEN    0
-#define PBUF_POOL_BUFSIZE               LWIP_MEM_ALIGN_SIZE(TCP_MSS+40+PBUF_LINK_ENCAPSULATION_HLEN+PBUF_LINK_HLEN)
-#define LWIP_PBUF_REF_T                 u8_t
-#define LWIP_SINGLE_NETIF               0
-#define LWIP_NETIF_HOSTNAME             0
-#define LWIP_NETIF_API                  0
-#define LWIP_NETIF_STATUS_CALLBACK      0
-#define LWIP_NETIF_EXT_STATUS_CALLBACK  0
-#define LWIP_NETIF_LINK_CALLBACK        0
-#define LWIP_NETIF_REMOVE_CALLBACK      0
-#define LWIP_NETIF_HWADDRHINT           0
-#define LWIP_NETIF_TX_SINGLE_PBUF       0
-#define LWIP_NUM_NETIF_CLIENT_DATA      0
-#define LWIP_HAVE_LOOPIF                (LWIP_NETIF_LOOPBACK && !LWIP_SINGLE_NETIF)
-#define LWIP_LOOPIF_MULTICAST           0
-#define LWIP_NETIF_LOOPBACK             0
-#define LWIP_LOOPBACK_MAX_PBUFS         0
-#define LWIP_NETIF_LOOPBACK_MULTITHREADING    (!NO_SYS)
-/*#define TCPIP_THREAD_NAME               "tcpip_thread"
-#define TCPIP_THREAD_STACKSIZE          0
-#define TCPIP_THREAD_PRIO               1
-#define TCPIP_MBOX_SIZE                 0
-#define LWIP_TCPIP_THREAD_ALIVE()
-#define SLIPIF_THREAD_NAME              "slipif_loop"
-#define SLIPIF_THREAD_STACKSIZE         0
-#define SLIPIF_THREAD_PRIO              1
-#define DEFAULT_THREAD_NAME             "lwIP"
-#define DEFAULT_THREAD_STACKSIZE        0
-#define DEFAULT_THREAD_PRIO             1
-#define DEFAULT_RAW_RECVMBOX_SIZE       0
-#define DEFAULT_UDP_RECVMBOX_SIZE       0
-#define DEFAULT_TCP_RECVMBOX_SIZE       0
-#define DEFAULT_ACCEPTMBOX_SIZE         0*/
-#define LWIP_NETCONN                    1
-#define LWIP_TCPIP_TIMEOUT              0
-#define LWIP_NETCONN_SEM_PER_THREAD     0
-#define LWIP_NETCONN_FULLDUPLEX         0
-#define LWIP_SOCKET                     1
-#define LWIP_COMPAT_SOCKETS             1 /* 0..2 */
-#define LWIP_POSIX_SOCKETS_IO_NAMES     1
-#define LWIP_SOCKET_OFFSET              0
-#define LWIP_TCP_KEEPALIVE              0
-#define LWIP_SO_SNDTIMEO                0
-#define LWIP_SO_RCVTIMEO                0
-#define LWIP_SO_SNDRCVTIMEO_NONSTANDARD 0
-#define LWIP_SO_RCVBUF                  0
-#define LWIP_SO_LINGER                  0
-#define RECV_BUFSIZE_DEFAULT            INT_MAX
-#define LWIP_TCP_CLOSE_TIMEOUT_MS_DEFAULT 20000
-#define SO_REUSE                        0
-#define SO_REUSE_RXTOALL                0
-#define LWIP_FIONREAD_LINUXMODE         0
-#define LWIP_SOCKET_SELECT              1
-#define LWIP_SOCKET_POLL                1
-#define LWIP_STATS                      1
-#define LWIP_STATS_DISPLAY              0
-#define LINK_STATS                      1
-#define ETHARP_STATS                    (LWIP_ARP)
-#define IP_STATS                        1
-#define IPFRAG_STATS                    (IP_REASSEMBLY || IP_FRAG)
-#define ICMP_STATS                      1
-#define IGMP_STATS                      (LWIP_IGMP)
-#define UDP_STATS                       (LWIP_UDP)
-#define TCP_STATS                       (LWIP_TCP)
-#define MEM_STATS                       ((MEM_LIBC_MALLOC == 0) && (MEM_USE_POOLS == 0))
-#define MEMP_STATS                      (MEMP_MEM_MALLOC == 0)
-#define SYS_STATS                       (NO_SYS == 0)
-#define IP6_STATS                       (LWIP_IPV6)
-#define ICMP6_STATS                     (LWIP_IPV6 && LWIP_ICMP6)
-#define IP6_FRAG_STATS                  (LWIP_IPV6 && (LWIP_IPV6_FRAG || LWIP_IPV6_REASS))
-#define MLD6_STATS                      (LWIP_IPV6 && LWIP_IPV6_MLD)
-#define ND6_STATS                       (LWIP_IPV6)
-#define MIB2_STATS                      0
-#define LWIP_CHECKSUM_CTRL_PER_NETIF    0
-#define CHECKSUM_GEN_IP                 1
-#define CHECKSUM_GEN_UDP                1
-#define CHECKSUM_GEN_TCP                1
-#define CHECKSUM_GEN_ICMP               1
-#define CHECKSUM_GEN_ICMP6              1
-#define CHECKSUM_CHECK_IP               1
-#define CHECKSUM_CHECK_UDP              1
-#define CHECKSUM_CHECK_TCP              1
-#define CHECKSUM_CHECK_ICMP             1
-#define CHECKSUM_CHECK_ICMP6            1
-#define LWIP_CHECKSUM_ON_COPY           0
-#define LWIP_IPV6                       1
-#define IPV6_REASS_MAXAGE               60
-#define LWIP_IPV6_SCOPES                (LWIP_IPV6 && !LWIP_SINGLE_NETIF)
-#define LWIP_IPV6_SCOPES_DEBUG          0
-#define LWIP_IPV6_NUM_ADDRESSES         3
-#define LWIP_IPV6_FORWARD               0
-#define LWIP_IPV6_FRAG                  1
-#define LWIP_IPV6_REASS                 (LWIP_IPV6)
-#define LWIP_IPV6_SEND_ROUTER_SOLICIT   1
-#define LWIP_IPV6_AUTOCONFIG            (LWIP_IPV6)
-#define LWIP_IPV6_ADDRESS_LIFETIMES     (LWIP_IPV6_AUTOCONFIG)
-#define LWIP_IPV6_DUP_DETECT_ATTEMPTS   1
-#define LWIP_ICMP6                      (LWIP_IPV6)
-#define LWIP_ICMP6_DATASIZE             8
-#define LWIP_ICMP6_HL                   255
-#define LWIP_IPV6_MLD                   (LWIP_IPV6)
-#define MEMP_NUM_MLD6_GROUP             4
-#define LWIP_ND6_QUEUEING               (LWIP_IPV6)
-#define MEMP_NUM_ND6_QUEUE              20
-#define LWIP_ND6_NUM_NEIGHBORS          10
-#define LWIP_ND6_NUM_DESTINATIONS       10
-#define LWIP_ND6_NUM_PREFIXES           5
-#define LWIP_ND6_NUM_ROUTERS            3
-#define LWIP_ND6_MAX_MULTICAST_SOLICIT  3
-#define LWIP_ND6_MAX_UNICAST_SOLICIT    3
-#define LWIP_ND6_MAX_ANYCAST_DELAY_TIME 1000
-#define LWIP_ND6_MAX_NEIGHBOR_ADVERTISEMENT  3
-#define LWIP_ND6_REACHABLE_TIME         30000
-#define LWIP_ND6_RETRANS_TIMER          1000
-#define LWIP_ND6_DELAY_FIRST_PROBE_TIME 5000
-#define LWIP_ND6_ALLOW_RA_UPDATES       1
-#define LWIP_ND6_TCP_REACHABILITY_HINTS 1
-#define LWIP_ND6_RDNSS_MAX_DNS_SERVERS  0
-#define LWIP_IPV6_DHCP6                 0
-#define LWIP_IPV6_DHCP6_STATEFUL        0
-#define LWIP_IPV6_DHCP6_STATELESS       LWIP_IPV6_DHCP6
-#define LWIP_DHCP6_GET_NTP_SRV          0
-#define LWIP_DHCP6_MAX_NTP_SERVERS      1
-#define LWIP_DHCP6_MAX_DNS_SERVERS      DNS_MAX_SERVERS
-
-/* TODO: check hooks */
-
-#define LWIP_DBG_MIN_LEVEL              LWIP_DBG_LEVEL_ALL
-#define LWIP_DBG_TYPES_ON               LWIP_DBG_ON
-#define ETHARP_DEBUG                    LWIP_DBG_OFF
-#define NETIF_DEBUG                     LWIP_DBG_OFF
-#define PBUF_DEBUG                      LWIP_DBG_OFF
-#define API_LIB_DEBUG                   LWIP_DBG_OFF
-#define API_MSG_DEBUG                   LWIP_DBG_OFF
-#define SOCKETS_DEBUG                   LWIP_DBG_OFF
-#define ICMP_DEBUG                      LWIP_DBG_OFF
-#define IGMP_DEBUG                      LWIP_DBG_OFF
-#define INET_DEBUG                      LWIP_DBG_OFF
-#define IP_DEBUG                        LWIP_DBG_OFF
-#define IP_REASS_DEBUG                  LWIP_DBG_OFF
-#define RAW_DEBUG                       LWIP_DBG_OFF
-#define MEM_DEBUG                       LWIP_DBG_OFF
-#define MEMP_DEBUG                      LWIP_DBG_OFF
-#define SYS_DEBUG                       LWIP_DBG_OFF
-#define TIMERS_DEBUG                    LWIP_DBG_OFF
-#define TCP_DEBUG                       LWIP_DBG_OFF
-#define TCP_INPUT_DEBUG                 LWIP_DBG_OFF
-#define TCP_FR_DEBUG                    LWIP_DBG_OFF
-#define TCP_RTO_DEBUG                   LWIP_DBG_OFF
-#define TCP_CWND_DEBUG                  LWIP_DBG_OFF
-#define TCP_WND_DEBUG                   LWIP_DBG_OFF
-#define TCP_OUTPUT_DEBUG                LWIP_DBG_OFF
-#define TCP_RST_DEBUG                   LWIP_DBG_OFF
-#define TCP_QLEN_DEBUG                  LWIP_DBG_OFF
-#define UDP_DEBUG                       LWIP_DBG_OFF
-#define TCPIP_DEBUG                     LWIP_DBG_OFF
-#define SLIP_DEBUG                      LWIP_DBG_OFF
-#define DHCP_DEBUG                      LWIP_DBG_OFF
-#define AUTOIP_DEBUG                    LWIP_DBG_OFF
-#define DNS_DEBUG                       LWIP_DBG_OFF
-#define IP6_DEBUG                       LWIP_DBG_OFF
-#define DHCP6_DEBUG                     LWIP_DBG_OFF
-#define LWIP_TESTMODE                   0
-
-#define LWIP_PERF                       0
diff --git a/contrib/examples/example_app/test_configs/opt_no_tcp_dualstack.h b/contrib/examples/example_app/test_configs/opt_no_tcp_dualstack.h
deleted file mode 100644
index 9d70acea..00000000
--- a/contrib/examples/example_app/test_configs/opt_no_tcp_dualstack.h
+++ /dev/null
@@ -1,4 +0,0 @@
-#include "test_configs/opt_dualstack.h"
-
-#undef LWIP_TCP
-#define LWIP_TCP 0
diff --git a/contrib/examples/example_app/test_configs/opt_no_tcp_ipv4only.h b/contrib/examples/example_app/test_configs/opt_no_tcp_ipv4only.h
deleted file mode 100644
index bd228318..00000000
--- a/contrib/examples/example_app/test_configs/opt_no_tcp_ipv4only.h
+++ /dev/null
@@ -1,4 +0,0 @@
-#include "test_configs/opt_ipv4only.h"
-
-#undef LWIP_TCP
-#define LWIP_TCP 0
diff --git a/contrib/examples/example_app/test_configs/opt_no_tcp_ipv6only.h b/contrib/examples/example_app/test_configs/opt_no_tcp_ipv6only.h
deleted file mode 100644
index 9f956e3c..00000000
--- a/contrib/examples/example_app/test_configs/opt_no_tcp_ipv6only.h
+++ /dev/null
@@ -1,4 +0,0 @@
-#include "test_configs/opt_ipv6only.h"
-
-#undef LWIP_TCP
-#define LWIP_TCP 0
diff --git a/contrib/examples/example_app/test_configs/opt_no_udp_dualstack.h b/contrib/examples/example_app/test_configs/opt_no_udp_dualstack.h
deleted file mode 100644
index c9b9e9af..00000000
--- a/contrib/examples/example_app/test_configs/opt_no_udp_dualstack.h
+++ /dev/null
@@ -1,4 +0,0 @@
-#include "test_configs/opt_dualstack.h"
-
-#undef LWIP_UDP
-#define LWIP_UDP 0
diff --git a/contrib/examples/example_app/test_configs/opt_no_udp_ipv4only.h b/contrib/examples/example_app/test_configs/opt_no_udp_ipv4only.h
deleted file mode 100644
index 7aa3ace9..00000000
--- a/contrib/examples/example_app/test_configs/opt_no_udp_ipv4only.h
+++ /dev/null
@@ -1,4 +0,0 @@
-#include "test_configs/opt_ipv4only.h"
-
-#undef LWIP_UDP
-#define LWIP_UDP 0
diff --git a/contrib/examples/example_app/test_configs/opt_no_udp_ipv6only.h b/contrib/examples/example_app/test_configs/opt_no_udp_ipv6only.h
deleted file mode 100644
index 0572798b..00000000
--- a/contrib/examples/example_app/test_configs/opt_no_udp_ipv6only.h
+++ /dev/null
@@ -1,4 +0,0 @@
-#include "test_configs/opt_ipv6only.h"
-
-#undef LWIP_UDP
-#define LWIP_UDP 0
diff --git a/contrib/examples/example_app/test_configs/opt_none.h b/contrib/examples/example_app/test_configs/opt_none.h
deleted file mode 100644
index 3c393218..00000000
--- a/contrib/examples/example_app/test_configs/opt_none.h
+++ /dev/null
@@ -1,2 +0,0 @@
-/* test and empty lwipopts.h file */
-
diff --git a/contrib/examples/example_app/test_configs/opt_nosys_dual.h b/contrib/examples/example_app/test_configs/opt_nosys_dual.h
deleted file mode 100644
index 17ee97ff..00000000
--- a/contrib/examples/example_app/test_configs/opt_nosys_dual.h
+++ /dev/null
@@ -1,295 +0,0 @@
-/* test an lwipopts.h file with default contents */
-#define NO_SYS                          0
-#define NO_SYS_NO_TIMERS                0
-#define LWIP_TIMERS                     1
-#define LWIP_TIMERS_CUSTOM              0
-#define LWIP_MPU_COMPATIBLE             0
-#define LWIP_TCPIP_CORE_LOCKING         1
-#define LWIP_TCPIP_CORE_LOCKING_INPUT   0
-#define SYS_LIGHTWEIGHT_PROT            1
-#define MEM_LIBC_MALLOC                 0
-#define MEMP_MEM_MALLOC                 0
-#define MEMP_MEM_INIT                   0
-#define MEM_ALIGNMENT                   1
-#define MEM_SIZE                        1600
-#define MEMP_OVERFLOW_CHECK             0
-#define MEMP_SANITY_CHECK               0
-#define MEM_OVERFLOW_CHECK              0
-#define MEM_SANITY_CHECK                0
-#define MEM_USE_POOLS                   0
-#define MEM_USE_POOLS_TRY_BIGGER_POOL   0
-#define MEMP_USE_CUSTOM_POOLS           0
-#define LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT 0
-/*#define MEMP_NUM_PBUF                   16
-#define MEMP_NUM_RAW_PCB                4
-#define MEMP_NUM_UDP_PCB                4
-#define MEMP_NUM_TCP_PCB                5
-#define MEMP_NUM_TCP_PCB_LISTEN         8
-#define MEMP_NUM_TCP_SEG                16
-#define MEMP_NUM_ALTCP_PCB              MEMP_NUM_TCP_PCB
-#define MEMP_NUM_REASSDATA              5
-#define MEMP_NUM_FRAG_PBUF              15
-#define MEMP_NUM_ARP_QUEUE              30
-#define MEMP_NUM_IGMP_GROUP             8
-#define MEMP_NUM_SYS_TIMEOUT            (LWIP_NUM_SYS_TIMEOUT_INTERNAL + 2)
-#define MEMP_NUM_NETBUF                 2
-#define MEMP_NUM_NETCONN                4
-#define MEMP_NUM_SELECT_CB              4
-#define MEMP_NUM_TCPIP_MSG_API          8
-#define MEMP_NUM_TCPIP_MSG_INPKT        8
-#define MEMP_NUM_NETDB                  1
-#define MEMP_NUM_LOCALHOSTLIST          1
-#define PBUF_POOL_SIZE                  16
-#define MEMP_NUM_API_MSG                MEMP_NUM_TCPIP_MSG_API
-#define MEMP_NUM_DNS_API_MSG            MEMP_NUM_TCPIP_MSG_API
-#define MEMP_NUM_SOCKET_SETGETSOCKOPT_DATA MEMP_NUM_TCPIP_MSG_API
-#define MEMP_NUM_NETIFAPI_MSG           MEMP_NUM_TCPIP_MSG_API*/
-#define LWIP_ARP                        1
-#define ARP_TABLE_SIZE                  10
-#define ARP_MAXAGE                      300
-#define ARP_QUEUEING                    0
-#define ARP_QUEUE_LEN                   3
-#define ETHARP_SUPPORT_VLAN             0
-#define LWIP_ETHERNET                   LWIP_ARP
-#define ETH_PAD_SIZE                    0
-#define ETHARP_SUPPORT_STATIC_ENTRIES   0
-#define ETHARP_TABLE_MATCH_NETIF        !LWIP_SINGLE_NETIF
-#define LWIP_IPV4                       1
-#define IP_FORWARD                      0
-#define IP_REASSEMBLY                   1
-#define IP_FRAG                         1
-#define IP_OPTIONS_ALLOWED              1
-#define IP_REASS_MAXAGE                 15
-#define IP_REASS_MAX_PBUFS              10
-#define IP_DEFAULT_TTL                  255
-#define IP_SOF_BROADCAST                0
-#define IP_SOF_BROADCAST_RECV           0
-#define IP_FORWARD_ALLOW_TX_ON_RX_NETIF 0
-#define LWIP_ICMP                       1
-#define ICMP_TTL                        (IP_DEFAULT_TTL)
-#define LWIP_BROADCAST_PING             0
-#define LWIP_MULTICAST_PING             0
-#define LWIP_RAW                        0
-#define RAW_TTL                         (IP_DEFAULT_TTL)
-#define LWIP_DHCP                       1
-#define LWIP_DHCP_CHECK_LINK_UP         0
-#define LWIP_DHCP_BOOTP_FILE            0
-#define LWIP_DHCP_GET_NTP_SRV           0
-#define LWIP_DHCP_MAX_NTP_SERVERS       1
-#define LWIP_DHCP_MAX_DNS_SERVERS       DNS_MAX_SERVERS
-#define LWIP_AUTOIP                     0
-#define LWIP_DHCP_AUTOIP_COOP           0
-#define LWIP_DHCP_AUTOIP_COOP_TRIES     9
-#define LWIP_MIB2_CALLBACKS             0
-#define LWIP_MULTICAST_TX_OPTIONS       ((LWIP_IGMP || LWIP_IPV6_MLD) && (LWIP_UDP || LWIP_RAW))
-#define LWIP_IGMP                       0
-#define LWIP_DNS                        0
-#define DNS_TABLE_SIZE                  4
-#define DNS_MAX_NAME_LENGTH             256
-#define DNS_MAX_SERVERS                 2
-#define DNS_MAX_RETRIES                 4
-#define DNS_DOES_NAME_CHECK             1
-#define LWIP_DNS_SECURE (LWIP_DNS_SECURE_RAND_XID | LWIP_DNS_SECURE_NO_MULTIPLE_OUTSTANDING | LWIP_DNS_SECURE_RAND_SRC_PORT)
-#define DNS_LOCAL_HOSTLIST              0
-#define DNS_LOCAL_HOSTLIST_IS_DYNAMIC   0
-#define LWIP_DNS_SUPPORT_MDNS_QUERIES   0
-#define LWIP_UDP                        1
-#define LWIP_UDPLITE                    0
-#define UDP_TTL                         (IP_DEFAULT_TTL)
-#define LWIP_NETBUF_RECVINFO            0
-#define LWIP_TCP                        1
-#define TCP_TTL                         (IP_DEFAULT_TTL)
-#define TCP_WND                         (4 * TCP_MSS)
-#define TCP_MAXRTX                      12
-#define TCP_SYNMAXRTX                   6
-#define TCP_QUEUE_OOSEQ                 (LWIP_TCP)
-#define LWIP_TCP_SACK_OUT               0
-#define LWIP_TCP_MAX_SACK_NUM           4
-#define TCP_MSS                         536
-#define TCP_CALCULATE_EFF_SEND_MSS      1
-#define TCP_SND_BUF                     (2 * TCP_MSS)
-#define TCP_SND_QUEUELEN                ((4 * (TCP_SND_BUF) + (TCP_MSS - 1))/(TCP_MSS))
-#define TCP_SNDLOWAT                    LWIP_MIN(LWIP_MAX(((TCP_SND_BUF)/2), (2 * TCP_MSS) + 1), (TCP_SND_BUF) - 1)
-#define TCP_SNDQUEUELOWAT               LWIP_MAX(((TCP_SND_QUEUELEN)/2), 5)
-#define TCP_OOSEQ_MAX_BYTES             0
-#define TCP_OOSEQ_BYTES_LIMIT(pcb)      TCP_OOSEQ_MAX_BYTES
-#define TCP_OOSEQ_MAX_PBUFS             0
-#define TCP_OOSEQ_PBUFS_LIMIT(pcb)      TCP_OOSEQ_MAX_PBUFS
-#define TCP_LISTEN_BACKLOG              0
-#define TCP_DEFAULT_LISTEN_BACKLOG      0xff
-#define TCP_OVERSIZE                    TCP_MSS
-#define LWIP_TCP_TIMESTAMPS             0
-#define TCP_WND_UPDATE_THRESHOLD        LWIP_MIN((TCP_WND / 4), (TCP_MSS * 4))
-#define LWIP_EVENT_API                  0
-#define LWIP_CALLBACK_API               1
-#define LWIP_WND_SCALE                  0
-#define TCP_RCV_SCALE                   0
-#define LWIP_TCP_PCB_NUM_EXT_ARGS       0
-#define LWIP_ALTCP                      0
-#define LWIP_ALTCP_TLS                  0
-#define PBUF_LINK_HLEN                  (14 + ETH_PAD_SIZE)
-#define PBUF_LINK_ENCAPSULATION_HLEN    0
-#define PBUF_POOL_BUFSIZE               LWIP_MEM_ALIGN_SIZE(TCP_MSS+40+PBUF_LINK_ENCAPSULATION_HLEN+PBUF_LINK_HLEN)
-#define LWIP_PBUF_REF_T                 u8_t
-#define LWIP_SINGLE_NETIF               0
-#define LWIP_NETIF_HOSTNAME             0
-#define LWIP_NETIF_API                  0
-#define LWIP_NETIF_STATUS_CALLBACK      0
-#define LWIP_NETIF_EXT_STATUS_CALLBACK  0
-#define LWIP_NETIF_LINK_CALLBACK        0
-#define LWIP_NETIF_REMOVE_CALLBACK      0
-#define LWIP_NETIF_HWADDRHINT           0
-#define LWIP_NETIF_TX_SINGLE_PBUF       0
-#define LWIP_NUM_NETIF_CLIENT_DATA      0
-#define LWIP_HAVE_LOOPIF                (LWIP_NETIF_LOOPBACK && !LWIP_SINGLE_NETIF)
-#define LWIP_LOOPIF_MULTICAST           0
-#define LWIP_NETIF_LOOPBACK             0
-#define LWIP_LOOPBACK_MAX_PBUFS         0
-#define LWIP_NETIF_LOOPBACK_MULTITHREADING    (!NO_SYS)
-/*#define TCPIP_THREAD_NAME               "tcpip_thread"
-#define TCPIP_THREAD_STACKSIZE          0
-#define TCPIP_THREAD_PRIO               1
-#define TCPIP_MBOX_SIZE                 0
-#define LWIP_TCPIP_THREAD_ALIVE()
-#define SLIPIF_THREAD_NAME              "slipif_loop"
-#define SLIPIF_THREAD_STACKSIZE         0
-#define SLIPIF_THREAD_PRIO              1
-#define DEFAULT_THREAD_NAME             "lwIP"
-#define DEFAULT_THREAD_STACKSIZE        0
-#define DEFAULT_THREAD_PRIO             1
-#define DEFAULT_RAW_RECVMBOX_SIZE       0
-#define DEFAULT_UDP_RECVMBOX_SIZE       0
-#define DEFAULT_TCP_RECVMBOX_SIZE       0
-#define DEFAULT_ACCEPTMBOX_SIZE         0*/
-#define LWIP_NETCONN                    0
-#define LWIP_TCPIP_TIMEOUT              0
-#define LWIP_NETCONN_SEM_PER_THREAD     0
-#define LWIP_NETCONN_FULLDUPLEX         0
-#define LWIP_SOCKET                     0
-#define LWIP_COMPAT_SOCKETS             1 /* 0..2 */
-#define LWIP_POSIX_SOCKETS_IO_NAMES     1
-#define LWIP_SOCKET_OFFSET              0
-#define LWIP_TCP_KEEPALIVE              0
-#define LWIP_SO_SNDTIMEO                0
-#define LWIP_SO_RCVTIMEO                0
-#define LWIP_SO_SNDRCVTIMEO_NONSTANDARD 0
-#define LWIP_SO_RCVBUF                  0
-#define LWIP_SO_LINGER                  0
-#define RECV_BUFSIZE_DEFAULT            INT_MAX
-#define LWIP_TCP_CLOSE_TIMEOUT_MS_DEFAULT 20000
-#define SO_REUSE                        0
-#define SO_REUSE_RXTOALL                0
-#define LWIP_FIONREAD_LINUXMODE         0
-#define LWIP_SOCKET_SELECT              1
-#define LWIP_SOCKET_POLL                1
-#define LWIP_STATS                      1
-#define LWIP_STATS_DISPLAY              0
-#define LINK_STATS                      1
-#define ETHARP_STATS                    (LWIP_ARP)
-#define IP_STATS                        1
-#define IPFRAG_STATS                    (IP_REASSEMBLY || IP_FRAG)
-#define ICMP_STATS                      1
-#define IGMP_STATS                      (LWIP_IGMP)
-#define UDP_STATS                       (LWIP_UDP)
-#define TCP_STATS                       (LWIP_TCP)
-#define MEM_STATS                       ((MEM_LIBC_MALLOC == 0) && (MEM_USE_POOLS == 0))
-#define MEMP_STATS                      (MEMP_MEM_MALLOC == 0)
-#define SYS_STATS                       (NO_SYS == 0)
-#define IP6_STATS                       (LWIP_IPV6)
-#define ICMP6_STATS                     (LWIP_IPV6 && LWIP_ICMP6)
-#define IP6_FRAG_STATS                  (LWIP_IPV6 && (LWIP_IPV6_FRAG || LWIP_IPV6_REASS))
-#define MLD6_STATS                      (LWIP_IPV6 && LWIP_IPV6_MLD)
-#define ND6_STATS                       (LWIP_IPV6)
-#define MIB2_STATS                      0
-#define LWIP_CHECKSUM_CTRL_PER_NETIF    0
-#define CHECKSUM_GEN_IP                 1
-#define CHECKSUM_GEN_UDP                1
-#define CHECKSUM_GEN_TCP                1
-#define CHECKSUM_GEN_ICMP               1
-#define CHECKSUM_GEN_ICMP6              1
-#define CHECKSUM_CHECK_IP               1
-#define CHECKSUM_CHECK_UDP              1
-#define CHECKSUM_CHECK_TCP              1
-#define CHECKSUM_CHECK_ICMP             1
-#define CHECKSUM_CHECK_ICMP6            1
-#define LWIP_CHECKSUM_ON_COPY           0
-#define LWIP_IPV6                       1
-#define IPV6_REASS_MAXAGE               60
-#define LWIP_IPV6_SCOPES                (LWIP_IPV6 && !LWIP_SINGLE_NETIF)
-#define LWIP_IPV6_SCOPES_DEBUG          0
-#define LWIP_IPV6_NUM_ADDRESSES         3
-#define LWIP_IPV6_FORWARD               0
-#define LWIP_IPV6_FRAG                  1
-#define LWIP_IPV6_REASS                 (LWIP_IPV6)
-#define LWIP_IPV6_SEND_ROUTER_SOLICIT   1
-#define LWIP_IPV6_AUTOCONFIG            (LWIP_IPV6)
-#define LWIP_IPV6_ADDRESS_LIFETIMES     (LWIP_IPV6_AUTOCONFIG)
-#define LWIP_IPV6_DUP_DETECT_ATTEMPTS   1
-#define LWIP_ICMP6                      (LWIP_IPV6)
-#define LWIP_ICMP6_DATASIZE             8
-#define LWIP_ICMP6_HL                   255
-#define LWIP_IPV6_MLD                   (LWIP_IPV6)
-#define MEMP_NUM_MLD6_GROUP             4
-#define LWIP_ND6_QUEUEING               (LWIP_IPV6)
-#define MEMP_NUM_ND6_QUEUE              20
-#define LWIP_ND6_NUM_NEIGHBORS          10
-#define LWIP_ND6_NUM_DESTINATIONS       10
-#define LWIP_ND6_NUM_PREFIXES           5
-#define LWIP_ND6_NUM_ROUTERS            3
-#define LWIP_ND6_MAX_MULTICAST_SOLICIT  3
-#define LWIP_ND6_MAX_UNICAST_SOLICIT    3
-#define LWIP_ND6_MAX_ANYCAST_DELAY_TIME 1000
-#define LWIP_ND6_MAX_NEIGHBOR_ADVERTISEMENT  3
-#define LWIP_ND6_REACHABLE_TIME         30000
-#define LWIP_ND6_RETRANS_TIMER          1000
-#define LWIP_ND6_DELAY_FIRST_PROBE_TIME 5000
-#define LWIP_ND6_ALLOW_RA_UPDATES       1
-#define LWIP_ND6_TCP_REACHABILITY_HINTS 1
-#define LWIP_ND6_RDNSS_MAX_DNS_SERVERS  0
-#define LWIP_IPV6_DHCP6                 0
-#define LWIP_IPV6_DHCP6_STATEFUL        0
-#define LWIP_IPV6_DHCP6_STATELESS       LWIP_IPV6_DHCP6
-#define LWIP_DHCP6_GET_NTP_SRV          0
-#define LWIP_DHCP6_MAX_NTP_SERVERS      1
-#define LWIP_DHCP6_MAX_DNS_SERVERS      DNS_MAX_SERVERS
-
-/* TODO: check hooks */
-
-#define LWIP_DBG_MIN_LEVEL              LWIP_DBG_LEVEL_ALL
-#define LWIP_DBG_TYPES_ON               LWIP_DBG_ON
-#define ETHARP_DEBUG                    LWIP_DBG_OFF
-#define NETIF_DEBUG                     LWIP_DBG_OFF
-#define PBUF_DEBUG                      LWIP_DBG_OFF
-#define API_LIB_DEBUG                   LWIP_DBG_OFF
-#define API_MSG_DEBUG                   LWIP_DBG_OFF
-#define SOCKETS_DEBUG                   LWIP_DBG_OFF
-#define ICMP_DEBUG                      LWIP_DBG_OFF
-#define IGMP_DEBUG                      LWIP_DBG_OFF
-#define INET_DEBUG                      LWIP_DBG_OFF
-#define IP_DEBUG                        LWIP_DBG_OFF
-#define IP_REASS_DEBUG                  LWIP_DBG_OFF
-#define RAW_DEBUG                       LWIP_DBG_OFF
-#define MEM_DEBUG                       LWIP_DBG_OFF
-#define MEMP_DEBUG                      LWIP_DBG_OFF
-#define SYS_DEBUG                       LWIP_DBG_OFF
-#define TIMERS_DEBUG                    LWIP_DBG_OFF
-#define TCP_DEBUG                       LWIP_DBG_OFF
-#define TCP_INPUT_DEBUG                 LWIP_DBG_OFF
-#define TCP_FR_DEBUG                    LWIP_DBG_OFF
-#define TCP_RTO_DEBUG                   LWIP_DBG_OFF
-#define TCP_CWND_DEBUG                  LWIP_DBG_OFF
-#define TCP_WND_DEBUG                   LWIP_DBG_OFF
-#define TCP_OUTPUT_DEBUG                LWIP_DBG_OFF
-#define TCP_RST_DEBUG                   LWIP_DBG_OFF
-#define TCP_QLEN_DEBUG                  LWIP_DBG_OFF
-#define UDP_DEBUG                       LWIP_DBG_OFF
-#define TCPIP_DEBUG                     LWIP_DBG_OFF
-#define SLIP_DEBUG                      LWIP_DBG_OFF
-#define DHCP_DEBUG                      LWIP_DBG_OFF
-#define AUTOIP_DEBUG                    LWIP_DBG_OFF
-#define DNS_DEBUG                       LWIP_DBG_OFF
-#define IP6_DEBUG                       LWIP_DBG_OFF
-#define DHCP6_DEBUG                     LWIP_DBG_OFF
-#define LWIP_TESTMODE                   0
-
-#define LWIP_PERF                       0
diff --git a/contrib/examples/example_app/test_configs/opt_nosys_ipv4.h b/contrib/examples/example_app/test_configs/opt_nosys_ipv4.h
deleted file mode 100644
index 024d79be..00000000
--- a/contrib/examples/example_app/test_configs/opt_nosys_ipv4.h
+++ /dev/null
@@ -1,295 +0,0 @@
-/* test an lwipopts.h file with default contents */
-#define NO_SYS                          0
-#define NO_SYS_NO_TIMERS                0
-#define LWIP_TIMERS                     1
-#define LWIP_TIMERS_CUSTOM              0
-#define LWIP_MPU_COMPATIBLE             0
-#define LWIP_TCPIP_CORE_LOCKING         1
-#define LWIP_TCPIP_CORE_LOCKING_INPUT   0
-#define SYS_LIGHTWEIGHT_PROT            1
-#define MEM_LIBC_MALLOC                 0
-#define MEMP_MEM_MALLOC                 0
-#define MEMP_MEM_INIT                   0
-#define MEM_ALIGNMENT                   1
-#define MEM_SIZE                        1600
-#define MEMP_OVERFLOW_CHECK             0
-#define MEMP_SANITY_CHECK               0
-#define MEM_OVERFLOW_CHECK              0
-#define MEM_SANITY_CHECK                0
-#define MEM_USE_POOLS                   0
-#define MEM_USE_POOLS_TRY_BIGGER_POOL   0
-#define MEMP_USE_CUSTOM_POOLS           0
-#define LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT 0
-/*#define MEMP_NUM_PBUF                   16
-#define MEMP_NUM_RAW_PCB                4
-#define MEMP_NUM_UDP_PCB                4
-#define MEMP_NUM_TCP_PCB                5
-#define MEMP_NUM_TCP_PCB_LISTEN         8
-#define MEMP_NUM_TCP_SEG                16
-#define MEMP_NUM_ALTCP_PCB              MEMP_NUM_TCP_PCB
-#define MEMP_NUM_REASSDATA              5
-#define MEMP_NUM_FRAG_PBUF              15
-#define MEMP_NUM_ARP_QUEUE              30
-#define MEMP_NUM_IGMP_GROUP             8
-#define MEMP_NUM_SYS_TIMEOUT            (LWIP_NUM_SYS_TIMEOUT_INTERNAL + 2)
-#define MEMP_NUM_NETBUF                 2
-#define MEMP_NUM_NETCONN                4
-#define MEMP_NUM_SELECT_CB              4
-#define MEMP_NUM_TCPIP_MSG_API          8
-#define MEMP_NUM_TCPIP_MSG_INPKT        8
-#define MEMP_NUM_NETDB                  1
-#define MEMP_NUM_LOCALHOSTLIST          1
-#define PBUF_POOL_SIZE                  16
-#define MEMP_NUM_API_MSG                MEMP_NUM_TCPIP_MSG_API
-#define MEMP_NUM_DNS_API_MSG            MEMP_NUM_TCPIP_MSG_API
-#define MEMP_NUM_SOCKET_SETGETSOCKOPT_DATA MEMP_NUM_TCPIP_MSG_API
-#define MEMP_NUM_NETIFAPI_MSG           MEMP_NUM_TCPIP_MSG_API*/
-#define LWIP_ARP                        1
-#define ARP_TABLE_SIZE                  10
-#define ARP_MAXAGE                      300
-#define ARP_QUEUEING                    0
-#define ARP_QUEUE_LEN                   3
-#define ETHARP_SUPPORT_VLAN             0
-#define LWIP_ETHERNET                   LWIP_ARP
-#define ETH_PAD_SIZE                    0
-#define ETHARP_SUPPORT_STATIC_ENTRIES   0
-#define ETHARP_TABLE_MATCH_NETIF        !LWIP_SINGLE_NETIF
-#define LWIP_IPV4                       1
-#define IP_FORWARD                      0
-#define IP_REASSEMBLY                   1
-#define IP_FRAG                         1
-#define IP_OPTIONS_ALLOWED              1
-#define IP_REASS_MAXAGE                 15
-#define IP_REASS_MAX_PBUFS              10
-#define IP_DEFAULT_TTL                  255
-#define IP_SOF_BROADCAST                0
-#define IP_SOF_BROADCAST_RECV           0
-#define IP_FORWARD_ALLOW_TX_ON_RX_NETIF 0
-#define LWIP_ICMP                       1
-#define ICMP_TTL                        (IP_DEFAULT_TTL)
-#define LWIP_BROADCAST_PING             0
-#define LWIP_MULTICAST_PING             0
-#define LWIP_RAW                        0
-#define RAW_TTL                         (IP_DEFAULT_TTL)
-#define LWIP_DHCP                       1
-#define LWIP_DHCP_CHECK_LINK_UP         0
-#define LWIP_DHCP_BOOTP_FILE            0
-#define LWIP_DHCP_GET_NTP_SRV           0
-#define LWIP_DHCP_MAX_NTP_SERVERS       1
-#define LWIP_DHCP_MAX_DNS_SERVERS       DNS_MAX_SERVERS
-#define LWIP_AUTOIP                     0
-#define LWIP_DHCP_AUTOIP_COOP           0
-#define LWIP_DHCP_AUTOIP_COOP_TRIES     9
-#define LWIP_MIB2_CALLBACKS             0
-#define LWIP_MULTICAST_TX_OPTIONS       ((LWIP_IGMP || LWIP_IPV6_MLD) && (LWIP_UDP || LWIP_RAW))
-#define LWIP_IGMP                       0
-#define LWIP_DNS                        0
-#define DNS_TABLE_SIZE                  4
-#define DNS_MAX_NAME_LENGTH             256
-#define DNS_MAX_SERVERS                 2
-#define DNS_MAX_RETRIES                 4
-#define DNS_DOES_NAME_CHECK             1
-#define LWIP_DNS_SECURE (LWIP_DNS_SECURE_RAND_XID | LWIP_DNS_SECURE_NO_MULTIPLE_OUTSTANDING | LWIP_DNS_SECURE_RAND_SRC_PORT)
-#define DNS_LOCAL_HOSTLIST              0
-#define DNS_LOCAL_HOSTLIST_IS_DYNAMIC   0
-#define LWIP_DNS_SUPPORT_MDNS_QUERIES   0
-#define LWIP_UDP                        1
-#define LWIP_UDPLITE                    0
-#define UDP_TTL                         (IP_DEFAULT_TTL)
-#define LWIP_NETBUF_RECVINFO            0
-#define LWIP_TCP                        1
-#define TCP_TTL                         (IP_DEFAULT_TTL)
-#define TCP_WND                         (4 * TCP_MSS)
-#define TCP_MAXRTX                      12
-#define TCP_SYNMAXRTX                   6
-#define TCP_QUEUE_OOSEQ                 (LWIP_TCP)
-#define LWIP_TCP_SACK_OUT               0
-#define LWIP_TCP_MAX_SACK_NUM           4
-#define TCP_MSS                         536
-#define TCP_CALCULATE_EFF_SEND_MSS      1
-#define TCP_SND_BUF                     (2 * TCP_MSS)
-#define TCP_SND_QUEUELEN                ((4 * (TCP_SND_BUF) + (TCP_MSS - 1))/(TCP_MSS))
-#define TCP_SNDLOWAT                    LWIP_MIN(LWIP_MAX(((TCP_SND_BUF)/2), (2 * TCP_MSS) + 1), (TCP_SND_BUF) - 1)
-#define TCP_SNDQUEUELOWAT               LWIP_MAX(((TCP_SND_QUEUELEN)/2), 5)
-#define TCP_OOSEQ_MAX_BYTES             0
-#define TCP_OOSEQ_BYTES_LIMIT(pcb)      TCP_OOSEQ_MAX_BYTES
-#define TCP_OOSEQ_MAX_PBUFS             0
-#define TCP_OOSEQ_PBUFS_LIMIT(pcb)      TCP_OOSEQ_MAX_PBUFS
-#define TCP_LISTEN_BACKLOG              0
-#define TCP_DEFAULT_LISTEN_BACKLOG      0xff
-#define TCP_OVERSIZE                    TCP_MSS
-#define LWIP_TCP_TIMESTAMPS             0
-#define TCP_WND_UPDATE_THRESHOLD        LWIP_MIN((TCP_WND / 4), (TCP_MSS * 4))
-#define LWIP_EVENT_API                  0
-#define LWIP_CALLBACK_API               1
-#define LWIP_WND_SCALE                  0
-#define TCP_RCV_SCALE                   0
-#define LWIP_TCP_PCB_NUM_EXT_ARGS       0
-#define LWIP_ALTCP                      0
-#define LWIP_ALTCP_TLS                  0
-#define PBUF_LINK_HLEN                  (14 + ETH_PAD_SIZE)
-#define PBUF_LINK_ENCAPSULATION_HLEN    0
-#define PBUF_POOL_BUFSIZE               LWIP_MEM_ALIGN_SIZE(TCP_MSS+40+PBUF_LINK_ENCAPSULATION_HLEN+PBUF_LINK_HLEN)
-#define LWIP_PBUF_REF_T                 u8_t
-#define LWIP_SINGLE_NETIF               0
-#define LWIP_NETIF_HOSTNAME             0
-#define LWIP_NETIF_API                  0
-#define LWIP_NETIF_STATUS_CALLBACK      0
-#define LWIP_NETIF_EXT_STATUS_CALLBACK  0
-#define LWIP_NETIF_LINK_CALLBACK        0
-#define LWIP_NETIF_REMOVE_CALLBACK      0
-#define LWIP_NETIF_HWADDRHINT           0
-#define LWIP_NETIF_TX_SINGLE_PBUF       0
-#define LWIP_NUM_NETIF_CLIENT_DATA      0
-#define LWIP_HAVE_LOOPIF                (LWIP_NETIF_LOOPBACK && !LWIP_SINGLE_NETIF)
-#define LWIP_LOOPIF_MULTICAST           0
-#define LWIP_NETIF_LOOPBACK             0
-#define LWIP_LOOPBACK_MAX_PBUFS         0
-#define LWIP_NETIF_LOOPBACK_MULTITHREADING    (!NO_SYS)
-/*#define TCPIP_THREAD_NAME               "tcpip_thread"
-#define TCPIP_THREAD_STACKSIZE          0
-#define TCPIP_THREAD_PRIO               1
-#define TCPIP_MBOX_SIZE                 0
-#define LWIP_TCPIP_THREAD_ALIVE()
-#define SLIPIF_THREAD_NAME              "slipif_loop"
-#define SLIPIF_THREAD_STACKSIZE         0
-#define SLIPIF_THREAD_PRIO              1
-#define DEFAULT_THREAD_NAME             "lwIP"
-#define DEFAULT_THREAD_STACKSIZE        0
-#define DEFAULT_THREAD_PRIO             1
-#define DEFAULT_RAW_RECVMBOX_SIZE       0
-#define DEFAULT_UDP_RECVMBOX_SIZE       0
-#define DEFAULT_TCP_RECVMBOX_SIZE       0
-#define DEFAULT_ACCEPTMBOX_SIZE         0*/
-#define LWIP_NETCONN                    0
-#define LWIP_TCPIP_TIMEOUT              0
-#define LWIP_NETCONN_SEM_PER_THREAD     0
-#define LWIP_NETCONN_FULLDUPLEX         0
-#define LWIP_SOCKET                     0
-#define LWIP_COMPAT_SOCKETS             1 /* 0..2 */
-#define LWIP_POSIX_SOCKETS_IO_NAMES     1
-#define LWIP_SOCKET_OFFSET              0
-#define LWIP_TCP_KEEPALIVE              0
-#define LWIP_SO_SNDTIMEO                0
-#define LWIP_SO_RCVTIMEO                0
-#define LWIP_SO_SNDRCVTIMEO_NONSTANDARD 0
-#define LWIP_SO_RCVBUF                  0
-#define LWIP_SO_LINGER                  0
-#define RECV_BUFSIZE_DEFAULT            INT_MAX
-#define LWIP_TCP_CLOSE_TIMEOUT_MS_DEFAULT 20000
-#define SO_REUSE                        0
-#define SO_REUSE_RXTOALL                0
-#define LWIP_FIONREAD_LINUXMODE         0
-#define LWIP_SOCKET_SELECT              1
-#define LWIP_SOCKET_POLL                1
-#define LWIP_STATS                      1
-#define LWIP_STATS_DISPLAY              0
-#define LINK_STATS                      1
-#define ETHARP_STATS                    (LWIP_ARP)
-#define IP_STATS                        1
-#define IPFRAG_STATS                    (IP_REASSEMBLY || IP_FRAG)
-#define ICMP_STATS                      1
-#define IGMP_STATS                      (LWIP_IGMP)
-#define UDP_STATS                       (LWIP_UDP)
-#define TCP_STATS                       (LWIP_TCP)
-#define MEM_STATS                       ((MEM_LIBC_MALLOC == 0) && (MEM_USE_POOLS == 0))
-#define MEMP_STATS                      (MEMP_MEM_MALLOC == 0)
-#define SYS_STATS                       (NO_SYS == 0)
-#define IP6_STATS                       (LWIP_IPV6)
-#define ICMP6_STATS                     (LWIP_IPV6 && LWIP_ICMP6)
-#define IP6_FRAG_STATS                  (LWIP_IPV6 && (LWIP_IPV6_FRAG || LWIP_IPV6_REASS))
-#define MLD6_STATS                      (LWIP_IPV6 && LWIP_IPV6_MLD)
-#define ND6_STATS                       (LWIP_IPV6)
-#define MIB2_STATS                      0
-#define LWIP_CHECKSUM_CTRL_PER_NETIF    0
-#define CHECKSUM_GEN_IP                 1
-#define CHECKSUM_GEN_UDP                1
-#define CHECKSUM_GEN_TCP                1
-#define CHECKSUM_GEN_ICMP               1
-#define CHECKSUM_GEN_ICMP6              1
-#define CHECKSUM_CHECK_IP               1
-#define CHECKSUM_CHECK_UDP              1
-#define CHECKSUM_CHECK_TCP              1
-#define CHECKSUM_CHECK_ICMP             1
-#define CHECKSUM_CHECK_ICMP6            1
-#define LWIP_CHECKSUM_ON_COPY           0
-#define LWIP_IPV6                       0
-#define IPV6_REASS_MAXAGE               60
-#define LWIP_IPV6_SCOPES                (LWIP_IPV6 && !LWIP_SINGLE_NETIF)
-#define LWIP_IPV6_SCOPES_DEBUG          0
-#define LWIP_IPV6_NUM_ADDRESSES         3
-#define LWIP_IPV6_FORWARD               0
-#define LWIP_IPV6_FRAG                  1
-#define LWIP_IPV6_REASS                 (LWIP_IPV6)
-#define LWIP_IPV6_SEND_ROUTER_SOLICIT   1
-#define LWIP_IPV6_AUTOCONFIG            (LWIP_IPV6)
-#define LWIP_IPV6_ADDRESS_LIFETIMES     (LWIP_IPV6_AUTOCONFIG)
-#define LWIP_IPV6_DUP_DETECT_ATTEMPTS   1
-#define LWIP_ICMP6                      (LWIP_IPV6)
-#define LWIP_ICMP6_DATASIZE             8
-#define LWIP_ICMP6_HL                   255
-#define LWIP_IPV6_MLD                   (LWIP_IPV6)
-#define MEMP_NUM_MLD6_GROUP             4
-#define LWIP_ND6_QUEUEING               (LWIP_IPV6)
-#define MEMP_NUM_ND6_QUEUE              20
-#define LWIP_ND6_NUM_NEIGHBORS          10
-#define LWIP_ND6_NUM_DESTINATIONS       10
-#define LWIP_ND6_NUM_PREFIXES           5
-#define LWIP_ND6_NUM_ROUTERS            3
-#define LWIP_ND6_MAX_MULTICAST_SOLICIT  3
-#define LWIP_ND6_MAX_UNICAST_SOLICIT    3
-#define LWIP_ND6_MAX_ANYCAST_DELAY_TIME 1000
-#define LWIP_ND6_MAX_NEIGHBOR_ADVERTISEMENT  3
-#define LWIP_ND6_REACHABLE_TIME         30000
-#define LWIP_ND6_RETRANS_TIMER          1000
-#define LWIP_ND6_DELAY_FIRST_PROBE_TIME 5000
-#define LWIP_ND6_ALLOW_RA_UPDATES       1
-#define LWIP_ND6_TCP_REACHABILITY_HINTS 1
-#define LWIP_ND6_RDNSS_MAX_DNS_SERVERS  0
-#define LWIP_IPV6_DHCP6                 0
-#define LWIP_IPV6_DHCP6_STATEFUL        0
-#define LWIP_IPV6_DHCP6_STATELESS       LWIP_IPV6_DHCP6
-#define LWIP_DHCP6_GET_NTP_SRV          0
-#define LWIP_DHCP6_MAX_NTP_SERVERS      1
-#define LWIP_DHCP6_MAX_DNS_SERVERS      DNS_MAX_SERVERS
-
-/* TODO: check hooks */
-
-#define LWIP_DBG_MIN_LEVEL              LWIP_DBG_LEVEL_ALL
-#define LWIP_DBG_TYPES_ON               LWIP_DBG_ON
-#define ETHARP_DEBUG                    LWIP_DBG_OFF
-#define NETIF_DEBUG                     LWIP_DBG_OFF
-#define PBUF_DEBUG                      LWIP_DBG_OFF
-#define API_LIB_DEBUG                   LWIP_DBG_OFF
-#define API_MSG_DEBUG                   LWIP_DBG_OFF
-#define SOCKETS_DEBUG                   LWIP_DBG_OFF
-#define ICMP_DEBUG                      LWIP_DBG_OFF
-#define IGMP_DEBUG                      LWIP_DBG_OFF
-#define INET_DEBUG                      LWIP_DBG_OFF
-#define IP_DEBUG                        LWIP_DBG_OFF
-#define IP_REASS_DEBUG                  LWIP_DBG_OFF
-#define RAW_DEBUG                       LWIP_DBG_OFF
-#define MEM_DEBUG                       LWIP_DBG_OFF
-#define MEMP_DEBUG                      LWIP_DBG_OFF
-#define SYS_DEBUG                       LWIP_DBG_OFF
-#define TIMERS_DEBUG                    LWIP_DBG_OFF
-#define TCP_DEBUG                       LWIP_DBG_OFF
-#define TCP_INPUT_DEBUG                 LWIP_DBG_OFF
-#define TCP_FR_DEBUG                    LWIP_DBG_OFF
-#define TCP_RTO_DEBUG                   LWIP_DBG_OFF
-#define TCP_CWND_DEBUG                  LWIP_DBG_OFF
-#define TCP_WND_DEBUG                   LWIP_DBG_OFF
-#define TCP_OUTPUT_DEBUG                LWIP_DBG_OFF
-#define TCP_RST_DEBUG                   LWIP_DBG_OFF
-#define TCP_QLEN_DEBUG                  LWIP_DBG_OFF
-#define UDP_DEBUG                       LWIP_DBG_OFF
-#define TCPIP_DEBUG                     LWIP_DBG_OFF
-#define SLIP_DEBUG                      LWIP_DBG_OFF
-#define DHCP_DEBUG                      LWIP_DBG_OFF
-#define AUTOIP_DEBUG                    LWIP_DBG_OFF
-#define DNS_DEBUG                       LWIP_DBG_OFF
-#define IP6_DEBUG                       LWIP_DBG_OFF
-#define DHCP6_DEBUG                     LWIP_DBG_OFF
-#define LWIP_TESTMODE                   0
-
-#define LWIP_PERF                       0
diff --git a/contrib/examples/example_app/test_configs/opt_nosys_ipv6.h b/contrib/examples/example_app/test_configs/opt_nosys_ipv6.h
deleted file mode 100644
index d0273521..00000000
--- a/contrib/examples/example_app/test_configs/opt_nosys_ipv6.h
+++ /dev/null
@@ -1,295 +0,0 @@
-/* test an lwipopts.h file with default contents */
-#define NO_SYS                          0
-#define NO_SYS_NO_TIMERS                0
-#define LWIP_TIMERS                     1
-#define LWIP_TIMERS_CUSTOM              0
-#define LWIP_MPU_COMPATIBLE             0
-#define LWIP_TCPIP_CORE_LOCKING         1
-#define LWIP_TCPIP_CORE_LOCKING_INPUT   0
-#define SYS_LIGHTWEIGHT_PROT            1
-#define MEM_LIBC_MALLOC                 0
-#define MEMP_MEM_MALLOC                 0
-#define MEMP_MEM_INIT                   0
-#define MEM_ALIGNMENT                   1
-#define MEM_SIZE                        1600
-#define MEMP_OVERFLOW_CHECK             0
-#define MEMP_SANITY_CHECK               0
-#define MEM_OVERFLOW_CHECK              0
-#define MEM_SANITY_CHECK                0
-#define MEM_USE_POOLS                   0
-#define MEM_USE_POOLS_TRY_BIGGER_POOL   0
-#define MEMP_USE_CUSTOM_POOLS           0
-#define LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT 0
-/*#define MEMP_NUM_PBUF                   16
-#define MEMP_NUM_RAW_PCB                4
-#define MEMP_NUM_UDP_PCB                4
-#define MEMP_NUM_TCP_PCB                5
-#define MEMP_NUM_TCP_PCB_LISTEN         8
-#define MEMP_NUM_TCP_SEG                16
-#define MEMP_NUM_ALTCP_PCB              MEMP_NUM_TCP_PCB
-#define MEMP_NUM_REASSDATA              5
-#define MEMP_NUM_FRAG_PBUF              15
-#define MEMP_NUM_ARP_QUEUE              30
-#define MEMP_NUM_IGMP_GROUP             8
-#define MEMP_NUM_SYS_TIMEOUT            (LWIP_NUM_SYS_TIMEOUT_INTERNAL + 2)
-#define MEMP_NUM_NETBUF                 2
-#define MEMP_NUM_NETCONN                4
-#define MEMP_NUM_SELECT_CB              4
-#define MEMP_NUM_TCPIP_MSG_API          8
-#define MEMP_NUM_TCPIP_MSG_INPKT        8
-#define MEMP_NUM_NETDB                  1
-#define MEMP_NUM_LOCALHOSTLIST          1
-#define PBUF_POOL_SIZE                  16
-#define MEMP_NUM_API_MSG                MEMP_NUM_TCPIP_MSG_API
-#define MEMP_NUM_DNS_API_MSG            MEMP_NUM_TCPIP_MSG_API
-#define MEMP_NUM_SOCKET_SETGETSOCKOPT_DATA MEMP_NUM_TCPIP_MSG_API
-#define MEMP_NUM_NETIFAPI_MSG           MEMP_NUM_TCPIP_MSG_API*/
-#define LWIP_ARP                        1
-#define ARP_TABLE_SIZE                  10
-#define ARP_MAXAGE                      300
-#define ARP_QUEUEING                    0
-#define ARP_QUEUE_LEN                   3
-#define ETHARP_SUPPORT_VLAN             0
-#define LWIP_ETHERNET                   LWIP_ARP
-#define ETH_PAD_SIZE                    0
-#define ETHARP_SUPPORT_STATIC_ENTRIES   0
-#define ETHARP_TABLE_MATCH_NETIF        !LWIP_SINGLE_NETIF
-#define LWIP_IPV4                       0
-#define IP_FORWARD                      0
-#define IP_REASSEMBLY                   1
-#define IP_FRAG                         1
-#define IP_OPTIONS_ALLOWED              1
-#define IP_REASS_MAXAGE                 15
-#define IP_REASS_MAX_PBUFS              10
-#define IP_DEFAULT_TTL                  255
-#define IP_SOF_BROADCAST                0
-#define IP_SOF_BROADCAST_RECV           0
-#define IP_FORWARD_ALLOW_TX_ON_RX_NETIF 0
-#define LWIP_ICMP                       1
-#define ICMP_TTL                        (IP_DEFAULT_TTL)
-#define LWIP_BROADCAST_PING             0
-#define LWIP_MULTICAST_PING             0
-#define LWIP_RAW                        0
-#define RAW_TTL                         (IP_DEFAULT_TTL)
-#define LWIP_DHCP                       0
-#define LWIP_DHCP_CHECK_LINK_UP         0
-#define LWIP_DHCP_BOOTP_FILE            0
-#define LWIP_DHCP_GET_NTP_SRV           0
-#define LWIP_DHCP_MAX_NTP_SERVERS       1
-#define LWIP_DHCP_MAX_DNS_SERVERS       DNS_MAX_SERVERS
-#define LWIP_AUTOIP                     0
-#define LWIP_DHCP_AUTOIP_COOP           0
-#define LWIP_DHCP_AUTOIP_COOP_TRIES     9
-#define LWIP_MIB2_CALLBACKS             0
-#define LWIP_MULTICAST_TX_OPTIONS       ((LWIP_IGMP || LWIP_IPV6_MLD) && (LWIP_UDP || LWIP_RAW))
-#define LWIP_IGMP                       0
-#define LWIP_DNS                        0
-#define DNS_TABLE_SIZE                  4
-#define DNS_MAX_NAME_LENGTH             256
-#define DNS_MAX_SERVERS                 2
-#define DNS_MAX_RETRIES                 4
-#define DNS_DOES_NAME_CHECK             1
-#define LWIP_DNS_SECURE (LWIP_DNS_SECURE_RAND_XID | LWIP_DNS_SECURE_NO_MULTIPLE_OUTSTANDING | LWIP_DNS_SECURE_RAND_SRC_PORT)
-#define DNS_LOCAL_HOSTLIST              0
-#define DNS_LOCAL_HOSTLIST_IS_DYNAMIC   0
-#define LWIP_DNS_SUPPORT_MDNS_QUERIES   0
-#define LWIP_UDP                        1
-#define LWIP_UDPLITE                    0
-#define UDP_TTL                         (IP_DEFAULT_TTL)
-#define LWIP_NETBUF_RECVINFO            0
-#define LWIP_TCP                        1
-#define TCP_TTL                         (IP_DEFAULT_TTL)
-#define TCP_WND                         (4 * TCP_MSS)
-#define TCP_MAXRTX                      12
-#define TCP_SYNMAXRTX                   6
-#define TCP_QUEUE_OOSEQ                 (LWIP_TCP)
-#define LWIP_TCP_SACK_OUT               0
-#define LWIP_TCP_MAX_SACK_NUM           4
-#define TCP_MSS                         536
-#define TCP_CALCULATE_EFF_SEND_MSS      1
-#define TCP_SND_BUF                     (2 * TCP_MSS)
-#define TCP_SND_QUEUELEN                ((4 * (TCP_SND_BUF) + (TCP_MSS - 1))/(TCP_MSS))
-#define TCP_SNDLOWAT                    LWIP_MIN(LWIP_MAX(((TCP_SND_BUF)/2), (2 * TCP_MSS) + 1), (TCP_SND_BUF) - 1)
-#define TCP_SNDQUEUELOWAT               LWIP_MAX(((TCP_SND_QUEUELEN)/2), 5)
-#define TCP_OOSEQ_MAX_BYTES             0
-#define TCP_OOSEQ_BYTES_LIMIT(pcb)      TCP_OOSEQ_MAX_BYTES
-#define TCP_OOSEQ_MAX_PBUFS             0
-#define TCP_OOSEQ_PBUFS_LIMIT(pcb)      TCP_OOSEQ_MAX_PBUFS
-#define TCP_LISTEN_BACKLOG              0
-#define TCP_DEFAULT_LISTEN_BACKLOG      0xff
-#define TCP_OVERSIZE                    TCP_MSS
-#define LWIP_TCP_TIMESTAMPS             0
-#define TCP_WND_UPDATE_THRESHOLD        LWIP_MIN((TCP_WND / 4), (TCP_MSS * 4))
-#define LWIP_EVENT_API                  0
-#define LWIP_CALLBACK_API               1
-#define LWIP_WND_SCALE                  0
-#define TCP_RCV_SCALE                   0
-#define LWIP_TCP_PCB_NUM_EXT_ARGS       0
-#define LWIP_ALTCP                      0
-#define LWIP_ALTCP_TLS                  0
-#define PBUF_LINK_HLEN                  (14 + ETH_PAD_SIZE)
-#define PBUF_LINK_ENCAPSULATION_HLEN    0
-#define PBUF_POOL_BUFSIZE               LWIP_MEM_ALIGN_SIZE(TCP_MSS+40+PBUF_LINK_ENCAPSULATION_HLEN+PBUF_LINK_HLEN)
-#define LWIP_PBUF_REF_T                 u8_t
-#define LWIP_SINGLE_NETIF               0
-#define LWIP_NETIF_HOSTNAME             0
-#define LWIP_NETIF_API                  0
-#define LWIP_NETIF_STATUS_CALLBACK      0
-#define LWIP_NETIF_EXT_STATUS_CALLBACK  0
-#define LWIP_NETIF_LINK_CALLBACK        0
-#define LWIP_NETIF_REMOVE_CALLBACK      0
-#define LWIP_NETIF_HWADDRHINT           0
-#define LWIP_NETIF_TX_SINGLE_PBUF       0
-#define LWIP_NUM_NETIF_CLIENT_DATA      0
-#define LWIP_HAVE_LOOPIF                (LWIP_NETIF_LOOPBACK && !LWIP_SINGLE_NETIF)
-#define LWIP_LOOPIF_MULTICAST           0
-#define LWIP_NETIF_LOOPBACK             0
-#define LWIP_LOOPBACK_MAX_PBUFS         0
-#define LWIP_NETIF_LOOPBACK_MULTITHREADING    (!NO_SYS)
-/*#define TCPIP_THREAD_NAME               "tcpip_thread"
-#define TCPIP_THREAD_STACKSIZE          0
-#define TCPIP_THREAD_PRIO               1
-#define TCPIP_MBOX_SIZE                 0
-#define LWIP_TCPIP_THREAD_ALIVE()
-#define SLIPIF_THREAD_NAME              "slipif_loop"
-#define SLIPIF_THREAD_STACKSIZE         0
-#define SLIPIF_THREAD_PRIO              1
-#define DEFAULT_THREAD_NAME             "lwIP"
-#define DEFAULT_THREAD_STACKSIZE        0
-#define DEFAULT_THREAD_PRIO             1
-#define DEFAULT_RAW_RECVMBOX_SIZE       0
-#define DEFAULT_UDP_RECVMBOX_SIZE       0
-#define DEFAULT_TCP_RECVMBOX_SIZE       0
-#define DEFAULT_ACCEPTMBOX_SIZE         0*/
-#define LWIP_NETCONN                    0
-#define LWIP_TCPIP_TIMEOUT              0
-#define LWIP_NETCONN_SEM_PER_THREAD     0
-#define LWIP_NETCONN_FULLDUPLEX         0
-#define LWIP_SOCKET                     0
-#define LWIP_COMPAT_SOCKETS             1 /* 0..2 */
-#define LWIP_POSIX_SOCKETS_IO_NAMES     1
-#define LWIP_SOCKET_OFFSET              0
-#define LWIP_TCP_KEEPALIVE              0
-#define LWIP_SO_SNDTIMEO                0
-#define LWIP_SO_RCVTIMEO                0
-#define LWIP_SO_SNDRCVTIMEO_NONSTANDARD 0
-#define LWIP_SO_RCVBUF                  0
-#define LWIP_SO_LINGER                  0
-#define RECV_BUFSIZE_DEFAULT            INT_MAX
-#define LWIP_TCP_CLOSE_TIMEOUT_MS_DEFAULT 20000
-#define SO_REUSE                        0
-#define SO_REUSE_RXTOALL                0
-#define LWIP_FIONREAD_LINUXMODE         0
-#define LWIP_SOCKET_SELECT              1
-#define LWIP_SOCKET_POLL                1
-#define LWIP_STATS                      1
-#define LWIP_STATS_DISPLAY              0
-#define LINK_STATS                      1
-#define ETHARP_STATS                    (LWIP_ARP)
-#define IP_STATS                        1
-#define IPFRAG_STATS                    (IP_REASSEMBLY || IP_FRAG)
-#define ICMP_STATS                      1
-#define IGMP_STATS                      (LWIP_IGMP)
-#define UDP_STATS                       (LWIP_UDP)
-#define TCP_STATS                       (LWIP_TCP)
-#define MEM_STATS                       ((MEM_LIBC_MALLOC == 0) && (MEM_USE_POOLS == 0))
-#define MEMP_STATS                      (MEMP_MEM_MALLOC == 0)
-#define SYS_STATS                       (NO_SYS == 0)
-#define IP6_STATS                       (LWIP_IPV6)
-#define ICMP6_STATS                     (LWIP_IPV6 && LWIP_ICMP6)
-#define IP6_FRAG_STATS                  (LWIP_IPV6 && (LWIP_IPV6_FRAG || LWIP_IPV6_REASS))
-#define MLD6_STATS                      (LWIP_IPV6 && LWIP_IPV6_MLD)
-#define ND6_STATS                       (LWIP_IPV6)
-#define MIB2_STATS                      0
-#define LWIP_CHECKSUM_CTRL_PER_NETIF    0
-#define CHECKSUM_GEN_IP                 1
-#define CHECKSUM_GEN_UDP                1
-#define CHECKSUM_GEN_TCP                1
-#define CHECKSUM_GEN_ICMP               1
-#define CHECKSUM_GEN_ICMP6              1
-#define CHECKSUM_CHECK_IP               1
-#define CHECKSUM_CHECK_UDP              1
-#define CHECKSUM_CHECK_TCP              1
-#define CHECKSUM_CHECK_ICMP             1
-#define CHECKSUM_CHECK_ICMP6            1
-#define LWIP_CHECKSUM_ON_COPY           0
-#define LWIP_IPV6                       1
-#define IPV6_REASS_MAXAGE               60
-#define LWIP_IPV6_SCOPES                (LWIP_IPV6 && !LWIP_SINGLE_NETIF)
-#define LWIP_IPV6_SCOPES_DEBUG          0
-#define LWIP_IPV6_NUM_ADDRESSES         3
-#define LWIP_IPV6_FORWARD               0
-#define LWIP_IPV6_FRAG                  1
-#define LWIP_IPV6_REASS                 (LWIP_IPV6)
-#define LWIP_IPV6_SEND_ROUTER_SOLICIT   1
-#define LWIP_IPV6_AUTOCONFIG            (LWIP_IPV6)
-#define LWIP_IPV6_ADDRESS_LIFETIMES     (LWIP_IPV6_AUTOCONFIG)
-#define LWIP_IPV6_DUP_DETECT_ATTEMPTS   1
-#define LWIP_ICMP6                      (LWIP_IPV6)
-#define LWIP_ICMP6_DATASIZE             8
-#define LWIP_ICMP6_HL                   255
-#define LWIP_IPV6_MLD                   (LWIP_IPV6)
-#define MEMP_NUM_MLD6_GROUP             4
-#define LWIP_ND6_QUEUEING               (LWIP_IPV6)
-#define MEMP_NUM_ND6_QUEUE              20
-#define LWIP_ND6_NUM_NEIGHBORS          10
-#define LWIP_ND6_NUM_DESTINATIONS       10
-#define LWIP_ND6_NUM_PREFIXES           5
-#define LWIP_ND6_NUM_ROUTERS            3
-#define LWIP_ND6_MAX_MULTICAST_SOLICIT  3
-#define LWIP_ND6_MAX_UNICAST_SOLICIT    3
-#define LWIP_ND6_MAX_ANYCAST_DELAY_TIME 1000
-#define LWIP_ND6_MAX_NEIGHBOR_ADVERTISEMENT  3
-#define LWIP_ND6_REACHABLE_TIME         30000
-#define LWIP_ND6_RETRANS_TIMER          1000
-#define LWIP_ND6_DELAY_FIRST_PROBE_TIME 5000
-#define LWIP_ND6_ALLOW_RA_UPDATES       1
-#define LWIP_ND6_TCP_REACHABILITY_HINTS 1
-#define LWIP_ND6_RDNSS_MAX_DNS_SERVERS  0
-#define LWIP_IPV6_DHCP6                 0
-#define LWIP_IPV6_DHCP6_STATEFUL        0
-#define LWIP_IPV6_DHCP6_STATELESS       LWIP_IPV6_DHCP6
-#define LWIP_DHCP6_GET_NTP_SRV          0
-#define LWIP_DHCP6_MAX_NTP_SERVERS      1
-#define LWIP_DHCP6_MAX_DNS_SERVERS      DNS_MAX_SERVERS
-
-/* TODO: check hooks */
-
-#define LWIP_DBG_MIN_LEVEL              LWIP_DBG_LEVEL_ALL
-#define LWIP_DBG_TYPES_ON               LWIP_DBG_ON
-#define ETHARP_DEBUG                    LWIP_DBG_OFF
-#define NETIF_DEBUG                     LWIP_DBG_OFF
-#define PBUF_DEBUG                      LWIP_DBG_OFF
-#define API_LIB_DEBUG                   LWIP_DBG_OFF
-#define API_MSG_DEBUG                   LWIP_DBG_OFF
-#define SOCKETS_DEBUG                   LWIP_DBG_OFF
-#define ICMP_DEBUG                      LWIP_DBG_OFF
-#define IGMP_DEBUG                      LWIP_DBG_OFF
-#define INET_DEBUG                      LWIP_DBG_OFF
-#define IP_DEBUG                        LWIP_DBG_OFF
-#define IP_REASS_DEBUG                  LWIP_DBG_OFF
-#define RAW_DEBUG                       LWIP_DBG_OFF
-#define MEM_DEBUG                       LWIP_DBG_OFF
-#define MEMP_DEBUG                      LWIP_DBG_OFF
-#define SYS_DEBUG                       LWIP_DBG_OFF
-#define TIMERS_DEBUG                    LWIP_DBG_OFF
-#define TCP_DEBUG                       LWIP_DBG_OFF
-#define TCP_INPUT_DEBUG                 LWIP_DBG_OFF
-#define TCP_FR_DEBUG                    LWIP_DBG_OFF
-#define TCP_RTO_DEBUG                   LWIP_DBG_OFF
-#define TCP_CWND_DEBUG                  LWIP_DBG_OFF
-#define TCP_WND_DEBUG                   LWIP_DBG_OFF
-#define TCP_OUTPUT_DEBUG                LWIP_DBG_OFF
-#define TCP_RST_DEBUG                   LWIP_DBG_OFF
-#define TCP_QLEN_DEBUG                  LWIP_DBG_OFF
-#define UDP_DEBUG                       LWIP_DBG_OFF
-#define TCPIP_DEBUG                     LWIP_DBG_OFF
-#define SLIP_DEBUG                      LWIP_DBG_OFF
-#define DHCP_DEBUG                      LWIP_DBG_OFF
-#define AUTOIP_DEBUG                    LWIP_DBG_OFF
-#define DNS_DEBUG                       LWIP_DBG_OFF
-#define IP6_DEBUG                       LWIP_DBG_OFF
-#define DHCP6_DEBUG                     LWIP_DBG_OFF
-#define LWIP_TESTMODE                   0
-
-#define LWIP_PERF                       0
diff --git a/contrib/examples/httpd/cgi_example/cgi_example.c b/contrib/examples/httpd/cgi_example/cgi_example.c
deleted file mode 100644
index c9c74763..00000000
--- a/contrib/examples/httpd/cgi_example/cgi_example.c
+++ /dev/null
@@ -1,107 +0,0 @@
-/**
- * @file
- * HTTPD simple CGI example
- *
- * This file demonstrates how to add support for basic CGI.
- */
- 
- /*
- * Copyright (c) 2017 Simon Goldschmidt
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Simon Goldschmidt <goldsimon@gmx.de>
- *
- */
-
-#include "lwip/opt.h"
-#include "cgi_example.h"
-
-#include "lwip/apps/httpd.h"
-
-#include "lwip/def.h"
-#include "lwip/mem.h"
-
-#include <stdio.h>
-#include <string.h>
-
-/** define LWIP_HTTPD_EXAMPLE_CGI_SIMPLE to 1 to enable this cgi example */
-#ifndef LWIP_HTTPD_EXAMPLE_CGI_SIMPLE
-#define LWIP_HTTPD_EXAMPLE_CGI_SIMPLE 0
-#endif
-
-#if LWIP_HTTPD_EXAMPLE_CGI_SIMPLE
-
-#if !LWIP_HTTPD_CGI
-#error LWIP_HTTPD_EXAMPLE_CGI_SIMPLE needs LWIP_HTTPD_CGI
-#endif
-
-static const char *cgi_handler_basic(int iIndex, int iNumParams, char *pcParam[], char *pcValue[]);
-
-static const tCGI cgi_handlers[] = {
-  {
-    "/basic_cgi",
-    cgi_handler_basic
-  },
-  {
-    "/basic_cgi_2",
-    cgi_handler_basic
-  }
-};
-
-void
-cgi_ex_init(void)
-{
-  http_set_cgi_handlers(cgi_handlers, LWIP_ARRAYSIZE(cgi_handlers));
-}
-
-/** This basic CGI function can parse param/value pairs and return an url that
- * is sent as a response by httpd.
- *
- * This example function just checks that the input url has two key value
- * parameter pairs: "foo=bar" and "test=123"
- * If not, it returns 404
- */
-static const char *
-cgi_handler_basic(int iIndex, int iNumParams, char *pcParam[], char *pcValue[])
-{
-  LWIP_ASSERT("check index", iIndex < LWIP_ARRAYSIZE(cgi_handlers));
-
-  if (iNumParams == 2) {
-    if (!strcmp(pcParam[0], "foo")) {
-      if (!strcmp(pcValue[0], "bar")) {
-        if (!strcmp(pcParam[1], "test")) {
-          if (!strcmp(pcValue[1], "123")) {
-            return "/index.html";
-          }
-        }
-      }
-    }
-  }
-  return "/404.html";
-}
-
-#endif /* LWIP_HTTPD_EXAMPLE_CGI_SIMPLE */
diff --git a/contrib/examples/httpd/cgi_example/cgi_example.h b/contrib/examples/httpd/cgi_example/cgi_example.h
deleted file mode 100644
index b655661b..00000000
--- a/contrib/examples/httpd/cgi_example/cgi_example.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (c) 2017 Simon Goldschmidt
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Simon Goldschmidt <goldsimon@gmx.de>
- *
- */
-
-#ifndef LWIP_HDR_HTTP_EXAMPLES_CGI_EXAMPLE
-#define LWIP_HDR_HTTP_EXAMPLES_CGI_EXAMPLE
-
-void cgi_ex_init(void);
-
-#endif /* LWIP_HDR_HTTP_EXAMPLES_CGI_EXAMPLE */
diff --git a/contrib/examples/httpd/examples_fs/404.html b/contrib/examples/httpd/examples_fs/404.html
deleted file mode 100644
index 40b343a9..00000000
--- a/contrib/examples/httpd/examples_fs/404.html
+++ /dev/null
@@ -1,21 +0,0 @@
-<html>
-<head><title>lwIP - A Lightweight TCP/IP Stack</title></head>
-<body bgcolor="white" text="black">
-
-    <table width="100%">
-      <tr valign="top"><td width="80">	  
-	  <a href="http://www.sics.se/"><img src="/img/sics.gif"
-	  border="0" alt="SICS logo" title="SICS logo"></a>
-	</td><td width="500">	  
-	  <h1>lwIP - A Lightweight TCP/IP Stack</h1>
-	  <h2>404 - Page not found</h2>
-	  <p>
-	    Sorry, the page you are requesting was not found on this
-	    server. 
-	  </p>
-	</td><td>
-	  &nbsp;
-	</td></tr>
-      </table>
-</body>
-</html>
diff --git a/contrib/examples/httpd/examples_fs/img/sics.gif b/contrib/examples/httpd/examples_fs/img/sics.gif
deleted file mode 100644
index 0a4fc7bb..00000000
Binary files a/contrib/examples/httpd/examples_fs/img/sics.gif and /dev/null differ
diff --git a/contrib/examples/httpd/examples_fs/index.html b/contrib/examples/httpd/examples_fs/index.html
deleted file mode 100644
index ab575ef0..00000000
--- a/contrib/examples/httpd/examples_fs/index.html
+++ /dev/null
@@ -1,47 +0,0 @@
-<html>
-<head><title>lwIP - A Lightweight TCP/IP Stack</title></head>
-<body bgcolor="white" text="black">
-
-    <table width="100%">
-      <tr valign="top"><td width="80">	  
-	  <a href="http://www.sics.se/"><img src="/img/sics.gif"
-	  border="0" alt="SICS logo" title="SICS logo"></a>
-	</td><td width="500">	  
-	  <h1>lwIP - A Lightweight TCP/IP Stack</h1>
-	  <p>
-	    The web page you are watching was served by a simple web
-	    server running on top of the lightweight TCP/IP stack <a
-	    href="http://www.sics.se/~adam/lwip/">lwIP</a>.
-	  </p>
-	  <p>
-	    lwIP is an open source implementation of the TCP/IP
-	    protocol suite that was originally written by <a
-	    href="http://www.sics.se/~adam/lwip/">Adam Dunkels
-	    of the Swedish Institute of Computer Science</a> but now is
-	    being actively developed by a team of developers
-	    distributed world-wide. Since it's release, lwIP has
-	    spurred a lot of interest and has been ported to several
-	    platforms and operating systems. lwIP can be used either
-	    with or without an underlying OS.
-	  </p>
-	  <p>
-	    The focus of the lwIP TCP/IP implementation is to reduce
-	    the RAM usage while still having a full scale TCP. This
-	    makes lwIP suitable for use in embedded systems with tens
-	    of kilobytes of free RAM and room for around 40 kilobytes
-	    of code ROM.
-	  </p>
-	  <p>
-	    More information about lwIP can be found at the lwIP
-	    homepage at <a
-	    href="http://savannah.nongnu.org/projects/lwip/">http://savannah.nongnu.org/projects/lwip/</a>
-	    or at the lwIP wiki at <a
-	    href="http://lwip.wikia.com/">http://lwip.wikia.com/</a>.
-	  </p>
-	</td><td>
-	  &nbsp;
-	</td></tr>
-      </table>
-</body>
-</html>
-
diff --git a/contrib/examples/httpd/examples_fs/login.html b/contrib/examples/httpd/examples_fs/login.html
deleted file mode 100644
index 71c535b4..00000000
--- a/contrib/examples/httpd/examples_fs/login.html
+++ /dev/null
@@ -1,28 +0,0 @@
-<html>
-<head><title>lwIP - A Lightweight TCP/IP Stack</title></head>
-<body bgcolor="white" text="black">
-
-<table width="100%">
- <tr valign="top">
-  <td width="80">
-   <a href="http://www.sics.se/"><img src="/img/sics.gif" border="0" alt="SICS logo" title="SICS logo"/></a>
-  </td>
-  <td width="500">
-   <h1>Login</h1>
-   <form name="login" action="login.cgi" method="post">
-    <div>
-     <label><b>Username</b></label>
-     <input type="text" placeholder="Enter Username" name="user" required>
-     <label><b>Password</b></label>
-     <input type="password" placeholder="Enter Password" name="pass" required>
-     <button type="submit">Login</button>
-    </div>
-   </form> 
-  </td>
-  <td>
-   &nbsp;
-  </td>
- </tr>
-</table>
-</body>
-</html>
diff --git a/contrib/examples/httpd/examples_fs/loginfail.html b/contrib/examples/httpd/examples_fs/loginfail.html
deleted file mode 100644
index 6d5c742b..00000000
--- a/contrib/examples/httpd/examples_fs/loginfail.html
+++ /dev/null
@@ -1,25 +0,0 @@
-<html>
-<head><title>lwIP - A Lightweight TCP/IP Stack</title></head>
-<body bgcolor="white" text="black">
-
- <table width="100%">
-  <tr valign="top">
-   <td width="80">
-    <a href="http://www.sics.se/"><img src="/img/sics.gif" border="0" alt="SICS logo" title="SICS logo"/></a>
-   </td>
-   <td width="500">
-    <h1>lwIP - A Lightweight TCP/IP Stack</h1>
-    <p>
-     Login failed.
-    </p>
-    <p>
-     Click <a href="login.html">here</a> to retry login.
-    </p>
-   </td>
-   <td>
-    &nbsp;
-   </td>
-  </tr>
- </table>
-</body>
-</html>
diff --git a/contrib/examples/httpd/examples_fs/session.html b/contrib/examples/httpd/examples_fs/session.html
deleted file mode 100644
index 72d3bff9..00000000
--- a/contrib/examples/httpd/examples_fs/session.html
+++ /dev/null
@@ -1,25 +0,0 @@
-<html>
-<head><title>lwIP - A Lightweight TCP/IP Stack</title></head>
-<body bgcolor="white" text="black">
-
- <table width="100%">
-  <tr valign="top">
-   <td width="80">
-    <a href="http://www.sics.se/"><img src="/img/sics.gif" border="0" alt="SICS logo" title="SICS logo"/></a>
-   </td>
-   <td width="500">
-    <h1>lwIP - A Lightweight TCP/IP Stack</h1>
-    <p>
-     Login succeeded, session active.
-    </p>
-    <p>
-     Click <a href="login.html">here</a> to retry login.
-    </p>
-   </td>
-   <td>
-    &nbsp;
-   </td>
-  </tr>
- </table>
-</body>
-</html>
diff --git a/contrib/examples/httpd/examples_fs/ssi.shtml b/contrib/examples/httpd/examples_fs/ssi.shtml
deleted file mode 100644
index 153d0167..00000000
--- a/contrib/examples/httpd/examples_fs/ssi.shtml
+++ /dev/null
@@ -1,315 +0,0 @@
-<html>
-<head><title>lwIP - A Lightweight TCP/IP Stack</title></head>
-<body bgcolor="white" text="black">
-
-    <table width="100%">
-      <tr valign="top"><td width="80">	  
-	  <a href="http://www.sics.se/"><img src="/img/sics.gif"
-	  border="0" alt="SICS logo" title="SICS logo"></a>
-	</td><td width="500">	  
-	  <h1>lwIP - A Lightweight TCP/IP Stack</h1>
-	  <h1><!--#HellWorl--></h1>
-	  <p>
-	    The web page you are watching was served by a simple web
-	    server running on top of the lightweight TCP/IP stack <a
-	    href="http://www.sics.se/~adam/lwip/">lwIP</a>.
-	  </p>
-	  <p>
-	    This page is here to test SSI, so here is a counter as
-	    an example of content changing for every request:
-	    "<!--#counter-->"
-	  </p>
-	  <p>
-	    And here is an example of a tag result buffer return in
-	    multiple parts: "<!--#MultPart-->"
-	  </p>
-	  <p>
-	    To test LWIP_HTTPD_CGI_SSI, here are the CGI parameters:
-	    <!--#CgiParam-->
-	  </p>
-	  <p>
-	    lwIP is an open source implementation of the TCP/IP
-	    protocol suite that was originally written by <a
-	    href="http://www.sics.se/~adam/lwip/">Adam Dunkels
-	    of the Swedish Institute of Computer Science</a> but now is
-	    being actively developed by a team of developers
-	    distributed world-wide. Since it's release, lwIP has
-	    spurred a lot of interest and has been ported to several
-	    platforms and operating systems. lwIP can be used either
-	    with or without an underlying OS.
-	  </p>
-	  <p>
-	  <p>
-	    lwIP is an open source implementation of the TCP/IP
-	    protocol suite that was originally written by <a
-	    href="http://www.sics.se/~adam/lwip/">Adam Dunkels
-	    of the Swedish Institute of Computer Science</a> but now is
-	    being actively developed by a team of developers
-	    distributed world-wide. Since it's release, lwIP has
-	    spurred a lot of interest and has been ported to several
-	    platforms and operating systems. lwIP can be used either
-	    with or without an underlying OS.
-	  </p>
-	  <p>
-	    lwIP is an open source implementation of the TCP/IP
-	    protocol suite that was originally written by <a
-	    href="http://www.sics.se/~adam/lwip/">Adam Dunkels
-	    of the Swedish Institute of Computer Science</a> but now is
-	    being actively developed by a team of developers
-	    distributed world-wide. Since it's release, lwIP has
-	    spurred a lot of interest and has been ported to several
-	    platforms and operating systems. lwIP can be used either
-	    with or without an underlying OS.
-	  </p>
-	  <p>
-	    lwIP is an open source implementation of the TCP/IP
-	    protocol suite that was originally written by <a
-	    href="http://www.sics.se/~adam/lwip/">Adam Dunkels
-	    of the Swedish Institute of Computer Science</a> but now is
-	    being actively developed by a team of developers
-	    distributed world-wide. Since it's release, lwIP has
-	    spurred a lot of interest and has been ported to several
-	    platforms and operating systems. lwIP can be used either
-	    with or without an underlying OS.
-	  </p>
-	  <p>
-	    lwIP is an open source implementation of the TCP/IP
-	    protocol suite that was originally written by <a
-	    href="http://www.sics.se/~adam/lwip/">Adam Dunkels
-	    of the Swedish Institute of Computer Science</a> but now is
-	    being actively developed by a team of developers
-	    distributed world-wide. Since it's release, lwIP has
-	    spurred a lot of interest and has been ported to several
-	    platforms and operating systems. lwIP can be used either
-	    with or without an underlying OS.
-	  </p>
-	  <p>
-	    lwIP is an open source implementation of the TCP/IP
-	    protocol suite that was originally written by <a
-	    href="http://www.sics.se/~adam/lwip/">Adam Dunkels
-	    of the Swedish Institute of Computer Science</a> but now is
-	    being actively developed by a team of developers
-	    distributed world-wide. Since it's release, lwIP has
-	    spurred a lot of interest and has been ported to several
-	    platforms and operating systems. lwIP can be used either
-	    with or without an underlying OS.
-	  </p>
-	  <p>
-	    lwIP is an open source implementation of the TCP/IP
-	    protocol suite that was originally written by <a
-	    href="http://www.sics.se/~adam/lwip/">Adam Dunkels
-	    of the Swedish Institute of Computer Science</a> but now is
-	    being actively developed by a team of developers
-	    distributed world-wide. Since it's release, lwIP has
-	    spurred a lot of interest and has been ported to several
-	    platforms and operating systems. lwIP can be used either
-	    with or without an underlying OS.
-	  </p>
-	  <p>
-	    lwIP is an open source implementation of the TCP/IP
-	    protocol suite that was originally written by <a
-	    href="http://www.sics.se/~adam/lwip/">Adam Dunkels
-	    of the Swedish Institute of Computer Science</a> but now is
-	    being actively developed by a team of developers
-	    distributed world-wide. Since it's release, lwIP has
-	    spurred a lot of interest and has been ported to several
-	    platforms and operating systems. lwIP can be used either
-	    with or without an underlying OS.
-	  </p>
-	  <p>
-	    lwIP is an open source implementation of the TCP/IP
-	    protocol suite that was originally written by <a
-	    href="http://www.sics.se/~adam/lwip/">Adam Dunkels
-	    of the Swedish Institute of Computer Science</a> but now is
-	    being actively developed by a team of developers
-	    distributed world-wide. Since it's release, lwIP has
-	    spurred a lot of interest and has been ported to several
-	    platforms and operating systems. lwIP can be used either
-	    with or without an underlying OS.
-	  </p>
-	  <p>
-	    lwIP is an open source implementation of the TCP/IP
-	    protocol suite that was originally written by <a
-	    href="http://www.sics.se/~adam/lwip/">Adam Dunkels
-	    of the Swedish Institute of Computer Science</a> but now is
-	    being actively developed by a team of developers
-	    distributed world-wide. Since it's release, lwIP has
-	    spurred a lot of interest and has been ported to several
-	    platforms and operating systems. lwIP can be used either
-	    with or without an underlying OS.
-	  </p>
-	  <p>
-	    lwIP is an open source implementation of the TCP/IP
-	    protocol suite that was originally written by <a
-	    href="http://www.sics.se/~adam/lwip/">Adam Dunkels
-	    of the Swedish Institute of Computer Science</a> but now is
-	    being actively developed by a team of developers
-	    distributed world-wide. Since it's release, lwIP has
-	    spurred a lot of interest and has been ported to several
-	    platforms and operating systems. lwIP can be used either
-	    with or without an underlying OS.
-	  </p>
-	  <p>
-	    lwIP is an open source implementation of the TCP/IP
-	    protocol suite that was originally written by <a
-	    href="http://www.sics.se/~adam/lwip/">Adam Dunkels
-	    of the Swedish Institute of Computer Science</a> but now is
-	    being actively developed by a team of developers
-	    distributed world-wide. Since it's release, lwIP has
-	    spurred a lot of interest and has been ported to several
-	    platforms and operating systems. lwIP can be used either
-	    with or without an underlying OS.
-	  </p>
-	  <p>
-	    lwIP is an open source implementation of the TCP/IP
-	    protocol suite that was originally written by <a
-	    href="http://www.sics.se/~adam/lwip/">Adam Dunkels
-	    of the Swedish Institute of Computer Science</a> but now is
-	    being actively developed by a team of developers
-	    distributed world-wide. Since it's release, lwIP has
-	    spurred a lot of interest and has been ported to several
-	    platforms and operating systems. lwIP can be used either
-	    with or without an underlying OS.
-	  </p>
-	  <p>
-	    lwIP is an open source implementation of the TCP/IP
-	    protocol suite that was originally written by <a
-	    href="http://www.sics.se/~adam/lwip/">Adam Dunkels
-	    of the Swedish Institute of Computer Science</a> but now is
-	    being actively developed by a team of developers
-	    distributed world-wide. Since it's release, lwIP has
-	    spurred a lot of interest and has been ported to several
-	    platforms and operating systems. lwIP can be used either
-	    with or without an underlying OS.
-	  </p>
-	  <p>
-	    lwIP is an open source implementation of the TCP/IP
-	    protocol suite that was originally written by <a
-	    href="http://www.sics.se/~adam/lwip/">Adam Dunkels
-	    of the Swedish Institute of Computer Science</a> but now is
-	    being actively developed by a team of developers
-	    distributed world-wide. Since it's release, lwIP has
-	    spurred a lot of interest and has been ported to several
-	    platforms and operating systems. lwIP can be used either
-	    with or without an underlying OS.
-	  </p>
-	  <p>
-	    lwIP is an open source implementation of the TCP/IP
-	    protocol suite that was originally written by <a
-	    href="http://www.sics.se/~adam/lwip/">Adam Dunkels
-	    of the Swedish Institute of Computer Science</a> but now is
-	    being actively developed by a team of developers
-	    distributed world-wide. Since it's release, lwIP has
-	    spurred a lot of interest and has been ported to several
-	    platforms and operating systems. lwIP can be used either
-	    with or without an underlying OS.
-	  </p>
-	  <p>
-	    lwIP is an open source implementation of the TCP/IP
-	    protocol suite that was originally written by <a
-	    href="http://www.sics.se/~adam/lwip/">Adam Dunkels
-	    of the Swedish Institute of Computer Science</a> but now is
-	    being actively developed by a team of developers
-	    distributed world-wide. Since it's release, lwIP has
-	    spurred a lot of interest and has been ported to several
-	    platforms and operating systems. lwIP can be used either
-	    with or without an underlying OS.
-	  </p>
-	  <p>
-	    lwIP is an open source implementation of the TCP/IP
-	    protocol suite that was originally written by <a
-	    href="http://www.sics.se/~adam/lwip/">Adam Dunkels
-	    of the Swedish Institute of Computer Science</a> but now is
-	    being actively developed by a team of developers
-	    distributed world-wide. Since it's release, lwIP has
-	    spurred a lot of interest and has been ported to several
-	    platforms and operating systems. lwIP can be used either
-	    with or without an underlying OS.
-	  </p>
-	  <p>
-	    lwIP is an open source implementation of the TCP/IP
-	    protocol suite that was originally written by <a
-	    href="http://www.sics.se/~adam/lwip/">Adam Dunkels
-	    of the Swedish Institute of Computer Science</a> but now is
-	    being actively developed by a team of developers
-	    distributed world-wide. Since it's release, lwIP has
-	    spurred a lot of interest and has been ported to several
-	    platforms and operating systems. lwIP can be used either
-	    with or without an underlying OS.
-	  </p>
-	  <p>
-	    lwIP is an open source implementation of the TCP/IP
-	    protocol suite that was originally written by <a
-	    href="http://www.sics.se/~adam/lwip/">Adam Dunkels
-	    of the Swedish Institute of Computer Science</a> but now is
-	    being actively developed by a team of developers
-	    distributed world-wide. Since it's release, lwIP has
-	    spurred a lot of interest and has been ported to several
-	    platforms and operating systems. lwIP can be used either
-	    with or without an underlying OS.
-	  </p>
-	  <p>
-	    lwIP is an open source implementation of the TCP/IP
-	    protocol suite that was originally written by <a
-	    href="http://www.sics.se/~adam/lwip/">Adam Dunkels
-	    of the Swedish Institute of Computer Science</a> but now is
-	    being actively developed by a team of developers
-	    distributed world-wide. Since it's release, lwIP has
-	    spurred a lot of interest and has been ported to several
-	    platforms and operating systems. lwIP can be used either
-	    with or without an underlying OS.
-	  </p>
-	  <p>
-	    lwIP is an open source implementation of the TCP/IP
-	    protocol suite that was originally written by <a
-	    href="http://www.sics.se/~adam/lwip/">Adam Dunkels
-	    of the Swedish Institute of Computer Science</a> but now is
-	    being actively developed by a team of developers
-	    distributed world-wide. Since it's release, lwIP has
-	    spurred a lot of interest and has been ported to several
-	    platforms and operating systems. lwIP can be used either
-	    with or without an underlying OS.
-	  </p>
-	  <p>
-	    lwIP is an open source implementation of the TCP/IP
-	    protocol suite that was originally written by <a
-	    href="http://www.sics.se/~adam/lwip/">Adam Dunkels
-	    of the Swedish Institute of Computer Science</a> but now is
-	    being actively developed by a team of developers
-	    distributed world-wide. Since it's release, lwIP has
-	    spurred a lot of interest and has been ported to several
-	    platforms and operating systems. lwIP can be used either
-	    with or without an underlying OS.
-	  </p>
-	  <p>
-	    lwIP is an open source implementation of the TCP/IP
-	    protocol suite that was originally written by <a
-	    href="http://www.sics.se/~adam/lwip/">Adam Dunkels
-	    of the Swedish Institute of Computer Science</a> but now is
-	    being actively developed by a team of developers
-	    distributed world-wide. Since it's release, lwIP has
-	    spurred a lot of interest and has been ported to several
-	    platforms and operating systems. lwIP can be used either
-	    with or without an underlying OS.
-	  </p>
-	  <p>
-	    The focus of the lwIP TCP/IP implementation is to reduce
-	    the RAM usage while still having a full scale TCP. This
-	    makes lwIP suitable for use in embedded systems with tens
-	    of kilobytes of free RAM and room for around 40 kilobytes
-	    of code ROM.
-	  </p>
-	  <p>
-	    More information about lwIP can be found at the lwIP
-	    homepage at <a
-	    href="http://savannah.nongnu.org/projects/lwip/">http://savannah.nongnu.org/projects/lwip/</a>
-	    or at the lwIP wiki at <a
-	    href="http://lwip.wikia.com/">http://lwip.wikia.com/</a>.
-	  </p>
-	</td><td>
-	  &nbsp;
-	</td></tr>
-      </table>
-</body>
-</html>
-
diff --git a/contrib/examples/httpd/examples_fsdata.c b/contrib/examples/httpd/examples_fsdata.c
deleted file mode 100644
index 7eed926a..00000000
--- a/contrib/examples/httpd/examples_fsdata.c
+++ /dev/null
@@ -1,1543 +0,0 @@
-#include "lwip/apps/fs.h"
-#include "lwip/def.h"
-
-
-#define file_NULL (struct fsdata_file *) NULL
-
-
-#ifndef FS_FILE_FLAGS_HEADER_INCLUDED
-#define FS_FILE_FLAGS_HEADER_INCLUDED 1
-#endif
-#ifndef FS_FILE_FLAGS_HEADER_PERSISTENT
-#define FS_FILE_FLAGS_HEADER_PERSISTENT 0
-#endif
-/* FSDATA_FILE_ALIGNMENT: 0=off, 1=by variable, 2=by include */
-#ifndef FSDATA_FILE_ALIGNMENT
-#define FSDATA_FILE_ALIGNMENT 0
-#endif
-#ifndef FSDATA_ALIGN_PRE
-#define FSDATA_ALIGN_PRE
-#endif
-#ifndef FSDATA_ALIGN_POST
-#define FSDATA_ALIGN_POST
-#endif
-#if FSDATA_FILE_ALIGNMENT==2
-#include "fsdata_alignment.h"
-#endif
-#if FSDATA_FILE_ALIGNMENT==1
-static const unsigned int dummy_align__img_sics_gif = 0;
-#endif
-static const unsigned char FSDATA_ALIGN_PRE data__img_sics_gif[] FSDATA_ALIGN_POST = {
-/* /img/sics.gif (14 chars) */
-0x2f,0x69,0x6d,0x67,0x2f,0x73,0x69,0x63,0x73,0x2e,0x67,0x69,0x66,0x00,0x00,0x00,
-
-/* HTTP header */
-/* "HTTP/1.1 200 OK
-" (17 bytes) */
-0x48,0x54,0x54,0x50,0x2f,0x31,0x2e,0x31,0x20,0x32,0x30,0x30,0x20,0x4f,0x4b,0x0d,
-0x0a,
-/* "Server: lwIP/2.0.3d (http://savannah.nongnu.org/projects/lwip)
-" (64 bytes) */
-0x53,0x65,0x72,0x76,0x65,0x72,0x3a,0x20,0x6c,0x77,0x49,0x50,0x2f,0x32,0x2e,0x30,
-0x2e,0x33,0x64,0x20,0x28,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x73,0x61,0x76,0x61,
-0x6e,0x6e,0x61,0x68,0x2e,0x6e,0x6f,0x6e,0x67,0x6e,0x75,0x2e,0x6f,0x72,0x67,0x2f,
-0x70,0x72,0x6f,0x6a,0x65,0x63,0x74,0x73,0x2f,0x6c,0x77,0x69,0x70,0x29,0x0d,0x0a,
-
-/* "Content-Length: 724
-" (18+ bytes) */
-0x43,0x6f,0x6e,0x74,0x65,0x6e,0x74,0x2d,0x4c,0x65,0x6e,0x67,0x74,0x68,0x3a,0x20,
-0x37,0x32,0x34,0x0d,0x0a,
-/* "Connection: keep-alive
-" (24 bytes) */
-0x43,0x6f,0x6e,0x6e,0x65,0x63,0x74,0x69,0x6f,0x6e,0x3a,0x20,0x6b,0x65,0x65,0x70,
-0x2d,0x61,0x6c,0x69,0x76,0x65,0x0d,0x0a,
-/* "Content-Type: image/gif
-
-" (27 bytes) */
-0x43,0x6f,0x6e,0x74,0x65,0x6e,0x74,0x2d,0x54,0x79,0x70,0x65,0x3a,0x20,0x69,0x6d,
-0x61,0x67,0x65,0x2f,0x67,0x69,0x66,0x0d,0x0a,0x0d,0x0a,
-/* raw file data (724 bytes) */
-0x47,0x49,0x46,0x38,0x39,0x61,0x46,0x00,0x22,0x00,0xa5,0x00,0x00,0xd9,0x2b,0x39,
-0x6a,0x6a,0x6a,0xbf,0xbf,0xbf,0x93,0x93,0x93,0x0f,0x0f,0x0f,0xb0,0xb0,0xb0,0xa6,
-0xa6,0xa6,0x80,0x80,0x80,0x76,0x76,0x76,0x1e,0x1e,0x1e,0x9d,0x9d,0x9d,0x2e,0x2e,
-0x2e,0x49,0x49,0x49,0x54,0x54,0x54,0x8a,0x8a,0x8a,0x60,0x60,0x60,0xc6,0xa6,0x99,
-0xbd,0xb5,0xb2,0xc2,0xab,0xa1,0xd9,0x41,0x40,0xd5,0x67,0x55,0xc0,0xb0,0xaa,0xd5,
-0x5e,0x4e,0xd6,0x50,0x45,0xcc,0x93,0x7d,0xc8,0xa1,0x90,0xce,0x8b,0x76,0xd2,0x7b,
-0x65,0xd1,0x84,0x6d,0xc9,0x99,0x86,0x3a,0x3a,0x3a,0x00,0x00,0x00,0xb8,0xb8,0xb8,
-0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
-0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
-0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
-0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
-0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
-0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x2c,0x00,0x00,
-0x00,0x00,0x46,0x00,0x22,0x00,0x00,0x06,0xfe,0x40,0x90,0x70,0x48,0x2c,0x1a,0x8f,
-0xc8,0xa4,0x72,0xc9,0x6c,0x3a,0x9f,0xd0,0xa8,0x74,0x4a,0xad,0x5a,0xaf,0xd8,0xac,
-0x76,0xa9,0x40,0x04,0xbe,0x83,0xe2,0x60,0x3c,0x50,0x20,0x0d,0x8e,0x6f,0x00,0x31,
-0x28,0x1c,0x0d,0x07,0xb5,0xc3,0x60,0x75,0x24,0x3e,0xf8,0xfc,0x87,0x11,0x06,0xe9,
-0x3d,0x46,0x07,0x0b,0x7a,0x7a,0x7c,0x43,0x06,0x1e,0x84,0x78,0x0b,0x07,0x6e,0x51,
-0x01,0x8a,0x84,0x08,0x7e,0x79,0x80,0x87,0x89,0x91,0x7a,0x93,0x0a,0x04,0x99,0x78,
-0x96,0x4f,0x03,0x9e,0x79,0x01,0x94,0x9f,0x43,0x9c,0xa3,0xa4,0x05,0x77,0xa3,0xa0,
-0x4e,0x98,0x79,0x0b,0x1e,0x83,0xa4,0xa6,0x1f,0x96,0x05,0x9d,0xaa,0x78,0x01,0x07,
-0x84,0x04,0x1e,0x1e,0xbb,0xb8,0x51,0x84,0x0e,0x43,0x05,0x07,0x77,0xa5,0x7f,0x42,
-0xb1,0xb2,0x01,0x63,0x08,0x0d,0xbb,0x01,0x0c,0x7a,0x0d,0x44,0x0e,0xd8,0xaf,0x4c,
-0x05,0x7a,0x04,0x47,0x07,0x07,0xb7,0x80,0xa2,0xe1,0x7d,0x44,0x05,0x01,0x04,0x01,
-0xd0,0xea,0x87,0x93,0x4f,0xe0,0x9a,0x49,0xce,0xd8,0x79,0x04,0x66,0x20,0x15,0x10,
-0x10,0x11,0x92,0x29,0x80,0xb6,0xc0,0x91,0x15,0x45,0x1e,0x90,0x19,0x71,0x46,0xa8,
-0x5c,0x04,0x0e,0x00,0x22,0x4e,0xe8,0x40,0x24,0x9f,0x3e,0x04,0x06,0xa7,0x58,0xd4,
-0x93,0xa0,0x1c,0x91,0x3f,0xe8,0xf0,0x88,0x03,0xb1,0x21,0xa2,0x49,0x00,0x19,0x86,
-0xfc,0x52,0x44,0xe0,0x01,0x9d,0x29,0x21,0x15,0x25,0x50,0xf7,0x67,0x25,0x1e,0x06,
-0xfd,0x4e,0x9a,0xb4,0x90,0xac,0x15,0xfa,0xcb,0x52,0x53,0x1e,0x8c,0xf2,0xf8,0x07,
-0x92,0x2d,0x08,0x3a,0x4d,0x12,0x49,0x95,0x49,0xdb,0x14,0x04,0xc4,0x14,0x85,0x29,
-0xaa,0xe7,0x01,0x08,0xa4,0x49,0x01,0x14,0x51,0xe0,0x53,0x91,0xd5,0x29,0x06,0x1a,
-0x64,0x02,0xf4,0xc7,0x81,0x9e,0x05,0x20,0x22,0x64,0xa5,0x30,0xae,0xab,0x9e,0x97,
-0x53,0xd8,0xb9,0xfd,0x50,0xef,0x93,0x02,0x42,0x74,0x34,0xe8,0x9c,0x20,0x21,0xc9,
-0x01,0x68,0x78,0xe6,0x55,0x29,0x20,0x56,0x4f,0x4c,0x40,0x51,0x71,0x82,0xc0,0x70,
-0x21,0x22,0x85,0xbe,0x4b,0x1c,0x44,0x05,0xea,0xa4,0x01,0xbf,0x22,0xb5,0xf0,0x1c,
-0x06,0x51,0x38,0x8f,0xe0,0x22,0xec,0x18,0xac,0x39,0x22,0xd4,0xd6,0x93,0x44,0x01,
-0x32,0x82,0xc8,0xfc,0x61,0xb3,0x01,0x45,0x0c,0x2e,0x83,0x30,0xd0,0x0e,0x17,0x24,
-0x0f,0x70,0x85,0x94,0xee,0x05,0x05,0x53,0x4b,0x32,0x1b,0x3f,0x98,0xd3,0x1d,0x29,
-0x81,0xb0,0xae,0x1e,0x8c,0x7e,0x68,0xe0,0x60,0x5a,0x54,0x8f,0xb0,0x78,0x69,0x73,
-0x06,0xa2,0x00,0x6b,0x57,0xca,0x3d,0x11,0x50,0xbd,0x04,0x30,0x4b,0x3a,0xd4,0xab,
-0x5f,0x1f,0x9b,0x3d,0x13,0x74,0x27,0x88,0x3c,0x25,0xe0,0x17,0xbe,0x7a,0x79,0x45,
-0x0d,0x0c,0xb0,0x8b,0xda,0x90,0xca,0x80,0x06,0x5d,0x17,0x60,0x1c,0x22,0x4c,0xd8,
-0x57,0x22,0x06,0x20,0x00,0x98,0x07,0x08,0xe4,0x56,0x80,0x80,0x1c,0xc5,0xb7,0xc5,
-0x82,0x0c,0x36,0xe8,0xe0,0x83,0x10,0x46,0x28,0xe1,0x84,0x14,0x56,0x68,0xa1,0x10,
-0x41,0x00,0x00,0x3b,};
-
-#if FSDATA_FILE_ALIGNMENT==1
-static const unsigned int dummy_align__404_html = 1;
-#endif
-static const unsigned char FSDATA_ALIGN_PRE data__404_html[] FSDATA_ALIGN_POST = {
-/* /404.html (10 chars) */
-0x2f,0x34,0x30,0x34,0x2e,0x68,0x74,0x6d,0x6c,0x00,0x00,0x00,
-
-/* HTTP header */
-/* "HTTP/1.1 404 File not found
-" (29 bytes) */
-0x48,0x54,0x54,0x50,0x2f,0x31,0x2e,0x31,0x20,0x34,0x30,0x34,0x20,0x46,0x69,0x6c,
-0x65,0x20,0x6e,0x6f,0x74,0x20,0x66,0x6f,0x75,0x6e,0x64,0x0d,0x0a,
-/* "Server: lwIP/2.0.3d (http://savannah.nongnu.org/projects/lwip)
-" (64 bytes) */
-0x53,0x65,0x72,0x76,0x65,0x72,0x3a,0x20,0x6c,0x77,0x49,0x50,0x2f,0x32,0x2e,0x30,
-0x2e,0x33,0x64,0x20,0x28,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x73,0x61,0x76,0x61,
-0x6e,0x6e,0x61,0x68,0x2e,0x6e,0x6f,0x6e,0x67,0x6e,0x75,0x2e,0x6f,0x72,0x67,0x2f,
-0x70,0x72,0x6f,0x6a,0x65,0x63,0x74,0x73,0x2f,0x6c,0x77,0x69,0x70,0x29,0x0d,0x0a,
-
-/* "Content-Length: 565
-" (18+ bytes) */
-0x43,0x6f,0x6e,0x74,0x65,0x6e,0x74,0x2d,0x4c,0x65,0x6e,0x67,0x74,0x68,0x3a,0x20,
-0x35,0x36,0x35,0x0d,0x0a,
-/* "Connection: keep-alive
-" (24 bytes) */
-0x43,0x6f,0x6e,0x6e,0x65,0x63,0x74,0x69,0x6f,0x6e,0x3a,0x20,0x6b,0x65,0x65,0x70,
-0x2d,0x61,0x6c,0x69,0x76,0x65,0x0d,0x0a,
-/* "Content-Type: text/html
-
-" (27 bytes) */
-0x43,0x6f,0x6e,0x74,0x65,0x6e,0x74,0x2d,0x54,0x79,0x70,0x65,0x3a,0x20,0x74,0x65,
-0x78,0x74,0x2f,0x68,0x74,0x6d,0x6c,0x0d,0x0a,0x0d,0x0a,
-/* raw file data (565 bytes) */
-0x3c,0x68,0x74,0x6d,0x6c,0x3e,0x0d,0x0a,0x3c,0x68,0x65,0x61,0x64,0x3e,0x3c,0x74,
-0x69,0x74,0x6c,0x65,0x3e,0x6c,0x77,0x49,0x50,0x20,0x2d,0x20,0x41,0x20,0x4c,0x69,
-0x67,0x68,0x74,0x77,0x65,0x69,0x67,0x68,0x74,0x20,0x54,0x43,0x50,0x2f,0x49,0x50,
-0x20,0x53,0x74,0x61,0x63,0x6b,0x3c,0x2f,0x74,0x69,0x74,0x6c,0x65,0x3e,0x3c,0x2f,
-0x68,0x65,0x61,0x64,0x3e,0x0d,0x0a,0x3c,0x62,0x6f,0x64,0x79,0x20,0x62,0x67,0x63,
-0x6f,0x6c,0x6f,0x72,0x3d,0x22,0x77,0x68,0x69,0x74,0x65,0x22,0x20,0x74,0x65,0x78,
-0x74,0x3d,0x22,0x62,0x6c,0x61,0x63,0x6b,0x22,0x3e,0x0d,0x0a,0x0d,0x0a,0x20,0x20,
-0x20,0x20,0x3c,0x74,0x61,0x62,0x6c,0x65,0x20,0x77,0x69,0x64,0x74,0x68,0x3d,0x22,
-0x31,0x30,0x30,0x25,0x22,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x3c,0x74,
-0x72,0x20,0x76,0x61,0x6c,0x69,0x67,0x6e,0x3d,0x22,0x74,0x6f,0x70,0x22,0x3e,0x3c,
-0x74,0x64,0x20,0x77,0x69,0x64,0x74,0x68,0x3d,0x22,0x38,0x30,0x22,0x3e,0x09,0x20,
-0x20,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x61,0x20,0x68,0x72,0x65,0x66,0x3d,0x22,0x68,
-0x74,0x74,0x70,0x3a,0x2f,0x2f,0x77,0x77,0x77,0x2e,0x73,0x69,0x63,0x73,0x2e,0x73,
-0x65,0x2f,0x22,0x3e,0x3c,0x69,0x6d,0x67,0x20,0x73,0x72,0x63,0x3d,0x22,0x2f,0x69,
-0x6d,0x67,0x2f,0x73,0x69,0x63,0x73,0x2e,0x67,0x69,0x66,0x22,0x0d,0x0a,0x09,0x20,
-0x20,0x62,0x6f,0x72,0x64,0x65,0x72,0x3d,0x22,0x30,0x22,0x20,0x61,0x6c,0x74,0x3d,
-0x22,0x53,0x49,0x43,0x53,0x20,0x6c,0x6f,0x67,0x6f,0x22,0x20,0x74,0x69,0x74,0x6c,
-0x65,0x3d,0x22,0x53,0x49,0x43,0x53,0x20,0x6c,0x6f,0x67,0x6f,0x22,0x3e,0x3c,0x2f,
-0x61,0x3e,0x0d,0x0a,0x09,0x3c,0x2f,0x74,0x64,0x3e,0x3c,0x74,0x64,0x20,0x77,0x69,
-0x64,0x74,0x68,0x3d,0x22,0x35,0x30,0x30,0x22,0x3e,0x09,0x20,0x20,0x0d,0x0a,0x09,
-0x20,0x20,0x3c,0x68,0x31,0x3e,0x6c,0x77,0x49,0x50,0x20,0x2d,0x20,0x41,0x20,0x4c,
-0x69,0x67,0x68,0x74,0x77,0x65,0x69,0x67,0x68,0x74,0x20,0x54,0x43,0x50,0x2f,0x49,
-0x50,0x20,0x53,0x74,0x61,0x63,0x6b,0x3c,0x2f,0x68,0x31,0x3e,0x0d,0x0a,0x09,0x20,
-0x20,0x3c,0x68,0x32,0x3e,0x34,0x30,0x34,0x20,0x2d,0x20,0x50,0x61,0x67,0x65,0x20,
-0x6e,0x6f,0x74,0x20,0x66,0x6f,0x75,0x6e,0x64,0x3c,0x2f,0x68,0x32,0x3e,0x0d,0x0a,
-0x09,0x20,0x20,0x3c,0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x53,0x6f,0x72,
-0x72,0x79,0x2c,0x20,0x74,0x68,0x65,0x20,0x70,0x61,0x67,0x65,0x20,0x79,0x6f,0x75,
-0x20,0x61,0x72,0x65,0x20,0x72,0x65,0x71,0x75,0x65,0x73,0x74,0x69,0x6e,0x67,0x20,
-0x77,0x61,0x73,0x20,0x6e,0x6f,0x74,0x20,0x66,0x6f,0x75,0x6e,0x64,0x20,0x6f,0x6e,
-0x20,0x74,0x68,0x69,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x73,0x65,0x72,0x76,
-0x65,0x72,0x2e,0x20,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x2f,0x70,0x3e,0x0d,0x0a,0x09,
-0x3c,0x2f,0x74,0x64,0x3e,0x3c,0x74,0x64,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x26,0x6e,
-0x62,0x73,0x70,0x3b,0x0d,0x0a,0x09,0x3c,0x2f,0x74,0x64,0x3e,0x3c,0x2f,0x74,0x72,
-0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x3c,0x2f,0x74,0x61,0x62,0x6c,0x65,
-0x3e,0x0d,0x0a,0x3c,0x2f,0x62,0x6f,0x64,0x79,0x3e,0x0d,0x0a,0x3c,0x2f,0x68,0x74,
-0x6d,0x6c,0x3e,0x0d,0x0a,};
-
-#if FSDATA_FILE_ALIGNMENT==1
-static const unsigned int dummy_align__index_html = 2;
-#endif
-static const unsigned char FSDATA_ALIGN_PRE data__index_html[] FSDATA_ALIGN_POST = {
-/* /index.html (12 chars) */
-0x2f,0x69,0x6e,0x64,0x65,0x78,0x2e,0x68,0x74,0x6d,0x6c,0x00,
-
-/* HTTP header */
-/* "HTTP/1.1 200 OK
-" (17 bytes) */
-0x48,0x54,0x54,0x50,0x2f,0x31,0x2e,0x31,0x20,0x32,0x30,0x30,0x20,0x4f,0x4b,0x0d,
-0x0a,
-/* "Server: lwIP/2.0.3d (http://savannah.nongnu.org/projects/lwip)
-" (64 bytes) */
-0x53,0x65,0x72,0x76,0x65,0x72,0x3a,0x20,0x6c,0x77,0x49,0x50,0x2f,0x32,0x2e,0x30,
-0x2e,0x33,0x64,0x20,0x28,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x73,0x61,0x76,0x61,
-0x6e,0x6e,0x61,0x68,0x2e,0x6e,0x6f,0x6e,0x67,0x6e,0x75,0x2e,0x6f,0x72,0x67,0x2f,
-0x70,0x72,0x6f,0x6a,0x65,0x63,0x74,0x73,0x2f,0x6c,0x77,0x69,0x70,0x29,0x0d,0x0a,
-
-/* "Content-Length: 1751
-" (18+ bytes) */
-0x43,0x6f,0x6e,0x74,0x65,0x6e,0x74,0x2d,0x4c,0x65,0x6e,0x67,0x74,0x68,0x3a,0x20,
-0x31,0x37,0x35,0x31,0x0d,0x0a,
-/* "Connection: keep-alive
-" (24 bytes) */
-0x43,0x6f,0x6e,0x6e,0x65,0x63,0x74,0x69,0x6f,0x6e,0x3a,0x20,0x6b,0x65,0x65,0x70,
-0x2d,0x61,0x6c,0x69,0x76,0x65,0x0d,0x0a,
-/* "Content-Type: text/html
-
-" (27 bytes) */
-0x43,0x6f,0x6e,0x74,0x65,0x6e,0x74,0x2d,0x54,0x79,0x70,0x65,0x3a,0x20,0x74,0x65,
-0x78,0x74,0x2f,0x68,0x74,0x6d,0x6c,0x0d,0x0a,0x0d,0x0a,
-/* raw file data (1751 bytes) */
-0x3c,0x68,0x74,0x6d,0x6c,0x3e,0x0d,0x0a,0x3c,0x68,0x65,0x61,0x64,0x3e,0x3c,0x74,
-0x69,0x74,0x6c,0x65,0x3e,0x6c,0x77,0x49,0x50,0x20,0x2d,0x20,0x41,0x20,0x4c,0x69,
-0x67,0x68,0x74,0x77,0x65,0x69,0x67,0x68,0x74,0x20,0x54,0x43,0x50,0x2f,0x49,0x50,
-0x20,0x53,0x74,0x61,0x63,0x6b,0x3c,0x2f,0x74,0x69,0x74,0x6c,0x65,0x3e,0x3c,0x2f,
-0x68,0x65,0x61,0x64,0x3e,0x0d,0x0a,0x3c,0x62,0x6f,0x64,0x79,0x20,0x62,0x67,0x63,
-0x6f,0x6c,0x6f,0x72,0x3d,0x22,0x77,0x68,0x69,0x74,0x65,0x22,0x20,0x74,0x65,0x78,
-0x74,0x3d,0x22,0x62,0x6c,0x61,0x63,0x6b,0x22,0x3e,0x0d,0x0a,0x0d,0x0a,0x20,0x20,
-0x20,0x20,0x3c,0x74,0x61,0x62,0x6c,0x65,0x20,0x77,0x69,0x64,0x74,0x68,0x3d,0x22,
-0x31,0x30,0x30,0x25,0x22,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x3c,0x74,
-0x72,0x20,0x76,0x61,0x6c,0x69,0x67,0x6e,0x3d,0x22,0x74,0x6f,0x70,0x22,0x3e,0x3c,
-0x74,0x64,0x20,0x77,0x69,0x64,0x74,0x68,0x3d,0x22,0x38,0x30,0x22,0x3e,0x09,0x20,
-0x20,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x61,0x20,0x68,0x72,0x65,0x66,0x3d,0x22,0x68,
-0x74,0x74,0x70,0x3a,0x2f,0x2f,0x77,0x77,0x77,0x2e,0x73,0x69,0x63,0x73,0x2e,0x73,
-0x65,0x2f,0x22,0x3e,0x3c,0x69,0x6d,0x67,0x20,0x73,0x72,0x63,0x3d,0x22,0x2f,0x69,
-0x6d,0x67,0x2f,0x73,0x69,0x63,0x73,0x2e,0x67,0x69,0x66,0x22,0x0d,0x0a,0x09,0x20,
-0x20,0x62,0x6f,0x72,0x64,0x65,0x72,0x3d,0x22,0x30,0x22,0x20,0x61,0x6c,0x74,0x3d,
-0x22,0x53,0x49,0x43,0x53,0x20,0x6c,0x6f,0x67,0x6f,0x22,0x20,0x74,0x69,0x74,0x6c,
-0x65,0x3d,0x22,0x53,0x49,0x43,0x53,0x20,0x6c,0x6f,0x67,0x6f,0x22,0x3e,0x3c,0x2f,
-0x61,0x3e,0x0d,0x0a,0x09,0x3c,0x2f,0x74,0x64,0x3e,0x3c,0x74,0x64,0x20,0x77,0x69,
-0x64,0x74,0x68,0x3d,0x22,0x35,0x30,0x30,0x22,0x3e,0x09,0x20,0x20,0x0d,0x0a,0x09,
-0x20,0x20,0x3c,0x68,0x31,0x3e,0x6c,0x77,0x49,0x50,0x20,0x2d,0x20,0x41,0x20,0x4c,
-0x69,0x67,0x68,0x74,0x77,0x65,0x69,0x67,0x68,0x74,0x20,0x54,0x43,0x50,0x2f,0x49,
-0x50,0x20,0x53,0x74,0x61,0x63,0x6b,0x3c,0x2f,0x68,0x31,0x3e,0x0d,0x0a,0x09,0x20,
-0x20,0x3c,0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x54,0x68,0x65,0x20,0x77,
-0x65,0x62,0x20,0x70,0x61,0x67,0x65,0x20,0x79,0x6f,0x75,0x20,0x61,0x72,0x65,0x20,
-0x77,0x61,0x74,0x63,0x68,0x69,0x6e,0x67,0x20,0x77,0x61,0x73,0x20,0x73,0x65,0x72,
-0x76,0x65,0x64,0x20,0x62,0x79,0x20,0x61,0x20,0x73,0x69,0x6d,0x70,0x6c,0x65,0x20,
-0x77,0x65,0x62,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x73,0x65,0x72,0x76,0x65,0x72,
-0x20,0x72,0x75,0x6e,0x6e,0x69,0x6e,0x67,0x20,0x6f,0x6e,0x20,0x74,0x6f,0x70,0x20,
-0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x6c,0x69,0x67,0x68,0x74,0x77,0x65,0x69,0x67,
-0x68,0x74,0x20,0x54,0x43,0x50,0x2f,0x49,0x50,0x20,0x73,0x74,0x61,0x63,0x6b,0x20,
-0x3c,0x61,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x68,0x72,0x65,0x66,0x3d,0x22,0x68,
-0x74,0x74,0x70,0x3a,0x2f,0x2f,0x77,0x77,0x77,0x2e,0x73,0x69,0x63,0x73,0x2e,0x73,
-0x65,0x2f,0x7e,0x61,0x64,0x61,0x6d,0x2f,0x6c,0x77,0x69,0x70,0x2f,0x22,0x3e,0x6c,
-0x77,0x49,0x50,0x3c,0x2f,0x61,0x3e,0x2e,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x2f,0x70,
-0x3e,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,
-0x6c,0x77,0x49,0x50,0x20,0x69,0x73,0x20,0x61,0x6e,0x20,0x6f,0x70,0x65,0x6e,0x20,
-0x73,0x6f,0x75,0x72,0x63,0x65,0x20,0x69,0x6d,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,
-0x61,0x74,0x69,0x6f,0x6e,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x54,0x43,0x50,
-0x2f,0x49,0x50,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x70,0x72,0x6f,0x74,0x6f,0x63,
-0x6f,0x6c,0x20,0x73,0x75,0x69,0x74,0x65,0x20,0x74,0x68,0x61,0x74,0x20,0x77,0x61,
-0x73,0x20,0x6f,0x72,0x69,0x67,0x69,0x6e,0x61,0x6c,0x6c,0x79,0x20,0x77,0x72,0x69,
-0x74,0x74,0x65,0x6e,0x20,0x62,0x79,0x20,0x3c,0x61,0x0d,0x0a,0x09,0x20,0x20,0x20,
-0x20,0x68,0x72,0x65,0x66,0x3d,0x22,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x77,0x77,
-0x77,0x2e,0x73,0x69,0x63,0x73,0x2e,0x73,0x65,0x2f,0x7e,0x61,0x64,0x61,0x6d,0x2f,
-0x6c,0x77,0x69,0x70,0x2f,0x22,0x3e,0x41,0x64,0x61,0x6d,0x20,0x44,0x75,0x6e,0x6b,
-0x65,0x6c,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,
-0x20,0x53,0x77,0x65,0x64,0x69,0x73,0x68,0x20,0x49,0x6e,0x73,0x74,0x69,0x74,0x75,
-0x74,0x65,0x20,0x6f,0x66,0x20,0x43,0x6f,0x6d,0x70,0x75,0x74,0x65,0x72,0x20,0x53,
-0x63,0x69,0x65,0x6e,0x63,0x65,0x3c,0x2f,0x61,0x3e,0x20,0x62,0x75,0x74,0x20,0x6e,
-0x6f,0x77,0x20,0x69,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x62,0x65,0x69,0x6e,
-0x67,0x20,0x61,0x63,0x74,0x69,0x76,0x65,0x6c,0x79,0x20,0x64,0x65,0x76,0x65,0x6c,
-0x6f,0x70,0x65,0x64,0x20,0x62,0x79,0x20,0x61,0x20,0x74,0x65,0x61,0x6d,0x20,0x6f,
-0x66,0x20,0x64,0x65,0x76,0x65,0x6c,0x6f,0x70,0x65,0x72,0x73,0x0d,0x0a,0x09,0x20,
-0x20,0x20,0x20,0x64,0x69,0x73,0x74,0x72,0x69,0x62,0x75,0x74,0x65,0x64,0x20,0x77,
-0x6f,0x72,0x6c,0x64,0x2d,0x77,0x69,0x64,0x65,0x2e,0x20,0x53,0x69,0x6e,0x63,0x65,
-0x20,0x69,0x74,0x27,0x73,0x20,0x72,0x65,0x6c,0x65,0x61,0x73,0x65,0x2c,0x20,0x6c,
-0x77,0x49,0x50,0x20,0x68,0x61,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x73,0x70,
-0x75,0x72,0x72,0x65,0x64,0x20,0x61,0x20,0x6c,0x6f,0x74,0x20,0x6f,0x66,0x20,0x69,
-0x6e,0x74,0x65,0x72,0x65,0x73,0x74,0x20,0x61,0x6e,0x64,0x20,0x68,0x61,0x73,0x20,
-0x62,0x65,0x65,0x6e,0x20,0x70,0x6f,0x72,0x74,0x65,0x64,0x20,0x74,0x6f,0x20,0x73,
-0x65,0x76,0x65,0x72,0x61,0x6c,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x70,0x6c,0x61,
-0x74,0x66,0x6f,0x72,0x6d,0x73,0x20,0x61,0x6e,0x64,0x20,0x6f,0x70,0x65,0x72,0x61,
-0x74,0x69,0x6e,0x67,0x20,0x73,0x79,0x73,0x74,0x65,0x6d,0x73,0x2e,0x20,0x6c,0x77,
-0x49,0x50,0x20,0x63,0x61,0x6e,0x20,0x62,0x65,0x20,0x75,0x73,0x65,0x64,0x20,0x65,
-0x69,0x74,0x68,0x65,0x72,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x77,0x69,0x74,0x68,
-0x20,0x6f,0x72,0x20,0x77,0x69,0x74,0x68,0x6f,0x75,0x74,0x20,0x61,0x6e,0x20,0x75,
-0x6e,0x64,0x65,0x72,0x6c,0x79,0x69,0x6e,0x67,0x20,0x4f,0x53,0x2e,0x0d,0x0a,0x09,
-0x20,0x20,0x3c,0x2f,0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x70,0x3e,0x0d,0x0a,
-0x09,0x20,0x20,0x20,0x20,0x54,0x68,0x65,0x20,0x66,0x6f,0x63,0x75,0x73,0x20,0x6f,
-0x66,0x20,0x74,0x68,0x65,0x20,0x6c,0x77,0x49,0x50,0x20,0x54,0x43,0x50,0x2f,0x49,
-0x50,0x20,0x69,0x6d,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,0x61,0x74,0x69,0x6f,0x6e,
-0x20,0x69,0x73,0x20,0x74,0x6f,0x20,0x72,0x65,0x64,0x75,0x63,0x65,0x0d,0x0a,0x09,
-0x20,0x20,0x20,0x20,0x74,0x68,0x65,0x20,0x52,0x41,0x4d,0x20,0x75,0x73,0x61,0x67,
-0x65,0x20,0x77,0x68,0x69,0x6c,0x65,0x20,0x73,0x74,0x69,0x6c,0x6c,0x20,0x68,0x61,
-0x76,0x69,0x6e,0x67,0x20,0x61,0x20,0x66,0x75,0x6c,0x6c,0x20,0x73,0x63,0x61,0x6c,
-0x65,0x20,0x54,0x43,0x50,0x2e,0x20,0x54,0x68,0x69,0x73,0x0d,0x0a,0x09,0x20,0x20,
-0x20,0x20,0x6d,0x61,0x6b,0x65,0x73,0x20,0x6c,0x77,0x49,0x50,0x20,0x73,0x75,0x69,
-0x74,0x61,0x62,0x6c,0x65,0x20,0x66,0x6f,0x72,0x20,0x75,0x73,0x65,0x20,0x69,0x6e,
-0x20,0x65,0x6d,0x62,0x65,0x64,0x64,0x65,0x64,0x20,0x73,0x79,0x73,0x74,0x65,0x6d,
-0x73,0x20,0x77,0x69,0x74,0x68,0x20,0x74,0x65,0x6e,0x73,0x0d,0x0a,0x09,0x20,0x20,
-0x20,0x20,0x6f,0x66,0x20,0x6b,0x69,0x6c,0x6f,0x62,0x79,0x74,0x65,0x73,0x20,0x6f,
-0x66,0x20,0x66,0x72,0x65,0x65,0x20,0x52,0x41,0x4d,0x20,0x61,0x6e,0x64,0x20,0x72,
-0x6f,0x6f,0x6d,0x20,0x66,0x6f,0x72,0x20,0x61,0x72,0x6f,0x75,0x6e,0x64,0x20,0x34,
-0x30,0x20,0x6b,0x69,0x6c,0x6f,0x62,0x79,0x74,0x65,0x73,0x0d,0x0a,0x09,0x20,0x20,
-0x20,0x20,0x6f,0x66,0x20,0x63,0x6f,0x64,0x65,0x20,0x52,0x4f,0x4d,0x2e,0x0d,0x0a,
-0x09,0x20,0x20,0x3c,0x2f,0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x70,0x3e,0x0d,
-0x0a,0x09,0x20,0x20,0x20,0x20,0x4d,0x6f,0x72,0x65,0x20,0x69,0x6e,0x66,0x6f,0x72,
-0x6d,0x61,0x74,0x69,0x6f,0x6e,0x20,0x61,0x62,0x6f,0x75,0x74,0x20,0x6c,0x77,0x49,
-0x50,0x20,0x63,0x61,0x6e,0x20,0x62,0x65,0x20,0x66,0x6f,0x75,0x6e,0x64,0x20,0x61,
-0x74,0x20,0x74,0x68,0x65,0x20,0x6c,0x77,0x49,0x50,0x0d,0x0a,0x09,0x20,0x20,0x20,
-0x20,0x68,0x6f,0x6d,0x65,0x70,0x61,0x67,0x65,0x20,0x61,0x74,0x20,0x3c,0x61,0x0d,
-0x0a,0x09,0x20,0x20,0x20,0x20,0x68,0x72,0x65,0x66,0x3d,0x22,0x68,0x74,0x74,0x70,
-0x3a,0x2f,0x2f,0x73,0x61,0x76,0x61,0x6e,0x6e,0x61,0x68,0x2e,0x6e,0x6f,0x6e,0x67,
-0x6e,0x75,0x2e,0x6f,0x72,0x67,0x2f,0x70,0x72,0x6f,0x6a,0x65,0x63,0x74,0x73,0x2f,
-0x6c,0x77,0x69,0x70,0x2f,0x22,0x3e,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x73,0x61,
-0x76,0x61,0x6e,0x6e,0x61,0x68,0x2e,0x6e,0x6f,0x6e,0x67,0x6e,0x75,0x2e,0x6f,0x72,
-0x67,0x2f,0x70,0x72,0x6f,0x6a,0x65,0x63,0x74,0x73,0x2f,0x6c,0x77,0x69,0x70,0x2f,
-0x3c,0x2f,0x61,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x6f,0x72,0x20,0x61,0x74,
-0x20,0x74,0x68,0x65,0x20,0x6c,0x77,0x49,0x50,0x20,0x77,0x69,0x6b,0x69,0x20,0x61,
-0x74,0x20,0x3c,0x61,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x68,0x72,0x65,0x66,0x3d,
-0x22,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x6c,0x77,0x69,0x70,0x2e,0x77,0x69,0x6b,
-0x69,0x61,0x2e,0x63,0x6f,0x6d,0x2f,0x22,0x3e,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,
-0x6c,0x77,0x69,0x70,0x2e,0x77,0x69,0x6b,0x69,0x61,0x2e,0x63,0x6f,0x6d,0x2f,0x3c,
-0x2f,0x61,0x3e,0x2e,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x2f,0x70,0x3e,0x0d,0x0a,0x09,
-0x3c,0x2f,0x74,0x64,0x3e,0x3c,0x74,0x64,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x26,0x6e,
-0x62,0x73,0x70,0x3b,0x0d,0x0a,0x09,0x3c,0x2f,0x74,0x64,0x3e,0x3c,0x2f,0x74,0x72,
-0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x3c,0x2f,0x74,0x61,0x62,0x6c,0x65,
-0x3e,0x0d,0x0a,0x3c,0x2f,0x62,0x6f,0x64,0x79,0x3e,0x0d,0x0a,0x3c,0x2f,0x68,0x74,
-0x6d,0x6c,0x3e,0x0d,0x0a,0x0d,0x0a,};
-
-#if FSDATA_FILE_ALIGNMENT==1
-static const unsigned int dummy_align__login_html = 3;
-#endif
-static const unsigned char FSDATA_ALIGN_PRE data__login_html[] FSDATA_ALIGN_POST = {
-/* /login.html (12 chars) */
-0x2f,0x6c,0x6f,0x67,0x69,0x6e,0x2e,0x68,0x74,0x6d,0x6c,0x00,
-
-/* HTTP header */
-/* "HTTP/1.1 200 OK
-" (17 bytes) */
-0x48,0x54,0x54,0x50,0x2f,0x31,0x2e,0x31,0x20,0x32,0x30,0x30,0x20,0x4f,0x4b,0x0d,
-0x0a,
-/* "Server: lwIP/2.0.3d (http://savannah.nongnu.org/projects/lwip)
-" (64 bytes) */
-0x53,0x65,0x72,0x76,0x65,0x72,0x3a,0x20,0x6c,0x77,0x49,0x50,0x2f,0x32,0x2e,0x30,
-0x2e,0x33,0x64,0x20,0x28,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x73,0x61,0x76,0x61,
-0x6e,0x6e,0x61,0x68,0x2e,0x6e,0x6f,0x6e,0x67,0x6e,0x75,0x2e,0x6f,0x72,0x67,0x2f,
-0x70,0x72,0x6f,0x6a,0x65,0x63,0x74,0x73,0x2f,0x6c,0x77,0x69,0x70,0x29,0x0d,0x0a,
-
-/* "Content-Length: 768
-" (18+ bytes) */
-0x43,0x6f,0x6e,0x74,0x65,0x6e,0x74,0x2d,0x4c,0x65,0x6e,0x67,0x74,0x68,0x3a,0x20,
-0x37,0x36,0x38,0x0d,0x0a,
-/* "Connection: keep-alive
-" (24 bytes) */
-0x43,0x6f,0x6e,0x6e,0x65,0x63,0x74,0x69,0x6f,0x6e,0x3a,0x20,0x6b,0x65,0x65,0x70,
-0x2d,0x61,0x6c,0x69,0x76,0x65,0x0d,0x0a,
-/* "Content-Type: text/html
-
-" (27 bytes) */
-0x43,0x6f,0x6e,0x74,0x65,0x6e,0x74,0x2d,0x54,0x79,0x70,0x65,0x3a,0x20,0x74,0x65,
-0x78,0x74,0x2f,0x68,0x74,0x6d,0x6c,0x0d,0x0a,0x0d,0x0a,
-/* raw file data (768 bytes) */
-0x3c,0x68,0x74,0x6d,0x6c,0x3e,0x0d,0x0a,0x3c,0x68,0x65,0x61,0x64,0x3e,0x3c,0x74,
-0x69,0x74,0x6c,0x65,0x3e,0x6c,0x77,0x49,0x50,0x20,0x2d,0x20,0x41,0x20,0x4c,0x69,
-0x67,0x68,0x74,0x77,0x65,0x69,0x67,0x68,0x74,0x20,0x54,0x43,0x50,0x2f,0x49,0x50,
-0x20,0x53,0x74,0x61,0x63,0x6b,0x3c,0x2f,0x74,0x69,0x74,0x6c,0x65,0x3e,0x3c,0x2f,
-0x68,0x65,0x61,0x64,0x3e,0x0d,0x0a,0x3c,0x62,0x6f,0x64,0x79,0x20,0x62,0x67,0x63,
-0x6f,0x6c,0x6f,0x72,0x3d,0x22,0x77,0x68,0x69,0x74,0x65,0x22,0x20,0x74,0x65,0x78,
-0x74,0x3d,0x22,0x62,0x6c,0x61,0x63,0x6b,0x22,0x3e,0x0d,0x0a,0x0d,0x0a,0x3c,0x74,
-0x61,0x62,0x6c,0x65,0x20,0x77,0x69,0x64,0x74,0x68,0x3d,0x22,0x31,0x30,0x30,0x25,
-0x22,0x3e,0x0d,0x0a,0x20,0x3c,0x74,0x72,0x20,0x76,0x61,0x6c,0x69,0x67,0x6e,0x3d,
-0x22,0x74,0x6f,0x70,0x22,0x3e,0x0d,0x0a,0x20,0x20,0x3c,0x74,0x64,0x20,0x77,0x69,
-0x64,0x74,0x68,0x3d,0x22,0x38,0x30,0x22,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x3c,0x61,
-0x20,0x68,0x72,0x65,0x66,0x3d,0x22,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x77,0x77,
-0x77,0x2e,0x73,0x69,0x63,0x73,0x2e,0x73,0x65,0x2f,0x22,0x3e,0x3c,0x69,0x6d,0x67,
-0x20,0x73,0x72,0x63,0x3d,0x22,0x2f,0x69,0x6d,0x67,0x2f,0x73,0x69,0x63,0x73,0x2e,
-0x67,0x69,0x66,0x22,0x20,0x62,0x6f,0x72,0x64,0x65,0x72,0x3d,0x22,0x30,0x22,0x20,
-0x61,0x6c,0x74,0x3d,0x22,0x53,0x49,0x43,0x53,0x20,0x6c,0x6f,0x67,0x6f,0x22,0x20,
-0x74,0x69,0x74,0x6c,0x65,0x3d,0x22,0x53,0x49,0x43,0x53,0x20,0x6c,0x6f,0x67,0x6f,
-0x22,0x2f,0x3e,0x3c,0x2f,0x61,0x3e,0x0d,0x0a,0x20,0x20,0x3c,0x2f,0x74,0x64,0x3e,
-0x0d,0x0a,0x20,0x20,0x3c,0x74,0x64,0x20,0x77,0x69,0x64,0x74,0x68,0x3d,0x22,0x35,
-0x30,0x30,0x22,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x3c,0x68,0x31,0x3e,0x4c,0x6f,0x67,
-0x69,0x6e,0x3c,0x2f,0x68,0x31,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x3c,0x66,0x6f,0x72,
-0x6d,0x20,0x6e,0x61,0x6d,0x65,0x3d,0x22,0x6c,0x6f,0x67,0x69,0x6e,0x22,0x20,0x61,
-0x63,0x74,0x69,0x6f,0x6e,0x3d,0x22,0x6c,0x6f,0x67,0x69,0x6e,0x2e,0x63,0x67,0x69,
-0x22,0x20,0x6d,0x65,0x74,0x68,0x6f,0x64,0x3d,0x22,0x70,0x6f,0x73,0x74,0x22,0x3e,
-0x0d,0x0a,0x20,0x20,0x20,0x20,0x3c,0x64,0x69,0x76,0x3e,0x0d,0x0a,0x20,0x20,0x20,
-0x20,0x20,0x3c,0x6c,0x61,0x62,0x65,0x6c,0x3e,0x3c,0x62,0x3e,0x55,0x73,0x65,0x72,
-0x6e,0x61,0x6d,0x65,0x3c,0x2f,0x62,0x3e,0x3c,0x2f,0x6c,0x61,0x62,0x65,0x6c,0x3e,
-0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x3c,0x69,0x6e,0x70,0x75,0x74,0x20,0x74,0x79,
-0x70,0x65,0x3d,0x22,0x74,0x65,0x78,0x74,0x22,0x20,0x70,0x6c,0x61,0x63,0x65,0x68,
-0x6f,0x6c,0x64,0x65,0x72,0x3d,0x22,0x45,0x6e,0x74,0x65,0x72,0x20,0x55,0x73,0x65,
-0x72,0x6e,0x61,0x6d,0x65,0x22,0x20,0x6e,0x61,0x6d,0x65,0x3d,0x22,0x75,0x73,0x65,
-0x72,0x22,0x20,0x72,0x65,0x71,0x75,0x69,0x72,0x65,0x64,0x3e,0x0d,0x0a,0x20,0x20,
-0x20,0x20,0x20,0x3c,0x6c,0x61,0x62,0x65,0x6c,0x3e,0x3c,0x62,0x3e,0x50,0x61,0x73,
-0x73,0x77,0x6f,0x72,0x64,0x3c,0x2f,0x62,0x3e,0x3c,0x2f,0x6c,0x61,0x62,0x65,0x6c,
-0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x3c,0x69,0x6e,0x70,0x75,0x74,0x20,0x74,
-0x79,0x70,0x65,0x3d,0x22,0x70,0x61,0x73,0x73,0x77,0x6f,0x72,0x64,0x22,0x20,0x70,
-0x6c,0x61,0x63,0x65,0x68,0x6f,0x6c,0x64,0x65,0x72,0x3d,0x22,0x45,0x6e,0x74,0x65,
-0x72,0x20,0x50,0x61,0x73,0x73,0x77,0x6f,0x72,0x64,0x22,0x20,0x6e,0x61,0x6d,0x65,
-0x3d,0x22,0x70,0x61,0x73,0x73,0x22,0x20,0x72,0x65,0x71,0x75,0x69,0x72,0x65,0x64,
-0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x3c,0x62,0x75,0x74,0x74,0x6f,0x6e,0x20,
-0x74,0x79,0x70,0x65,0x3d,0x22,0x73,0x75,0x62,0x6d,0x69,0x74,0x22,0x3e,0x4c,0x6f,
-0x67,0x69,0x6e,0x3c,0x2f,0x62,0x75,0x74,0x74,0x6f,0x6e,0x3e,0x0d,0x0a,0x20,0x20,
-0x20,0x20,0x3c,0x2f,0x64,0x69,0x76,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x3c,0x2f,0x66,
-0x6f,0x72,0x6d,0x3e,0x20,0x0d,0x0a,0x20,0x20,0x3c,0x2f,0x74,0x64,0x3e,0x0d,0x0a,
-0x20,0x20,0x3c,0x74,0x64,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x26,0x6e,0x62,0x73,0x70,
-0x3b,0x0d,0x0a,0x20,0x20,0x3c,0x2f,0x74,0x64,0x3e,0x0d,0x0a,0x20,0x3c,0x2f,0x74,
-0x72,0x3e,0x0d,0x0a,0x3c,0x2f,0x74,0x61,0x62,0x6c,0x65,0x3e,0x0d,0x0a,0x3c,0x2f,
-0x62,0x6f,0x64,0x79,0x3e,0x0d,0x0a,0x3c,0x2f,0x68,0x74,0x6d,0x6c,0x3e,0x0d,0x0a,
-};
-
-#if FSDATA_FILE_ALIGNMENT==1
-static const unsigned int dummy_align__loginfail_html = 4;
-#endif
-static const unsigned char FSDATA_ALIGN_PRE data__loginfail_html[] FSDATA_ALIGN_POST = {
-/* /loginfail.html (16 chars) */
-0x2f,0x6c,0x6f,0x67,0x69,0x6e,0x66,0x61,0x69,0x6c,0x2e,0x68,0x74,0x6d,0x6c,0x00,
-
-
-/* HTTP header */
-/* "HTTP/1.1 200 OK
-" (17 bytes) */
-0x48,0x54,0x54,0x50,0x2f,0x31,0x2e,0x31,0x20,0x32,0x30,0x30,0x20,0x4f,0x4b,0x0d,
-0x0a,
-/* "Server: lwIP/2.0.3d (http://savannah.nongnu.org/projects/lwip)
-" (64 bytes) */
-0x53,0x65,0x72,0x76,0x65,0x72,0x3a,0x20,0x6c,0x77,0x49,0x50,0x2f,0x32,0x2e,0x30,
-0x2e,0x33,0x64,0x20,0x28,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x73,0x61,0x76,0x61,
-0x6e,0x6e,0x61,0x68,0x2e,0x6e,0x6f,0x6e,0x67,0x6e,0x75,0x2e,0x6f,0x72,0x67,0x2f,
-0x70,0x72,0x6f,0x6a,0x65,0x63,0x74,0x73,0x2f,0x6c,0x77,0x69,0x70,0x29,0x0d,0x0a,
-
-/* "Content-Length: 559
-" (18+ bytes) */
-0x43,0x6f,0x6e,0x74,0x65,0x6e,0x74,0x2d,0x4c,0x65,0x6e,0x67,0x74,0x68,0x3a,0x20,
-0x35,0x35,0x39,0x0d,0x0a,
-/* "Connection: keep-alive
-" (24 bytes) */
-0x43,0x6f,0x6e,0x6e,0x65,0x63,0x74,0x69,0x6f,0x6e,0x3a,0x20,0x6b,0x65,0x65,0x70,
-0x2d,0x61,0x6c,0x69,0x76,0x65,0x0d,0x0a,
-/* "Content-Type: text/html
-
-" (27 bytes) */
-0x43,0x6f,0x6e,0x74,0x65,0x6e,0x74,0x2d,0x54,0x79,0x70,0x65,0x3a,0x20,0x74,0x65,
-0x78,0x74,0x2f,0x68,0x74,0x6d,0x6c,0x0d,0x0a,0x0d,0x0a,
-/* raw file data (559 bytes) */
-0x3c,0x68,0x74,0x6d,0x6c,0x3e,0x0d,0x0a,0x3c,0x68,0x65,0x61,0x64,0x3e,0x3c,0x74,
-0x69,0x74,0x6c,0x65,0x3e,0x6c,0x77,0x49,0x50,0x20,0x2d,0x20,0x41,0x20,0x4c,0x69,
-0x67,0x68,0x74,0x77,0x65,0x69,0x67,0x68,0x74,0x20,0x54,0x43,0x50,0x2f,0x49,0x50,
-0x20,0x53,0x74,0x61,0x63,0x6b,0x3c,0x2f,0x74,0x69,0x74,0x6c,0x65,0x3e,0x3c,0x2f,
-0x68,0x65,0x61,0x64,0x3e,0x0d,0x0a,0x3c,0x62,0x6f,0x64,0x79,0x20,0x62,0x67,0x63,
-0x6f,0x6c,0x6f,0x72,0x3d,0x22,0x77,0x68,0x69,0x74,0x65,0x22,0x20,0x74,0x65,0x78,
-0x74,0x3d,0x22,0x62,0x6c,0x61,0x63,0x6b,0x22,0x3e,0x0d,0x0a,0x0d,0x0a,0x20,0x3c,
-0x74,0x61,0x62,0x6c,0x65,0x20,0x77,0x69,0x64,0x74,0x68,0x3d,0x22,0x31,0x30,0x30,
-0x25,0x22,0x3e,0x0d,0x0a,0x20,0x20,0x3c,0x74,0x72,0x20,0x76,0x61,0x6c,0x69,0x67,
-0x6e,0x3d,0x22,0x74,0x6f,0x70,0x22,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x3c,0x74,0x64,
-0x20,0x77,0x69,0x64,0x74,0x68,0x3d,0x22,0x38,0x30,0x22,0x3e,0x0d,0x0a,0x20,0x20,
-0x20,0x20,0x3c,0x61,0x20,0x68,0x72,0x65,0x66,0x3d,0x22,0x68,0x74,0x74,0x70,0x3a,
-0x2f,0x2f,0x77,0x77,0x77,0x2e,0x73,0x69,0x63,0x73,0x2e,0x73,0x65,0x2f,0x22,0x3e,
-0x3c,0x69,0x6d,0x67,0x20,0x73,0x72,0x63,0x3d,0x22,0x2f,0x69,0x6d,0x67,0x2f,0x73,
-0x69,0x63,0x73,0x2e,0x67,0x69,0x66,0x22,0x20,0x62,0x6f,0x72,0x64,0x65,0x72,0x3d,
-0x22,0x30,0x22,0x20,0x61,0x6c,0x74,0x3d,0x22,0x53,0x49,0x43,0x53,0x20,0x6c,0x6f,
-0x67,0x6f,0x22,0x20,0x74,0x69,0x74,0x6c,0x65,0x3d,0x22,0x53,0x49,0x43,0x53,0x20,
-0x6c,0x6f,0x67,0x6f,0x22,0x2f,0x3e,0x3c,0x2f,0x61,0x3e,0x0d,0x0a,0x20,0x20,0x20,
-0x3c,0x2f,0x74,0x64,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x3c,0x74,0x64,0x20,0x77,0x69,
-0x64,0x74,0x68,0x3d,0x22,0x35,0x30,0x30,0x22,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,
-0x3c,0x68,0x31,0x3e,0x6c,0x77,0x49,0x50,0x20,0x2d,0x20,0x41,0x20,0x4c,0x69,0x67,
-0x68,0x74,0x77,0x65,0x69,0x67,0x68,0x74,0x20,0x54,0x43,0x50,0x2f,0x49,0x50,0x20,
-0x53,0x74,0x61,0x63,0x6b,0x3c,0x2f,0x68,0x31,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,
-0x3c,0x70,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x4c,0x6f,0x67,0x69,0x6e,0x20,
-0x66,0x61,0x69,0x6c,0x65,0x64,0x2e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x3c,0x2f,0x70,
-0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x3c,0x70,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,
-0x20,0x43,0x6c,0x69,0x63,0x6b,0x20,0x3c,0x61,0x20,0x68,0x72,0x65,0x66,0x3d,0x22,
-0x6c,0x6f,0x67,0x69,0x6e,0x2e,0x68,0x74,0x6d,0x6c,0x22,0x3e,0x68,0x65,0x72,0x65,
-0x3c,0x2f,0x61,0x3e,0x20,0x74,0x6f,0x20,0x72,0x65,0x74,0x72,0x79,0x20,0x6c,0x6f,
-0x67,0x69,0x6e,0x2e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x3c,0x2f,0x70,0x3e,0x0d,0x0a,
-0x20,0x20,0x20,0x3c,0x2f,0x74,0x64,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x3c,0x74,0x64,
-0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x26,0x6e,0x62,0x73,0x70,0x3b,0x0d,0x0a,0x20,
-0x20,0x20,0x3c,0x2f,0x74,0x64,0x3e,0x0d,0x0a,0x20,0x20,0x3c,0x2f,0x74,0x72,0x3e,
-0x0d,0x0a,0x20,0x3c,0x2f,0x74,0x61,0x62,0x6c,0x65,0x3e,0x0d,0x0a,0x3c,0x2f,0x62,
-0x6f,0x64,0x79,0x3e,0x0d,0x0a,0x3c,0x2f,0x68,0x74,0x6d,0x6c,0x3e,0x0d,0x0a,};
-
-#if FSDATA_FILE_ALIGNMENT==1
-static const unsigned int dummy_align__session_html = 5;
-#endif
-static const unsigned char FSDATA_ALIGN_PRE data__session_html[] FSDATA_ALIGN_POST = {
-/* /session.html (14 chars) */
-0x2f,0x73,0x65,0x73,0x73,0x69,0x6f,0x6e,0x2e,0x68,0x74,0x6d,0x6c,0x00,0x00,0x00,
-
-/* HTTP header */
-/* "HTTP/1.1 200 OK
-" (17 bytes) */
-0x48,0x54,0x54,0x50,0x2f,0x31,0x2e,0x31,0x20,0x32,0x30,0x30,0x20,0x4f,0x4b,0x0d,
-0x0a,
-/* "Server: lwIP/2.0.3d (http://savannah.nongnu.org/projects/lwip)
-" (64 bytes) */
-0x53,0x65,0x72,0x76,0x65,0x72,0x3a,0x20,0x6c,0x77,0x49,0x50,0x2f,0x32,0x2e,0x30,
-0x2e,0x33,0x64,0x20,0x28,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x73,0x61,0x76,0x61,
-0x6e,0x6e,0x61,0x68,0x2e,0x6e,0x6f,0x6e,0x67,0x6e,0x75,0x2e,0x6f,0x72,0x67,0x2f,
-0x70,0x72,0x6f,0x6a,0x65,0x63,0x74,0x73,0x2f,0x6c,0x77,0x69,0x70,0x29,0x0d,0x0a,
-
-/* "Content-Length: 578
-" (18+ bytes) */
-0x43,0x6f,0x6e,0x74,0x65,0x6e,0x74,0x2d,0x4c,0x65,0x6e,0x67,0x74,0x68,0x3a,0x20,
-0x35,0x37,0x38,0x0d,0x0a,
-/* "Connection: keep-alive
-" (24 bytes) */
-0x43,0x6f,0x6e,0x6e,0x65,0x63,0x74,0x69,0x6f,0x6e,0x3a,0x20,0x6b,0x65,0x65,0x70,
-0x2d,0x61,0x6c,0x69,0x76,0x65,0x0d,0x0a,
-/* "Content-Type: text/html
-
-" (27 bytes) */
-0x43,0x6f,0x6e,0x74,0x65,0x6e,0x74,0x2d,0x54,0x79,0x70,0x65,0x3a,0x20,0x74,0x65,
-0x78,0x74,0x2f,0x68,0x74,0x6d,0x6c,0x0d,0x0a,0x0d,0x0a,
-/* raw file data (578 bytes) */
-0x3c,0x68,0x74,0x6d,0x6c,0x3e,0x0d,0x0a,0x3c,0x68,0x65,0x61,0x64,0x3e,0x3c,0x74,
-0x69,0x74,0x6c,0x65,0x3e,0x6c,0x77,0x49,0x50,0x20,0x2d,0x20,0x41,0x20,0x4c,0x69,
-0x67,0x68,0x74,0x77,0x65,0x69,0x67,0x68,0x74,0x20,0x54,0x43,0x50,0x2f,0x49,0x50,
-0x20,0x53,0x74,0x61,0x63,0x6b,0x3c,0x2f,0x74,0x69,0x74,0x6c,0x65,0x3e,0x3c,0x2f,
-0x68,0x65,0x61,0x64,0x3e,0x0d,0x0a,0x3c,0x62,0x6f,0x64,0x79,0x20,0x62,0x67,0x63,
-0x6f,0x6c,0x6f,0x72,0x3d,0x22,0x77,0x68,0x69,0x74,0x65,0x22,0x20,0x74,0x65,0x78,
-0x74,0x3d,0x22,0x62,0x6c,0x61,0x63,0x6b,0x22,0x3e,0x0d,0x0a,0x0d,0x0a,0x20,0x3c,
-0x74,0x61,0x62,0x6c,0x65,0x20,0x77,0x69,0x64,0x74,0x68,0x3d,0x22,0x31,0x30,0x30,
-0x25,0x22,0x3e,0x0d,0x0a,0x20,0x20,0x3c,0x74,0x72,0x20,0x76,0x61,0x6c,0x69,0x67,
-0x6e,0x3d,0x22,0x74,0x6f,0x70,0x22,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x3c,0x74,0x64,
-0x20,0x77,0x69,0x64,0x74,0x68,0x3d,0x22,0x38,0x30,0x22,0x3e,0x0d,0x0a,0x20,0x20,
-0x20,0x20,0x3c,0x61,0x20,0x68,0x72,0x65,0x66,0x3d,0x22,0x68,0x74,0x74,0x70,0x3a,
-0x2f,0x2f,0x77,0x77,0x77,0x2e,0x73,0x69,0x63,0x73,0x2e,0x73,0x65,0x2f,0x22,0x3e,
-0x3c,0x69,0x6d,0x67,0x20,0x73,0x72,0x63,0x3d,0x22,0x2f,0x69,0x6d,0x67,0x2f,0x73,
-0x69,0x63,0x73,0x2e,0x67,0x69,0x66,0x22,0x20,0x62,0x6f,0x72,0x64,0x65,0x72,0x3d,
-0x22,0x30,0x22,0x20,0x61,0x6c,0x74,0x3d,0x22,0x53,0x49,0x43,0x53,0x20,0x6c,0x6f,
-0x67,0x6f,0x22,0x20,0x74,0x69,0x74,0x6c,0x65,0x3d,0x22,0x53,0x49,0x43,0x53,0x20,
-0x6c,0x6f,0x67,0x6f,0x22,0x2f,0x3e,0x3c,0x2f,0x61,0x3e,0x0d,0x0a,0x20,0x20,0x20,
-0x3c,0x2f,0x74,0x64,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x3c,0x74,0x64,0x20,0x77,0x69,
-0x64,0x74,0x68,0x3d,0x22,0x35,0x30,0x30,0x22,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,
-0x3c,0x68,0x31,0x3e,0x6c,0x77,0x49,0x50,0x20,0x2d,0x20,0x41,0x20,0x4c,0x69,0x67,
-0x68,0x74,0x77,0x65,0x69,0x67,0x68,0x74,0x20,0x54,0x43,0x50,0x2f,0x49,0x50,0x20,
-0x53,0x74,0x61,0x63,0x6b,0x3c,0x2f,0x68,0x31,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,
-0x3c,0x70,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x4c,0x6f,0x67,0x69,0x6e,0x20,
-0x73,0x75,0x63,0x63,0x65,0x65,0x64,0x65,0x64,0x2c,0x20,0x73,0x65,0x73,0x73,0x69,
-0x6f,0x6e,0x20,0x61,0x63,0x74,0x69,0x76,0x65,0x2e,0x0d,0x0a,0x20,0x20,0x20,0x20,
-0x3c,0x2f,0x70,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x3c,0x70,0x3e,0x0d,0x0a,0x20,
-0x20,0x20,0x20,0x20,0x43,0x6c,0x69,0x63,0x6b,0x20,0x3c,0x61,0x20,0x68,0x72,0x65,
-0x66,0x3d,0x22,0x6c,0x6f,0x67,0x69,0x6e,0x2e,0x68,0x74,0x6d,0x6c,0x22,0x3e,0x68,
-0x65,0x72,0x65,0x3c,0x2f,0x61,0x3e,0x20,0x74,0x6f,0x20,0x72,0x65,0x74,0x72,0x79,
-0x20,0x6c,0x6f,0x67,0x69,0x6e,0x2e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x3c,0x2f,0x70,
-0x3e,0x0d,0x0a,0x20,0x20,0x20,0x3c,0x2f,0x74,0x64,0x3e,0x0d,0x0a,0x20,0x20,0x20,
-0x3c,0x74,0x64,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x26,0x6e,0x62,0x73,0x70,0x3b,
-0x0d,0x0a,0x20,0x20,0x20,0x3c,0x2f,0x74,0x64,0x3e,0x0d,0x0a,0x20,0x20,0x3c,0x2f,
-0x74,0x72,0x3e,0x0d,0x0a,0x20,0x3c,0x2f,0x74,0x61,0x62,0x6c,0x65,0x3e,0x0d,0x0a,
-0x3c,0x2f,0x62,0x6f,0x64,0x79,0x3e,0x0d,0x0a,0x3c,0x2f,0x68,0x74,0x6d,0x6c,0x3e,
-0x0d,0x0a,};
-
-#if FSDATA_FILE_ALIGNMENT==1
-static const unsigned int dummy_align__ssi_shtml = 6;
-#endif
-static const unsigned char FSDATA_ALIGN_PRE data__ssi_shtml[] FSDATA_ALIGN_POST = {
-/* /ssi.shtml (11 chars) */
-0x2f,0x73,0x73,0x69,0x2e,0x73,0x68,0x74,0x6d,0x6c,0x00,0x00,
-
-/* HTTP header */
-/* "HTTP/1.1 200 OK
-" (17 bytes) */
-0x48,0x54,0x54,0x50,0x2f,0x31,0x2e,0x31,0x20,0x32,0x30,0x30,0x20,0x4f,0x4b,0x0d,
-0x0a,
-/* "Server: lwIP/2.0.3d (http://savannah.nongnu.org/projects/lwip)
-" (64 bytes) */
-0x53,0x65,0x72,0x76,0x65,0x72,0x3a,0x20,0x6c,0x77,0x49,0x50,0x2f,0x32,0x2e,0x30,
-0x2e,0x33,0x64,0x20,0x28,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x73,0x61,0x76,0x61,
-0x6e,0x6e,0x61,0x68,0x2e,0x6e,0x6f,0x6e,0x67,0x6e,0x75,0x2e,0x6f,0x72,0x67,0x2f,
-0x70,0x72,0x6f,0x6a,0x65,0x63,0x74,0x73,0x2f,0x6c,0x77,0x69,0x70,0x29,0x0d,0x0a,
-
-/* "Connection: Close
-" (19 bytes) */
-0x43,0x6f,0x6e,0x6e,0x65,0x63,0x74,0x69,0x6f,0x6e,0x3a,0x20,0x43,0x6c,0x6f,0x73,
-0x65,0x0d,0x0a,
-/* "Content-Type: text/html
-Expires: Fri, 10 Apr 2008 14:00:00 GMT
-Pragma: no-cache
-
-" (85 bytes) */
-0x43,0x6f,0x6e,0x74,0x65,0x6e,0x74,0x2d,0x54,0x79,0x70,0x65,0x3a,0x20,0x74,0x65,
-0x78,0x74,0x2f,0x68,0x74,0x6d,0x6c,0x0d,0x0a,0x45,0x78,0x70,0x69,0x72,0x65,0x73,
-0x3a,0x20,0x46,0x72,0x69,0x2c,0x20,0x31,0x30,0x20,0x41,0x70,0x72,0x20,0x32,0x30,
-0x30,0x38,0x20,0x31,0x34,0x3a,0x30,0x30,0x3a,0x30,0x30,0x20,0x47,0x4d,0x54,0x0d,
-0x0a,0x50,0x72,0x61,0x67,0x6d,0x61,0x3a,0x20,0x6e,0x6f,0x2d,0x63,0x61,0x63,0x68,
-0x65,0x0d,0x0a,0x0d,0x0a,
-/* raw file data (14429 bytes) */
-0x3c,0x68,0x74,0x6d,0x6c,0x3e,0x0d,0x0a,0x3c,0x68,0x65,0x61,0x64,0x3e,0x3c,0x74,
-0x69,0x74,0x6c,0x65,0x3e,0x6c,0x77,0x49,0x50,0x20,0x2d,0x20,0x41,0x20,0x4c,0x69,
-0x67,0x68,0x74,0x77,0x65,0x69,0x67,0x68,0x74,0x20,0x54,0x43,0x50,0x2f,0x49,0x50,
-0x20,0x53,0x74,0x61,0x63,0x6b,0x3c,0x2f,0x74,0x69,0x74,0x6c,0x65,0x3e,0x3c,0x2f,
-0x68,0x65,0x61,0x64,0x3e,0x0d,0x0a,0x3c,0x62,0x6f,0x64,0x79,0x20,0x62,0x67,0x63,
-0x6f,0x6c,0x6f,0x72,0x3d,0x22,0x77,0x68,0x69,0x74,0x65,0x22,0x20,0x74,0x65,0x78,
-0x74,0x3d,0x22,0x62,0x6c,0x61,0x63,0x6b,0x22,0x3e,0x0d,0x0a,0x0d,0x0a,0x20,0x20,
-0x20,0x20,0x3c,0x74,0x61,0x62,0x6c,0x65,0x20,0x77,0x69,0x64,0x74,0x68,0x3d,0x22,
-0x31,0x30,0x30,0x25,0x22,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x3c,0x74,
-0x72,0x20,0x76,0x61,0x6c,0x69,0x67,0x6e,0x3d,0x22,0x74,0x6f,0x70,0x22,0x3e,0x3c,
-0x74,0x64,0x20,0x77,0x69,0x64,0x74,0x68,0x3d,0x22,0x38,0x30,0x22,0x3e,0x09,0x20,
-0x20,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x61,0x20,0x68,0x72,0x65,0x66,0x3d,0x22,0x68,
-0x74,0x74,0x70,0x3a,0x2f,0x2f,0x77,0x77,0x77,0x2e,0x73,0x69,0x63,0x73,0x2e,0x73,
-0x65,0x2f,0x22,0x3e,0x3c,0x69,0x6d,0x67,0x20,0x73,0x72,0x63,0x3d,0x22,0x2f,0x69,
-0x6d,0x67,0x2f,0x73,0x69,0x63,0x73,0x2e,0x67,0x69,0x66,0x22,0x0d,0x0a,0x09,0x20,
-0x20,0x62,0x6f,0x72,0x64,0x65,0x72,0x3d,0x22,0x30,0x22,0x20,0x61,0x6c,0x74,0x3d,
-0x22,0x53,0x49,0x43,0x53,0x20,0x6c,0x6f,0x67,0x6f,0x22,0x20,0x74,0x69,0x74,0x6c,
-0x65,0x3d,0x22,0x53,0x49,0x43,0x53,0x20,0x6c,0x6f,0x67,0x6f,0x22,0x3e,0x3c,0x2f,
-0x61,0x3e,0x0d,0x0a,0x09,0x3c,0x2f,0x74,0x64,0x3e,0x3c,0x74,0x64,0x20,0x77,0x69,
-0x64,0x74,0x68,0x3d,0x22,0x35,0x30,0x30,0x22,0x3e,0x09,0x20,0x20,0x0d,0x0a,0x09,
-0x20,0x20,0x3c,0x68,0x31,0x3e,0x6c,0x77,0x49,0x50,0x20,0x2d,0x20,0x41,0x20,0x4c,
-0x69,0x67,0x68,0x74,0x77,0x65,0x69,0x67,0x68,0x74,0x20,0x54,0x43,0x50,0x2f,0x49,
-0x50,0x20,0x53,0x74,0x61,0x63,0x6b,0x3c,0x2f,0x68,0x31,0x3e,0x0d,0x0a,0x09,0x20,
-0x20,0x3c,0x68,0x31,0x3e,0x3c,0x21,0x2d,0x2d,0x23,0x48,0x65,0x6c,0x6c,0x57,0x6f,
-0x72,0x6c,0x2d,0x2d,0x3e,0x3c,0x2f,0x68,0x31,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x3c,
-0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x54,0x68,0x65,0x20,0x77,0x65,0x62,
-0x20,0x70,0x61,0x67,0x65,0x20,0x79,0x6f,0x75,0x20,0x61,0x72,0x65,0x20,0x77,0x61,
-0x74,0x63,0x68,0x69,0x6e,0x67,0x20,0x77,0x61,0x73,0x20,0x73,0x65,0x72,0x76,0x65,
-0x64,0x20,0x62,0x79,0x20,0x61,0x20,0x73,0x69,0x6d,0x70,0x6c,0x65,0x20,0x77,0x65,
-0x62,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x73,0x65,0x72,0x76,0x65,0x72,0x20,0x72,
-0x75,0x6e,0x6e,0x69,0x6e,0x67,0x20,0x6f,0x6e,0x20,0x74,0x6f,0x70,0x20,0x6f,0x66,
-0x20,0x74,0x68,0x65,0x20,0x6c,0x69,0x67,0x68,0x74,0x77,0x65,0x69,0x67,0x68,0x74,
-0x20,0x54,0x43,0x50,0x2f,0x49,0x50,0x20,0x73,0x74,0x61,0x63,0x6b,0x20,0x3c,0x61,
-0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x68,0x72,0x65,0x66,0x3d,0x22,0x68,0x74,0x74,
-0x70,0x3a,0x2f,0x2f,0x77,0x77,0x77,0x2e,0x73,0x69,0x63,0x73,0x2e,0x73,0x65,0x2f,
-0x7e,0x61,0x64,0x61,0x6d,0x2f,0x6c,0x77,0x69,0x70,0x2f,0x22,0x3e,0x6c,0x77,0x49,
-0x50,0x3c,0x2f,0x61,0x3e,0x2e,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x2f,0x70,0x3e,0x0d,
-0x0a,0x09,0x20,0x20,0x3c,0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x54,0x68,
-0x69,0x73,0x20,0x70,0x61,0x67,0x65,0x20,0x69,0x73,0x20,0x68,0x65,0x72,0x65,0x20,
-0x74,0x6f,0x20,0x74,0x65,0x73,0x74,0x20,0x53,0x53,0x49,0x2c,0x20,0x73,0x6f,0x20,
-0x68,0x65,0x72,0x65,0x20,0x69,0x73,0x20,0x61,0x20,0x63,0x6f,0x75,0x6e,0x74,0x65,
-0x72,0x20,0x61,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x61,0x6e,0x20,0x65,0x78,
-0x61,0x6d,0x70,0x6c,0x65,0x20,0x6f,0x66,0x20,0x63,0x6f,0x6e,0x74,0x65,0x6e,0x74,
-0x20,0x63,0x68,0x61,0x6e,0x67,0x69,0x6e,0x67,0x20,0x66,0x6f,0x72,0x20,0x65,0x76,
-0x65,0x72,0x79,0x20,0x72,0x65,0x71,0x75,0x65,0x73,0x74,0x3a,0x0d,0x0a,0x09,0x20,
-0x20,0x20,0x20,0x22,0x3c,0x21,0x2d,0x2d,0x23,0x63,0x6f,0x75,0x6e,0x74,0x65,0x72,
-0x2d,0x2d,0x3e,0x22,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x2f,0x70,0x3e,0x0d,0x0a,0x09,
-0x20,0x20,0x3c,0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x41,0x6e,0x64,0x20,
-0x68,0x65,0x72,0x65,0x20,0x69,0x73,0x20,0x61,0x6e,0x20,0x65,0x78,0x61,0x6d,0x70,
-0x6c,0x65,0x20,0x6f,0x66,0x20,0x61,0x20,0x74,0x61,0x67,0x20,0x72,0x65,0x73,0x75,
-0x6c,0x74,0x20,0x62,0x75,0x66,0x66,0x65,0x72,0x20,0x72,0x65,0x74,0x75,0x72,0x6e,
-0x20,0x69,0x6e,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x6d,0x75,0x6c,0x74,0x69,0x70,
-0x6c,0x65,0x20,0x70,0x61,0x72,0x74,0x73,0x3a,0x20,0x22,0x3c,0x21,0x2d,0x2d,0x23,
-0x4d,0x75,0x6c,0x74,0x50,0x61,0x72,0x74,0x2d,0x2d,0x3e,0x22,0x0d,0x0a,0x09,0x20,
-0x20,0x3c,0x2f,0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x70,0x3e,0x0d,0x0a,0x09,
-0x20,0x20,0x20,0x20,0x54,0x6f,0x20,0x74,0x65,0x73,0x74,0x20,0x4c,0x57,0x49,0x50,
-0x5f,0x48,0x54,0x54,0x50,0x44,0x5f,0x43,0x47,0x49,0x5f,0x53,0x53,0x49,0x2c,0x20,
-0x68,0x65,0x72,0x65,0x20,0x61,0x72,0x65,0x20,0x74,0x68,0x65,0x20,0x43,0x47,0x49,
-0x20,0x70,0x61,0x72,0x61,0x6d,0x65,0x74,0x65,0x72,0x73,0x3a,0x0d,0x0a,0x09,0x20,
-0x20,0x20,0x20,0x3c,0x21,0x2d,0x2d,0x23,0x43,0x67,0x69,0x50,0x61,0x72,0x61,0x6d,
-0x2d,0x2d,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x2f,0x70,0x3e,0x0d,0x0a,0x09,0x20,
-0x20,0x3c,0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x6c,0x77,0x49,0x50,0x20,
-0x69,0x73,0x20,0x61,0x6e,0x20,0x6f,0x70,0x65,0x6e,0x20,0x73,0x6f,0x75,0x72,0x63,
-0x65,0x20,0x69,0x6d,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,0x61,0x74,0x69,0x6f,0x6e,
-0x20,0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x54,0x43,0x50,0x2f,0x49,0x50,0x0d,0x0a,
-0x09,0x20,0x20,0x20,0x20,0x70,0x72,0x6f,0x74,0x6f,0x63,0x6f,0x6c,0x20,0x73,0x75,
-0x69,0x74,0x65,0x20,0x74,0x68,0x61,0x74,0x20,0x77,0x61,0x73,0x20,0x6f,0x72,0x69,
-0x67,0x69,0x6e,0x61,0x6c,0x6c,0x79,0x20,0x77,0x72,0x69,0x74,0x74,0x65,0x6e,0x20,
-0x62,0x79,0x20,0x3c,0x61,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x68,0x72,0x65,0x66,
-0x3d,0x22,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x77,0x77,0x77,0x2e,0x73,0x69,0x63,
-0x73,0x2e,0x73,0x65,0x2f,0x7e,0x61,0x64,0x61,0x6d,0x2f,0x6c,0x77,0x69,0x70,0x2f,
-0x22,0x3e,0x41,0x64,0x61,0x6d,0x20,0x44,0x75,0x6e,0x6b,0x65,0x6c,0x73,0x0d,0x0a,
-0x09,0x20,0x20,0x20,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x53,0x77,0x65,0x64,
-0x69,0x73,0x68,0x20,0x49,0x6e,0x73,0x74,0x69,0x74,0x75,0x74,0x65,0x20,0x6f,0x66,
-0x20,0x43,0x6f,0x6d,0x70,0x75,0x74,0x65,0x72,0x20,0x53,0x63,0x69,0x65,0x6e,0x63,
-0x65,0x3c,0x2f,0x61,0x3e,0x20,0x62,0x75,0x74,0x20,0x6e,0x6f,0x77,0x20,0x69,0x73,
-0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x62,0x65,0x69,0x6e,0x67,0x20,0x61,0x63,0x74,
-0x69,0x76,0x65,0x6c,0x79,0x20,0x64,0x65,0x76,0x65,0x6c,0x6f,0x70,0x65,0x64,0x20,
-0x62,0x79,0x20,0x61,0x20,0x74,0x65,0x61,0x6d,0x20,0x6f,0x66,0x20,0x64,0x65,0x76,
-0x65,0x6c,0x6f,0x70,0x65,0x72,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x64,0x69,
-0x73,0x74,0x72,0x69,0x62,0x75,0x74,0x65,0x64,0x20,0x77,0x6f,0x72,0x6c,0x64,0x2d,
-0x77,0x69,0x64,0x65,0x2e,0x20,0x53,0x69,0x6e,0x63,0x65,0x20,0x69,0x74,0x27,0x73,
-0x20,0x72,0x65,0x6c,0x65,0x61,0x73,0x65,0x2c,0x20,0x6c,0x77,0x49,0x50,0x20,0x68,
-0x61,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x73,0x70,0x75,0x72,0x72,0x65,0x64,
-0x20,0x61,0x20,0x6c,0x6f,0x74,0x20,0x6f,0x66,0x20,0x69,0x6e,0x74,0x65,0x72,0x65,
-0x73,0x74,0x20,0x61,0x6e,0x64,0x20,0x68,0x61,0x73,0x20,0x62,0x65,0x65,0x6e,0x20,
-0x70,0x6f,0x72,0x74,0x65,0x64,0x20,0x74,0x6f,0x20,0x73,0x65,0x76,0x65,0x72,0x61,
-0x6c,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x70,0x6c,0x61,0x74,0x66,0x6f,0x72,0x6d,
-0x73,0x20,0x61,0x6e,0x64,0x20,0x6f,0x70,0x65,0x72,0x61,0x74,0x69,0x6e,0x67,0x20,
-0x73,0x79,0x73,0x74,0x65,0x6d,0x73,0x2e,0x20,0x6c,0x77,0x49,0x50,0x20,0x63,0x61,
-0x6e,0x20,0x62,0x65,0x20,0x75,0x73,0x65,0x64,0x20,0x65,0x69,0x74,0x68,0x65,0x72,
-0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x77,0x69,0x74,0x68,0x20,0x6f,0x72,0x20,0x77,
-0x69,0x74,0x68,0x6f,0x75,0x74,0x20,0x61,0x6e,0x20,0x75,0x6e,0x64,0x65,0x72,0x6c,
-0x79,0x69,0x6e,0x67,0x20,0x4f,0x53,0x2e,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x2f,0x70,
-0x3e,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x70,
-0x3e,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x6c,0x77,0x49,0x50,0x20,0x69,0x73,0x20,
-0x61,0x6e,0x20,0x6f,0x70,0x65,0x6e,0x20,0x73,0x6f,0x75,0x72,0x63,0x65,0x20,0x69,
-0x6d,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,0x61,0x74,0x69,0x6f,0x6e,0x20,0x6f,0x66,
-0x20,0x74,0x68,0x65,0x20,0x54,0x43,0x50,0x2f,0x49,0x50,0x0d,0x0a,0x09,0x20,0x20,
-0x20,0x20,0x70,0x72,0x6f,0x74,0x6f,0x63,0x6f,0x6c,0x20,0x73,0x75,0x69,0x74,0x65,
-0x20,0x74,0x68,0x61,0x74,0x20,0x77,0x61,0x73,0x20,0x6f,0x72,0x69,0x67,0x69,0x6e,
-0x61,0x6c,0x6c,0x79,0x20,0x77,0x72,0x69,0x74,0x74,0x65,0x6e,0x20,0x62,0x79,0x20,
-0x3c,0x61,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x68,0x72,0x65,0x66,0x3d,0x22,0x68,
-0x74,0x74,0x70,0x3a,0x2f,0x2f,0x77,0x77,0x77,0x2e,0x73,0x69,0x63,0x73,0x2e,0x73,
-0x65,0x2f,0x7e,0x61,0x64,0x61,0x6d,0x2f,0x6c,0x77,0x69,0x70,0x2f,0x22,0x3e,0x41,
-0x64,0x61,0x6d,0x20,0x44,0x75,0x6e,0x6b,0x65,0x6c,0x73,0x0d,0x0a,0x09,0x20,0x20,
-0x20,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x53,0x77,0x65,0x64,0x69,0x73,0x68,
-0x20,0x49,0x6e,0x73,0x74,0x69,0x74,0x75,0x74,0x65,0x20,0x6f,0x66,0x20,0x43,0x6f,
-0x6d,0x70,0x75,0x74,0x65,0x72,0x20,0x53,0x63,0x69,0x65,0x6e,0x63,0x65,0x3c,0x2f,
-0x61,0x3e,0x20,0x62,0x75,0x74,0x20,0x6e,0x6f,0x77,0x20,0x69,0x73,0x0d,0x0a,0x09,
-0x20,0x20,0x20,0x20,0x62,0x65,0x69,0x6e,0x67,0x20,0x61,0x63,0x74,0x69,0x76,0x65,
-0x6c,0x79,0x20,0x64,0x65,0x76,0x65,0x6c,0x6f,0x70,0x65,0x64,0x20,0x62,0x79,0x20,
-0x61,0x20,0x74,0x65,0x61,0x6d,0x20,0x6f,0x66,0x20,0x64,0x65,0x76,0x65,0x6c,0x6f,
-0x70,0x65,0x72,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x64,0x69,0x73,0x74,0x72,
-0x69,0x62,0x75,0x74,0x65,0x64,0x20,0x77,0x6f,0x72,0x6c,0x64,0x2d,0x77,0x69,0x64,
-0x65,0x2e,0x20,0x53,0x69,0x6e,0x63,0x65,0x20,0x69,0x74,0x27,0x73,0x20,0x72,0x65,
-0x6c,0x65,0x61,0x73,0x65,0x2c,0x20,0x6c,0x77,0x49,0x50,0x20,0x68,0x61,0x73,0x0d,
-0x0a,0x09,0x20,0x20,0x20,0x20,0x73,0x70,0x75,0x72,0x72,0x65,0x64,0x20,0x61,0x20,
-0x6c,0x6f,0x74,0x20,0x6f,0x66,0x20,0x69,0x6e,0x74,0x65,0x72,0x65,0x73,0x74,0x20,
-0x61,0x6e,0x64,0x20,0x68,0x61,0x73,0x20,0x62,0x65,0x65,0x6e,0x20,0x70,0x6f,0x72,
-0x74,0x65,0x64,0x20,0x74,0x6f,0x20,0x73,0x65,0x76,0x65,0x72,0x61,0x6c,0x0d,0x0a,
-0x09,0x20,0x20,0x20,0x20,0x70,0x6c,0x61,0x74,0x66,0x6f,0x72,0x6d,0x73,0x20,0x61,
-0x6e,0x64,0x20,0x6f,0x70,0x65,0x72,0x61,0x74,0x69,0x6e,0x67,0x20,0x73,0x79,0x73,
-0x74,0x65,0x6d,0x73,0x2e,0x20,0x6c,0x77,0x49,0x50,0x20,0x63,0x61,0x6e,0x20,0x62,
-0x65,0x20,0x75,0x73,0x65,0x64,0x20,0x65,0x69,0x74,0x68,0x65,0x72,0x0d,0x0a,0x09,
-0x20,0x20,0x20,0x20,0x77,0x69,0x74,0x68,0x20,0x6f,0x72,0x20,0x77,0x69,0x74,0x68,
-0x6f,0x75,0x74,0x20,0x61,0x6e,0x20,0x75,0x6e,0x64,0x65,0x72,0x6c,0x79,0x69,0x6e,
-0x67,0x20,0x4f,0x53,0x2e,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x2f,0x70,0x3e,0x0d,0x0a,
-0x09,0x20,0x20,0x3c,0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x6c,0x77,0x49,
-0x50,0x20,0x69,0x73,0x20,0x61,0x6e,0x20,0x6f,0x70,0x65,0x6e,0x20,0x73,0x6f,0x75,
-0x72,0x63,0x65,0x20,0x69,0x6d,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,0x61,0x74,0x69,
-0x6f,0x6e,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x54,0x43,0x50,0x2f,0x49,0x50,
-0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x70,0x72,0x6f,0x74,0x6f,0x63,0x6f,0x6c,0x20,
-0x73,0x75,0x69,0x74,0x65,0x20,0x74,0x68,0x61,0x74,0x20,0x77,0x61,0x73,0x20,0x6f,
-0x72,0x69,0x67,0x69,0x6e,0x61,0x6c,0x6c,0x79,0x20,0x77,0x72,0x69,0x74,0x74,0x65,
-0x6e,0x20,0x62,0x79,0x20,0x3c,0x61,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x68,0x72,
-0x65,0x66,0x3d,0x22,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x77,0x77,0x77,0x2e,0x73,
-0x69,0x63,0x73,0x2e,0x73,0x65,0x2f,0x7e,0x61,0x64,0x61,0x6d,0x2f,0x6c,0x77,0x69,
-0x70,0x2f,0x22,0x3e,0x41,0x64,0x61,0x6d,0x20,0x44,0x75,0x6e,0x6b,0x65,0x6c,0x73,
-0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x53,0x77,
-0x65,0x64,0x69,0x73,0x68,0x20,0x49,0x6e,0x73,0x74,0x69,0x74,0x75,0x74,0x65,0x20,
-0x6f,0x66,0x20,0x43,0x6f,0x6d,0x70,0x75,0x74,0x65,0x72,0x20,0x53,0x63,0x69,0x65,
-0x6e,0x63,0x65,0x3c,0x2f,0x61,0x3e,0x20,0x62,0x75,0x74,0x20,0x6e,0x6f,0x77,0x20,
-0x69,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x62,0x65,0x69,0x6e,0x67,0x20,0x61,
-0x63,0x74,0x69,0x76,0x65,0x6c,0x79,0x20,0x64,0x65,0x76,0x65,0x6c,0x6f,0x70,0x65,
-0x64,0x20,0x62,0x79,0x20,0x61,0x20,0x74,0x65,0x61,0x6d,0x20,0x6f,0x66,0x20,0x64,
-0x65,0x76,0x65,0x6c,0x6f,0x70,0x65,0x72,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,
-0x64,0x69,0x73,0x74,0x72,0x69,0x62,0x75,0x74,0x65,0x64,0x20,0x77,0x6f,0x72,0x6c,
-0x64,0x2d,0x77,0x69,0x64,0x65,0x2e,0x20,0x53,0x69,0x6e,0x63,0x65,0x20,0x69,0x74,
-0x27,0x73,0x20,0x72,0x65,0x6c,0x65,0x61,0x73,0x65,0x2c,0x20,0x6c,0x77,0x49,0x50,
-0x20,0x68,0x61,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x73,0x70,0x75,0x72,0x72,
-0x65,0x64,0x20,0x61,0x20,0x6c,0x6f,0x74,0x20,0x6f,0x66,0x20,0x69,0x6e,0x74,0x65,
-0x72,0x65,0x73,0x74,0x20,0x61,0x6e,0x64,0x20,0x68,0x61,0x73,0x20,0x62,0x65,0x65,
-0x6e,0x20,0x70,0x6f,0x72,0x74,0x65,0x64,0x20,0x74,0x6f,0x20,0x73,0x65,0x76,0x65,
-0x72,0x61,0x6c,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x70,0x6c,0x61,0x74,0x66,0x6f,
-0x72,0x6d,0x73,0x20,0x61,0x6e,0x64,0x20,0x6f,0x70,0x65,0x72,0x61,0x74,0x69,0x6e,
-0x67,0x20,0x73,0x79,0x73,0x74,0x65,0x6d,0x73,0x2e,0x20,0x6c,0x77,0x49,0x50,0x20,
-0x63,0x61,0x6e,0x20,0x62,0x65,0x20,0x75,0x73,0x65,0x64,0x20,0x65,0x69,0x74,0x68,
-0x65,0x72,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x77,0x69,0x74,0x68,0x20,0x6f,0x72,
-0x20,0x77,0x69,0x74,0x68,0x6f,0x75,0x74,0x20,0x61,0x6e,0x20,0x75,0x6e,0x64,0x65,
-0x72,0x6c,0x79,0x69,0x6e,0x67,0x20,0x4f,0x53,0x2e,0x0d,0x0a,0x09,0x20,0x20,0x3c,
-0x2f,0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,
-0x20,0x20,0x6c,0x77,0x49,0x50,0x20,0x69,0x73,0x20,0x61,0x6e,0x20,0x6f,0x70,0x65,
-0x6e,0x20,0x73,0x6f,0x75,0x72,0x63,0x65,0x20,0x69,0x6d,0x70,0x6c,0x65,0x6d,0x65,
-0x6e,0x74,0x61,0x74,0x69,0x6f,0x6e,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x54,
-0x43,0x50,0x2f,0x49,0x50,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x70,0x72,0x6f,0x74,
-0x6f,0x63,0x6f,0x6c,0x20,0x73,0x75,0x69,0x74,0x65,0x20,0x74,0x68,0x61,0x74,0x20,
-0x77,0x61,0x73,0x20,0x6f,0x72,0x69,0x67,0x69,0x6e,0x61,0x6c,0x6c,0x79,0x20,0x77,
-0x72,0x69,0x74,0x74,0x65,0x6e,0x20,0x62,0x79,0x20,0x3c,0x61,0x0d,0x0a,0x09,0x20,
-0x20,0x20,0x20,0x68,0x72,0x65,0x66,0x3d,0x22,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,
-0x77,0x77,0x77,0x2e,0x73,0x69,0x63,0x73,0x2e,0x73,0x65,0x2f,0x7e,0x61,0x64,0x61,
-0x6d,0x2f,0x6c,0x77,0x69,0x70,0x2f,0x22,0x3e,0x41,0x64,0x61,0x6d,0x20,0x44,0x75,
-0x6e,0x6b,0x65,0x6c,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x6f,0x66,0x20,0x74,
-0x68,0x65,0x20,0x53,0x77,0x65,0x64,0x69,0x73,0x68,0x20,0x49,0x6e,0x73,0x74,0x69,
-0x74,0x75,0x74,0x65,0x20,0x6f,0x66,0x20,0x43,0x6f,0x6d,0x70,0x75,0x74,0x65,0x72,
-0x20,0x53,0x63,0x69,0x65,0x6e,0x63,0x65,0x3c,0x2f,0x61,0x3e,0x20,0x62,0x75,0x74,
-0x20,0x6e,0x6f,0x77,0x20,0x69,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x62,0x65,
-0x69,0x6e,0x67,0x20,0x61,0x63,0x74,0x69,0x76,0x65,0x6c,0x79,0x20,0x64,0x65,0x76,
-0x65,0x6c,0x6f,0x70,0x65,0x64,0x20,0x62,0x79,0x20,0x61,0x20,0x74,0x65,0x61,0x6d,
-0x20,0x6f,0x66,0x20,0x64,0x65,0x76,0x65,0x6c,0x6f,0x70,0x65,0x72,0x73,0x0d,0x0a,
-0x09,0x20,0x20,0x20,0x20,0x64,0x69,0x73,0x74,0x72,0x69,0x62,0x75,0x74,0x65,0x64,
-0x20,0x77,0x6f,0x72,0x6c,0x64,0x2d,0x77,0x69,0x64,0x65,0x2e,0x20,0x53,0x69,0x6e,
-0x63,0x65,0x20,0x69,0x74,0x27,0x73,0x20,0x72,0x65,0x6c,0x65,0x61,0x73,0x65,0x2c,
-0x20,0x6c,0x77,0x49,0x50,0x20,0x68,0x61,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,
-0x73,0x70,0x75,0x72,0x72,0x65,0x64,0x20,0x61,0x20,0x6c,0x6f,0x74,0x20,0x6f,0x66,
-0x20,0x69,0x6e,0x74,0x65,0x72,0x65,0x73,0x74,0x20,0x61,0x6e,0x64,0x20,0x68,0x61,
-0x73,0x20,0x62,0x65,0x65,0x6e,0x20,0x70,0x6f,0x72,0x74,0x65,0x64,0x20,0x74,0x6f,
-0x20,0x73,0x65,0x76,0x65,0x72,0x61,0x6c,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x70,
-0x6c,0x61,0x74,0x66,0x6f,0x72,0x6d,0x73,0x20,0x61,0x6e,0x64,0x20,0x6f,0x70,0x65,
-0x72,0x61,0x74,0x69,0x6e,0x67,0x20,0x73,0x79,0x73,0x74,0x65,0x6d,0x73,0x2e,0x20,
-0x6c,0x77,0x49,0x50,0x20,0x63,0x61,0x6e,0x20,0x62,0x65,0x20,0x75,0x73,0x65,0x64,
-0x20,0x65,0x69,0x74,0x68,0x65,0x72,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x77,0x69,
-0x74,0x68,0x20,0x6f,0x72,0x20,0x77,0x69,0x74,0x68,0x6f,0x75,0x74,0x20,0x61,0x6e,
-0x20,0x75,0x6e,0x64,0x65,0x72,0x6c,0x79,0x69,0x6e,0x67,0x20,0x4f,0x53,0x2e,0x0d,
-0x0a,0x09,0x20,0x20,0x3c,0x2f,0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x70,0x3e,
-0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x6c,0x77,0x49,0x50,0x20,0x69,0x73,0x20,0x61,
-0x6e,0x20,0x6f,0x70,0x65,0x6e,0x20,0x73,0x6f,0x75,0x72,0x63,0x65,0x20,0x69,0x6d,
-0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,0x61,0x74,0x69,0x6f,0x6e,0x20,0x6f,0x66,0x20,
-0x74,0x68,0x65,0x20,0x54,0x43,0x50,0x2f,0x49,0x50,0x0d,0x0a,0x09,0x20,0x20,0x20,
-0x20,0x70,0x72,0x6f,0x74,0x6f,0x63,0x6f,0x6c,0x20,0x73,0x75,0x69,0x74,0x65,0x20,
-0x74,0x68,0x61,0x74,0x20,0x77,0x61,0x73,0x20,0x6f,0x72,0x69,0x67,0x69,0x6e,0x61,
-0x6c,0x6c,0x79,0x20,0x77,0x72,0x69,0x74,0x74,0x65,0x6e,0x20,0x62,0x79,0x20,0x3c,
-0x61,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x68,0x72,0x65,0x66,0x3d,0x22,0x68,0x74,
-0x74,0x70,0x3a,0x2f,0x2f,0x77,0x77,0x77,0x2e,0x73,0x69,0x63,0x73,0x2e,0x73,0x65,
-0x2f,0x7e,0x61,0x64,0x61,0x6d,0x2f,0x6c,0x77,0x69,0x70,0x2f,0x22,0x3e,0x41,0x64,
-0x61,0x6d,0x20,0x44,0x75,0x6e,0x6b,0x65,0x6c,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,
-0x20,0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x53,0x77,0x65,0x64,0x69,0x73,0x68,0x20,
-0x49,0x6e,0x73,0x74,0x69,0x74,0x75,0x74,0x65,0x20,0x6f,0x66,0x20,0x43,0x6f,0x6d,
-0x70,0x75,0x74,0x65,0x72,0x20,0x53,0x63,0x69,0x65,0x6e,0x63,0x65,0x3c,0x2f,0x61,
-0x3e,0x20,0x62,0x75,0x74,0x20,0x6e,0x6f,0x77,0x20,0x69,0x73,0x0d,0x0a,0x09,0x20,
-0x20,0x20,0x20,0x62,0x65,0x69,0x6e,0x67,0x20,0x61,0x63,0x74,0x69,0x76,0x65,0x6c,
-0x79,0x20,0x64,0x65,0x76,0x65,0x6c,0x6f,0x70,0x65,0x64,0x20,0x62,0x79,0x20,0x61,
-0x20,0x74,0x65,0x61,0x6d,0x20,0x6f,0x66,0x20,0x64,0x65,0x76,0x65,0x6c,0x6f,0x70,
-0x65,0x72,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x64,0x69,0x73,0x74,0x72,0x69,
-0x62,0x75,0x74,0x65,0x64,0x20,0x77,0x6f,0x72,0x6c,0x64,0x2d,0x77,0x69,0x64,0x65,
-0x2e,0x20,0x53,0x69,0x6e,0x63,0x65,0x20,0x69,0x74,0x27,0x73,0x20,0x72,0x65,0x6c,
-0x65,0x61,0x73,0x65,0x2c,0x20,0x6c,0x77,0x49,0x50,0x20,0x68,0x61,0x73,0x0d,0x0a,
-0x09,0x20,0x20,0x20,0x20,0x73,0x70,0x75,0x72,0x72,0x65,0x64,0x20,0x61,0x20,0x6c,
-0x6f,0x74,0x20,0x6f,0x66,0x20,0x69,0x6e,0x74,0x65,0x72,0x65,0x73,0x74,0x20,0x61,
-0x6e,0x64,0x20,0x68,0x61,0x73,0x20,0x62,0x65,0x65,0x6e,0x20,0x70,0x6f,0x72,0x74,
-0x65,0x64,0x20,0x74,0x6f,0x20,0x73,0x65,0x76,0x65,0x72,0x61,0x6c,0x0d,0x0a,0x09,
-0x20,0x20,0x20,0x20,0x70,0x6c,0x61,0x74,0x66,0x6f,0x72,0x6d,0x73,0x20,0x61,0x6e,
-0x64,0x20,0x6f,0x70,0x65,0x72,0x61,0x74,0x69,0x6e,0x67,0x20,0x73,0x79,0x73,0x74,
-0x65,0x6d,0x73,0x2e,0x20,0x6c,0x77,0x49,0x50,0x20,0x63,0x61,0x6e,0x20,0x62,0x65,
-0x20,0x75,0x73,0x65,0x64,0x20,0x65,0x69,0x74,0x68,0x65,0x72,0x0d,0x0a,0x09,0x20,
-0x20,0x20,0x20,0x77,0x69,0x74,0x68,0x20,0x6f,0x72,0x20,0x77,0x69,0x74,0x68,0x6f,
-0x75,0x74,0x20,0x61,0x6e,0x20,0x75,0x6e,0x64,0x65,0x72,0x6c,0x79,0x69,0x6e,0x67,
-0x20,0x4f,0x53,0x2e,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x2f,0x70,0x3e,0x0d,0x0a,0x09,
-0x20,0x20,0x3c,0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x6c,0x77,0x49,0x50,
-0x20,0x69,0x73,0x20,0x61,0x6e,0x20,0x6f,0x70,0x65,0x6e,0x20,0x73,0x6f,0x75,0x72,
-0x63,0x65,0x20,0x69,0x6d,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,0x61,0x74,0x69,0x6f,
-0x6e,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x54,0x43,0x50,0x2f,0x49,0x50,0x0d,
-0x0a,0x09,0x20,0x20,0x20,0x20,0x70,0x72,0x6f,0x74,0x6f,0x63,0x6f,0x6c,0x20,0x73,
-0x75,0x69,0x74,0x65,0x20,0x74,0x68,0x61,0x74,0x20,0x77,0x61,0x73,0x20,0x6f,0x72,
-0x69,0x67,0x69,0x6e,0x61,0x6c,0x6c,0x79,0x20,0x77,0x72,0x69,0x74,0x74,0x65,0x6e,
-0x20,0x62,0x79,0x20,0x3c,0x61,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x68,0x72,0x65,
-0x66,0x3d,0x22,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x77,0x77,0x77,0x2e,0x73,0x69,
-0x63,0x73,0x2e,0x73,0x65,0x2f,0x7e,0x61,0x64,0x61,0x6d,0x2f,0x6c,0x77,0x69,0x70,
-0x2f,0x22,0x3e,0x41,0x64,0x61,0x6d,0x20,0x44,0x75,0x6e,0x6b,0x65,0x6c,0x73,0x0d,
-0x0a,0x09,0x20,0x20,0x20,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x53,0x77,0x65,
-0x64,0x69,0x73,0x68,0x20,0x49,0x6e,0x73,0x74,0x69,0x74,0x75,0x74,0x65,0x20,0x6f,
-0x66,0x20,0x43,0x6f,0x6d,0x70,0x75,0x74,0x65,0x72,0x20,0x53,0x63,0x69,0x65,0x6e,
-0x63,0x65,0x3c,0x2f,0x61,0x3e,0x20,0x62,0x75,0x74,0x20,0x6e,0x6f,0x77,0x20,0x69,
-0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x62,0x65,0x69,0x6e,0x67,0x20,0x61,0x63,
-0x74,0x69,0x76,0x65,0x6c,0x79,0x20,0x64,0x65,0x76,0x65,0x6c,0x6f,0x70,0x65,0x64,
-0x20,0x62,0x79,0x20,0x61,0x20,0x74,0x65,0x61,0x6d,0x20,0x6f,0x66,0x20,0x64,0x65,
-0x76,0x65,0x6c,0x6f,0x70,0x65,0x72,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x64,
-0x69,0x73,0x74,0x72,0x69,0x62,0x75,0x74,0x65,0x64,0x20,0x77,0x6f,0x72,0x6c,0x64,
-0x2d,0x77,0x69,0x64,0x65,0x2e,0x20,0x53,0x69,0x6e,0x63,0x65,0x20,0x69,0x74,0x27,
-0x73,0x20,0x72,0x65,0x6c,0x65,0x61,0x73,0x65,0x2c,0x20,0x6c,0x77,0x49,0x50,0x20,
-0x68,0x61,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x73,0x70,0x75,0x72,0x72,0x65,
-0x64,0x20,0x61,0x20,0x6c,0x6f,0x74,0x20,0x6f,0x66,0x20,0x69,0x6e,0x74,0x65,0x72,
-0x65,0x73,0x74,0x20,0x61,0x6e,0x64,0x20,0x68,0x61,0x73,0x20,0x62,0x65,0x65,0x6e,
-0x20,0x70,0x6f,0x72,0x74,0x65,0x64,0x20,0x74,0x6f,0x20,0x73,0x65,0x76,0x65,0x72,
-0x61,0x6c,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x70,0x6c,0x61,0x74,0x66,0x6f,0x72,
-0x6d,0x73,0x20,0x61,0x6e,0x64,0x20,0x6f,0x70,0x65,0x72,0x61,0x74,0x69,0x6e,0x67,
-0x20,0x73,0x79,0x73,0x74,0x65,0x6d,0x73,0x2e,0x20,0x6c,0x77,0x49,0x50,0x20,0x63,
-0x61,0x6e,0x20,0x62,0x65,0x20,0x75,0x73,0x65,0x64,0x20,0x65,0x69,0x74,0x68,0x65,
-0x72,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x77,0x69,0x74,0x68,0x20,0x6f,0x72,0x20,
-0x77,0x69,0x74,0x68,0x6f,0x75,0x74,0x20,0x61,0x6e,0x20,0x75,0x6e,0x64,0x65,0x72,
-0x6c,0x79,0x69,0x6e,0x67,0x20,0x4f,0x53,0x2e,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x2f,
-0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x20,
-0x20,0x6c,0x77,0x49,0x50,0x20,0x69,0x73,0x20,0x61,0x6e,0x20,0x6f,0x70,0x65,0x6e,
-0x20,0x73,0x6f,0x75,0x72,0x63,0x65,0x20,0x69,0x6d,0x70,0x6c,0x65,0x6d,0x65,0x6e,
-0x74,0x61,0x74,0x69,0x6f,0x6e,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x54,0x43,
-0x50,0x2f,0x49,0x50,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x70,0x72,0x6f,0x74,0x6f,
-0x63,0x6f,0x6c,0x20,0x73,0x75,0x69,0x74,0x65,0x20,0x74,0x68,0x61,0x74,0x20,0x77,
-0x61,0x73,0x20,0x6f,0x72,0x69,0x67,0x69,0x6e,0x61,0x6c,0x6c,0x79,0x20,0x77,0x72,
-0x69,0x74,0x74,0x65,0x6e,0x20,0x62,0x79,0x20,0x3c,0x61,0x0d,0x0a,0x09,0x20,0x20,
-0x20,0x20,0x68,0x72,0x65,0x66,0x3d,0x22,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x77,
-0x77,0x77,0x2e,0x73,0x69,0x63,0x73,0x2e,0x73,0x65,0x2f,0x7e,0x61,0x64,0x61,0x6d,
-0x2f,0x6c,0x77,0x69,0x70,0x2f,0x22,0x3e,0x41,0x64,0x61,0x6d,0x20,0x44,0x75,0x6e,
-0x6b,0x65,0x6c,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x6f,0x66,0x20,0x74,0x68,
-0x65,0x20,0x53,0x77,0x65,0x64,0x69,0x73,0x68,0x20,0x49,0x6e,0x73,0x74,0x69,0x74,
-0x75,0x74,0x65,0x20,0x6f,0x66,0x20,0x43,0x6f,0x6d,0x70,0x75,0x74,0x65,0x72,0x20,
-0x53,0x63,0x69,0x65,0x6e,0x63,0x65,0x3c,0x2f,0x61,0x3e,0x20,0x62,0x75,0x74,0x20,
-0x6e,0x6f,0x77,0x20,0x69,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x62,0x65,0x69,
-0x6e,0x67,0x20,0x61,0x63,0x74,0x69,0x76,0x65,0x6c,0x79,0x20,0x64,0x65,0x76,0x65,
-0x6c,0x6f,0x70,0x65,0x64,0x20,0x62,0x79,0x20,0x61,0x20,0x74,0x65,0x61,0x6d,0x20,
-0x6f,0x66,0x20,0x64,0x65,0x76,0x65,0x6c,0x6f,0x70,0x65,0x72,0x73,0x0d,0x0a,0x09,
-0x20,0x20,0x20,0x20,0x64,0x69,0x73,0x74,0x72,0x69,0x62,0x75,0x74,0x65,0x64,0x20,
-0x77,0x6f,0x72,0x6c,0x64,0x2d,0x77,0x69,0x64,0x65,0x2e,0x20,0x53,0x69,0x6e,0x63,
-0x65,0x20,0x69,0x74,0x27,0x73,0x20,0x72,0x65,0x6c,0x65,0x61,0x73,0x65,0x2c,0x20,
-0x6c,0x77,0x49,0x50,0x20,0x68,0x61,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x73,
-0x70,0x75,0x72,0x72,0x65,0x64,0x20,0x61,0x20,0x6c,0x6f,0x74,0x20,0x6f,0x66,0x20,
-0x69,0x6e,0x74,0x65,0x72,0x65,0x73,0x74,0x20,0x61,0x6e,0x64,0x20,0x68,0x61,0x73,
-0x20,0x62,0x65,0x65,0x6e,0x20,0x70,0x6f,0x72,0x74,0x65,0x64,0x20,0x74,0x6f,0x20,
-0x73,0x65,0x76,0x65,0x72,0x61,0x6c,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x70,0x6c,
-0x61,0x74,0x66,0x6f,0x72,0x6d,0x73,0x20,0x61,0x6e,0x64,0x20,0x6f,0x70,0x65,0x72,
-0x61,0x74,0x69,0x6e,0x67,0x20,0x73,0x79,0x73,0x74,0x65,0x6d,0x73,0x2e,0x20,0x6c,
-0x77,0x49,0x50,0x20,0x63,0x61,0x6e,0x20,0x62,0x65,0x20,0x75,0x73,0x65,0x64,0x20,
-0x65,0x69,0x74,0x68,0x65,0x72,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x77,0x69,0x74,
-0x68,0x20,0x6f,0x72,0x20,0x77,0x69,0x74,0x68,0x6f,0x75,0x74,0x20,0x61,0x6e,0x20,
-0x75,0x6e,0x64,0x65,0x72,0x6c,0x79,0x69,0x6e,0x67,0x20,0x4f,0x53,0x2e,0x0d,0x0a,
-0x09,0x20,0x20,0x3c,0x2f,0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x70,0x3e,0x0d,
-0x0a,0x09,0x20,0x20,0x20,0x20,0x6c,0x77,0x49,0x50,0x20,0x69,0x73,0x20,0x61,0x6e,
-0x20,0x6f,0x70,0x65,0x6e,0x20,0x73,0x6f,0x75,0x72,0x63,0x65,0x20,0x69,0x6d,0x70,
-0x6c,0x65,0x6d,0x65,0x6e,0x74,0x61,0x74,0x69,0x6f,0x6e,0x20,0x6f,0x66,0x20,0x74,
-0x68,0x65,0x20,0x54,0x43,0x50,0x2f,0x49,0x50,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,
-0x70,0x72,0x6f,0x74,0x6f,0x63,0x6f,0x6c,0x20,0x73,0x75,0x69,0x74,0x65,0x20,0x74,
-0x68,0x61,0x74,0x20,0x77,0x61,0x73,0x20,0x6f,0x72,0x69,0x67,0x69,0x6e,0x61,0x6c,
-0x6c,0x79,0x20,0x77,0x72,0x69,0x74,0x74,0x65,0x6e,0x20,0x62,0x79,0x20,0x3c,0x61,
-0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x68,0x72,0x65,0x66,0x3d,0x22,0x68,0x74,0x74,
-0x70,0x3a,0x2f,0x2f,0x77,0x77,0x77,0x2e,0x73,0x69,0x63,0x73,0x2e,0x73,0x65,0x2f,
-0x7e,0x61,0x64,0x61,0x6d,0x2f,0x6c,0x77,0x69,0x70,0x2f,0x22,0x3e,0x41,0x64,0x61,
-0x6d,0x20,0x44,0x75,0x6e,0x6b,0x65,0x6c,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,
-0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x53,0x77,0x65,0x64,0x69,0x73,0x68,0x20,0x49,
-0x6e,0x73,0x74,0x69,0x74,0x75,0x74,0x65,0x20,0x6f,0x66,0x20,0x43,0x6f,0x6d,0x70,
-0x75,0x74,0x65,0x72,0x20,0x53,0x63,0x69,0x65,0x6e,0x63,0x65,0x3c,0x2f,0x61,0x3e,
-0x20,0x62,0x75,0x74,0x20,0x6e,0x6f,0x77,0x20,0x69,0x73,0x0d,0x0a,0x09,0x20,0x20,
-0x20,0x20,0x62,0x65,0x69,0x6e,0x67,0x20,0x61,0x63,0x74,0x69,0x76,0x65,0x6c,0x79,
-0x20,0x64,0x65,0x76,0x65,0x6c,0x6f,0x70,0x65,0x64,0x20,0x62,0x79,0x20,0x61,0x20,
-0x74,0x65,0x61,0x6d,0x20,0x6f,0x66,0x20,0x64,0x65,0x76,0x65,0x6c,0x6f,0x70,0x65,
-0x72,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x64,0x69,0x73,0x74,0x72,0x69,0x62,
-0x75,0x74,0x65,0x64,0x20,0x77,0x6f,0x72,0x6c,0x64,0x2d,0x77,0x69,0x64,0x65,0x2e,
-0x20,0x53,0x69,0x6e,0x63,0x65,0x20,0x69,0x74,0x27,0x73,0x20,0x72,0x65,0x6c,0x65,
-0x61,0x73,0x65,0x2c,0x20,0x6c,0x77,0x49,0x50,0x20,0x68,0x61,0x73,0x0d,0x0a,0x09,
-0x20,0x20,0x20,0x20,0x73,0x70,0x75,0x72,0x72,0x65,0x64,0x20,0x61,0x20,0x6c,0x6f,
-0x74,0x20,0x6f,0x66,0x20,0x69,0x6e,0x74,0x65,0x72,0x65,0x73,0x74,0x20,0x61,0x6e,
-0x64,0x20,0x68,0x61,0x73,0x20,0x62,0x65,0x65,0x6e,0x20,0x70,0x6f,0x72,0x74,0x65,
-0x64,0x20,0x74,0x6f,0x20,0x73,0x65,0x76,0x65,0x72,0x61,0x6c,0x0d,0x0a,0x09,0x20,
-0x20,0x20,0x20,0x70,0x6c,0x61,0x74,0x66,0x6f,0x72,0x6d,0x73,0x20,0x61,0x6e,0x64,
-0x20,0x6f,0x70,0x65,0x72,0x61,0x74,0x69,0x6e,0x67,0x20,0x73,0x79,0x73,0x74,0x65,
-0x6d,0x73,0x2e,0x20,0x6c,0x77,0x49,0x50,0x20,0x63,0x61,0x6e,0x20,0x62,0x65,0x20,
-0x75,0x73,0x65,0x64,0x20,0x65,0x69,0x74,0x68,0x65,0x72,0x0d,0x0a,0x09,0x20,0x20,
-0x20,0x20,0x77,0x69,0x74,0x68,0x20,0x6f,0x72,0x20,0x77,0x69,0x74,0x68,0x6f,0x75,
-0x74,0x20,0x61,0x6e,0x20,0x75,0x6e,0x64,0x65,0x72,0x6c,0x79,0x69,0x6e,0x67,0x20,
-0x4f,0x53,0x2e,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x2f,0x70,0x3e,0x0d,0x0a,0x09,0x20,
-0x20,0x3c,0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x6c,0x77,0x49,0x50,0x20,
-0x69,0x73,0x20,0x61,0x6e,0x20,0x6f,0x70,0x65,0x6e,0x20,0x73,0x6f,0x75,0x72,0x63,
-0x65,0x20,0x69,0x6d,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,0x61,0x74,0x69,0x6f,0x6e,
-0x20,0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x54,0x43,0x50,0x2f,0x49,0x50,0x0d,0x0a,
-0x09,0x20,0x20,0x20,0x20,0x70,0x72,0x6f,0x74,0x6f,0x63,0x6f,0x6c,0x20,0x73,0x75,
-0x69,0x74,0x65,0x20,0x74,0x68,0x61,0x74,0x20,0x77,0x61,0x73,0x20,0x6f,0x72,0x69,
-0x67,0x69,0x6e,0x61,0x6c,0x6c,0x79,0x20,0x77,0x72,0x69,0x74,0x74,0x65,0x6e,0x20,
-0x62,0x79,0x20,0x3c,0x61,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x68,0x72,0x65,0x66,
-0x3d,0x22,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x77,0x77,0x77,0x2e,0x73,0x69,0x63,
-0x73,0x2e,0x73,0x65,0x2f,0x7e,0x61,0x64,0x61,0x6d,0x2f,0x6c,0x77,0x69,0x70,0x2f,
-0x22,0x3e,0x41,0x64,0x61,0x6d,0x20,0x44,0x75,0x6e,0x6b,0x65,0x6c,0x73,0x0d,0x0a,
-0x09,0x20,0x20,0x20,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x53,0x77,0x65,0x64,
-0x69,0x73,0x68,0x20,0x49,0x6e,0x73,0x74,0x69,0x74,0x75,0x74,0x65,0x20,0x6f,0x66,
-0x20,0x43,0x6f,0x6d,0x70,0x75,0x74,0x65,0x72,0x20,0x53,0x63,0x69,0x65,0x6e,0x63,
-0x65,0x3c,0x2f,0x61,0x3e,0x20,0x62,0x75,0x74,0x20,0x6e,0x6f,0x77,0x20,0x69,0x73,
-0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x62,0x65,0x69,0x6e,0x67,0x20,0x61,0x63,0x74,
-0x69,0x76,0x65,0x6c,0x79,0x20,0x64,0x65,0x76,0x65,0x6c,0x6f,0x70,0x65,0x64,0x20,
-0x62,0x79,0x20,0x61,0x20,0x74,0x65,0x61,0x6d,0x20,0x6f,0x66,0x20,0x64,0x65,0x76,
-0x65,0x6c,0x6f,0x70,0x65,0x72,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x64,0x69,
-0x73,0x74,0x72,0x69,0x62,0x75,0x74,0x65,0x64,0x20,0x77,0x6f,0x72,0x6c,0x64,0x2d,
-0x77,0x69,0x64,0x65,0x2e,0x20,0x53,0x69,0x6e,0x63,0x65,0x20,0x69,0x74,0x27,0x73,
-0x20,0x72,0x65,0x6c,0x65,0x61,0x73,0x65,0x2c,0x20,0x6c,0x77,0x49,0x50,0x20,0x68,
-0x61,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x73,0x70,0x75,0x72,0x72,0x65,0x64,
-0x20,0x61,0x20,0x6c,0x6f,0x74,0x20,0x6f,0x66,0x20,0x69,0x6e,0x74,0x65,0x72,0x65,
-0x73,0x74,0x20,0x61,0x6e,0x64,0x20,0x68,0x61,0x73,0x20,0x62,0x65,0x65,0x6e,0x20,
-0x70,0x6f,0x72,0x74,0x65,0x64,0x20,0x74,0x6f,0x20,0x73,0x65,0x76,0x65,0x72,0x61,
-0x6c,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x70,0x6c,0x61,0x74,0x66,0x6f,0x72,0x6d,
-0x73,0x20,0x61,0x6e,0x64,0x20,0x6f,0x70,0x65,0x72,0x61,0x74,0x69,0x6e,0x67,0x20,
-0x73,0x79,0x73,0x74,0x65,0x6d,0x73,0x2e,0x20,0x6c,0x77,0x49,0x50,0x20,0x63,0x61,
-0x6e,0x20,0x62,0x65,0x20,0x75,0x73,0x65,0x64,0x20,0x65,0x69,0x74,0x68,0x65,0x72,
-0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x77,0x69,0x74,0x68,0x20,0x6f,0x72,0x20,0x77,
-0x69,0x74,0x68,0x6f,0x75,0x74,0x20,0x61,0x6e,0x20,0x75,0x6e,0x64,0x65,0x72,0x6c,
-0x79,0x69,0x6e,0x67,0x20,0x4f,0x53,0x2e,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x2f,0x70,
-0x3e,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,
-0x6c,0x77,0x49,0x50,0x20,0x69,0x73,0x20,0x61,0x6e,0x20,0x6f,0x70,0x65,0x6e,0x20,
-0x73,0x6f,0x75,0x72,0x63,0x65,0x20,0x69,0x6d,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,
-0x61,0x74,0x69,0x6f,0x6e,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x54,0x43,0x50,
-0x2f,0x49,0x50,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x70,0x72,0x6f,0x74,0x6f,0x63,
-0x6f,0x6c,0x20,0x73,0x75,0x69,0x74,0x65,0x20,0x74,0x68,0x61,0x74,0x20,0x77,0x61,
-0x73,0x20,0x6f,0x72,0x69,0x67,0x69,0x6e,0x61,0x6c,0x6c,0x79,0x20,0x77,0x72,0x69,
-0x74,0x74,0x65,0x6e,0x20,0x62,0x79,0x20,0x3c,0x61,0x0d,0x0a,0x09,0x20,0x20,0x20,
-0x20,0x68,0x72,0x65,0x66,0x3d,0x22,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x77,0x77,
-0x77,0x2e,0x73,0x69,0x63,0x73,0x2e,0x73,0x65,0x2f,0x7e,0x61,0x64,0x61,0x6d,0x2f,
-0x6c,0x77,0x69,0x70,0x2f,0x22,0x3e,0x41,0x64,0x61,0x6d,0x20,0x44,0x75,0x6e,0x6b,
-0x65,0x6c,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,
-0x20,0x53,0x77,0x65,0x64,0x69,0x73,0x68,0x20,0x49,0x6e,0x73,0x74,0x69,0x74,0x75,
-0x74,0x65,0x20,0x6f,0x66,0x20,0x43,0x6f,0x6d,0x70,0x75,0x74,0x65,0x72,0x20,0x53,
-0x63,0x69,0x65,0x6e,0x63,0x65,0x3c,0x2f,0x61,0x3e,0x20,0x62,0x75,0x74,0x20,0x6e,
-0x6f,0x77,0x20,0x69,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x62,0x65,0x69,0x6e,
-0x67,0x20,0x61,0x63,0x74,0x69,0x76,0x65,0x6c,0x79,0x20,0x64,0x65,0x76,0x65,0x6c,
-0x6f,0x70,0x65,0x64,0x20,0x62,0x79,0x20,0x61,0x20,0x74,0x65,0x61,0x6d,0x20,0x6f,
-0x66,0x20,0x64,0x65,0x76,0x65,0x6c,0x6f,0x70,0x65,0x72,0x73,0x0d,0x0a,0x09,0x20,
-0x20,0x20,0x20,0x64,0x69,0x73,0x74,0x72,0x69,0x62,0x75,0x74,0x65,0x64,0x20,0x77,
-0x6f,0x72,0x6c,0x64,0x2d,0x77,0x69,0x64,0x65,0x2e,0x20,0x53,0x69,0x6e,0x63,0x65,
-0x20,0x69,0x74,0x27,0x73,0x20,0x72,0x65,0x6c,0x65,0x61,0x73,0x65,0x2c,0x20,0x6c,
-0x77,0x49,0x50,0x20,0x68,0x61,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x73,0x70,
-0x75,0x72,0x72,0x65,0x64,0x20,0x61,0x20,0x6c,0x6f,0x74,0x20,0x6f,0x66,0x20,0x69,
-0x6e,0x74,0x65,0x72,0x65,0x73,0x74,0x20,0x61,0x6e,0x64,0x20,0x68,0x61,0x73,0x20,
-0x62,0x65,0x65,0x6e,0x20,0x70,0x6f,0x72,0x74,0x65,0x64,0x20,0x74,0x6f,0x20,0x73,
-0x65,0x76,0x65,0x72,0x61,0x6c,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x70,0x6c,0x61,
-0x74,0x66,0x6f,0x72,0x6d,0x73,0x20,0x61,0x6e,0x64,0x20,0x6f,0x70,0x65,0x72,0x61,
-0x74,0x69,0x6e,0x67,0x20,0x73,0x79,0x73,0x74,0x65,0x6d,0x73,0x2e,0x20,0x6c,0x77,
-0x49,0x50,0x20,0x63,0x61,0x6e,0x20,0x62,0x65,0x20,0x75,0x73,0x65,0x64,0x20,0x65,
-0x69,0x74,0x68,0x65,0x72,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x77,0x69,0x74,0x68,
-0x20,0x6f,0x72,0x20,0x77,0x69,0x74,0x68,0x6f,0x75,0x74,0x20,0x61,0x6e,0x20,0x75,
-0x6e,0x64,0x65,0x72,0x6c,0x79,0x69,0x6e,0x67,0x20,0x4f,0x53,0x2e,0x0d,0x0a,0x09,
-0x20,0x20,0x3c,0x2f,0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x70,0x3e,0x0d,0x0a,
-0x09,0x20,0x20,0x20,0x20,0x6c,0x77,0x49,0x50,0x20,0x69,0x73,0x20,0x61,0x6e,0x20,
-0x6f,0x70,0x65,0x6e,0x20,0x73,0x6f,0x75,0x72,0x63,0x65,0x20,0x69,0x6d,0x70,0x6c,
-0x65,0x6d,0x65,0x6e,0x74,0x61,0x74,0x69,0x6f,0x6e,0x20,0x6f,0x66,0x20,0x74,0x68,
-0x65,0x20,0x54,0x43,0x50,0x2f,0x49,0x50,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x70,
-0x72,0x6f,0x74,0x6f,0x63,0x6f,0x6c,0x20,0x73,0x75,0x69,0x74,0x65,0x20,0x74,0x68,
-0x61,0x74,0x20,0x77,0x61,0x73,0x20,0x6f,0x72,0x69,0x67,0x69,0x6e,0x61,0x6c,0x6c,
-0x79,0x20,0x77,0x72,0x69,0x74,0x74,0x65,0x6e,0x20,0x62,0x79,0x20,0x3c,0x61,0x0d,
-0x0a,0x09,0x20,0x20,0x20,0x20,0x68,0x72,0x65,0x66,0x3d,0x22,0x68,0x74,0x74,0x70,
-0x3a,0x2f,0x2f,0x77,0x77,0x77,0x2e,0x73,0x69,0x63,0x73,0x2e,0x73,0x65,0x2f,0x7e,
-0x61,0x64,0x61,0x6d,0x2f,0x6c,0x77,0x69,0x70,0x2f,0x22,0x3e,0x41,0x64,0x61,0x6d,
-0x20,0x44,0x75,0x6e,0x6b,0x65,0x6c,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x6f,
-0x66,0x20,0x74,0x68,0x65,0x20,0x53,0x77,0x65,0x64,0x69,0x73,0x68,0x20,0x49,0x6e,
-0x73,0x74,0x69,0x74,0x75,0x74,0x65,0x20,0x6f,0x66,0x20,0x43,0x6f,0x6d,0x70,0x75,
-0x74,0x65,0x72,0x20,0x53,0x63,0x69,0x65,0x6e,0x63,0x65,0x3c,0x2f,0x61,0x3e,0x20,
-0x62,0x75,0x74,0x20,0x6e,0x6f,0x77,0x20,0x69,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,
-0x20,0x62,0x65,0x69,0x6e,0x67,0x20,0x61,0x63,0x74,0x69,0x76,0x65,0x6c,0x79,0x20,
-0x64,0x65,0x76,0x65,0x6c,0x6f,0x70,0x65,0x64,0x20,0x62,0x79,0x20,0x61,0x20,0x74,
-0x65,0x61,0x6d,0x20,0x6f,0x66,0x20,0x64,0x65,0x76,0x65,0x6c,0x6f,0x70,0x65,0x72,
-0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x64,0x69,0x73,0x74,0x72,0x69,0x62,0x75,
-0x74,0x65,0x64,0x20,0x77,0x6f,0x72,0x6c,0x64,0x2d,0x77,0x69,0x64,0x65,0x2e,0x20,
-0x53,0x69,0x6e,0x63,0x65,0x20,0x69,0x74,0x27,0x73,0x20,0x72,0x65,0x6c,0x65,0x61,
-0x73,0x65,0x2c,0x20,0x6c,0x77,0x49,0x50,0x20,0x68,0x61,0x73,0x0d,0x0a,0x09,0x20,
-0x20,0x20,0x20,0x73,0x70,0x75,0x72,0x72,0x65,0x64,0x20,0x61,0x20,0x6c,0x6f,0x74,
-0x20,0x6f,0x66,0x20,0x69,0x6e,0x74,0x65,0x72,0x65,0x73,0x74,0x20,0x61,0x6e,0x64,
-0x20,0x68,0x61,0x73,0x20,0x62,0x65,0x65,0x6e,0x20,0x70,0x6f,0x72,0x74,0x65,0x64,
-0x20,0x74,0x6f,0x20,0x73,0x65,0x76,0x65,0x72,0x61,0x6c,0x0d,0x0a,0x09,0x20,0x20,
-0x20,0x20,0x70,0x6c,0x61,0x74,0x66,0x6f,0x72,0x6d,0x73,0x20,0x61,0x6e,0x64,0x20,
-0x6f,0x70,0x65,0x72,0x61,0x74,0x69,0x6e,0x67,0x20,0x73,0x79,0x73,0x74,0x65,0x6d,
-0x73,0x2e,0x20,0x6c,0x77,0x49,0x50,0x20,0x63,0x61,0x6e,0x20,0x62,0x65,0x20,0x75,
-0x73,0x65,0x64,0x20,0x65,0x69,0x74,0x68,0x65,0x72,0x0d,0x0a,0x09,0x20,0x20,0x20,
-0x20,0x77,0x69,0x74,0x68,0x20,0x6f,0x72,0x20,0x77,0x69,0x74,0x68,0x6f,0x75,0x74,
-0x20,0x61,0x6e,0x20,0x75,0x6e,0x64,0x65,0x72,0x6c,0x79,0x69,0x6e,0x67,0x20,0x4f,
-0x53,0x2e,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x2f,0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,
-0x3c,0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x6c,0x77,0x49,0x50,0x20,0x69,
-0x73,0x20,0x61,0x6e,0x20,0x6f,0x70,0x65,0x6e,0x20,0x73,0x6f,0x75,0x72,0x63,0x65,
-0x20,0x69,0x6d,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,0x61,0x74,0x69,0x6f,0x6e,0x20,
-0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x54,0x43,0x50,0x2f,0x49,0x50,0x0d,0x0a,0x09,
-0x20,0x20,0x20,0x20,0x70,0x72,0x6f,0x74,0x6f,0x63,0x6f,0x6c,0x20,0x73,0x75,0x69,
-0x74,0x65,0x20,0x74,0x68,0x61,0x74,0x20,0x77,0x61,0x73,0x20,0x6f,0x72,0x69,0x67,
-0x69,0x6e,0x61,0x6c,0x6c,0x79,0x20,0x77,0x72,0x69,0x74,0x74,0x65,0x6e,0x20,0x62,
-0x79,0x20,0x3c,0x61,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x68,0x72,0x65,0x66,0x3d,
-0x22,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x77,0x77,0x77,0x2e,0x73,0x69,0x63,0x73,
-0x2e,0x73,0x65,0x2f,0x7e,0x61,0x64,0x61,0x6d,0x2f,0x6c,0x77,0x69,0x70,0x2f,0x22,
-0x3e,0x41,0x64,0x61,0x6d,0x20,0x44,0x75,0x6e,0x6b,0x65,0x6c,0x73,0x0d,0x0a,0x09,
-0x20,0x20,0x20,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x53,0x77,0x65,0x64,0x69,
-0x73,0x68,0x20,0x49,0x6e,0x73,0x74,0x69,0x74,0x75,0x74,0x65,0x20,0x6f,0x66,0x20,
-0x43,0x6f,0x6d,0x70,0x75,0x74,0x65,0x72,0x20,0x53,0x63,0x69,0x65,0x6e,0x63,0x65,
-0x3c,0x2f,0x61,0x3e,0x20,0x62,0x75,0x74,0x20,0x6e,0x6f,0x77,0x20,0x69,0x73,0x0d,
-0x0a,0x09,0x20,0x20,0x20,0x20,0x62,0x65,0x69,0x6e,0x67,0x20,0x61,0x63,0x74,0x69,
-0x76,0x65,0x6c,0x79,0x20,0x64,0x65,0x76,0x65,0x6c,0x6f,0x70,0x65,0x64,0x20,0x62,
-0x79,0x20,0x61,0x20,0x74,0x65,0x61,0x6d,0x20,0x6f,0x66,0x20,0x64,0x65,0x76,0x65,
-0x6c,0x6f,0x70,0x65,0x72,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x64,0x69,0x73,
-0x74,0x72,0x69,0x62,0x75,0x74,0x65,0x64,0x20,0x77,0x6f,0x72,0x6c,0x64,0x2d,0x77,
-0x69,0x64,0x65,0x2e,0x20,0x53,0x69,0x6e,0x63,0x65,0x20,0x69,0x74,0x27,0x73,0x20,
-0x72,0x65,0x6c,0x65,0x61,0x73,0x65,0x2c,0x20,0x6c,0x77,0x49,0x50,0x20,0x68,0x61,
-0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x73,0x70,0x75,0x72,0x72,0x65,0x64,0x20,
-0x61,0x20,0x6c,0x6f,0x74,0x20,0x6f,0x66,0x20,0x69,0x6e,0x74,0x65,0x72,0x65,0x73,
-0x74,0x20,0x61,0x6e,0x64,0x20,0x68,0x61,0x73,0x20,0x62,0x65,0x65,0x6e,0x20,0x70,
-0x6f,0x72,0x74,0x65,0x64,0x20,0x74,0x6f,0x20,0x73,0x65,0x76,0x65,0x72,0x61,0x6c,
-0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x70,0x6c,0x61,0x74,0x66,0x6f,0x72,0x6d,0x73,
-0x20,0x61,0x6e,0x64,0x20,0x6f,0x70,0x65,0x72,0x61,0x74,0x69,0x6e,0x67,0x20,0x73,
-0x79,0x73,0x74,0x65,0x6d,0x73,0x2e,0x20,0x6c,0x77,0x49,0x50,0x20,0x63,0x61,0x6e,
-0x20,0x62,0x65,0x20,0x75,0x73,0x65,0x64,0x20,0x65,0x69,0x74,0x68,0x65,0x72,0x0d,
-0x0a,0x09,0x20,0x20,0x20,0x20,0x77,0x69,0x74,0x68,0x20,0x6f,0x72,0x20,0x77,0x69,
-0x74,0x68,0x6f,0x75,0x74,0x20,0x61,0x6e,0x20,0x75,0x6e,0x64,0x65,0x72,0x6c,0x79,
-0x69,0x6e,0x67,0x20,0x4f,0x53,0x2e,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x2f,0x70,0x3e,
-0x0d,0x0a,0x09,0x20,0x20,0x3c,0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x6c,
-0x77,0x49,0x50,0x20,0x69,0x73,0x20,0x61,0x6e,0x20,0x6f,0x70,0x65,0x6e,0x20,0x73,
-0x6f,0x75,0x72,0x63,0x65,0x20,0x69,0x6d,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,0x61,
-0x74,0x69,0x6f,0x6e,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x54,0x43,0x50,0x2f,
-0x49,0x50,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x70,0x72,0x6f,0x74,0x6f,0x63,0x6f,
-0x6c,0x20,0x73,0x75,0x69,0x74,0x65,0x20,0x74,0x68,0x61,0x74,0x20,0x77,0x61,0x73,
-0x20,0x6f,0x72,0x69,0x67,0x69,0x6e,0x61,0x6c,0x6c,0x79,0x20,0x77,0x72,0x69,0x74,
-0x74,0x65,0x6e,0x20,0x62,0x79,0x20,0x3c,0x61,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,
-0x68,0x72,0x65,0x66,0x3d,0x22,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x77,0x77,0x77,
-0x2e,0x73,0x69,0x63,0x73,0x2e,0x73,0x65,0x2f,0x7e,0x61,0x64,0x61,0x6d,0x2f,0x6c,
-0x77,0x69,0x70,0x2f,0x22,0x3e,0x41,0x64,0x61,0x6d,0x20,0x44,0x75,0x6e,0x6b,0x65,
-0x6c,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,0x20,
-0x53,0x77,0x65,0x64,0x69,0x73,0x68,0x20,0x49,0x6e,0x73,0x74,0x69,0x74,0x75,0x74,
-0x65,0x20,0x6f,0x66,0x20,0x43,0x6f,0x6d,0x70,0x75,0x74,0x65,0x72,0x20,0x53,0x63,
-0x69,0x65,0x6e,0x63,0x65,0x3c,0x2f,0x61,0x3e,0x20,0x62,0x75,0x74,0x20,0x6e,0x6f,
-0x77,0x20,0x69,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x62,0x65,0x69,0x6e,0x67,
-0x20,0x61,0x63,0x74,0x69,0x76,0x65,0x6c,0x79,0x20,0x64,0x65,0x76,0x65,0x6c,0x6f,
-0x70,0x65,0x64,0x20,0x62,0x79,0x20,0x61,0x20,0x74,0x65,0x61,0x6d,0x20,0x6f,0x66,
-0x20,0x64,0x65,0x76,0x65,0x6c,0x6f,0x70,0x65,0x72,0x73,0x0d,0x0a,0x09,0x20,0x20,
-0x20,0x20,0x64,0x69,0x73,0x74,0x72,0x69,0x62,0x75,0x74,0x65,0x64,0x20,0x77,0x6f,
-0x72,0x6c,0x64,0x2d,0x77,0x69,0x64,0x65,0x2e,0x20,0x53,0x69,0x6e,0x63,0x65,0x20,
-0x69,0x74,0x27,0x73,0x20,0x72,0x65,0x6c,0x65,0x61,0x73,0x65,0x2c,0x20,0x6c,0x77,
-0x49,0x50,0x20,0x68,0x61,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x73,0x70,0x75,
-0x72,0x72,0x65,0x64,0x20,0x61,0x20,0x6c,0x6f,0x74,0x20,0x6f,0x66,0x20,0x69,0x6e,
-0x74,0x65,0x72,0x65,0x73,0x74,0x20,0x61,0x6e,0x64,0x20,0x68,0x61,0x73,0x20,0x62,
-0x65,0x65,0x6e,0x20,0x70,0x6f,0x72,0x74,0x65,0x64,0x20,0x74,0x6f,0x20,0x73,0x65,
-0x76,0x65,0x72,0x61,0x6c,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x70,0x6c,0x61,0x74,
-0x66,0x6f,0x72,0x6d,0x73,0x20,0x61,0x6e,0x64,0x20,0x6f,0x70,0x65,0x72,0x61,0x74,
-0x69,0x6e,0x67,0x20,0x73,0x79,0x73,0x74,0x65,0x6d,0x73,0x2e,0x20,0x6c,0x77,0x49,
-0x50,0x20,0x63,0x61,0x6e,0x20,0x62,0x65,0x20,0x75,0x73,0x65,0x64,0x20,0x65,0x69,
-0x74,0x68,0x65,0x72,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x77,0x69,0x74,0x68,0x20,
-0x6f,0x72,0x20,0x77,0x69,0x74,0x68,0x6f,0x75,0x74,0x20,0x61,0x6e,0x20,0x75,0x6e,
-0x64,0x65,0x72,0x6c,0x79,0x69,0x6e,0x67,0x20,0x4f,0x53,0x2e,0x0d,0x0a,0x09,0x20,
-0x20,0x3c,0x2f,0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x70,0x3e,0x0d,0x0a,0x09,
-0x20,0x20,0x20,0x20,0x6c,0x77,0x49,0x50,0x20,0x69,0x73,0x20,0x61,0x6e,0x20,0x6f,
-0x70,0x65,0x6e,0x20,0x73,0x6f,0x75,0x72,0x63,0x65,0x20,0x69,0x6d,0x70,0x6c,0x65,
-0x6d,0x65,0x6e,0x74,0x61,0x74,0x69,0x6f,0x6e,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,
-0x20,0x54,0x43,0x50,0x2f,0x49,0x50,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x70,0x72,
-0x6f,0x74,0x6f,0x63,0x6f,0x6c,0x20,0x73,0x75,0x69,0x74,0x65,0x20,0x74,0x68,0x61,
-0x74,0x20,0x77,0x61,0x73,0x20,0x6f,0x72,0x69,0x67,0x69,0x6e,0x61,0x6c,0x6c,0x79,
-0x20,0x77,0x72,0x69,0x74,0x74,0x65,0x6e,0x20,0x62,0x79,0x20,0x3c,0x61,0x0d,0x0a,
-0x09,0x20,0x20,0x20,0x20,0x68,0x72,0x65,0x66,0x3d,0x22,0x68,0x74,0x74,0x70,0x3a,
-0x2f,0x2f,0x77,0x77,0x77,0x2e,0x73,0x69,0x63,0x73,0x2e,0x73,0x65,0x2f,0x7e,0x61,
-0x64,0x61,0x6d,0x2f,0x6c,0x77,0x69,0x70,0x2f,0x22,0x3e,0x41,0x64,0x61,0x6d,0x20,
-0x44,0x75,0x6e,0x6b,0x65,0x6c,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x6f,0x66,
-0x20,0x74,0x68,0x65,0x20,0x53,0x77,0x65,0x64,0x69,0x73,0x68,0x20,0x49,0x6e,0x73,
-0x74,0x69,0x74,0x75,0x74,0x65,0x20,0x6f,0x66,0x20,0x43,0x6f,0x6d,0x70,0x75,0x74,
-0x65,0x72,0x20,0x53,0x63,0x69,0x65,0x6e,0x63,0x65,0x3c,0x2f,0x61,0x3e,0x20,0x62,
-0x75,0x74,0x20,0x6e,0x6f,0x77,0x20,0x69,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,
-0x62,0x65,0x69,0x6e,0x67,0x20,0x61,0x63,0x74,0x69,0x76,0x65,0x6c,0x79,0x20,0x64,
-0x65,0x76,0x65,0x6c,0x6f,0x70,0x65,0x64,0x20,0x62,0x79,0x20,0x61,0x20,0x74,0x65,
-0x61,0x6d,0x20,0x6f,0x66,0x20,0x64,0x65,0x76,0x65,0x6c,0x6f,0x70,0x65,0x72,0x73,
-0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x64,0x69,0x73,0x74,0x72,0x69,0x62,0x75,0x74,
-0x65,0x64,0x20,0x77,0x6f,0x72,0x6c,0x64,0x2d,0x77,0x69,0x64,0x65,0x2e,0x20,0x53,
-0x69,0x6e,0x63,0x65,0x20,0x69,0x74,0x27,0x73,0x20,0x72,0x65,0x6c,0x65,0x61,0x73,
-0x65,0x2c,0x20,0x6c,0x77,0x49,0x50,0x20,0x68,0x61,0x73,0x0d,0x0a,0x09,0x20,0x20,
-0x20,0x20,0x73,0x70,0x75,0x72,0x72,0x65,0x64,0x20,0x61,0x20,0x6c,0x6f,0x74,0x20,
-0x6f,0x66,0x20,0x69,0x6e,0x74,0x65,0x72,0x65,0x73,0x74,0x20,0x61,0x6e,0x64,0x20,
-0x68,0x61,0x73,0x20,0x62,0x65,0x65,0x6e,0x20,0x70,0x6f,0x72,0x74,0x65,0x64,0x20,
-0x74,0x6f,0x20,0x73,0x65,0x76,0x65,0x72,0x61,0x6c,0x0d,0x0a,0x09,0x20,0x20,0x20,
-0x20,0x70,0x6c,0x61,0x74,0x66,0x6f,0x72,0x6d,0x73,0x20,0x61,0x6e,0x64,0x20,0x6f,
-0x70,0x65,0x72,0x61,0x74,0x69,0x6e,0x67,0x20,0x73,0x79,0x73,0x74,0x65,0x6d,0x73,
-0x2e,0x20,0x6c,0x77,0x49,0x50,0x20,0x63,0x61,0x6e,0x20,0x62,0x65,0x20,0x75,0x73,
-0x65,0x64,0x20,0x65,0x69,0x74,0x68,0x65,0x72,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,
-0x77,0x69,0x74,0x68,0x20,0x6f,0x72,0x20,0x77,0x69,0x74,0x68,0x6f,0x75,0x74,0x20,
-0x61,0x6e,0x20,0x75,0x6e,0x64,0x65,0x72,0x6c,0x79,0x69,0x6e,0x67,0x20,0x4f,0x53,
-0x2e,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x2f,0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x3c,
-0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x6c,0x77,0x49,0x50,0x20,0x69,0x73,
-0x20,0x61,0x6e,0x20,0x6f,0x70,0x65,0x6e,0x20,0x73,0x6f,0x75,0x72,0x63,0x65,0x20,
-0x69,0x6d,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,0x61,0x74,0x69,0x6f,0x6e,0x20,0x6f,
-0x66,0x20,0x74,0x68,0x65,0x20,0x54,0x43,0x50,0x2f,0x49,0x50,0x0d,0x0a,0x09,0x20,
-0x20,0x20,0x20,0x70,0x72,0x6f,0x74,0x6f,0x63,0x6f,0x6c,0x20,0x73,0x75,0x69,0x74,
-0x65,0x20,0x74,0x68,0x61,0x74,0x20,0x77,0x61,0x73,0x20,0x6f,0x72,0x69,0x67,0x69,
-0x6e,0x61,0x6c,0x6c,0x79,0x20,0x77,0x72,0x69,0x74,0x74,0x65,0x6e,0x20,0x62,0x79,
-0x20,0x3c,0x61,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x68,0x72,0x65,0x66,0x3d,0x22,
-0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x77,0x77,0x77,0x2e,0x73,0x69,0x63,0x73,0x2e,
-0x73,0x65,0x2f,0x7e,0x61,0x64,0x61,0x6d,0x2f,0x6c,0x77,0x69,0x70,0x2f,0x22,0x3e,
-0x41,0x64,0x61,0x6d,0x20,0x44,0x75,0x6e,0x6b,0x65,0x6c,0x73,0x0d,0x0a,0x09,0x20,
-0x20,0x20,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x53,0x77,0x65,0x64,0x69,0x73,
-0x68,0x20,0x49,0x6e,0x73,0x74,0x69,0x74,0x75,0x74,0x65,0x20,0x6f,0x66,0x20,0x43,
-0x6f,0x6d,0x70,0x75,0x74,0x65,0x72,0x20,0x53,0x63,0x69,0x65,0x6e,0x63,0x65,0x3c,
-0x2f,0x61,0x3e,0x20,0x62,0x75,0x74,0x20,0x6e,0x6f,0x77,0x20,0x69,0x73,0x0d,0x0a,
-0x09,0x20,0x20,0x20,0x20,0x62,0x65,0x69,0x6e,0x67,0x20,0x61,0x63,0x74,0x69,0x76,
-0x65,0x6c,0x79,0x20,0x64,0x65,0x76,0x65,0x6c,0x6f,0x70,0x65,0x64,0x20,0x62,0x79,
-0x20,0x61,0x20,0x74,0x65,0x61,0x6d,0x20,0x6f,0x66,0x20,0x64,0x65,0x76,0x65,0x6c,
-0x6f,0x70,0x65,0x72,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x64,0x69,0x73,0x74,
-0x72,0x69,0x62,0x75,0x74,0x65,0x64,0x20,0x77,0x6f,0x72,0x6c,0x64,0x2d,0x77,0x69,
-0x64,0x65,0x2e,0x20,0x53,0x69,0x6e,0x63,0x65,0x20,0x69,0x74,0x27,0x73,0x20,0x72,
-0x65,0x6c,0x65,0x61,0x73,0x65,0x2c,0x20,0x6c,0x77,0x49,0x50,0x20,0x68,0x61,0x73,
-0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x73,0x70,0x75,0x72,0x72,0x65,0x64,0x20,0x61,
-0x20,0x6c,0x6f,0x74,0x20,0x6f,0x66,0x20,0x69,0x6e,0x74,0x65,0x72,0x65,0x73,0x74,
-0x20,0x61,0x6e,0x64,0x20,0x68,0x61,0x73,0x20,0x62,0x65,0x65,0x6e,0x20,0x70,0x6f,
-0x72,0x74,0x65,0x64,0x20,0x74,0x6f,0x20,0x73,0x65,0x76,0x65,0x72,0x61,0x6c,0x0d,
-0x0a,0x09,0x20,0x20,0x20,0x20,0x70,0x6c,0x61,0x74,0x66,0x6f,0x72,0x6d,0x73,0x20,
-0x61,0x6e,0x64,0x20,0x6f,0x70,0x65,0x72,0x61,0x74,0x69,0x6e,0x67,0x20,0x73,0x79,
-0x73,0x74,0x65,0x6d,0x73,0x2e,0x20,0x6c,0x77,0x49,0x50,0x20,0x63,0x61,0x6e,0x20,
-0x62,0x65,0x20,0x75,0x73,0x65,0x64,0x20,0x65,0x69,0x74,0x68,0x65,0x72,0x0d,0x0a,
-0x09,0x20,0x20,0x20,0x20,0x77,0x69,0x74,0x68,0x20,0x6f,0x72,0x20,0x77,0x69,0x74,
-0x68,0x6f,0x75,0x74,0x20,0x61,0x6e,0x20,0x75,0x6e,0x64,0x65,0x72,0x6c,0x79,0x69,
-0x6e,0x67,0x20,0x4f,0x53,0x2e,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x2f,0x70,0x3e,0x0d,
-0x0a,0x09,0x20,0x20,0x3c,0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x6c,0x77,
-0x49,0x50,0x20,0x69,0x73,0x20,0x61,0x6e,0x20,0x6f,0x70,0x65,0x6e,0x20,0x73,0x6f,
-0x75,0x72,0x63,0x65,0x20,0x69,0x6d,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,0x61,0x74,
-0x69,0x6f,0x6e,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x54,0x43,0x50,0x2f,0x49,
-0x50,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x70,0x72,0x6f,0x74,0x6f,0x63,0x6f,0x6c,
-0x20,0x73,0x75,0x69,0x74,0x65,0x20,0x74,0x68,0x61,0x74,0x20,0x77,0x61,0x73,0x20,
-0x6f,0x72,0x69,0x67,0x69,0x6e,0x61,0x6c,0x6c,0x79,0x20,0x77,0x72,0x69,0x74,0x74,
-0x65,0x6e,0x20,0x62,0x79,0x20,0x3c,0x61,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x68,
-0x72,0x65,0x66,0x3d,0x22,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x77,0x77,0x77,0x2e,
-0x73,0x69,0x63,0x73,0x2e,0x73,0x65,0x2f,0x7e,0x61,0x64,0x61,0x6d,0x2f,0x6c,0x77,
-0x69,0x70,0x2f,0x22,0x3e,0x41,0x64,0x61,0x6d,0x20,0x44,0x75,0x6e,0x6b,0x65,0x6c,
-0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x53,
-0x77,0x65,0x64,0x69,0x73,0x68,0x20,0x49,0x6e,0x73,0x74,0x69,0x74,0x75,0x74,0x65,
-0x20,0x6f,0x66,0x20,0x43,0x6f,0x6d,0x70,0x75,0x74,0x65,0x72,0x20,0x53,0x63,0x69,
-0x65,0x6e,0x63,0x65,0x3c,0x2f,0x61,0x3e,0x20,0x62,0x75,0x74,0x20,0x6e,0x6f,0x77,
-0x20,0x69,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x62,0x65,0x69,0x6e,0x67,0x20,
-0x61,0x63,0x74,0x69,0x76,0x65,0x6c,0x79,0x20,0x64,0x65,0x76,0x65,0x6c,0x6f,0x70,
-0x65,0x64,0x20,0x62,0x79,0x20,0x61,0x20,0x74,0x65,0x61,0x6d,0x20,0x6f,0x66,0x20,
-0x64,0x65,0x76,0x65,0x6c,0x6f,0x70,0x65,0x72,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,
-0x20,0x64,0x69,0x73,0x74,0x72,0x69,0x62,0x75,0x74,0x65,0x64,0x20,0x77,0x6f,0x72,
-0x6c,0x64,0x2d,0x77,0x69,0x64,0x65,0x2e,0x20,0x53,0x69,0x6e,0x63,0x65,0x20,0x69,
-0x74,0x27,0x73,0x20,0x72,0x65,0x6c,0x65,0x61,0x73,0x65,0x2c,0x20,0x6c,0x77,0x49,
-0x50,0x20,0x68,0x61,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x73,0x70,0x75,0x72,
-0x72,0x65,0x64,0x20,0x61,0x20,0x6c,0x6f,0x74,0x20,0x6f,0x66,0x20,0x69,0x6e,0x74,
-0x65,0x72,0x65,0x73,0x74,0x20,0x61,0x6e,0x64,0x20,0x68,0x61,0x73,0x20,0x62,0x65,
-0x65,0x6e,0x20,0x70,0x6f,0x72,0x74,0x65,0x64,0x20,0x74,0x6f,0x20,0x73,0x65,0x76,
-0x65,0x72,0x61,0x6c,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x70,0x6c,0x61,0x74,0x66,
-0x6f,0x72,0x6d,0x73,0x20,0x61,0x6e,0x64,0x20,0x6f,0x70,0x65,0x72,0x61,0x74,0x69,
-0x6e,0x67,0x20,0x73,0x79,0x73,0x74,0x65,0x6d,0x73,0x2e,0x20,0x6c,0x77,0x49,0x50,
-0x20,0x63,0x61,0x6e,0x20,0x62,0x65,0x20,0x75,0x73,0x65,0x64,0x20,0x65,0x69,0x74,
-0x68,0x65,0x72,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x77,0x69,0x74,0x68,0x20,0x6f,
-0x72,0x20,0x77,0x69,0x74,0x68,0x6f,0x75,0x74,0x20,0x61,0x6e,0x20,0x75,0x6e,0x64,
-0x65,0x72,0x6c,0x79,0x69,0x6e,0x67,0x20,0x4f,0x53,0x2e,0x0d,0x0a,0x09,0x20,0x20,
-0x3c,0x2f,0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x70,0x3e,0x0d,0x0a,0x09,0x20,
-0x20,0x20,0x20,0x6c,0x77,0x49,0x50,0x20,0x69,0x73,0x20,0x61,0x6e,0x20,0x6f,0x70,
-0x65,0x6e,0x20,0x73,0x6f,0x75,0x72,0x63,0x65,0x20,0x69,0x6d,0x70,0x6c,0x65,0x6d,
-0x65,0x6e,0x74,0x61,0x74,0x69,0x6f,0x6e,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,0x20,
-0x54,0x43,0x50,0x2f,0x49,0x50,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x70,0x72,0x6f,
-0x74,0x6f,0x63,0x6f,0x6c,0x20,0x73,0x75,0x69,0x74,0x65,0x20,0x74,0x68,0x61,0x74,
-0x20,0x77,0x61,0x73,0x20,0x6f,0x72,0x69,0x67,0x69,0x6e,0x61,0x6c,0x6c,0x79,0x20,
-0x77,0x72,0x69,0x74,0x74,0x65,0x6e,0x20,0x62,0x79,0x20,0x3c,0x61,0x0d,0x0a,0x09,
-0x20,0x20,0x20,0x20,0x68,0x72,0x65,0x66,0x3d,0x22,0x68,0x74,0x74,0x70,0x3a,0x2f,
-0x2f,0x77,0x77,0x77,0x2e,0x73,0x69,0x63,0x73,0x2e,0x73,0x65,0x2f,0x7e,0x61,0x64,
-0x61,0x6d,0x2f,0x6c,0x77,0x69,0x70,0x2f,0x22,0x3e,0x41,0x64,0x61,0x6d,0x20,0x44,
-0x75,0x6e,0x6b,0x65,0x6c,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x6f,0x66,0x20,
-0x74,0x68,0x65,0x20,0x53,0x77,0x65,0x64,0x69,0x73,0x68,0x20,0x49,0x6e,0x73,0x74,
-0x69,0x74,0x75,0x74,0x65,0x20,0x6f,0x66,0x20,0x43,0x6f,0x6d,0x70,0x75,0x74,0x65,
-0x72,0x20,0x53,0x63,0x69,0x65,0x6e,0x63,0x65,0x3c,0x2f,0x61,0x3e,0x20,0x62,0x75,
-0x74,0x20,0x6e,0x6f,0x77,0x20,0x69,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x62,
-0x65,0x69,0x6e,0x67,0x20,0x61,0x63,0x74,0x69,0x76,0x65,0x6c,0x79,0x20,0x64,0x65,
-0x76,0x65,0x6c,0x6f,0x70,0x65,0x64,0x20,0x62,0x79,0x20,0x61,0x20,0x74,0x65,0x61,
-0x6d,0x20,0x6f,0x66,0x20,0x64,0x65,0x76,0x65,0x6c,0x6f,0x70,0x65,0x72,0x73,0x0d,
-0x0a,0x09,0x20,0x20,0x20,0x20,0x64,0x69,0x73,0x74,0x72,0x69,0x62,0x75,0x74,0x65,
-0x64,0x20,0x77,0x6f,0x72,0x6c,0x64,0x2d,0x77,0x69,0x64,0x65,0x2e,0x20,0x53,0x69,
-0x6e,0x63,0x65,0x20,0x69,0x74,0x27,0x73,0x20,0x72,0x65,0x6c,0x65,0x61,0x73,0x65,
-0x2c,0x20,0x6c,0x77,0x49,0x50,0x20,0x68,0x61,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,
-0x20,0x73,0x70,0x75,0x72,0x72,0x65,0x64,0x20,0x61,0x20,0x6c,0x6f,0x74,0x20,0x6f,
-0x66,0x20,0x69,0x6e,0x74,0x65,0x72,0x65,0x73,0x74,0x20,0x61,0x6e,0x64,0x20,0x68,
-0x61,0x73,0x20,0x62,0x65,0x65,0x6e,0x20,0x70,0x6f,0x72,0x74,0x65,0x64,0x20,0x74,
-0x6f,0x20,0x73,0x65,0x76,0x65,0x72,0x61,0x6c,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,
-0x70,0x6c,0x61,0x74,0x66,0x6f,0x72,0x6d,0x73,0x20,0x61,0x6e,0x64,0x20,0x6f,0x70,
-0x65,0x72,0x61,0x74,0x69,0x6e,0x67,0x20,0x73,0x79,0x73,0x74,0x65,0x6d,0x73,0x2e,
-0x20,0x6c,0x77,0x49,0x50,0x20,0x63,0x61,0x6e,0x20,0x62,0x65,0x20,0x75,0x73,0x65,
-0x64,0x20,0x65,0x69,0x74,0x68,0x65,0x72,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x77,
-0x69,0x74,0x68,0x20,0x6f,0x72,0x20,0x77,0x69,0x74,0x68,0x6f,0x75,0x74,0x20,0x61,
-0x6e,0x20,0x75,0x6e,0x64,0x65,0x72,0x6c,0x79,0x69,0x6e,0x67,0x20,0x4f,0x53,0x2e,
-0x0d,0x0a,0x09,0x20,0x20,0x3c,0x2f,0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x70,
-0x3e,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x6c,0x77,0x49,0x50,0x20,0x69,0x73,0x20,
-0x61,0x6e,0x20,0x6f,0x70,0x65,0x6e,0x20,0x73,0x6f,0x75,0x72,0x63,0x65,0x20,0x69,
-0x6d,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,0x61,0x74,0x69,0x6f,0x6e,0x20,0x6f,0x66,
-0x20,0x74,0x68,0x65,0x20,0x54,0x43,0x50,0x2f,0x49,0x50,0x0d,0x0a,0x09,0x20,0x20,
-0x20,0x20,0x70,0x72,0x6f,0x74,0x6f,0x63,0x6f,0x6c,0x20,0x73,0x75,0x69,0x74,0x65,
-0x20,0x74,0x68,0x61,0x74,0x20,0x77,0x61,0x73,0x20,0x6f,0x72,0x69,0x67,0x69,0x6e,
-0x61,0x6c,0x6c,0x79,0x20,0x77,0x72,0x69,0x74,0x74,0x65,0x6e,0x20,0x62,0x79,0x20,
-0x3c,0x61,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x68,0x72,0x65,0x66,0x3d,0x22,0x68,
-0x74,0x74,0x70,0x3a,0x2f,0x2f,0x77,0x77,0x77,0x2e,0x73,0x69,0x63,0x73,0x2e,0x73,
-0x65,0x2f,0x7e,0x61,0x64,0x61,0x6d,0x2f,0x6c,0x77,0x69,0x70,0x2f,0x22,0x3e,0x41,
-0x64,0x61,0x6d,0x20,0x44,0x75,0x6e,0x6b,0x65,0x6c,0x73,0x0d,0x0a,0x09,0x20,0x20,
-0x20,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x53,0x77,0x65,0x64,0x69,0x73,0x68,
-0x20,0x49,0x6e,0x73,0x74,0x69,0x74,0x75,0x74,0x65,0x20,0x6f,0x66,0x20,0x43,0x6f,
-0x6d,0x70,0x75,0x74,0x65,0x72,0x20,0x53,0x63,0x69,0x65,0x6e,0x63,0x65,0x3c,0x2f,
-0x61,0x3e,0x20,0x62,0x75,0x74,0x20,0x6e,0x6f,0x77,0x20,0x69,0x73,0x0d,0x0a,0x09,
-0x20,0x20,0x20,0x20,0x62,0x65,0x69,0x6e,0x67,0x20,0x61,0x63,0x74,0x69,0x76,0x65,
-0x6c,0x79,0x20,0x64,0x65,0x76,0x65,0x6c,0x6f,0x70,0x65,0x64,0x20,0x62,0x79,0x20,
-0x61,0x20,0x74,0x65,0x61,0x6d,0x20,0x6f,0x66,0x20,0x64,0x65,0x76,0x65,0x6c,0x6f,
-0x70,0x65,0x72,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x64,0x69,0x73,0x74,0x72,
-0x69,0x62,0x75,0x74,0x65,0x64,0x20,0x77,0x6f,0x72,0x6c,0x64,0x2d,0x77,0x69,0x64,
-0x65,0x2e,0x20,0x53,0x69,0x6e,0x63,0x65,0x20,0x69,0x74,0x27,0x73,0x20,0x72,0x65,
-0x6c,0x65,0x61,0x73,0x65,0x2c,0x20,0x6c,0x77,0x49,0x50,0x20,0x68,0x61,0x73,0x0d,
-0x0a,0x09,0x20,0x20,0x20,0x20,0x73,0x70,0x75,0x72,0x72,0x65,0x64,0x20,0x61,0x20,
-0x6c,0x6f,0x74,0x20,0x6f,0x66,0x20,0x69,0x6e,0x74,0x65,0x72,0x65,0x73,0x74,0x20,
-0x61,0x6e,0x64,0x20,0x68,0x61,0x73,0x20,0x62,0x65,0x65,0x6e,0x20,0x70,0x6f,0x72,
-0x74,0x65,0x64,0x20,0x74,0x6f,0x20,0x73,0x65,0x76,0x65,0x72,0x61,0x6c,0x0d,0x0a,
-0x09,0x20,0x20,0x20,0x20,0x70,0x6c,0x61,0x74,0x66,0x6f,0x72,0x6d,0x73,0x20,0x61,
-0x6e,0x64,0x20,0x6f,0x70,0x65,0x72,0x61,0x74,0x69,0x6e,0x67,0x20,0x73,0x79,0x73,
-0x74,0x65,0x6d,0x73,0x2e,0x20,0x6c,0x77,0x49,0x50,0x20,0x63,0x61,0x6e,0x20,0x62,
-0x65,0x20,0x75,0x73,0x65,0x64,0x20,0x65,0x69,0x74,0x68,0x65,0x72,0x0d,0x0a,0x09,
-0x20,0x20,0x20,0x20,0x77,0x69,0x74,0x68,0x20,0x6f,0x72,0x20,0x77,0x69,0x74,0x68,
-0x6f,0x75,0x74,0x20,0x61,0x6e,0x20,0x75,0x6e,0x64,0x65,0x72,0x6c,0x79,0x69,0x6e,
-0x67,0x20,0x4f,0x53,0x2e,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x2f,0x70,0x3e,0x0d,0x0a,
-0x09,0x20,0x20,0x3c,0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x6c,0x77,0x49,
-0x50,0x20,0x69,0x73,0x20,0x61,0x6e,0x20,0x6f,0x70,0x65,0x6e,0x20,0x73,0x6f,0x75,
-0x72,0x63,0x65,0x20,0x69,0x6d,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,0x61,0x74,0x69,
-0x6f,0x6e,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x54,0x43,0x50,0x2f,0x49,0x50,
-0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x70,0x72,0x6f,0x74,0x6f,0x63,0x6f,0x6c,0x20,
-0x73,0x75,0x69,0x74,0x65,0x20,0x74,0x68,0x61,0x74,0x20,0x77,0x61,0x73,0x20,0x6f,
-0x72,0x69,0x67,0x69,0x6e,0x61,0x6c,0x6c,0x79,0x20,0x77,0x72,0x69,0x74,0x74,0x65,
-0x6e,0x20,0x62,0x79,0x20,0x3c,0x61,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x68,0x72,
-0x65,0x66,0x3d,0x22,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x77,0x77,0x77,0x2e,0x73,
-0x69,0x63,0x73,0x2e,0x73,0x65,0x2f,0x7e,0x61,0x64,0x61,0x6d,0x2f,0x6c,0x77,0x69,
-0x70,0x2f,0x22,0x3e,0x41,0x64,0x61,0x6d,0x20,0x44,0x75,0x6e,0x6b,0x65,0x6c,0x73,
-0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x53,0x77,
-0x65,0x64,0x69,0x73,0x68,0x20,0x49,0x6e,0x73,0x74,0x69,0x74,0x75,0x74,0x65,0x20,
-0x6f,0x66,0x20,0x43,0x6f,0x6d,0x70,0x75,0x74,0x65,0x72,0x20,0x53,0x63,0x69,0x65,
-0x6e,0x63,0x65,0x3c,0x2f,0x61,0x3e,0x20,0x62,0x75,0x74,0x20,0x6e,0x6f,0x77,0x20,
-0x69,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x62,0x65,0x69,0x6e,0x67,0x20,0x61,
-0x63,0x74,0x69,0x76,0x65,0x6c,0x79,0x20,0x64,0x65,0x76,0x65,0x6c,0x6f,0x70,0x65,
-0x64,0x20,0x62,0x79,0x20,0x61,0x20,0x74,0x65,0x61,0x6d,0x20,0x6f,0x66,0x20,0x64,
-0x65,0x76,0x65,0x6c,0x6f,0x70,0x65,0x72,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,
-0x64,0x69,0x73,0x74,0x72,0x69,0x62,0x75,0x74,0x65,0x64,0x20,0x77,0x6f,0x72,0x6c,
-0x64,0x2d,0x77,0x69,0x64,0x65,0x2e,0x20,0x53,0x69,0x6e,0x63,0x65,0x20,0x69,0x74,
-0x27,0x73,0x20,0x72,0x65,0x6c,0x65,0x61,0x73,0x65,0x2c,0x20,0x6c,0x77,0x49,0x50,
-0x20,0x68,0x61,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x73,0x70,0x75,0x72,0x72,
-0x65,0x64,0x20,0x61,0x20,0x6c,0x6f,0x74,0x20,0x6f,0x66,0x20,0x69,0x6e,0x74,0x65,
-0x72,0x65,0x73,0x74,0x20,0x61,0x6e,0x64,0x20,0x68,0x61,0x73,0x20,0x62,0x65,0x65,
-0x6e,0x20,0x70,0x6f,0x72,0x74,0x65,0x64,0x20,0x74,0x6f,0x20,0x73,0x65,0x76,0x65,
-0x72,0x61,0x6c,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x70,0x6c,0x61,0x74,0x66,0x6f,
-0x72,0x6d,0x73,0x20,0x61,0x6e,0x64,0x20,0x6f,0x70,0x65,0x72,0x61,0x74,0x69,0x6e,
-0x67,0x20,0x73,0x79,0x73,0x74,0x65,0x6d,0x73,0x2e,0x20,0x6c,0x77,0x49,0x50,0x20,
-0x63,0x61,0x6e,0x20,0x62,0x65,0x20,0x75,0x73,0x65,0x64,0x20,0x65,0x69,0x74,0x68,
-0x65,0x72,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x77,0x69,0x74,0x68,0x20,0x6f,0x72,
-0x20,0x77,0x69,0x74,0x68,0x6f,0x75,0x74,0x20,0x61,0x6e,0x20,0x75,0x6e,0x64,0x65,
-0x72,0x6c,0x79,0x69,0x6e,0x67,0x20,0x4f,0x53,0x2e,0x0d,0x0a,0x09,0x20,0x20,0x3c,
-0x2f,0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,
-0x20,0x20,0x6c,0x77,0x49,0x50,0x20,0x69,0x73,0x20,0x61,0x6e,0x20,0x6f,0x70,0x65,
-0x6e,0x20,0x73,0x6f,0x75,0x72,0x63,0x65,0x20,0x69,0x6d,0x70,0x6c,0x65,0x6d,0x65,
-0x6e,0x74,0x61,0x74,0x69,0x6f,0x6e,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x54,
-0x43,0x50,0x2f,0x49,0x50,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x70,0x72,0x6f,0x74,
-0x6f,0x63,0x6f,0x6c,0x20,0x73,0x75,0x69,0x74,0x65,0x20,0x74,0x68,0x61,0x74,0x20,
-0x77,0x61,0x73,0x20,0x6f,0x72,0x69,0x67,0x69,0x6e,0x61,0x6c,0x6c,0x79,0x20,0x77,
-0x72,0x69,0x74,0x74,0x65,0x6e,0x20,0x62,0x79,0x20,0x3c,0x61,0x0d,0x0a,0x09,0x20,
-0x20,0x20,0x20,0x68,0x72,0x65,0x66,0x3d,0x22,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,
-0x77,0x77,0x77,0x2e,0x73,0x69,0x63,0x73,0x2e,0x73,0x65,0x2f,0x7e,0x61,0x64,0x61,
-0x6d,0x2f,0x6c,0x77,0x69,0x70,0x2f,0x22,0x3e,0x41,0x64,0x61,0x6d,0x20,0x44,0x75,
-0x6e,0x6b,0x65,0x6c,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x6f,0x66,0x20,0x74,
-0x68,0x65,0x20,0x53,0x77,0x65,0x64,0x69,0x73,0x68,0x20,0x49,0x6e,0x73,0x74,0x69,
-0x74,0x75,0x74,0x65,0x20,0x6f,0x66,0x20,0x43,0x6f,0x6d,0x70,0x75,0x74,0x65,0x72,
-0x20,0x53,0x63,0x69,0x65,0x6e,0x63,0x65,0x3c,0x2f,0x61,0x3e,0x20,0x62,0x75,0x74,
-0x20,0x6e,0x6f,0x77,0x20,0x69,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x62,0x65,
-0x69,0x6e,0x67,0x20,0x61,0x63,0x74,0x69,0x76,0x65,0x6c,0x79,0x20,0x64,0x65,0x76,
-0x65,0x6c,0x6f,0x70,0x65,0x64,0x20,0x62,0x79,0x20,0x61,0x20,0x74,0x65,0x61,0x6d,
-0x20,0x6f,0x66,0x20,0x64,0x65,0x76,0x65,0x6c,0x6f,0x70,0x65,0x72,0x73,0x0d,0x0a,
-0x09,0x20,0x20,0x20,0x20,0x64,0x69,0x73,0x74,0x72,0x69,0x62,0x75,0x74,0x65,0x64,
-0x20,0x77,0x6f,0x72,0x6c,0x64,0x2d,0x77,0x69,0x64,0x65,0x2e,0x20,0x53,0x69,0x6e,
-0x63,0x65,0x20,0x69,0x74,0x27,0x73,0x20,0x72,0x65,0x6c,0x65,0x61,0x73,0x65,0x2c,
-0x20,0x6c,0x77,0x49,0x50,0x20,0x68,0x61,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,
-0x73,0x70,0x75,0x72,0x72,0x65,0x64,0x20,0x61,0x20,0x6c,0x6f,0x74,0x20,0x6f,0x66,
-0x20,0x69,0x6e,0x74,0x65,0x72,0x65,0x73,0x74,0x20,0x61,0x6e,0x64,0x20,0x68,0x61,
-0x73,0x20,0x62,0x65,0x65,0x6e,0x20,0x70,0x6f,0x72,0x74,0x65,0x64,0x20,0x74,0x6f,
-0x20,0x73,0x65,0x76,0x65,0x72,0x61,0x6c,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x70,
-0x6c,0x61,0x74,0x66,0x6f,0x72,0x6d,0x73,0x20,0x61,0x6e,0x64,0x20,0x6f,0x70,0x65,
-0x72,0x61,0x74,0x69,0x6e,0x67,0x20,0x73,0x79,0x73,0x74,0x65,0x6d,0x73,0x2e,0x20,
-0x6c,0x77,0x49,0x50,0x20,0x63,0x61,0x6e,0x20,0x62,0x65,0x20,0x75,0x73,0x65,0x64,
-0x20,0x65,0x69,0x74,0x68,0x65,0x72,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x77,0x69,
-0x74,0x68,0x20,0x6f,0x72,0x20,0x77,0x69,0x74,0x68,0x6f,0x75,0x74,0x20,0x61,0x6e,
-0x20,0x75,0x6e,0x64,0x65,0x72,0x6c,0x79,0x69,0x6e,0x67,0x20,0x4f,0x53,0x2e,0x0d,
-0x0a,0x09,0x20,0x20,0x3c,0x2f,0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x70,0x3e,
-0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x6c,0x77,0x49,0x50,0x20,0x69,0x73,0x20,0x61,
-0x6e,0x20,0x6f,0x70,0x65,0x6e,0x20,0x73,0x6f,0x75,0x72,0x63,0x65,0x20,0x69,0x6d,
-0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,0x61,0x74,0x69,0x6f,0x6e,0x20,0x6f,0x66,0x20,
-0x74,0x68,0x65,0x20,0x54,0x43,0x50,0x2f,0x49,0x50,0x0d,0x0a,0x09,0x20,0x20,0x20,
-0x20,0x70,0x72,0x6f,0x74,0x6f,0x63,0x6f,0x6c,0x20,0x73,0x75,0x69,0x74,0x65,0x20,
-0x74,0x68,0x61,0x74,0x20,0x77,0x61,0x73,0x20,0x6f,0x72,0x69,0x67,0x69,0x6e,0x61,
-0x6c,0x6c,0x79,0x20,0x77,0x72,0x69,0x74,0x74,0x65,0x6e,0x20,0x62,0x79,0x20,0x3c,
-0x61,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x68,0x72,0x65,0x66,0x3d,0x22,0x68,0x74,
-0x74,0x70,0x3a,0x2f,0x2f,0x77,0x77,0x77,0x2e,0x73,0x69,0x63,0x73,0x2e,0x73,0x65,
-0x2f,0x7e,0x61,0x64,0x61,0x6d,0x2f,0x6c,0x77,0x69,0x70,0x2f,0x22,0x3e,0x41,0x64,
-0x61,0x6d,0x20,0x44,0x75,0x6e,0x6b,0x65,0x6c,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,
-0x20,0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x53,0x77,0x65,0x64,0x69,0x73,0x68,0x20,
-0x49,0x6e,0x73,0x74,0x69,0x74,0x75,0x74,0x65,0x20,0x6f,0x66,0x20,0x43,0x6f,0x6d,
-0x70,0x75,0x74,0x65,0x72,0x20,0x53,0x63,0x69,0x65,0x6e,0x63,0x65,0x3c,0x2f,0x61,
-0x3e,0x20,0x62,0x75,0x74,0x20,0x6e,0x6f,0x77,0x20,0x69,0x73,0x0d,0x0a,0x09,0x20,
-0x20,0x20,0x20,0x62,0x65,0x69,0x6e,0x67,0x20,0x61,0x63,0x74,0x69,0x76,0x65,0x6c,
-0x79,0x20,0x64,0x65,0x76,0x65,0x6c,0x6f,0x70,0x65,0x64,0x20,0x62,0x79,0x20,0x61,
-0x20,0x74,0x65,0x61,0x6d,0x20,0x6f,0x66,0x20,0x64,0x65,0x76,0x65,0x6c,0x6f,0x70,
-0x65,0x72,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x64,0x69,0x73,0x74,0x72,0x69,
-0x62,0x75,0x74,0x65,0x64,0x20,0x77,0x6f,0x72,0x6c,0x64,0x2d,0x77,0x69,0x64,0x65,
-0x2e,0x20,0x53,0x69,0x6e,0x63,0x65,0x20,0x69,0x74,0x27,0x73,0x20,0x72,0x65,0x6c,
-0x65,0x61,0x73,0x65,0x2c,0x20,0x6c,0x77,0x49,0x50,0x20,0x68,0x61,0x73,0x0d,0x0a,
-0x09,0x20,0x20,0x20,0x20,0x73,0x70,0x75,0x72,0x72,0x65,0x64,0x20,0x61,0x20,0x6c,
-0x6f,0x74,0x20,0x6f,0x66,0x20,0x69,0x6e,0x74,0x65,0x72,0x65,0x73,0x74,0x20,0x61,
-0x6e,0x64,0x20,0x68,0x61,0x73,0x20,0x62,0x65,0x65,0x6e,0x20,0x70,0x6f,0x72,0x74,
-0x65,0x64,0x20,0x74,0x6f,0x20,0x73,0x65,0x76,0x65,0x72,0x61,0x6c,0x0d,0x0a,0x09,
-0x20,0x20,0x20,0x20,0x70,0x6c,0x61,0x74,0x66,0x6f,0x72,0x6d,0x73,0x20,0x61,0x6e,
-0x64,0x20,0x6f,0x70,0x65,0x72,0x61,0x74,0x69,0x6e,0x67,0x20,0x73,0x79,0x73,0x74,
-0x65,0x6d,0x73,0x2e,0x20,0x6c,0x77,0x49,0x50,0x20,0x63,0x61,0x6e,0x20,0x62,0x65,
-0x20,0x75,0x73,0x65,0x64,0x20,0x65,0x69,0x74,0x68,0x65,0x72,0x0d,0x0a,0x09,0x20,
-0x20,0x20,0x20,0x77,0x69,0x74,0x68,0x20,0x6f,0x72,0x20,0x77,0x69,0x74,0x68,0x6f,
-0x75,0x74,0x20,0x61,0x6e,0x20,0x75,0x6e,0x64,0x65,0x72,0x6c,0x79,0x69,0x6e,0x67,
-0x20,0x4f,0x53,0x2e,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x2f,0x70,0x3e,0x0d,0x0a,0x09,
-0x20,0x20,0x3c,0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x6c,0x77,0x49,0x50,
-0x20,0x69,0x73,0x20,0x61,0x6e,0x20,0x6f,0x70,0x65,0x6e,0x20,0x73,0x6f,0x75,0x72,
-0x63,0x65,0x20,0x69,0x6d,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,0x61,0x74,0x69,0x6f,
-0x6e,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x54,0x43,0x50,0x2f,0x49,0x50,0x0d,
-0x0a,0x09,0x20,0x20,0x20,0x20,0x70,0x72,0x6f,0x74,0x6f,0x63,0x6f,0x6c,0x20,0x73,
-0x75,0x69,0x74,0x65,0x20,0x74,0x68,0x61,0x74,0x20,0x77,0x61,0x73,0x20,0x6f,0x72,
-0x69,0x67,0x69,0x6e,0x61,0x6c,0x6c,0x79,0x20,0x77,0x72,0x69,0x74,0x74,0x65,0x6e,
-0x20,0x62,0x79,0x20,0x3c,0x61,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x68,0x72,0x65,
-0x66,0x3d,0x22,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x77,0x77,0x77,0x2e,0x73,0x69,
-0x63,0x73,0x2e,0x73,0x65,0x2f,0x7e,0x61,0x64,0x61,0x6d,0x2f,0x6c,0x77,0x69,0x70,
-0x2f,0x22,0x3e,0x41,0x64,0x61,0x6d,0x20,0x44,0x75,0x6e,0x6b,0x65,0x6c,0x73,0x0d,
-0x0a,0x09,0x20,0x20,0x20,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x53,0x77,0x65,
-0x64,0x69,0x73,0x68,0x20,0x49,0x6e,0x73,0x74,0x69,0x74,0x75,0x74,0x65,0x20,0x6f,
-0x66,0x20,0x43,0x6f,0x6d,0x70,0x75,0x74,0x65,0x72,0x20,0x53,0x63,0x69,0x65,0x6e,
-0x63,0x65,0x3c,0x2f,0x61,0x3e,0x20,0x62,0x75,0x74,0x20,0x6e,0x6f,0x77,0x20,0x69,
-0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x62,0x65,0x69,0x6e,0x67,0x20,0x61,0x63,
-0x74,0x69,0x76,0x65,0x6c,0x79,0x20,0x64,0x65,0x76,0x65,0x6c,0x6f,0x70,0x65,0x64,
-0x20,0x62,0x79,0x20,0x61,0x20,0x74,0x65,0x61,0x6d,0x20,0x6f,0x66,0x20,0x64,0x65,
-0x76,0x65,0x6c,0x6f,0x70,0x65,0x72,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x64,
-0x69,0x73,0x74,0x72,0x69,0x62,0x75,0x74,0x65,0x64,0x20,0x77,0x6f,0x72,0x6c,0x64,
-0x2d,0x77,0x69,0x64,0x65,0x2e,0x20,0x53,0x69,0x6e,0x63,0x65,0x20,0x69,0x74,0x27,
-0x73,0x20,0x72,0x65,0x6c,0x65,0x61,0x73,0x65,0x2c,0x20,0x6c,0x77,0x49,0x50,0x20,
-0x68,0x61,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x73,0x70,0x75,0x72,0x72,0x65,
-0x64,0x20,0x61,0x20,0x6c,0x6f,0x74,0x20,0x6f,0x66,0x20,0x69,0x6e,0x74,0x65,0x72,
-0x65,0x73,0x74,0x20,0x61,0x6e,0x64,0x20,0x68,0x61,0x73,0x20,0x62,0x65,0x65,0x6e,
-0x20,0x70,0x6f,0x72,0x74,0x65,0x64,0x20,0x74,0x6f,0x20,0x73,0x65,0x76,0x65,0x72,
-0x61,0x6c,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x70,0x6c,0x61,0x74,0x66,0x6f,0x72,
-0x6d,0x73,0x20,0x61,0x6e,0x64,0x20,0x6f,0x70,0x65,0x72,0x61,0x74,0x69,0x6e,0x67,
-0x20,0x73,0x79,0x73,0x74,0x65,0x6d,0x73,0x2e,0x20,0x6c,0x77,0x49,0x50,0x20,0x63,
-0x61,0x6e,0x20,0x62,0x65,0x20,0x75,0x73,0x65,0x64,0x20,0x65,0x69,0x74,0x68,0x65,
-0x72,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x77,0x69,0x74,0x68,0x20,0x6f,0x72,0x20,
-0x77,0x69,0x74,0x68,0x6f,0x75,0x74,0x20,0x61,0x6e,0x20,0x75,0x6e,0x64,0x65,0x72,
-0x6c,0x79,0x69,0x6e,0x67,0x20,0x4f,0x53,0x2e,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x2f,
-0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x20,
-0x20,0x6c,0x77,0x49,0x50,0x20,0x69,0x73,0x20,0x61,0x6e,0x20,0x6f,0x70,0x65,0x6e,
-0x20,0x73,0x6f,0x75,0x72,0x63,0x65,0x20,0x69,0x6d,0x70,0x6c,0x65,0x6d,0x65,0x6e,
-0x74,0x61,0x74,0x69,0x6f,0x6e,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x54,0x43,
-0x50,0x2f,0x49,0x50,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x70,0x72,0x6f,0x74,0x6f,
-0x63,0x6f,0x6c,0x20,0x73,0x75,0x69,0x74,0x65,0x20,0x74,0x68,0x61,0x74,0x20,0x77,
-0x61,0x73,0x20,0x6f,0x72,0x69,0x67,0x69,0x6e,0x61,0x6c,0x6c,0x79,0x20,0x77,0x72,
-0x69,0x74,0x74,0x65,0x6e,0x20,0x62,0x79,0x20,0x3c,0x61,0x0d,0x0a,0x09,0x20,0x20,
-0x20,0x20,0x68,0x72,0x65,0x66,0x3d,0x22,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x77,
-0x77,0x77,0x2e,0x73,0x69,0x63,0x73,0x2e,0x73,0x65,0x2f,0x7e,0x61,0x64,0x61,0x6d,
-0x2f,0x6c,0x77,0x69,0x70,0x2f,0x22,0x3e,0x41,0x64,0x61,0x6d,0x20,0x44,0x75,0x6e,
-0x6b,0x65,0x6c,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x6f,0x66,0x20,0x74,0x68,
-0x65,0x20,0x53,0x77,0x65,0x64,0x69,0x73,0x68,0x20,0x49,0x6e,0x73,0x74,0x69,0x74,
-0x75,0x74,0x65,0x20,0x6f,0x66,0x20,0x43,0x6f,0x6d,0x70,0x75,0x74,0x65,0x72,0x20,
-0x53,0x63,0x69,0x65,0x6e,0x63,0x65,0x3c,0x2f,0x61,0x3e,0x20,0x62,0x75,0x74,0x20,
-0x6e,0x6f,0x77,0x20,0x69,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x62,0x65,0x69,
-0x6e,0x67,0x20,0x61,0x63,0x74,0x69,0x76,0x65,0x6c,0x79,0x20,0x64,0x65,0x76,0x65,
-0x6c,0x6f,0x70,0x65,0x64,0x20,0x62,0x79,0x20,0x61,0x20,0x74,0x65,0x61,0x6d,0x20,
-0x6f,0x66,0x20,0x64,0x65,0x76,0x65,0x6c,0x6f,0x70,0x65,0x72,0x73,0x0d,0x0a,0x09,
-0x20,0x20,0x20,0x20,0x64,0x69,0x73,0x74,0x72,0x69,0x62,0x75,0x74,0x65,0x64,0x20,
-0x77,0x6f,0x72,0x6c,0x64,0x2d,0x77,0x69,0x64,0x65,0x2e,0x20,0x53,0x69,0x6e,0x63,
-0x65,0x20,0x69,0x74,0x27,0x73,0x20,0x72,0x65,0x6c,0x65,0x61,0x73,0x65,0x2c,0x20,
-0x6c,0x77,0x49,0x50,0x20,0x68,0x61,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x73,
-0x70,0x75,0x72,0x72,0x65,0x64,0x20,0x61,0x20,0x6c,0x6f,0x74,0x20,0x6f,0x66,0x20,
-0x69,0x6e,0x74,0x65,0x72,0x65,0x73,0x74,0x20,0x61,0x6e,0x64,0x20,0x68,0x61,0x73,
-0x20,0x62,0x65,0x65,0x6e,0x20,0x70,0x6f,0x72,0x74,0x65,0x64,0x20,0x74,0x6f,0x20,
-0x73,0x65,0x76,0x65,0x72,0x61,0x6c,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x70,0x6c,
-0x61,0x74,0x66,0x6f,0x72,0x6d,0x73,0x20,0x61,0x6e,0x64,0x20,0x6f,0x70,0x65,0x72,
-0x61,0x74,0x69,0x6e,0x67,0x20,0x73,0x79,0x73,0x74,0x65,0x6d,0x73,0x2e,0x20,0x6c,
-0x77,0x49,0x50,0x20,0x63,0x61,0x6e,0x20,0x62,0x65,0x20,0x75,0x73,0x65,0x64,0x20,
-0x65,0x69,0x74,0x68,0x65,0x72,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x77,0x69,0x74,
-0x68,0x20,0x6f,0x72,0x20,0x77,0x69,0x74,0x68,0x6f,0x75,0x74,0x20,0x61,0x6e,0x20,
-0x75,0x6e,0x64,0x65,0x72,0x6c,0x79,0x69,0x6e,0x67,0x20,0x4f,0x53,0x2e,0x0d,0x0a,
-0x09,0x20,0x20,0x3c,0x2f,0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x70,0x3e,0x0d,
-0x0a,0x09,0x20,0x20,0x20,0x20,0x6c,0x77,0x49,0x50,0x20,0x69,0x73,0x20,0x61,0x6e,
-0x20,0x6f,0x70,0x65,0x6e,0x20,0x73,0x6f,0x75,0x72,0x63,0x65,0x20,0x69,0x6d,0x70,
-0x6c,0x65,0x6d,0x65,0x6e,0x74,0x61,0x74,0x69,0x6f,0x6e,0x20,0x6f,0x66,0x20,0x74,
-0x68,0x65,0x20,0x54,0x43,0x50,0x2f,0x49,0x50,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,
-0x70,0x72,0x6f,0x74,0x6f,0x63,0x6f,0x6c,0x20,0x73,0x75,0x69,0x74,0x65,0x20,0x74,
-0x68,0x61,0x74,0x20,0x77,0x61,0x73,0x20,0x6f,0x72,0x69,0x67,0x69,0x6e,0x61,0x6c,
-0x6c,0x79,0x20,0x77,0x72,0x69,0x74,0x74,0x65,0x6e,0x20,0x62,0x79,0x20,0x3c,0x61,
-0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x68,0x72,0x65,0x66,0x3d,0x22,0x68,0x74,0x74,
-0x70,0x3a,0x2f,0x2f,0x77,0x77,0x77,0x2e,0x73,0x69,0x63,0x73,0x2e,0x73,0x65,0x2f,
-0x7e,0x61,0x64,0x61,0x6d,0x2f,0x6c,0x77,0x69,0x70,0x2f,0x22,0x3e,0x41,0x64,0x61,
-0x6d,0x20,0x44,0x75,0x6e,0x6b,0x65,0x6c,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,
-0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x53,0x77,0x65,0x64,0x69,0x73,0x68,0x20,0x49,
-0x6e,0x73,0x74,0x69,0x74,0x75,0x74,0x65,0x20,0x6f,0x66,0x20,0x43,0x6f,0x6d,0x70,
-0x75,0x74,0x65,0x72,0x20,0x53,0x63,0x69,0x65,0x6e,0x63,0x65,0x3c,0x2f,0x61,0x3e,
-0x20,0x62,0x75,0x74,0x20,0x6e,0x6f,0x77,0x20,0x69,0x73,0x0d,0x0a,0x09,0x20,0x20,
-0x20,0x20,0x62,0x65,0x69,0x6e,0x67,0x20,0x61,0x63,0x74,0x69,0x76,0x65,0x6c,0x79,
-0x20,0x64,0x65,0x76,0x65,0x6c,0x6f,0x70,0x65,0x64,0x20,0x62,0x79,0x20,0x61,0x20,
-0x74,0x65,0x61,0x6d,0x20,0x6f,0x66,0x20,0x64,0x65,0x76,0x65,0x6c,0x6f,0x70,0x65,
-0x72,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x64,0x69,0x73,0x74,0x72,0x69,0x62,
-0x75,0x74,0x65,0x64,0x20,0x77,0x6f,0x72,0x6c,0x64,0x2d,0x77,0x69,0x64,0x65,0x2e,
-0x20,0x53,0x69,0x6e,0x63,0x65,0x20,0x69,0x74,0x27,0x73,0x20,0x72,0x65,0x6c,0x65,
-0x61,0x73,0x65,0x2c,0x20,0x6c,0x77,0x49,0x50,0x20,0x68,0x61,0x73,0x0d,0x0a,0x09,
-0x20,0x20,0x20,0x20,0x73,0x70,0x75,0x72,0x72,0x65,0x64,0x20,0x61,0x20,0x6c,0x6f,
-0x74,0x20,0x6f,0x66,0x20,0x69,0x6e,0x74,0x65,0x72,0x65,0x73,0x74,0x20,0x61,0x6e,
-0x64,0x20,0x68,0x61,0x73,0x20,0x62,0x65,0x65,0x6e,0x20,0x70,0x6f,0x72,0x74,0x65,
-0x64,0x20,0x74,0x6f,0x20,0x73,0x65,0x76,0x65,0x72,0x61,0x6c,0x0d,0x0a,0x09,0x20,
-0x20,0x20,0x20,0x70,0x6c,0x61,0x74,0x66,0x6f,0x72,0x6d,0x73,0x20,0x61,0x6e,0x64,
-0x20,0x6f,0x70,0x65,0x72,0x61,0x74,0x69,0x6e,0x67,0x20,0x73,0x79,0x73,0x74,0x65,
-0x6d,0x73,0x2e,0x20,0x6c,0x77,0x49,0x50,0x20,0x63,0x61,0x6e,0x20,0x62,0x65,0x20,
-0x75,0x73,0x65,0x64,0x20,0x65,0x69,0x74,0x68,0x65,0x72,0x0d,0x0a,0x09,0x20,0x20,
-0x20,0x20,0x77,0x69,0x74,0x68,0x20,0x6f,0x72,0x20,0x77,0x69,0x74,0x68,0x6f,0x75,
-0x74,0x20,0x61,0x6e,0x20,0x75,0x6e,0x64,0x65,0x72,0x6c,0x79,0x69,0x6e,0x67,0x20,
-0x4f,0x53,0x2e,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x2f,0x70,0x3e,0x0d,0x0a,0x09,0x20,
-0x20,0x3c,0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x54,0x68,0x65,0x20,0x66,
-0x6f,0x63,0x75,0x73,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x6c,0x77,0x49,0x50,
-0x20,0x54,0x43,0x50,0x2f,0x49,0x50,0x20,0x69,0x6d,0x70,0x6c,0x65,0x6d,0x65,0x6e,
-0x74,0x61,0x74,0x69,0x6f,0x6e,0x20,0x69,0x73,0x20,0x74,0x6f,0x20,0x72,0x65,0x64,
-0x75,0x63,0x65,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x74,0x68,0x65,0x20,0x52,0x41,
-0x4d,0x20,0x75,0x73,0x61,0x67,0x65,0x20,0x77,0x68,0x69,0x6c,0x65,0x20,0x73,0x74,
-0x69,0x6c,0x6c,0x20,0x68,0x61,0x76,0x69,0x6e,0x67,0x20,0x61,0x20,0x66,0x75,0x6c,
-0x6c,0x20,0x73,0x63,0x61,0x6c,0x65,0x20,0x54,0x43,0x50,0x2e,0x20,0x54,0x68,0x69,
-0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x6d,0x61,0x6b,0x65,0x73,0x20,0x6c,0x77,
-0x49,0x50,0x20,0x73,0x75,0x69,0x74,0x61,0x62,0x6c,0x65,0x20,0x66,0x6f,0x72,0x20,
-0x75,0x73,0x65,0x20,0x69,0x6e,0x20,0x65,0x6d,0x62,0x65,0x64,0x64,0x65,0x64,0x20,
-0x73,0x79,0x73,0x74,0x65,0x6d,0x73,0x20,0x77,0x69,0x74,0x68,0x20,0x74,0x65,0x6e,
-0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x6f,0x66,0x20,0x6b,0x69,0x6c,0x6f,0x62,
-0x79,0x74,0x65,0x73,0x20,0x6f,0x66,0x20,0x66,0x72,0x65,0x65,0x20,0x52,0x41,0x4d,
-0x20,0x61,0x6e,0x64,0x20,0x72,0x6f,0x6f,0x6d,0x20,0x66,0x6f,0x72,0x20,0x61,0x72,
-0x6f,0x75,0x6e,0x64,0x20,0x34,0x30,0x20,0x6b,0x69,0x6c,0x6f,0x62,0x79,0x74,0x65,
-0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x6f,0x66,0x20,0x63,0x6f,0x64,0x65,0x20,
-0x52,0x4f,0x4d,0x2e,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x2f,0x70,0x3e,0x0d,0x0a,0x09,
-0x20,0x20,0x3c,0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x4d,0x6f,0x72,0x65,
-0x20,0x69,0x6e,0x66,0x6f,0x72,0x6d,0x61,0x74,0x69,0x6f,0x6e,0x20,0x61,0x62,0x6f,
-0x75,0x74,0x20,0x6c,0x77,0x49,0x50,0x20,0x63,0x61,0x6e,0x20,0x62,0x65,0x20,0x66,
-0x6f,0x75,0x6e,0x64,0x20,0x61,0x74,0x20,0x74,0x68,0x65,0x20,0x6c,0x77,0x49,0x50,
-0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x68,0x6f,0x6d,0x65,0x70,0x61,0x67,0x65,0x20,
-0x61,0x74,0x20,0x3c,0x61,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x68,0x72,0x65,0x66,
-0x3d,0x22,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x73,0x61,0x76,0x61,0x6e,0x6e,0x61,
-0x68,0x2e,0x6e,0x6f,0x6e,0x67,0x6e,0x75,0x2e,0x6f,0x72,0x67,0x2f,0x70,0x72,0x6f,
-0x6a,0x65,0x63,0x74,0x73,0x2f,0x6c,0x77,0x69,0x70,0x2f,0x22,0x3e,0x68,0x74,0x74,
-0x70,0x3a,0x2f,0x2f,0x73,0x61,0x76,0x61,0x6e,0x6e,0x61,0x68,0x2e,0x6e,0x6f,0x6e,
-0x67,0x6e,0x75,0x2e,0x6f,0x72,0x67,0x2f,0x70,0x72,0x6f,0x6a,0x65,0x63,0x74,0x73,
-0x2f,0x6c,0x77,0x69,0x70,0x2f,0x3c,0x2f,0x61,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x20,
-0x20,0x6f,0x72,0x20,0x61,0x74,0x20,0x74,0x68,0x65,0x20,0x6c,0x77,0x49,0x50,0x20,
-0x77,0x69,0x6b,0x69,0x20,0x61,0x74,0x20,0x3c,0x61,0x0d,0x0a,0x09,0x20,0x20,0x20,
-0x20,0x68,0x72,0x65,0x66,0x3d,0x22,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x6c,0x77,
-0x69,0x70,0x2e,0x77,0x69,0x6b,0x69,0x61,0x2e,0x63,0x6f,0x6d,0x2f,0x22,0x3e,0x68,
-0x74,0x74,0x70,0x3a,0x2f,0x2f,0x6c,0x77,0x69,0x70,0x2e,0x77,0x69,0x6b,0x69,0x61,
-0x2e,0x63,0x6f,0x6d,0x2f,0x3c,0x2f,0x61,0x3e,0x2e,0x0d,0x0a,0x09,0x20,0x20,0x3c,
-0x2f,0x70,0x3e,0x0d,0x0a,0x09,0x3c,0x2f,0x74,0x64,0x3e,0x3c,0x74,0x64,0x3e,0x0d,
-0x0a,0x09,0x20,0x20,0x26,0x6e,0x62,0x73,0x70,0x3b,0x0d,0x0a,0x09,0x3c,0x2f,0x74,
-0x64,0x3e,0x3c,0x2f,0x74,0x72,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x3c,
-0x2f,0x74,0x61,0x62,0x6c,0x65,0x3e,0x0d,0x0a,0x3c,0x2f,0x62,0x6f,0x64,0x79,0x3e,
-0x0d,0x0a,0x3c,0x2f,0x68,0x74,0x6d,0x6c,0x3e,0x0d,0x0a,0x0d,0x0a,};
-
-
-
-const struct fsdata_file file__img_sics_gif[] = { {
-file_NULL,
-data__img_sics_gif,
-data__img_sics_gif + 16,
-sizeof(data__img_sics_gif) - 16,
-FS_FILE_FLAGS_HEADER_INCLUDED | FS_FILE_FLAGS_HEADER_PERSISTENT | FS_FILE_FLAGS_HEADER_HTTPVER_1_1,
-}};
-
-const struct fsdata_file file__404_html[] = { {
-file__img_sics_gif,
-data__404_html,
-data__404_html + 12,
-sizeof(data__404_html) - 12,
-FS_FILE_FLAGS_HEADER_INCLUDED | FS_FILE_FLAGS_HEADER_PERSISTENT | FS_FILE_FLAGS_HEADER_HTTPVER_1_1,
-}};
-
-const struct fsdata_file file__index_html[] = { {
-file__404_html,
-data__index_html,
-data__index_html + 12,
-sizeof(data__index_html) - 12,
-FS_FILE_FLAGS_HEADER_INCLUDED | FS_FILE_FLAGS_HEADER_PERSISTENT | FS_FILE_FLAGS_HEADER_HTTPVER_1_1,
-}};
-
-const struct fsdata_file file__login_html[] = { {
-file__index_html,
-data__login_html,
-data__login_html + 12,
-sizeof(data__login_html) - 12,
-FS_FILE_FLAGS_HEADER_INCLUDED | FS_FILE_FLAGS_HEADER_PERSISTENT | FS_FILE_FLAGS_HEADER_HTTPVER_1_1,
-}};
-
-const struct fsdata_file file__loginfail_html[] = { {
-file__login_html,
-data__loginfail_html,
-data__loginfail_html + 16,
-sizeof(data__loginfail_html) - 16,
-FS_FILE_FLAGS_HEADER_INCLUDED | FS_FILE_FLAGS_HEADER_PERSISTENT | FS_FILE_FLAGS_HEADER_HTTPVER_1_1,
-}};
-
-const struct fsdata_file file__session_html[] = { {
-file__loginfail_html,
-data__session_html,
-data__session_html + 16,
-sizeof(data__session_html) - 16,
-FS_FILE_FLAGS_HEADER_INCLUDED | FS_FILE_FLAGS_HEADER_PERSISTENT | FS_FILE_FLAGS_HEADER_HTTPVER_1_1,
-}};
-
-const struct fsdata_file file__ssi_shtml[] = { {
-file__session_html,
-data__ssi_shtml,
-data__ssi_shtml + 12,
-sizeof(data__ssi_shtml) - 12,
-FS_FILE_FLAGS_HEADER_INCLUDED | FS_FILE_FLAGS_SSI,
-}};
-
-#define FS_ROOT file__ssi_shtml
-#define FS_NUMFILES 7
-
diff --git a/contrib/examples/httpd/fs_example/fs_example.c b/contrib/examples/httpd/fs_example/fs_example.c
deleted file mode 100644
index 92c64354..00000000
--- a/contrib/examples/httpd/fs_example/fs_example.c
+++ /dev/null
@@ -1,321 +0,0 @@
-/**
- * @file
- * HTTPD custom file system example
- *
- * This file demonstrates how to add support for an external file system to httpd.
- * It provides access to the specified root directory and uses stdio.h file functions
- * to read files.
- *
- * ATTENTION: This implementation is *not* secure: no checks are added to ensure
- * files are only read below the specified root directory!
- */
- 
- /*
- * Copyright (c) 2017 Simon Goldschmidt
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Simon Goldschmidt <goldsimon@gmx.de>
- *
- */
-
-#include "lwip/opt.h"
-#include "fs_example.h"
-
-#include "lwip/apps/fs.h"
-#include "lwip/def.h"
-#include "lwip/mem.h"
-
-#include <stdio.h>
-#include <string.h>
-
-/** define LWIP_HTTPD_EXAMPLE_CUSTOMFILES to 1 to enable this file system */
-#ifndef LWIP_HTTPD_EXAMPLE_CUSTOMFILES
-#define LWIP_HTTPD_EXAMPLE_CUSTOMFILES 0
-#endif
-
-/** define LWIP_HTTPD_EXAMPLE_CUSTOMFILES_DELAYED to 1 to delay open and read
- * as if e.g. reading from external SPI flash */
-#ifndef LWIP_HTTPD_EXAMPLE_CUSTOMFILES_DELAYED
-#define LWIP_HTTPD_EXAMPLE_CUSTOMFILES_DELAYED 1
-#endif
-
-/** define LWIP_HTTPD_EXAMPLE_CUSTOMFILES_LIMIT_READ to the number of bytes
- * to read to emulate limited transfer buffers and don't read whole files in
- * one chunk.
- * WARNING: lowering this slows down the connection!
- */
-#ifndef LWIP_HTTPD_EXAMPLE_CUSTOMFILES_LIMIT_READ
-#define LWIP_HTTPD_EXAMPLE_CUSTOMFILES_LIMIT_READ 0
-#endif
-
-#if LWIP_HTTPD_EXAMPLE_CUSTOMFILES
-
-#if !LWIP_HTTPD_CUSTOM_FILES
-#error This needs LWIP_HTTPD_CUSTOM_FILES
-#endif
-#if !LWIP_HTTPD_DYNAMIC_HEADERS
-#error This needs LWIP_HTTPD_DYNAMIC_HEADERS
-#endif
-#if !LWIP_HTTPD_DYNAMIC_FILE_READ
-#error This wants to demonstrate read-after-open, so LWIP_HTTPD_DYNAMIC_FILE_READ is required!
-#endif
-#if !LWIP_HTTPD_FS_ASYNC_READ
-#error This needs LWIP_HTTPD_FS_ASYNC_READ
-#endif
-
-#if LWIP_HTTPD_EXAMPLE_CUSTOMFILES_DELAYED
-#include "lwip/tcpip.h"
-#endif
-
-struct fs_custom_data {
-  FILE *f;
-#if LWIP_HTTPD_EXAMPLE_CUSTOMFILES_DELAYED
-  int delay_read;
-  fs_wait_cb callback_fn;
-  void *callback_arg;
-#endif
-};
-
-const char* fs_ex_root_dir;
-
-void
-fs_ex_init(const char *httpd_root_dir)
-{
-  fs_ex_root_dir = strdup(httpd_root_dir);
-}
-
-#if LWIP_HTTPD_CUSTOM_FILES
-int
-fs_open_custom(struct fs_file *file, const char *name)
-{
-  char full_filename[256];
-  FILE *f;
-
-  snprintf(full_filename, 255, "%s%s", fs_ex_root_dir, name);
-  full_filename[255] = 0;
-
-  f = fopen(full_filename, "rb");
-  if (f != NULL) {
-    if (!fseek(f, 0, SEEK_END)) {
-      int len = (int)ftell(f);
-      if(!fseek(f, 0, SEEK_SET)) {
-        struct fs_custom_data *data = (struct fs_custom_data *)mem_malloc(sizeof(struct fs_custom_data));
-        LWIP_ASSERT("out of memory?", data != NULL);
-        memset(file, 0, sizeof(struct fs_file));
-#if LWIP_HTTPD_EXAMPLE_CUSTOMFILES_DELAYED
-        file->len = 0; /* read size delayed */
-        data->delay_read = 3;
-        LWIP_UNUSED_ARG(len);
-#else
-        file->len = len;
-#endif
-        file->flags = FS_FILE_FLAGS_HEADER_PERSISTENT;
-        data->f = f;
-        file->pextension = data;
-        return 1;
-      }
-    }
-    fclose(f);
-  }
-  return 0;
-}
-
-void
-fs_close_custom(struct fs_file *file)
-{
-  if (file && file->pextension) {
-    struct fs_custom_data *data = (struct fs_custom_data *)file->pextension;
-    if (data->f != NULL) {
-      fclose(data->f);
-      data->f = NULL;
-    }
-    mem_free(data);
-  }
-}
-
-#if LWIP_HTTPD_FS_ASYNC_READ
-u8_t
-fs_canread_custom(struct fs_file *file)
-{
-  /* This function is only necessary for asynchronous I/O:
-     If reading would block, return 0 and implement fs_wait_read_custom() to call the
-     supplied callback if reading works. */
-#if LWIP_HTTPD_EXAMPLE_CUSTOMFILES_DELAYED
-  struct fs_custom_data *data;
-  LWIP_ASSERT("file != NULL", file != NULL);
-  data = (struct fs_custom_data *)file->pextension;
-  if (data == NULL) {
-    /* file transfer has been completed already */
-    LWIP_ASSERT("transfer complete", file->index == file->len);
-    return 1;
-  }
-  LWIP_ASSERT("data != NULL", data != NULL);
-  /* This just simulates a simple delay. This delay would normally come e.g. from SPI transfer */
-  if (data->delay_read == 3) {
-    /* delayed file size mode */
-    data->delay_read = 1;
-    LWIP_ASSERT("", file->len == 0);
-    if (!fseek(data->f, 0, SEEK_END)) {
-      int len = (int)ftell(data->f);
-      if(!fseek(data->f, 0, SEEK_SET)) {
-        file->len = len; /* read size delayed */
-        data->delay_read = 1;
-        return 0;
-      }
-    }
-    /* if we come here, something is wrong with the file */
-    LWIP_ASSERT("file error", 0);
-  }
-  if (data->delay_read == 1) {
-    /* tell read function to delay further */
-  }
-#endif
-  LWIP_UNUSED_ARG(file);
-  return 1;
-}
-
-#if LWIP_HTTPD_EXAMPLE_CUSTOMFILES_DELAYED
-static void
-fs_example_read_cb(void *arg)
-{
-  struct fs_custom_data *data = (struct fs_custom_data *)arg;
-  fs_wait_cb callback_fn = data->callback_fn;
-  void *callback_arg = data->callback_arg;
-  data->callback_fn = NULL;
-  data->callback_arg = NULL;
-
-  LWIP_ASSERT("no callback_fn", callback_fn != NULL);
-
-  callback_fn(callback_arg);
-}
-#endif
-
-u8_t
-fs_wait_read_custom(struct fs_file *file, fs_wait_cb callback_fn, void *callback_arg)
-{
-#if LWIP_HTTPD_EXAMPLE_CUSTOMFILES_DELAYED
-  err_t err;
-  struct fs_custom_data *data = (struct fs_custom_data *)file->pextension;
-  LWIP_ASSERT("data not set", data != NULL);
-  data->callback_fn = callback_fn;
-  data->callback_arg = callback_arg;
-  err = tcpip_try_callback(fs_example_read_cb, data);
-  LWIP_ASSERT("out of queue elements?", err == ERR_OK);
-  LWIP_UNUSED_ARG(err);
-#else
-  LWIP_ASSERT("not implemented in this example configuration", 0);
-#endif
-  LWIP_UNUSED_ARG(file);
-  LWIP_UNUSED_ARG(callback_fn);
-  LWIP_UNUSED_ARG(callback_arg);
-  /* Return
-     - 1 if ready to read (at least one byte)
-     - 0 if reading should be delayed (call 'tcpip_callback(callback_fn, callback_arg)' when ready) */
-  return 1;
-}
-
-int
-fs_read_async_custom(struct fs_file *file, char *buffer, int count, fs_wait_cb callback_fn, void *callback_arg)
-{
-  struct fs_custom_data *data = (struct fs_custom_data *)file->pextension;
-  FILE *f;
-  int len;
-  int read_count = count;
-  LWIP_ASSERT("data not set", data != NULL);
-
-#if LWIP_HTTPD_EXAMPLE_CUSTOMFILES_DELAYED
-  /* This just simulates a delay. This delay would normally come e.g. from SPI transfer */
-  LWIP_ASSERT("invalid state", data->delay_read >= 0 && data->delay_read <= 2);
-  if (data->delay_read == 2) {
-    /* no delay next time */
-    data->delay_read = 0;
-    return FS_READ_DELAYED;
-  } else if (data->delay_read == 1) {
-    err_t err;
-    /* execute requested delay */
-    data->delay_read = 2;
-    LWIP_ASSERT("duplicate callback request", data->callback_fn == NULL);
-    data->callback_fn = callback_fn;
-    data->callback_arg = callback_arg;
-    err = tcpip_try_callback(fs_example_read_cb, data);
-    LWIP_ASSERT("out of queue elements?", err == ERR_OK);
-    LWIP_UNUSED_ARG(err);
-    return FS_READ_DELAYED;
-  }
-  /* execute this read but delay the next one */
-  data->delay_read = 1;
-#endif
-
-#if LWIP_HTTPD_EXAMPLE_CUSTOMFILES_LIMIT_READ
-  read_count = LWIP_MIN(read_count, LWIP_HTTPD_EXAMPLE_CUSTOMFILES_LIMIT_READ);
-#endif
-
-  f = data->f;
-  len = (int)fread(buffer, 1, read_count, f);
-
-  LWIP_UNUSED_ARG(callback_fn);
-  LWIP_UNUSED_ARG(callback_arg);
-
-  file->index += len;
-
-  /* Return
-     - FS_READ_EOF if all bytes have been read
-     - FS_READ_DELAYED if reading is delayed (call 'tcpip_callback(callback_fn, callback_arg)' when done) */
-  if (len == 0) {
-    /* all bytes read already */
-    return FS_READ_EOF;
-  }
-  return len;
-}
-
-#else /* LWIP_HTTPD_FS_ASYNC_READ */
-int
-fs_read_custom(struct fs_file *file, char *buffer, int count)
-{
-  struct fs_custom_data *data = (struct fs_custom_data *)file->pextension;
-  FILE *f;
-  int len;
-  int read_count = count;
-  LWIP_ASSERT("data not set", data != NULL);
-
-#if LWIP_HTTPD_EXAMPLE_CUSTOMFILES_LIMIT_READ
-  read_count = LWIP_MIN(read_count, LWIP_HTTPD_EXAMPLE_CUSTOMFILES_LIMIT_READ);
-#endif
-
-  f = data->f;
-  len = (int)fread(buffer, 1, read_count, f);
-
-  file->index += len;
-
-  /* Return FS_READ_EOF if all bytes have been read */
-  return len;
-}
-
-#endif /* LWIP_HTTPD_FS_ASYNC_READ */
-#endif /* LWIP_HTTPD_CUSTOM_FILES */
-
-#endif /* LWIP_HTTPD_EXAMPLE_CUSTOMFILES */
diff --git a/contrib/examples/httpd/fs_example/fs_example.h b/contrib/examples/httpd/fs_example/fs_example.h
deleted file mode 100644
index b399e4d5..00000000
--- a/contrib/examples/httpd/fs_example/fs_example.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (c) 2017 Simon Goldschmidt
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Simon Goldschmidt <goldsimon@gmx.de>
- *
- */
-
-#ifndef LWIP_HDR_HTTP_EXAMPLES_FS_EXAMPLE
-#define LWIP_HDR_HTTP_EXAMPLES_FS_EXAMPLE
-
-void fs_ex_init(const char *httpd_root_dir);
-
-#endif /* LWIP_HDR_HTTP_EXAMPLES_FS_EXAMPLE */
diff --git a/contrib/examples/httpd/genfiles_example/genfiles_example.c b/contrib/examples/httpd/genfiles_example/genfiles_example.c
deleted file mode 100644
index 95e5bdb7..00000000
--- a/contrib/examples/httpd/genfiles_example/genfiles_example.c
+++ /dev/null
@@ -1,183 +0,0 @@
-/**
- * @file
- * HTTPD custom file system example for runtime generated files
- *
- * This file demonstrates how to add support for generated files to httpd.
- */
- 
- /*
- * Copyright (c) 2017 Simon Goldschmidt
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Simon Goldschmidt <goldsimon@gmx.de>
- *
- */
-
-#include "lwip/opt.h"
-#include "genfiles_example.h"
-
-#include "lwip/apps/fs.h"
-#include "lwip/def.h"
-#include "lwip/mem.h"
-
-#include <stdio.h>
-#include <string.h>
-
-/** define LWIP_HTTPD_EXAMPLE_GENERATEDFILES to 1 to enable this file system */
-#ifndef LWIP_HTTPD_EXAMPLE_GENERATEDFILES
-#define LWIP_HTTPD_EXAMPLE_GENERATEDFILES 0
-#endif
-
-#if LWIP_HTTPD_EXAMPLE_GENERATEDFILES
-
-#if !LWIP_HTTPD_CUSTOM_FILES
-#error This needs LWIP_HTTPD_CUSTOM_FILES
-#endif
-#if !LWIP_HTTPD_DYNAMIC_HEADERS
-#error This needs LWIP_HTTPD_DYNAMIC_HEADERS
-#endif
-
-/* This is the page we send. It's not generated, as you see.
- * Generating custom things instead of memcpy is left to your imagination :-)
- */
-const char generated_html[] =
-"<html>\n"
-"<head><title>lwIP - A Lightweight TCP/IP Stack</title></head>\n"
-" <body bgcolor=\"white\" text=\"black\">\n"
-"  <table width=\"100%\">\n"
-"   <tr valign=\"top\">\n"
-"    <td width=\"80\">\n"
-"     <a href=\"http://www.sics.se/\"><img src=\"/img/sics.gif\"\n"
-"      border=\"0\" alt=\"SICS logo\" title=\"SICS logo\"></a>\n"
-"    </td>\n"
-"    <td width=\"500\">\n"
-"     <h1>lwIP - A Lightweight TCP/IP Stack</h1>\n"
-"     <h2>Generated page</h2>\n"
-"     <p>This page might be generated in-memory at runtime</p>\n"
-"    </td>\n"
-"    <td>\n"
-"    &nbsp;\n"
-"    </td>\n"
-"   </tr>\n"
-"  </table>\n"
-" </body>\n"
-"</html>";
-
-
-void
-genfiles_ex_init(void)
-{
-  /* nothing to do here yet */
-}
-
-int
-fs_open_custom(struct fs_file *file, const char *name)
-{
-  /* this example only provides one file */
-  if (!strcmp(name, "/generated.html")) {
-    /* initialize fs_file correctly */
-    memset(file, 0, sizeof(struct fs_file));
-    file->pextension = mem_malloc(sizeof(generated_html));
-    if (file->pextension != NULL) {
-      /* instead of doing memcpy, you would generate e.g. a JSON here */
-      memcpy(file->pextension, generated_html, sizeof(generated_html));
-      file->data = (const char *)file->pextension;
-      file->len = sizeof(generated_html) - 1; /* don't send the trailing 0 */
-      file->index = file->len;
-      /* allow persisteng connections */
-      file->flags = FS_FILE_FLAGS_HEADER_PERSISTENT;
-      return 1;
-    }
-  }
-  return 0;
-}
-
-void
-fs_close_custom(struct fs_file *file)
-{
-  if (file && file->pextension) {
-    mem_free(file->pextension);
-    file->pextension = NULL;
-  }
-}
-
-#if LWIP_HTTPD_FS_ASYNC_READ
-u8_t
-fs_canread_custom(struct fs_file *file)
-{
-  LWIP_UNUSED_ARG(file);
-  /* This example does not use delayed/async reading */
-  return 1;
-}
-
-u8_t
-fs_wait_read_custom(struct fs_file *file, fs_wait_cb callback_fn, void *callback_arg)
-{
-  LWIP_ASSERT("not implemented in this example configuration", 0);
-  LWIP_UNUSED_ARG(file);
-  LWIP_UNUSED_ARG(callback_fn);
-  LWIP_UNUSED_ARG(callback_arg);
-  /* Return
-     - 1 if ready to read (at least one byte)
-     - 0 if reading should be delayed (call 'tcpip_callback(callback_fn, callback_arg)' when ready) */
-  return 1;
-}
-
-int
-fs_read_async_custom(struct fs_file *file, char *buffer, int count, fs_wait_cb callback_fn, void *callback_arg)
-{
-  LWIP_ASSERT("not implemented in this example configuration", 0);
-  LWIP_UNUSED_ARG(file);
-  LWIP_UNUSED_ARG(buffer);
-  LWIP_UNUSED_ARG(count);
-  LWIP_UNUSED_ARG(callback_fn);
-  LWIP_UNUSED_ARG(callback_arg);
-  /* Return
-     - FS_READ_EOF if all bytes have been read
-     - FS_READ_DELAYED if reading is delayed (call 'tcpip_callback(callback_fn, callback_arg)' when done) */
-  /* all bytes read already */
-  return FS_READ_EOF;
-}
-
-#else /* LWIP_HTTPD_FS_ASYNC_READ */
-int
-fs_read_custom(struct fs_file *file, char *buffer, int count)
-{
-  LWIP_ASSERT("not implemented in this example configuration", 0);
-  LWIP_UNUSED_ARG(file);
-  LWIP_UNUSED_ARG(buffer);
-  LWIP_UNUSED_ARG(count);
-  /* Return
-     - FS_READ_EOF if all bytes have been read
-     - FS_READ_DELAYED if reading is delayed (call 'tcpip_callback(callback_fn, callback_arg)' when done) */
-  /* all bytes read already */
-  return FS_READ_EOF;
-}
-
-#endif /* LWIP_HTTPD_FS_ASYNC_READ */
-
-#endif /* LWIP_HTTPD_EXAMPLE_GENERATEDFILES */
diff --git a/contrib/examples/httpd/genfiles_example/genfiles_example.h b/contrib/examples/httpd/genfiles_example/genfiles_example.h
deleted file mode 100644
index dd9731e0..00000000
--- a/contrib/examples/httpd/genfiles_example/genfiles_example.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (c) 2017 Simon Goldschmidt
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Simon Goldschmidt <goldsimon@gmx.de>
- *
- */
-
-#ifndef LWIP_HDR_HTTP_EXAMPLES_GENFILES_EXAMPLE
-#define LWIP_HDR_HTTP_EXAMPLES_GENFILES_EXAMPLE
-
-void genfiles_ex_init(void);
-
-#endif /* LWIP_HDR_HTTP_EXAMPLES_GENFILES_EXAMPLE */
diff --git a/contrib/examples/httpd/post_example/post_example.c b/contrib/examples/httpd/post_example/post_example.c
deleted file mode 100644
index 110b3f12..00000000
--- a/contrib/examples/httpd/post_example/post_example.c
+++ /dev/null
@@ -1,157 +0,0 @@
-/**
- * @file
- * HTTPD example for simple POST
- */
- 
- /*
- * Copyright (c) 2017 Simon Goldschmidt
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Simon Goldschmidt <goldsimon@gmx.de>
- *
- */
-
-#include "lwip/opt.h"
-
-#include "lwip/apps/httpd.h"
-#include "lwip/def.h"
-#include "lwip/mem.h"
-
-#include <stdio.h>
-#include <string.h>
-
-/** define LWIP_HTTPD_EXAMPLE_GENERATEDFILES to 1 to enable this file system */
-#ifndef LWIP_HTTPD_EXAMPLE_SIMPLEPOST
-#define LWIP_HTTPD_EXAMPLE_SIMPLEPOST 0
-#endif
-
-#if LWIP_HTTPD_EXAMPLE_SIMPLEPOST
-
-#if !LWIP_HTTPD_SUPPORT_POST
-#error This needs LWIP_HTTPD_SUPPORT_POST
-#endif
-
-#define USER_PASS_BUFSIZE 16
-
-static void *current_connection;
-static void *valid_connection;
-static char last_user[USER_PASS_BUFSIZE];
-
-err_t
-httpd_post_begin(void *connection, const char *uri, const char *http_request,
-                 u16_t http_request_len, int content_len, char *response_uri,
-                 u16_t response_uri_len, u8_t *post_auto_wnd)
-{
-  LWIP_UNUSED_ARG(connection);
-  LWIP_UNUSED_ARG(http_request);
-  LWIP_UNUSED_ARG(http_request_len);
-  LWIP_UNUSED_ARG(content_len);
-  LWIP_UNUSED_ARG(post_auto_wnd);
-  if (!memcmp(uri, "/login.cgi", 11)) {
-    if (current_connection != connection) {
-      current_connection = connection;
-      valid_connection = NULL;
-      /* default page is "login failed" */
-      snprintf(response_uri, response_uri_len, "/loginfail.html");
-      /* e.g. for large uploads to slow flash over a fast connection, you should
-         manually update the rx window. That way, a sender can only send a full
-         tcp window at a time. If this is required, set 'post_aut_wnd' to 0.
-         We do not need to throttle upload speed here, so: */
-      *post_auto_wnd = 1;
-      return ERR_OK;
-    }
-  }
-  return ERR_VAL;
-}
-
-err_t
-httpd_post_receive_data(void *connection, struct pbuf *p)
-{
-  if (current_connection == connection) {
-    u16_t token_user = pbuf_memfind(p, "user=", 5, 0);
-    u16_t token_pass = pbuf_memfind(p, "pass=", 5, 0);
-    if ((token_user != 0xFFFF) && (token_pass != 0xFFFF)) {
-      u16_t value_user = token_user + 5;
-      u16_t value_pass = token_pass + 5;
-      u16_t len_user = 0;
-      u16_t len_pass = 0;
-      u16_t tmp;
-      /* find user len */
-      tmp = pbuf_memfind(p, "&", 1, value_user);
-      if (tmp != 0xFFFF) {
-        len_user = tmp - value_user;
-      } else {
-        len_user = p->tot_len - value_user;
-      }
-      /* find pass len */
-      tmp = pbuf_memfind(p, "&", 1, value_pass);
-      if (tmp != 0xFFFF) {
-        len_pass = tmp - value_pass;
-      } else {
-        len_pass = p->tot_len - value_pass;
-      }
-      if ((len_user > 0) && (len_user < USER_PASS_BUFSIZE) &&
-          (len_pass > 0) && (len_pass < USER_PASS_BUFSIZE)) {
-        /* provide contiguous storage if p is a chained pbuf */
-        char buf_user[USER_PASS_BUFSIZE];
-        char buf_pass[USER_PASS_BUFSIZE];
-        char *user = (char *)pbuf_get_contiguous(p, buf_user, sizeof(buf_user), len_user, value_user);
-        char *pass = (char *)pbuf_get_contiguous(p, buf_pass, sizeof(buf_pass), len_pass, value_pass);
-        if (user && pass) {
-          user[len_user] = 0;
-          pass[len_pass] = 0;
-          if (!strcmp(user, "lwip") && !strcmp(pass, "post")) {
-            /* user and password are correct, create a "session" */
-            valid_connection = connection;
-            memcpy(last_user, user, sizeof(last_user));
-          }
-        }
-      }
-    }
-    /* not returning ERR_OK aborts the connection, so return ERR_OK unless the
-       conenction is unknown */
-    return ERR_OK;
-  }
-  return ERR_VAL;
-}
-
-void
-httpd_post_finished(void *connection, char *response_uri, u16_t response_uri_len)
-{
-  /* default page is "login failed" */
-  snprintf(response_uri, response_uri_len, "/loginfail.html");
-  if (current_connection == connection) {
-    if (valid_connection == connection) {
-      /* login succeeded */
-      snprintf(response_uri, response_uri_len, "/session.html");
-    }
-    current_connection = NULL;
-    valid_connection = NULL;
-  }
-}
-
-#endif /* LWIP_HTTPD_EXAMPLE_SIMPLEPOST*/
diff --git a/contrib/examples/httpd/ssi_example/ssi_example.c b/contrib/examples/httpd/ssi_example/ssi_example.c
deleted file mode 100644
index 2024e2ea..00000000
--- a/contrib/examples/httpd/ssi_example/ssi_example.c
+++ /dev/null
@@ -1,264 +0,0 @@
-/**
- * @file
- * HTTPD simple SSI example
- *
- * This file demonstrates how to add support for SSI.
- * It does this in a very simple way by providing the three tags 'HelloWorld'
- * 'counter', and 'MultiPart'.
- *
- * This file also demonstrates how to integrate CGI with SSI.
- */
- 
- /*
- * Copyright (c) 2017 Simon Goldschmidt
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Simon Goldschmidt <goldsimon@gmx.de>
- *
- */
-
-#include "lwip/opt.h"
-#include "ssi_example.h"
-
-#include "lwip/apps/httpd.h"
-
-#include "lwip/def.h"
-#include "lwip/mem.h"
-
-#include <stdio.h>
-#include <string.h>
-
-/** define LWIP_HTTPD_EXAMPLE_SSI_SIMPLE to 1 to enable this ssi example*/
-#ifndef LWIP_HTTPD_EXAMPLE_SSI_SIMPLE
-#define LWIP_HTTPD_EXAMPLE_SSI_SIMPLE 0
-#endif
-
-/** define LWIP_HTTPD_EXAMPLE_SSI_SIMPLE_CGI_INTEGRATION to 1 to show how to
- * integrate CGI into SSI (LWIP_HTTPD_CGI_SSI) */
-#ifndef LWIP_HTTPD_EXAMPLE_SSI_SIMPLE_CGI_INTEGRATION
-#define LWIP_HTTPD_EXAMPLE_SSI_SIMPLE_CGI_INTEGRATION 0
-#endif
-
-#if LWIP_HTTPD_EXAMPLE_SSI_SIMPLE
-
-#if LWIP_HTTPD_EXAMPLE_SSI_SIMPLE_CGI_INTEGRATION
-#if !LWIP_HTTPD_FILE_STATE
-#error LWIP_HTTPD_EXAMPLE_SSI_SIMPLE_CGI_INTEGRATION needs LWIP_HTTPD_FILE_STATE
-#endif
-#if !LWIP_HTTPD_CGI_SSI
-#error LWIP_HTTPD_EXAMPLE_SSI_SIMPLE_CGI_INTEGRATION needs LWIP_HTTPD_CGI_SSI
-#endif
-
-#define MAX_CGI_LEN   16
-#endif
-
-const char * ssi_example_tags[] = {
-  "HellWorl",
-  "counter",
-  "MultPart"
-#if LWIP_HTTPD_EXAMPLE_SSI_SIMPLE_CGI_INTEGRATION
-  ,"CgiParam"
-#endif
-};
-
-u16_t ssi_example_ssi_handler(
-#if LWIP_HTTPD_SSI_RAW
-                             const char* ssi_tag_name,
-#else /* LWIP_HTTPD_SSI_RAW */
-                             int iIndex,
-#endif /* LWIP_HTTPD_SSI_RAW */
-                             char *pcInsert, int iInsertLen
-#if LWIP_HTTPD_SSI_MULTIPART
-                             , u16_t current_tag_part, u16_t *next_tag_part
-#endif /* LWIP_HTTPD_SSI_MULTIPART */
-#if defined(LWIP_HTTPD_FILE_STATE) && LWIP_HTTPD_FILE_STATE
-                             , void *connection_state
-#endif /* LWIP_HTTPD_FILE_STATE */
-                             )
-{
-  size_t printed;
-#if LWIP_HTTPD_SSI_RAW
-  /* a real application could use if(!strcmp) blocks here, but we want to keep
-     the differences between configurations small, so translate string to index here */
-  int iIndex;
-  for (iIndex = 0; iIndex < LWIP_ARRAYSIZE(ssi_example_tags); iIndex++) {
-    if(!strcmp(ssi_tag_name, ssi_example_tags[iIndex])) {
-      break;
-    }
-  }
-#endif
-#if defined(LWIP_HTTPD_FILE_STATE) && LWIP_HTTPD_FILE_STATE
-  LWIP_UNUSED_ARG(connection_state);
-#endif
-
-  switch (iIndex) {
-  case 0: /* "HelloWorld" */
-    printed = snprintf(pcInsert, iInsertLen, "Hello World!");
-    break;
-  case 1: /* "counter" */
-    {
-      static int counter;
-      counter++;
-      printed = snprintf(pcInsert, iInsertLen, "%d", counter);
-    }
-    break;
-  case 2: /* "MultPart" */
-#if LWIP_HTTPD_SSI_MULTIPART
-    switch (current_tag_part) {
-    case 0:
-      printed = snprintf(pcInsert, iInsertLen, "part0");
-      *next_tag_part = 1;
-      break;
-    case 1:
-      printed = snprintf(pcInsert, iInsertLen, "part1");
-      *next_tag_part = 2;
-      break;
-    case 2:
-      printed = snprintf(pcInsert, iInsertLen, "part2");
-      break;
-    default:
-      printed = snprintf(pcInsert, iInsertLen, "unhandled part: %d", (int)current_tag_part);
-      break;
-    }
-#else
-    printed = snprintf(pcInsert, iInsertLen, "LWIP_HTTPD_SSI_MULTIPART disabled");
-#endif
-    break;
-#if LWIP_HTTPD_EXAMPLE_SSI_SIMPLE_CGI_INTEGRATION
-  case 3:
-    if (connection_state) {
-      char *params = (char *)connection_state;
-      if (*params) {
-        printed = snprintf(pcInsert, iInsertLen, "%s", (char *)params);
-      } else {
-        printed = snprintf(pcInsert, iInsertLen, "none");
-      }
-    } else {
-       printed = snprintf(pcInsert, iInsertLen, "NULL");
-    }
-    break;
-#endif
-  default: /* unknown tag */
-    printed = 0;
-    break;
-  }
-  LWIP_ASSERT("sane length", printed <= 0xFFFF);
-  return (u16_t)printed;
-}
-
-void
-ssi_ex_init(void)
-{
-  int i;
-  for (i = 0; i < LWIP_ARRAYSIZE(ssi_example_tags); i++) {
-    LWIP_ASSERT("tag too long for LWIP_HTTPD_MAX_TAG_NAME_LEN",
-      strlen(ssi_example_tags[i]) <= LWIP_HTTPD_MAX_TAG_NAME_LEN);
-  }
-
-  http_set_ssi_handler(ssi_example_ssi_handler,
-#if LWIP_HTTPD_SSI_RAW
-    NULL, 0
-#else
-    ssi_example_tags, LWIP_ARRAYSIZE(ssi_example_tags)
-#endif
-    );
-}
-
-#if LWIP_HTTPD_EXAMPLE_SSI_SIMPLE_CGI_INTEGRATION
-void *
-fs_state_init(struct fs_file *file, const char *name)
-{
-  char *ret;
-  LWIP_UNUSED_ARG(file);
-  LWIP_UNUSED_ARG(name);
-  ret = (char *)mem_malloc(MAX_CGI_LEN);
-  if (ret) {
-    *ret = 0;
-  }
-  return ret;
-}
-
-void
-fs_state_free(struct fs_file *file, void *state)
-{
-  LWIP_UNUSED_ARG(file);
-  if (state != NULL) {
-    mem_free(state);
-  }
-}
-
-void
-httpd_cgi_handler(struct fs_file *file, const char* uri, int iNumParams,
-                              char **pcParam, char **pcValue
-#if defined(LWIP_HTTPD_FILE_STATE) && LWIP_HTTPD_FILE_STATE
-                                     , void *connection_state
-#endif /* LWIP_HTTPD_FILE_STATE */
-                                     )
-{
-  LWIP_UNUSED_ARG(file);
-  LWIP_UNUSED_ARG(uri);
-  if (connection_state != NULL) {
-    char *start = (char *)connection_state;
-    char *end = start + MAX_CGI_LEN;
-    int i;
-    memset(start, 0, MAX_CGI_LEN);
-    /* print a string of the arguments: */
-    for (i = 0; i < iNumParams; i++) {
-      size_t len;
-      len = end - start;
-      if (len) {
-        size_t inlen = strlen(pcParam[i]);
-        size_t copylen = LWIP_MIN(inlen, len);
-        memcpy(start, pcParam[i], copylen);
-        start += copylen;
-        len -= copylen;
-      }
-      if (len) {
-        *start = '=';
-        start++;
-        len--;
-      }
-      if (len) {
-        size_t inlen = strlen(pcValue[i]);
-        size_t copylen = LWIP_MIN(inlen, len);
-        memcpy(start, pcValue[i], copylen);
-        start += copylen;
-        len -= copylen;
-      }
-      if (len) {
-        *start = ';';
-        len--;
-      }
-      /* ensure NULL termination */
-      end--;
-      *end = 0;
-    }
-  }
-}
-#endif /* LWIP_HTTPD_EXAMPLE_SSI_SIMPLE_CGI_INTEGRATION */
-
-#endif /* LWIP_HTTPD_EXAMPLE_SSI_SIMPLE */
diff --git a/contrib/examples/httpd/ssi_example/ssi_example.h b/contrib/examples/httpd/ssi_example/ssi_example.h
deleted file mode 100644
index b7ec298a..00000000
--- a/contrib/examples/httpd/ssi_example/ssi_example.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (c) 2017 Simon Goldschmidt
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Simon Goldschmidt <goldsimon@gmx.de>
- *
- */
-
-#ifndef LWIP_HDR_HTTP_EXAMPLES_SSI_EXAMPLE
-#define LWIP_HDR_HTTP_EXAMPLES_SSI_EXAMPLE
-
-void ssi_ex_init(void);
-
-#endif /* LWIP_HDR_HTTP_EXAMPLES_SSI_EXAMPLE */
diff --git a/contrib/examples/lwiperf/lwiperf_example.c b/contrib/examples/lwiperf/lwiperf_example.c
deleted file mode 100644
index a33bc6f2..00000000
--- a/contrib/examples/lwiperf/lwiperf_example.c
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Dirk Ziegelmeier <dziegel@gmx.de>
- *
- */
-
-#include "lwip/apps/lwiperf.h"
-#include "lwiperf_example.h"
-
-static void
-lwiperf_report(void *arg, enum lwiperf_report_type report_type,
-  const ip_addr_t* local_addr, u16_t local_port, const ip_addr_t* remote_addr, u16_t remote_port,
-  u32_t bytes_transferred, u32_t ms_duration, u32_t bandwidth_kbitpsec)
-{
-  LWIP_UNUSED_ARG(arg);
-  LWIP_UNUSED_ARG(local_addr);
-  LWIP_UNUSED_ARG(local_port);
-
-  LWIP_PLATFORM_DIAG(("IPERF report: type=%d, remote: %s:%d, total bytes: %"U32_F", duration in ms: %"U32_F", kbits/s: %"U32_F"\n",
-    (int)report_type, ipaddr_ntoa(remote_addr), (int)remote_port, bytes_transferred, ms_duration, bandwidth_kbitpsec));
-}
-
-void
-lwiperf_example_init(void)
-{
-  lwiperf_start_tcp_server_default(lwiperf_report, NULL);
-}
diff --git a/contrib/examples/lwiperf/lwiperf_example.h b/contrib/examples/lwiperf/lwiperf_example.h
deleted file mode 100644
index d7b35c88..00000000
--- a/contrib/examples/lwiperf/lwiperf_example.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Dirk Ziegelmeier <dziegel@gmx.de>
- *
- */
-
-#ifndef LWIPERF_EXAMPLE_H
-#define LWIPERF_EXAMPLE_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-void lwiperf_example_init(void);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* LWIPERF_EXAMPLE_H */
diff --git a/contrib/examples/mdns/mdns_example.c b/contrib/examples/mdns/mdns_example.c
deleted file mode 100644
index 208048a2..00000000
--- a/contrib/examples/mdns/mdns_example.c
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Dirk Ziegelmeier <dziegel@gmx.de>
- *
- */
-
-#include "lwip/apps/mdns.h"
-#include "mdns_example.h"
-
-#if LWIP_MDNS_RESPONDER
-static void
-srv_txt(struct mdns_service *service, void *txt_userdata)
-{
-  err_t res;
-  LWIP_UNUSED_ARG(txt_userdata);
-  
-  res = mdns_resp_add_service_txtitem(service, "path=/", 6);
-  LWIP_ERROR("mdns add service txt failed\n", (res == ERR_OK), return);
-}
-#endif
-
-#if LWIP_MDNS_RESPONDER
-static void
-mdns_example_report(struct netif* netif, u8_t result)
-{
-  LWIP_PLATFORM_DIAG(("mdns status[netif %d]: %d\n", netif->num, result));
-}
-#endif
-
-void
-mdns_example_init(void)
-{
-#if LWIP_MDNS_RESPONDER
-  mdns_resp_register_name_result_cb(mdns_example_report);
-  mdns_resp_init();
-  mdns_resp_add_netif(netif_default, "lwip");
-  mdns_resp_add_service(netif_default, "myweb", "_http", DNSSD_PROTO_TCP, 80, srv_txt, NULL);
-  mdns_resp_announce(netif_default);
-#endif
-}
diff --git a/contrib/examples/mdns/mdns_example.h b/contrib/examples/mdns/mdns_example.h
deleted file mode 100644
index ab51ade5..00000000
--- a/contrib/examples/mdns/mdns_example.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Dirk Ziegelmeier <dziegel@gmx.de>
- *
- */
-
-#ifndef MDNS_EXAMPLE_H
-#define MDNS_EXAMPLE_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-void mdns_example_init(void);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* MDNS_EXAMPLE_H */
diff --git a/contrib/examples/mqtt/mqtt_example.c b/contrib/examples/mqtt/mqtt_example.c
deleted file mode 100644
index bb277d6f..00000000
--- a/contrib/examples/mqtt/mqtt_example.c
+++ /dev/null
@@ -1,128 +0,0 @@
-/*
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Dirk Ziegelmeier <dziegel@gmx.de>
- *
- */
-
-#include "lwip/apps/mqtt.h"
-#include "mqtt_example.h"
-
-#if LWIP_TCP
-
-/** Define this to a compile-time IP address initialization
- * to connect anything else than IPv4 loopback
- */
-#ifndef LWIP_MQTT_EXAMPLE_IPADDR_INIT
-#if LWIP_IPV4
-#define LWIP_MQTT_EXAMPLE_IPADDR_INIT = IPADDR4_INIT(PP_HTONL(IPADDR_LOOPBACK))
-#else
-#define LWIP_MQTT_EXAMPLE_IPADDR_INIT
-#endif
-#endif
-
-static ip_addr_t mqtt_ip LWIP_MQTT_EXAMPLE_IPADDR_INIT;
-static mqtt_client_t* mqtt_client;
-
-static const struct mqtt_connect_client_info_t mqtt_client_info =
-{
-  "test",
-  NULL, /* user */
-  NULL, /* pass */
-  100,  /* keep alive */
-  NULL, /* will_topic */
-  NULL, /* will_msg */
-  0,    /* will_qos */
-  0     /* will_retain */
-#if LWIP_ALTCP && LWIP_ALTCP_TLS
-  , NULL
-#endif
-};
-
-static void
-mqtt_incoming_data_cb(void *arg, const u8_t *data, u16_t len, u8_t flags)
-{
-  const struct mqtt_connect_client_info_t* client_info = (const struct mqtt_connect_client_info_t*)arg;
-  LWIP_UNUSED_ARG(data);
-
-  LWIP_PLATFORM_DIAG(("MQTT client \"%s\" data cb: len %d, flags %d\n", client_info->client_id,
-          (int)len, (int)flags));
-}
-
-static void
-mqtt_incoming_publish_cb(void *arg, const char *topic, u32_t tot_len)
-{
-  const struct mqtt_connect_client_info_t* client_info = (const struct mqtt_connect_client_info_t*)arg;
-
-  LWIP_PLATFORM_DIAG(("MQTT client \"%s\" publish cb: topic %s, len %d\n", client_info->client_id,
-          topic, (int)tot_len));
-}
-
-static void
-mqtt_request_cb(void *arg, err_t err)
-{
-  const struct mqtt_connect_client_info_t* client_info = (const struct mqtt_connect_client_info_t*)arg;
-
-  LWIP_PLATFORM_DIAG(("MQTT client \"%s\" request cb: err %d\n", client_info->client_id, (int)err));
-}
-
-static void
-mqtt_connection_cb(mqtt_client_t *client, void *arg, mqtt_connection_status_t status)
-{
-  const struct mqtt_connect_client_info_t* client_info = (const struct mqtt_connect_client_info_t*)arg;
-  LWIP_UNUSED_ARG(client);
-
-  LWIP_PLATFORM_DIAG(("MQTT client \"%s\" connection cb: status %d\n", client_info->client_id, (int)status));
-
-  if (status == MQTT_CONNECT_ACCEPTED) {
-    mqtt_sub_unsub(client,
-            "topic_qos1", 1,
-            mqtt_request_cb, LWIP_CONST_CAST(void*, client_info),
-            1);
-    mqtt_sub_unsub(client,
-            "topic_qos0", 0,
-            mqtt_request_cb, LWIP_CONST_CAST(void*, client_info),
-            1);
-  }
-}
-#endif /* LWIP_TCP */
-
-void
-mqtt_example_init(void)
-{
-#if LWIP_TCP
-  mqtt_client = mqtt_client_new();
-
-  mqtt_set_inpub_callback(mqtt_client,
-          mqtt_incoming_publish_cb,
-          mqtt_incoming_data_cb,
-          LWIP_CONST_CAST(void*, &mqtt_client_info));
-
-  mqtt_client_connect(mqtt_client,
-          &mqtt_ip, MQTT_PORT,
-          mqtt_connection_cb, LWIP_CONST_CAST(void*, &mqtt_client_info),
-          &mqtt_client_info);
-#endif /* LWIP_TCP */
-}
diff --git a/contrib/examples/mqtt/mqtt_example.h b/contrib/examples/mqtt/mqtt_example.h
deleted file mode 100644
index 797678b2..00000000
--- a/contrib/examples/mqtt/mqtt_example.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Dirk Ziegelmeier <dziegel@gmx.de>
- *
- */
-
-#ifndef MQTT_EXAMPLE_H
-#define MQTT_EXAMPLE_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-void mqtt_example_init(void);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* MQTT_EXAMPLE_H */
diff --git a/contrib/examples/ppp/pppos_example.c b/contrib/examples/ppp/pppos_example.c
deleted file mode 100644
index 84e0224a..00000000
--- a/contrib/examples/ppp/pppos_example.c
+++ /dev/null
@@ -1,221 +0,0 @@
-/*
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Dirk Ziegelmeier <dziegel@gmx.de>
- *
- */
-
-#include "lwip/dns.h"
-
-#ifndef PPPOS_SUPPORT
-#define PPPOS_SUPPORT 0
-#endif /* PPPOS_SUPPORT */
-
-#if PPPOS_SUPPORT
-#include "netif/ppp/pppos.h"
-#include "lwip/sio.h"
-#define PPP_PTY_TEST 1
-#endif /* PPPOS_SUPPORT */
-
-#include "pppos_example.h"
-
-#include <stdio.h>
-
-#if PPPOS_SUPPORT
-static sio_fd_t ppp_sio;
-static ppp_pcb *ppp;
-static struct netif pppos_netif;
-
-static void
-pppos_rx_thread(void *arg)
-{
-  u32_t len;
-  u8_t buffer[128];
-  LWIP_UNUSED_ARG(arg);
-
-  /* Please read the "PPPoS input path" chapter in the PPP documentation. */
-  while (1) {
-    len = sio_read(ppp_sio, buffer, sizeof(buffer));
-    if (len > 0) {
-      /* Pass received raw characters from PPPoS to be decoded through lwIP
-       * TCPIP thread using the TCPIP API. This is thread safe in all cases
-       * but you should avoid passing data byte after byte. */
-      pppos_input_tcpip(ppp, buffer, len);
-    }
-  }
-}
-
-static void
-ppp_link_status_cb(ppp_pcb *pcb, int err_code, void *ctx)
-{
-    struct netif *pppif = ppp_netif(pcb);
-    LWIP_UNUSED_ARG(ctx);
-
-    switch(err_code) {
-    case PPPERR_NONE:               /* No error. */
-        {
-#if LWIP_DNS
-        const ip_addr_t *ns;
-#endif /* LWIP_DNS */
-        fprintf(stderr, "ppp_link_status_cb: PPPERR_NONE\n\r");
-#if LWIP_IPV4
-        fprintf(stderr, "   our_ip4addr = %s\n\r", ip4addr_ntoa(netif_ip4_addr(pppif)));
-        fprintf(stderr, "   his_ipaddr  = %s\n\r", ip4addr_ntoa(netif_ip4_gw(pppif)));
-        fprintf(stderr, "   netmask     = %s\n\r", ip4addr_ntoa(netif_ip4_netmask(pppif)));
-#endif /* LWIP_IPV4 */
-#if LWIP_IPV6
-        fprintf(stderr, "   our_ip6addr = %s\n\r", ip6addr_ntoa(netif_ip6_addr(pppif, 0)));
-#endif /* LWIP_IPV6 */
-
-#if LWIP_DNS
-        ns = dns_getserver(0);
-        fprintf(stderr, "   dns1        = %s\n\r", ipaddr_ntoa(ns));
-        ns = dns_getserver(1);
-        fprintf(stderr, "   dns2        = %s\n\r", ipaddr_ntoa(ns));
-#endif /* LWIP_DNS */
-#if PPP_IPV6_SUPPORT
-        fprintf(stderr, "   our6_ipaddr = %s\n\r", ip6addr_ntoa(netif_ip6_addr(pppif, 0)));
-#endif /* PPP_IPV6_SUPPORT */
-        }
-        break;
-
-    case PPPERR_PARAM:             /* Invalid parameter. */
-        printf("ppp_link_status_cb: PPPERR_PARAM\n");
-        break;
-
-    case PPPERR_OPEN:              /* Unable to open PPP session. */
-        printf("ppp_link_status_cb: PPPERR_OPEN\n");
-        break;
-
-    case PPPERR_DEVICE:            /* Invalid I/O device for PPP. */
-        printf("ppp_link_status_cb: PPPERR_DEVICE\n");
-        break;
-
-    case PPPERR_ALLOC:             /* Unable to allocate resources. */
-        printf("ppp_link_status_cb: PPPERR_ALLOC\n");
-        break;
-
-    case PPPERR_USER:              /* User interrupt. */
-        printf("ppp_link_status_cb: PPPERR_USER\n");
-        break;
-
-    case PPPERR_CONNECT:           /* Connection lost. */
-        printf("ppp_link_status_cb: PPPERR_CONNECT\n");
-        break;
-
-    case PPPERR_AUTHFAIL:          /* Failed authentication challenge. */
-        printf("ppp_link_status_cb: PPPERR_AUTHFAIL\n");
-        break;
-
-    case PPPERR_PROTOCOL:          /* Failed to meet protocol. */
-        printf("ppp_link_status_cb: PPPERR_PROTOCOL\n");
-        break;
-
-    case PPPERR_PEERDEAD:          /* Connection timeout. */
-        printf("ppp_link_status_cb: PPPERR_PEERDEAD\n");
-        break;
-
-    case PPPERR_IDLETIMEOUT:       /* Idle Timeout. */
-        printf("ppp_link_status_cb: PPPERR_IDLETIMEOUT\n");
-        break;
-
-    case PPPERR_CONNECTTIME:       /* PPPERR_CONNECTTIME. */
-        printf("ppp_link_status_cb: PPPERR_CONNECTTIME\n");
-        break;
-
-    case PPPERR_LOOPBACK:          /* Connection timeout. */
-        printf("ppp_link_status_cb: PPPERR_LOOPBACK\n");
-        break;
-
-    default:
-        printf("ppp_link_status_cb: unknown errCode %d\n", err_code);
-        break;
-    }
-}
-
-static u32_t
-ppp_output_cb(ppp_pcb *pcb, u8_t *data, u32_t len, void *ctx)
-{
-  LWIP_UNUSED_ARG(pcb);
-  LWIP_UNUSED_ARG(ctx);
-  return sio_write(ppp_sio, data, len);
-}
-
-#if LWIP_NETIF_STATUS_CALLBACK
-static void
-netif_status_callback(struct netif *nif)
-{
-  printf("PPPNETIF: %c%c%d is %s\n", nif->name[0], nif->name[1], nif->num,
-         netif_is_up(nif) ? "UP" : "DOWN");
-#if LWIP_IPV4
-  printf("IPV4: Host at %s ", ip4addr_ntoa(netif_ip4_addr(nif)));
-  printf("mask %s ", ip4addr_ntoa(netif_ip4_netmask(nif)));
-  printf("gateway %s\n", ip4addr_ntoa(netif_ip4_gw(nif)));
-#endif /* LWIP_IPV4 */
-#if LWIP_IPV6
-  printf("IPV6: Host at %s\n", ip6addr_ntoa(netif_ip6_addr(nif, 0)));
-#endif /* LWIP_IPV6 */
-#if LWIP_NETIF_HOSTNAME
-  printf("FQDN: %s\n", netif_get_hostname(nif));
-#endif /* LWIP_NETIF_HOSTNAME */
-}
-#endif /* LWIP_NETIF_STATUS_CALLBACK */
-#endif
-
-void
-pppos_example_init(void)
-{
-#if PPPOS_SUPPORT
-#if PPP_PTY_TEST
-  ppp_sio = sio_open(2);
-#else
-  ppp_sio = sio_open(0);
-#endif
-  if(!ppp_sio)
-  {
-      perror("PPPOS example: Error opening device");
-      return;
-  }
-
-  ppp = pppos_create(&pppos_netif, ppp_output_cb, ppp_link_status_cb, NULL);
-  if (!ppp)
-  {
-      printf("PPPOS example: Could not create PPP control interface");
-      return;
-  }
-
-#ifdef LWIP_PPP_CHAP_TEST
-  ppp_set_auth(ppp, PPPAUTHTYPE_CHAP, "lwip", "mysecret");
-#endif
-
-  ppp_connect(ppp, 0);
-
-#if LWIP_NETIF_STATUS_CALLBACK
-  netif_set_status_callback(&pppos_netif, netif_status_callback);
-#endif /* LWIP_NETIF_STATUS_CALLBACK */
-
-  sys_thread_new("pppos_rx_thread", pppos_rx_thread, NULL, DEFAULT_THREAD_STACKSIZE, DEFAULT_THREAD_PRIO);
-#endif /* PPPOS_SUPPORT */
-}
diff --git a/contrib/examples/ppp/pppos_example.h b/contrib/examples/ppp/pppos_example.h
deleted file mode 100644
index 726961c8..00000000
--- a/contrib/examples/ppp/pppos_example.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Dirk Ziegelmeier <dziegel@gmx.de>
- *
- */
-
-#ifndef PPPOS_EXAMPLE_H
-#define PPPOS_EXAMPLE_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-void pppos_example_init(void);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* PPPOS_EXAMPLE_H */
diff --git a/contrib/examples/snmp/snmp_example.c b/contrib/examples/snmp/snmp_example.c
deleted file mode 100644
index 59524747..00000000
--- a/contrib/examples/snmp/snmp_example.c
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Dirk Ziegelmeier <dziegel@gmx.de>
- *
- */
-
-#include "lwip/netif.h"
-#include "lwip/apps/snmp.h"
-#include "lwip/apps/snmp_mib2.h"
-#include "lwip/apps/snmpv3.h"
-#include "lwip/apps/snmp_snmpv2_framework.h"
-#include "lwip/apps/snmp_snmpv2_usm.h"
-#include "examples/snmp/snmp_v3/snmpv3_dummy.h"
-#include "examples/snmp/snmp_private_mib/private_mib.h"
-#include "snmp_example.h"
-
-#if LWIP_SNMP
-static const struct snmp_mib *mibs[] = {
-  &mib2,
-  &mib_private
-#if LWIP_SNMP_V3
-  , &snmpframeworkmib
-  , &snmpusmmib
-#endif
-};
-#endif /* LWIP_SNMP */
-
-void
-snmp_example_init(void)
-{
-#if LWIP_SNMP
-  s32_t req_nr;
-  lwip_privmib_init();
-#if SNMP_LWIP_MIB2
-#if SNMP_USE_NETCONN
-  snmp_threadsync_init(&snmp_mib2_lwip_locks, snmp_mib2_lwip_synchronizer);
-#endif /* SNMP_USE_NETCONN */
-  snmp_mib2_set_syscontact_readonly((const u8_t*)"root", NULL);
-  snmp_mib2_set_syslocation_readonly((const u8_t*)"lwIP development PC", NULL);
-  snmp_mib2_set_sysdescr((const u8_t*)"lwIP example", NULL);
-#endif /* SNMP_LWIP_MIB2 */
-
-#if LWIP_SNMP_V3
-  snmpv3_dummy_init();
-#endif
-
-  snmp_set_mibs(mibs, LWIP_ARRAYSIZE(mibs));
-  snmp_init();
-
-  snmp_trap_dst_ip_set(0, &netif_default->gw);
-  snmp_trap_dst_enable(0, 1);
-
-  snmp_send_inform_generic(SNMP_GENTRAP_COLDSTART, NULL, &req_nr);
-  snmp_send_trap_generic(SNMP_GENTRAP_COLDSTART);
-
-#endif /* LWIP_SNMP */
-}
diff --git a/contrib/examples/snmp/snmp_example.h b/contrib/examples/snmp/snmp_example.h
deleted file mode 100644
index fafcd68f..00000000
--- a/contrib/examples/snmp/snmp_example.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Dirk Ziegelmeier <dziegel@gmx.de>
- *
- */
-
-#ifndef SNMP_EXAMPLE_H
-#define SNMP_EXAMPLE_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-void snmp_example_init(void);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* SNMP_EXAMPLE_H */
diff --git a/contrib/examples/snmp/snmp_private_mib/lwip_prvmib.c b/contrib/examples/snmp/snmp_private_mib/lwip_prvmib.c
deleted file mode 100644
index 51a49fe1..00000000
--- a/contrib/examples/snmp/snmp_private_mib/lwip_prvmib.c
+++ /dev/null
@@ -1,401 +0,0 @@
-/**
- * @file
- * lwip Private MIB 
- *
- * @todo create MIB file for this example
- * @note the lwip enterprise tree root (26381) is owned by the lwIP project.
- * It is NOT allowed to allocate new objects under this ID (26381) without our,
- * the lwip developers, permission!
- *
- * Please apply for your own ID with IANA: http://www.iana.org/numbers.html
- *  
- * lwip        OBJECT IDENTIFIER ::= { enterprises 26381 }
- * example     OBJECT IDENTIFIER ::= { lwip 1 }
- */
- 
-/*
- * Copyright (c) 2006 Axon Digital Design B.V., The Netherlands.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * Author: Christiaan Simons <christiaan.simons@axon.tv>
- */
-
-#include "private_mib.h"
-
-#if LWIP_SNMP
-
-/** Directory where the sensor files are */
-#define SENSORS_DIR           "w:\\sensors"
-/** Set to 1 to read sensor values from files (in directory defined by SENSORS_DIR) */
-#define SENSORS_USE_FILES     0
-/** Set to 1 to search sensor files at startup (in directory defined by SENSORS_DIR) */
-#define SENSORS_SEARCH_FILES  0
-
-#if SENSORS_SEARCH_FILES
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <dirent.h>
-#endif /* SENSORS_SEARCH_FILES */
-
-#include <string.h>
-#include <stdio.h>
-
-#include "lwip/apps/snmp_table.h"
-#include "lwip/apps/snmp_scalar.h"
-
-#if !SENSORS_USE_FILES || !SENSORS_SEARCH_FILES
-/** When not using & searching files, defines the number of sensors */
-#define SENSOR_COUNT 4
-#endif /* !SENSORS_USE_FILES || !SENSORS_SEARCH_FILES */
-
-/*
-  This example presents a table for a few (at most 10) sensors.
-  Sensor detection takes place at initialization (once only).
-  Sensors may and can not be added or removed after agent
-  has started. Note this is only a limitation of this crude example,
-  the agent does support dynamic object insertions and removals.
-   
-  You'll need to manually create a directory called "sensors" and
-  a few single line text files with an integer temperature value.
-  The files must be called [0..9].txt. 
-   
-  ./sensors/0.txt [content: 20]
-  ./sensors/3.txt [content: 75]
-    
-  The sensor values may be changed in runtime by editing the 
-  text files in the "sensors" directory.
-*/
-
-#define SENSOR_MAX      10
-#define SENSOR_NAME_LEN 20
-
-struct sensor_inf
-{
-  u8_t num;
-
-  char file[SENSOR_NAME_LEN + 1];
-
-#if !SENSORS_USE_FILES
-  /** When not using files, contains the value of the sensor */
-  s32_t value;
-#endif /* !SENSORS_USE_FILES */
-};
-
-static struct sensor_inf sensors[SENSOR_MAX];
-
-static s16_t      sensor_count_get_value(struct snmp_node_instance* instance, void* value);
-static snmp_err_t sensor_table_get_cell_instance(const u32_t* column, const u32_t* row_oid, u8_t row_oid_len, struct snmp_node_instance* cell_instance);
-static snmp_err_t sensor_table_get_next_cell_instance(const u32_t* column, struct snmp_obj_id* row_oid, struct snmp_node_instance* cell_instance);
-static s16_t      sensor_table_get_value(struct snmp_node_instance* instance, void* value);
-static snmp_err_t sensor_table_set_value(struct snmp_node_instance* instance, u16_t len, void *value);
-
-/* sensorentry .1.3.6.1.4.1.26381.1.1.1 (.level0.level1)
-   where level 0 is the table column (temperature/file name)
-   and level 1 the table row (sensor index) */
-static const struct snmp_table_col_def sensor_table_columns[] = {
-  { 1, SNMP_ASN1_TYPE_INTEGER,      SNMP_NODE_INSTANCE_READ_WRITE },
-  { 2, SNMP_ASN1_TYPE_OCTET_STRING, SNMP_NODE_INSTANCE_READ_ONLY  }
-};
-
-/* sensortable .1.3.6.1.4.1.26381.1.1 */
-static const struct snmp_table_node sensor_table = SNMP_TABLE_CREATE(
-  1, sensor_table_columns, 
-  sensor_table_get_cell_instance, sensor_table_get_next_cell_instance, 
-  sensor_table_get_value, snmp_set_test_ok, sensor_table_set_value);
-
-/* sensorcount .1.3.6.1.4.1.26381.1.2 */
-static const struct snmp_scalar_node sensor_count = SNMP_SCALAR_CREATE_NODE_READONLY(
-  2, SNMP_ASN1_TYPE_INTEGER, sensor_count_get_value); 
-
-/* example .1.3.6.1.4.1.26381.1 */
-static const struct snmp_node* const example_nodes[] = {
-  &sensor_table.node.node,
-  &sensor_count.node.node
-};
-static const struct snmp_tree_node example_node = SNMP_CREATE_TREE_NODE(1, example_nodes);
-
-static const u32_t prvmib_base_oid[] = { 1,3,6,1,4,1,26381,1 };
-const struct snmp_mib mib_private = SNMP_MIB_CREATE(prvmib_base_oid, &example_node.node);
-
-#if 0
-/* for reference: we could also have expressed it like this: */
-
-/* lwip .1.3.6.1.4.1.26381 */
-static const struct snmp_node* const lwip_nodes[] = {
-  &example_node.node
-};
-static const struct snmp_tree_node lwip_node = SNMP_CREATE_TREE_NODE(26381, lwip_nodes);
-
-/* enterprises .1.3.6.1.4.1 */
-static const struct snmp_node* const enterprises_nodes[] = {
-  &lwip_node.node
-};
-static const struct snmp_tree_node enterprises_node = SNMP_CREATE_TREE_NODE(1, enterprises_nodes);
-
-/* private .1.3.6.1.4 */
-static const struct snmp_node* const private_nodes[] = {
-  &enterprises_node.node
-};
-static const struct snmp_tree_node private_root = SNMP_CREATE_TREE_NODE(4, private_nodes);
-
-static const u32_t prvmib_base_oid[] = { 1,3,6,1,4 };
-const struct snmp_mib mib_private = SNMP_MIB_CREATE(prvmib_base_oid, &private_root.node);
-#endif
-
-/**
- * Initialises this private MIB before use.
- * @see main.c
- */
-void
-lwip_privmib_init(void)
-{
-#if SENSORS_USE_FILES && SENSORS_SEARCH_FILES
-  char *buf, *ebuf, *cp;
-  size_t bufsize;
-  int nbytes;
-  struct stat sb;
-  struct dirent *dp;
-  int fd;
-#else /* SENSORS_USE_FILES && SENSORS_SEARCH_FILES */
-  u8_t i;
-#endif /* SENSORS_USE_FILES && SENSORS_SEARCH_FILES */
-
-  memset(sensors, 0, sizeof(sensors));
-  
-  printf("SNMP private MIB start, detecting sensors.\n");
-
-#if SENSORS_USE_FILES && SENSORS_SEARCH_FILES
-  /* look for sensors in sensors directory */
-  fd = open(SENSORS_DIR, O_RDONLY);
-  if (fd > -1)
-  {
-    fstat(fd, &sb);
-    bufsize = sb.st_size;
-    if (bufsize < (size_t)sb.st_blksize)
-    {
-      bufsize = sb.st_blksize;
-    }
-    buf = (char*)malloc(bufsize);
-    if (buf != NULL)
-    {
-      do
-      {
-        long base;
-        
-        nbytes = getdirentries(fd, buf, bufsize, &base);
-        if (nbytes > 0)
-        {
-          ebuf = buf + nbytes;
-          cp = buf;
-          while (cp < ebuf)
-          {
-            dp = (struct dirent *)cp;
-            if (lwip_isdigit(dp->d_name[0]))
-            {
-              unsigned char idx = dp->d_name[0] - '0';
-
-              sensors[idx].num = idx+1;
-              strncpy(&sensors[idx].file[0], dp->d_name, SENSOR_NAME_LEN);
-              printf("%s\n", sensors[idx].file);
-            }
-            cp += dp->d_reclen;
-          }
-        } 
-      }
-      while (nbytes > 0);
-    
-      free(buf);
-    }
-    close(fd);
-  }
-#else /* SENSORS_USE_FILES && SENSORS_SEARCH_FILES */
-  for (i = 0; i < SENSOR_COUNT; i++) {
-    sensors[i].num = (u8_t)(i + 1);
-    snprintf(sensors[i].file, sizeof(sensors[i].file), "%d.txt", i);
-
-#if !SENSORS_USE_FILES
-    /* initialize sensor value to != zero */
-    sensors[i].value = 11 * (i+1);
-#endif /* !SENSORS_USE_FILES */
-  }
-#endif /* SENSORS_USE_FILE && SENSORS_SEARCH_FILES */
-}
-
-/* sensorcount .1.3.6.1.4.1.26381.1.2 */
-static s16_t
-sensor_count_get_value(struct snmp_node_instance* instance, void* value)
-{
-  size_t count = 0;
-  u32_t *uint_ptr = (u32_t*)value;
-
-  LWIP_UNUSED_ARG(instance);
-  
-  for(count=0; count<LWIP_ARRAYSIZE(sensors); count++) {
-    if(sensors[count].num == 0) {
-      *uint_ptr = (u32_t)count;
-      return sizeof(*uint_ptr);
-    }
-  }
-
-  return 0;  
-}
-
-/* sensortable .1.3.6.1.4.1.26381.1.1 */
-/* list of allowed value ranges for incoming OID */
-static const struct snmp_oid_range sensor_table_oid_ranges[] = {
-  { 1, SENSOR_MAX+1 }
-};
-
-static snmp_err_t
-sensor_table_get_cell_instance(const u32_t* column, const u32_t* row_oid, u8_t row_oid_len, struct snmp_node_instance* cell_instance)
-{
-  u32_t sensor_num;
-  size_t i;
-
-  LWIP_UNUSED_ARG(column);
-
-  /* check if incoming OID length and if values are in plausible range */
-  if(!snmp_oid_in_range(row_oid, row_oid_len, sensor_table_oid_ranges, LWIP_ARRAYSIZE(sensor_table_oid_ranges))) {
-    return SNMP_ERR_NOSUCHINSTANCE;
-  }
-
-  /* get sensor index from incoming OID */
-  sensor_num = row_oid[0];
-
-  /* find sensor with index */
-  for(i=0; i<LWIP_ARRAYSIZE(sensors); i++) {
-    if(sensors[i].num != 0) {
-      if(sensors[i].num == sensor_num) {
-        /* store sensor index for subsequent operations (get/test/set) */
-        cell_instance->reference.u32 = (u32_t)i;
-        return SNMP_ERR_NOERROR;
-      }
-    }
-  }
-
-  /* not found */
-  return SNMP_ERR_NOSUCHINSTANCE;
-}
-
-static snmp_err_t
-sensor_table_get_next_cell_instance(const u32_t* column, struct snmp_obj_id* row_oid, struct snmp_node_instance* cell_instance)
-{
-  size_t i;
-  struct snmp_next_oid_state state;
-  u32_t result_temp[LWIP_ARRAYSIZE(sensor_table_oid_ranges)];
-
-  LWIP_UNUSED_ARG(column);
-  
-  /* init struct to search next oid */
-  snmp_next_oid_init(&state, row_oid->id, row_oid->len, result_temp, LWIP_ARRAYSIZE(sensor_table_oid_ranges));
-
-  /* iterate over all possible OIDs to find the next one */
-  for(i=0; i<LWIP_ARRAYSIZE(sensors); i++) {
-    if(sensors[i].num != 0) {
-      u32_t test_oid[LWIP_ARRAYSIZE(sensor_table_oid_ranges)];
-
-      test_oid[0] = sensors[i].num;
-
-      /* check generated OID: is it a candidate for the next one? */
-      snmp_next_oid_check(&state, test_oid, LWIP_ARRAYSIZE(sensor_table_oid_ranges), (void*)i);
-    }
-  }
-
-  /* did we find a next one? */
-  if(state.status == SNMP_NEXT_OID_STATUS_SUCCESS) {
-    snmp_oid_assign(row_oid, state.next_oid, state.next_oid_len);
-    /* store sensor index for subsequent operations (get/test/set) */
-    cell_instance->reference.u32 = LWIP_CONST_CAST(u32_t, state.reference);
-    return SNMP_ERR_NOERROR;
-  }
-
-  /* not found */
-  return SNMP_ERR_NOSUCHINSTANCE;
-}
-
-static s16_t
-sensor_table_get_value(struct snmp_node_instance* instance, void* value)
-{
-  u32_t i = instance->reference.u32;
-  s32_t *temperature = (s32_t *)value;
-
-  switch (SNMP_TABLE_GET_COLUMN_FROM_OID(instance->instance_oid.id))
-  {
-  case 1: /* sensor value */
-#if SENSORS_USE_FILES
-    FILE* sensf;
-    char senspath[sizeof(SENSORS_DIR)+1+SENSOR_NAME_LEN+1] = SENSORS_DIR"/";
-
-    strncpy(&senspath[sizeof(SENSORS_DIR)],
-            sensors[i].file,
-            SENSOR_NAME_LEN);
-    sensf = fopen(senspath,"r");
-    if (sensf != NULL)
-    {
-      fscanf(sensf,"%"S32_F,temperature);
-      fclose(sensf);
-    }
-#else /* SENSORS_USE_FILES */
-    *temperature = sensors[i].value;
-#endif /* SENSORS_USE_FILES */
-    return sizeof(s32_t);
-  case 2: /* file name */
-    MEMCPY(value, sensors[i].file, strlen(sensors[i].file));
-    return (s16_t)strlen(sensors[i].file);
-  default:
-    return 0;
-  }
-}
-
-static snmp_err_t
-sensor_table_set_value(struct snmp_node_instance* instance, u16_t len, void *value)
-{
-  u32_t i = instance->reference.u32;
-  s32_t *temperature = (s32_t *)value;
-#if SENSORS_USE_FILES
-  FILE* sensf;
-  char senspath[sizeof(SENSORS_DIR)+1+SENSOR_NAME_LEN+1] = SENSORS_DIR"/";
-
-  strncpy(&senspath[sizeof(SENSORS_DIR)],
-          sensors[i].file,
-          SENSOR_NAME_LEN);
-  sensf = fopen(senspath, "w");
-  if (sensf != NULL)
-  {
-    fprintf(sensf, "%"S32_F, *temperature);
-    fclose(sensf);
-  }
-#else /* SENSORS_USE_FILES */
-  sensors[i].value = *temperature;
-#endif /* SENSORS_USE_FILES */  
-
-  LWIP_UNUSED_ARG(len);
-
-  return SNMP_ERR_NOERROR;
-}
-
-#endif /* LWIP_SNMP */
diff --git a/contrib/examples/snmp/snmp_private_mib/private_mib.h b/contrib/examples/snmp/snmp_private_mib/private_mib.h
deleted file mode 100644
index 69be8a4f..00000000
--- a/contrib/examples/snmp/snmp_private_mib/private_mib.h
+++ /dev/null
@@ -1,26 +0,0 @@
-/**
- * @file
- * Exports Private lwIP MIB 
- */
-
-#ifndef LWIP_HDR_PRIVATE_MIB_H
-#define LWIP_HDR_PRIVATE_MIB_H
-
-#include "lwip/apps/snmp_opts.h"
-
-#include "lwip/apps/snmp_core.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* export MIB */
-extern const struct snmp_mib mib_private;
-
-void lwip_privmib_init(void);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff --git a/contrib/examples/snmp/snmp_v3/snmpv3_dummy.c b/contrib/examples/snmp/snmp_v3/snmpv3_dummy.c
deleted file mode 100644
index a7c53ed7..00000000
--- a/contrib/examples/snmp/snmp_v3/snmpv3_dummy.c
+++ /dev/null
@@ -1,395 +0,0 @@
-/**
- * @file
- * Dummy SNMPv3 functions.
- */
-
-/*
- * Copyright (c) 2016 Elias Oenal.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * Author: Elias Oenal <lwip@eliasoenal.com>
- *         Dirk Ziegelmeier <dirk@ziegelmeier.net>
- */
-
-#include "lwip/apps/snmpv3.h"
-#include "snmpv3_dummy.h"
-#include <string.h>
-#include "lwip/err.h"
-#include "lwip/def.h"
-#include "lwip/timeouts.h"
-
-#if LWIP_SNMP && LWIP_SNMP_V3
-
-struct user_table_entry {
-  char               username[32];
-  snmpv3_auth_algo_t auth_algo;
-  u8_t               auth_key[20];
-  snmpv3_priv_algo_t priv_algo;
-  u8_t               priv_key[20];
-};
-
-static struct user_table_entry user_table[] = {
-  { "lwip", SNMP_V3_AUTH_ALGO_INVAL, "" , SNMP_V3_PRIV_ALGO_INVAL, "" },
-  { "piwl", SNMP_V3_AUTH_ALGO_INVAL, "" , SNMP_V3_PRIV_ALGO_INVAL, "" },
-  { "test", SNMP_V3_AUTH_ALGO_INVAL, "" , SNMP_V3_PRIV_ALGO_INVAL, "" }
-};
-
-static char snmpv3_engineid[32];
-static u8_t snmpv3_engineid_len;
-
-static u32_t enginetime = 0;
-
-/* In this implementation engineboots is volatile. In a real world application this value should be stored in non-volatile memory.*/
-static u32_t engineboots = 0;
-
-/**
- * @brief   Get the user table entry for the given username.
- *
- * @param[in] username  pointer to the username
- *
- * @return              pointer to the user table entry or NULL if not found.
- */
-static struct user_table_entry*
-get_user(const char *username)
-{
-  size_t i;
-
-  for (i = 0; i < LWIP_ARRAYSIZE(user_table); i++) {
-    if (strnlen(username, 32) != strnlen(user_table[i].username, 32)) {
-      continue;
-    }
-
-    if (memcmp(username, user_table[i].username, strnlen(username, 32)) == 0) {
-      return &user_table[i];
-    }
-  }
-
-  return NULL;
-}
-
-u8_t
-snmpv3_get_amount_of_users(void)
-{
-  return LWIP_ARRAYSIZE(user_table);
-}
-
-/**
- * @brief Get the username of a user number (index)
- * @param username is a pointer to a string.
- * @param index is the user index.
- * @return ERR_OK if user is found, ERR_VAL is user is not found.
- */
-err_t
-snmpv3_get_username(char *username, u8_t index)
-{
-  if (index < LWIP_ARRAYSIZE(user_table)) {
-    MEMCPY(username, user_table[index].username, sizeof(user_table[0].username));
-    return ERR_OK;
-  }
-
-  return ERR_VAL;
-}
-
-/**
- * Timer callback function that increments enginetime and reschedules itself.
- *
- * @param arg unused argument
- */
-static void
-snmpv3_enginetime_timer(void *arg)
-{
-  LWIP_UNUSED_ARG(arg);
-  
-  enginetime++;
-
-  /* This handles the engine time reset */
-  snmpv3_get_engine_time_internal();
-
-  /* restart timer */
-  sys_timeout(1000, snmpv3_enginetime_timer, NULL);
-}
-
-err_t
-snmpv3_set_user_auth_algo(const char *username, snmpv3_auth_algo_t algo)
-{
-  struct user_table_entry *p = get_user(username);
-
-  if (p) {
-    switch (algo) {
-    case SNMP_V3_AUTH_ALGO_INVAL:
-      if (p->priv_algo != SNMP_V3_PRIV_ALGO_INVAL) {
-        /* Privacy MUST be disabled before configuring authentication */
-        break;
-      } else {
-        p->auth_algo = algo;
-        return ERR_OK;
-      }
-#if LWIP_SNMP_V3_CRYPTO
-    case SNMP_V3_AUTH_ALGO_MD5:
-    case SNMP_V3_AUTH_ALGO_SHA:
-#endif
-      p->auth_algo = algo;
-      return ERR_OK;
-    default:
-      break;
-    }
-  }
-
-  return ERR_VAL;
-}
-
-err_t
-snmpv3_set_user_priv_algo(const char *username, snmpv3_priv_algo_t algo)
-{
-  struct user_table_entry *p = get_user(username);
-
-  if (p) {
-    switch (algo) {
-#if LWIP_SNMP_V3_CRYPTO
-    case SNMP_V3_PRIV_ALGO_AES:
-    case SNMP_V3_PRIV_ALGO_DES:
-      if (p->auth_algo == SNMP_V3_AUTH_ALGO_INVAL) {
-        /* Authentication MUST be enabled before configuring privacy */
-        break;
-      } else {
-        p->priv_algo = algo;
-        return ERR_OK;
-      }
-#endif
-    case SNMP_V3_PRIV_ALGO_INVAL:
-      p->priv_algo = algo;
-      return ERR_OK;
-    default:
-      break;
-    }
-  }
-
-  return ERR_VAL;
-}
-
-err_t
-snmpv3_set_user_auth_key(const char *username, const char *password)
-{
-  struct user_table_entry *p = get_user(username);
-  const char *engineid;
-  u8_t engineid_len;
-
-  if (p) {
-    /* password should be at least 8 characters long */
-    if (strlen(password) >= 8) {
-      memset(p->auth_key, 0, sizeof(p->auth_key));
-      snmpv3_get_engine_id(&engineid, &engineid_len);
-      switch (p->auth_algo) {
-      case SNMP_V3_AUTH_ALGO_INVAL:
-        return ERR_OK;
-#if LWIP_SNMP_V3_CRYPTO
-      case SNMP_V3_AUTH_ALGO_MD5:
-        snmpv3_password_to_key_md5((const u8_t*)password, strlen(password), (const u8_t*)engineid, engineid_len, p->auth_key);
-        return ERR_OK;
-      case SNMP_V3_AUTH_ALGO_SHA:
-        snmpv3_password_to_key_sha((const u8_t*)password, strlen(password), (const u8_t*)engineid, engineid_len, p->auth_key);
-        return ERR_OK;
-#endif
-      default:
-        return ERR_VAL;
-      }
-    }
-  }
-
-  return ERR_VAL;
-}
-
-err_t
-snmpv3_set_user_priv_key(const char *username, const char *password)
-{
-  struct user_table_entry *p = get_user(username);
-  const char *engineid;
-  u8_t engineid_len;
-
-  if (p) {
-    /* password should be at least 8 characters long */
-    if (strlen(password) >= 8) {
-      memset(p->priv_key, 0, sizeof(p->priv_key));
-      snmpv3_get_engine_id(&engineid, &engineid_len);
-      switch (p->auth_algo) {
-      case SNMP_V3_AUTH_ALGO_INVAL:
-        return ERR_OK;
-#if LWIP_SNMP_V3_CRYPTO
-      case SNMP_V3_AUTH_ALGO_MD5:
-        snmpv3_password_to_key_md5((const u8_t*)password, strlen(password), (const u8_t*)engineid, engineid_len, p->priv_key);
-        return ERR_OK;
-      case SNMP_V3_AUTH_ALGO_SHA:
-        snmpv3_password_to_key_sha((const u8_t*)password, strlen(password), (const u8_t*)engineid, engineid_len, p->priv_key);
-        return ERR_OK;
-#endif
-      default:
-        return ERR_VAL;
-      }
-    }
-  }
-
-  return ERR_VAL;
-}
-
-/**
- * @brief   Get the storage type of the given username.
- *
- * @param[in] username  pointer to the username
- * @param[out] type     the storage type
- *
- * @return              ERR_OK if the user was found, ERR_VAL if not.
- */
-err_t
-snmpv3_get_user_storagetype(const char *username, snmpv3_user_storagetype_t *type)
-{
-  if (get_user(username) != NULL) {
-    /* Found user in user table
-     * In this dummy implementation, storage is permanent because no user can be deleted.
-     * All changes to users are lost after a reboot.*/
-    *type = SNMP_V3_USER_STORAGETYPE_PERMANENT;
-    return ERR_OK;
-  }
-
-  return ERR_VAL;
-}
-
-/**
- *  @param username is a pointer to a string.
- * @param auth_algo is a pointer to u8_t. The implementation has to set this if user was found.
- * @param auth_key is a pointer to a pointer to a string. Implementation has to set this if user was found.
- * @param priv_algo is a pointer to u8_t. The implementation has to set this if user was found.
- * @param priv_key is a pointer to a pointer to a string. Implementation has to set this if user was found.
- */
-err_t
-snmpv3_get_user(const char* username, snmpv3_auth_algo_t *auth_algo, u8_t *auth_key, snmpv3_priv_algo_t *priv_algo, u8_t *priv_key)
-{
-  const struct user_table_entry *p;
-  
-  /* The msgUserName specifies the user (principal) on whose behalf the
-     message is being exchanged. Note that a zero-length userName will
-     not match any user, but it can be used for snmpEngineID discovery. */
-  if(strlen(username) == 0) {
-    return ERR_OK;
-  }
-  
-  p = get_user(username);
-
-  if (!p) {
-    return ERR_VAL;
-  }
-  
-  if (auth_algo != NULL) {
-    *auth_algo = p->auth_algo;
-  }
-  if(auth_key != NULL) {
-    MEMCPY(auth_key, p->auth_key, sizeof(p->auth_key));
-  }
-  if (priv_algo != NULL) {
-    *priv_algo = p->priv_algo;
-  }
-  if(priv_key != NULL) {
-    MEMCPY(priv_key, p->priv_key, sizeof(p->priv_key));
-  }
-  return ERR_OK;
-}
-
-/**
- * Get engine ID from persistence
- */
-void
-snmpv3_get_engine_id(const char **id, u8_t *len)
-{
-  *id = snmpv3_engineid;
-  *len = snmpv3_engineid_len;
-}
-
-/**
- * Store engine ID in persistence
- */
-err_t
-snmpv3_set_engine_id(const char *id, u8_t len)
-{
-  MEMCPY(snmpv3_engineid, id, len);
-  snmpv3_engineid_len = len;
-  return ERR_OK;
-}
-
-/**
- * Get engine boots from persistence. Must be increased on each boot.
- */
-u32_t
-snmpv3_get_engine_boots(void)
-{
-  return engineboots;
-}
-
-/**
- * Store engine boots in persistence
- */
-void 
-snmpv3_set_engine_boots(u32_t boots)
-{
-  engineboots = boots;
-}
-
-/**
- * RFC3414 2.2.2.
- * Once the timer reaches 2147483647 it gets reset to zero and the
- * engine boot ups get incremented.
- */
-u32_t
-snmpv3_get_engine_time(void)
-{
-  return enginetime;
-}
-
-/**
- * Reset current engine time to 0
- */
-void
-snmpv3_reset_engine_time(void)
-{
-  enginetime = 0;
-}
-
-/**
- * Initialize dummy SNMPv3 implementation
- */
-void
-snmpv3_dummy_init(void)
-{
-  snmpv3_set_engine_id("FOO", 3);
-
-  snmpv3_set_user_auth_algo("lwip", SNMP_V3_AUTH_ALGO_SHA);
-  snmpv3_set_user_auth_key("lwip", "maplesyrup");
-
-  snmpv3_set_user_priv_algo("lwip", SNMP_V3_PRIV_ALGO_DES);
-  snmpv3_set_user_priv_key("lwip", "maplesyrup");
-
-  /* Start the engine time timer */
-  snmpv3_enginetime_timer(NULL);
-}
-
-#endif /* LWIP_SNMP && LWIP_SNMP_V3 */
diff --git a/contrib/examples/snmp/snmp_v3/snmpv3_dummy.h b/contrib/examples/snmp/snmp_v3/snmpv3_dummy.h
deleted file mode 100644
index ba25b6d7..00000000
--- a/contrib/examples/snmp/snmp_v3/snmpv3_dummy.h
+++ /dev/null
@@ -1,53 +0,0 @@
-/**
- * @file
- * Dummy SNMPv3 functions.
- */
-
-/*
- * Copyright (c) 2017 Dirk Ziegelmeier.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * Author: Dirk Ziegelmeier <dziegel@gmx.de>
- */
-
-#ifndef LWIP_HDR_APPS_SNMP_V3_DUMMY_H
-#define LWIP_HDR_APPS_SNMP_V3_DUMMY_H
-
-#include "lwip/apps/snmp_opts.h"
-#include "lwip/err.h"
-#include "lwip/apps/snmpv3.h"
-
-#if LWIP_SNMP && LWIP_SNMP_V3
-
-err_t snmpv3_set_user_auth_algo(const char *username, snmpv3_auth_algo_t algo);
-err_t snmpv3_set_user_priv_algo(const char *username, snmpv3_priv_algo_t algo);
-err_t snmpv3_set_user_auth_key(const char *username, const char *password);
-err_t snmpv3_set_user_priv_key(const char *username, const char *password);
-
-void snmpv3_dummy_init(void);
-
-#endif /* LWIP_SNMP && LWIP_SNMP_V3 */
-
-#endif /* LWIP_HDR_APPS_SNMP_V3_DUMMY_H */
diff --git a/contrib/examples/sntp/sntp_example.c b/contrib/examples/sntp/sntp_example.c
deleted file mode 100644
index 60178bff..00000000
--- a/contrib/examples/sntp/sntp_example.c
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Dirk Ziegelmeier <dziegel@gmx.de>
- *
- */
-
-#include <time.h>
-
-#include "lwip/opt.h"
-#include "lwip/apps/sntp.h"
-#include "sntp_example.h"
-#include "lwip/netif.h"
-
-void
-sntp_set_system_time(u32_t sec)
-{
-  char buf[32];
-  struct tm current_time_val;
-  time_t current_time = (time_t)sec;
-
-#ifdef _MSC_VER
-  localtime_s(&current_time_val, &current_time);
-#else
-  localtime_r(&current_time, &current_time_val);
-#endif
-  
-  strftime(buf, sizeof(buf), "%d.%m.%Y %H:%M:%S", &current_time_val);
-  LWIP_PLATFORM_DIAG(("SNTP time: %s\n", buf));
-}
-
-void
-sntp_example_init(void)
-{
-  sntp_setoperatingmode(SNTP_OPMODE_POLL);
-#if LWIP_DHCP
-  sntp_servermode_dhcp(1); /* get SNTP server via DHCP */
-#else /* LWIP_DHCP */
-#if LWIP_IPV4
-  sntp_setserver(0, netif_ip_gw4(netif_default));
-#endif /* LWIP_IPV4 */
-#endif /* LWIP_DHCP */
-  sntp_init();
-}
diff --git a/contrib/examples/sntp/sntp_example.h b/contrib/examples/sntp/sntp_example.h
deleted file mode 100644
index 94fc10db..00000000
--- a/contrib/examples/sntp/sntp_example.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Dirk Ziegelmeier <dziegel@gmx.de>
- *
- */
-
-#ifndef SNTP_EXAMPLE_H
-#define SNTP_EXAMPLE_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-void sntp_example_init(void);
-
-void sntp_set_system_time(u32_t sec);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* SNTP_EXAMPLE_H */
diff --git a/contrib/examples/tftp/tftp_example.c b/contrib/examples/tftp/tftp_example.c
deleted file mode 100644
index 3e140146..00000000
--- a/contrib/examples/tftp/tftp_example.c
+++ /dev/null
@@ -1,155 +0,0 @@
-/*
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Dirk Ziegelmeier <dziegel@gmx.de>
- *
- */
-
-#include <stdio.h>
-
-#include "lwip/apps/tftp_client.h"
-#include "lwip/apps/tftp_server.h"
-#include "tftp_example.h"
-
-#include <string.h>
-
-#if LWIP_UDP
-
-/* Define a base directory for TFTP access
- * ATTENTION: This code does NOT check for sandboxing,
- * i.e. '..' in paths is not checked! */
-#ifndef LWIP_TFTP_EXAMPLE_BASE_DIR
-#define LWIP_TFTP_EXAMPLE_BASE_DIR ""
-#endif
-
-/* Define this to a file to get via tftp client */
-#ifndef LWIP_TFTP_EXAMPLE_CLIENT_FILENAME
-#define LWIP_TFTP_EXAMPLE_CLIENT_FILENAME "test.bin"
-#endif
-
-/* Define this to a server IP string */
-#ifndef LWIP_TFTP_EXAMPLE_CLIENT_REMOTEIP
-#define LWIP_TFTP_EXAMPLE_CLIENT_REMOTEIP "192.168.0.1"
-#endif
-
-static char full_filename[256];
-
-static void *
-tftp_open_file(const char* fname, u8_t is_write)
-{
-  snprintf(full_filename, sizeof(full_filename), "%s%s", LWIP_TFTP_EXAMPLE_BASE_DIR, fname);
-  full_filename[sizeof(full_filename)-1] = 0;
-
-  if (is_write) {
-    return (void*)fopen(full_filename, "wb");
-  } else {
-    return (void*)fopen(full_filename, "rb");
-  }
-}
-
-static void*
-tftp_open(const char* fname, const char* mode, u8_t is_write)
-{
-  LWIP_UNUSED_ARG(mode);
-  return tftp_open_file(fname, is_write);
-}
-
-static void
-tftp_close(void* handle)
-{
-  fclose((FILE*)handle);
-}
-
-static int
-tftp_read(void* handle, void* buf, int bytes)
-{
-  int ret = fread(buf, 1, bytes, (FILE*)handle);
-  if (ret <= 0) {
-    return -1;
-  }
-  return ret;
-}
-
-static int
-tftp_write(void* handle, struct pbuf* p)
-{
-  while (p != NULL) {
-    if (fwrite(p->payload, 1, p->len, (FILE*)handle) != (size_t)p->len) {
-      return -1;
-    }
-    p = p->next;
-  }
-
-  return 0;
-}
-
-/* For TFTP client only */
-static void
-tftp_error(void* handle, int err, const char* msg, int size)
-{
-  char message[100];
-
-  LWIP_UNUSED_ARG(handle);
-
-  memset(message, 0, sizeof(message));
-  MEMCPY(message, msg, LWIP_MIN(sizeof(message)-1, (size_t)size));
-
-  printf("TFTP error: %d (%s)", err, message);
-}
-
-static const struct tftp_context tftp = {
-  tftp_open,
-  tftp_close,
-  tftp_read,
-  tftp_write,
-  tftp_error
-};
-
-void
-tftp_example_init_server(void)
-{
-  tftp_init_server(&tftp);
-}
-
-void
-tftp_example_init_client(void)
-{
-  void *f;
-  err_t err;
-  ip_addr_t srv;
-  int ret = ipaddr_aton(LWIP_TFTP_EXAMPLE_CLIENT_REMOTEIP, &srv);
-  LWIP_ASSERT("ipaddr_aton failed", ret == 1);
-
-  err = tftp_init_client(&tftp);
-  LWIP_ASSERT("tftp_init_client failed", err == ERR_OK);
-
-  f = tftp_open_file(LWIP_TFTP_EXAMPLE_CLIENT_FILENAME, 1);
-  LWIP_ASSERT("failed to create file", f != NULL);
-
-  err = tftp_get(f, &srv, TFTP_PORT, LWIP_TFTP_EXAMPLE_CLIENT_FILENAME, TFTP_MODE_OCTET);
-  LWIP_ASSERT("tftp_get failed", err == ERR_OK);
-}
-
-#endif /* LWIP_UDP */
diff --git a/contrib/examples/tftp/tftp_example.h b/contrib/examples/tftp/tftp_example.h
deleted file mode 100644
index 73407004..00000000
--- a/contrib/examples/tftp/tftp_example.h
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * To change this license header, choose License Headers in Project Properties.
- * To change this template file, choose Tools | Templates
- * and open the template in the editor.
- */
-
-/* 
- * File:   tftp_example.h
- * Author: dziegel
- *
- * Created on February 17, 2018, 3:43 PM
- */
-
-#ifndef TFTP_EXAMPLE_H
-#define TFTP_EXAMPLE_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-void tftp_example_init_server(void);
-void tftp_example_init_client(void);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* TFTP_EXAMPLE_H */
-
diff --git a/contrib/ports/CMakeCommon.cmake b/contrib/ports/CMakeCommon.cmake
deleted file mode 100644
index 47e86657..00000000
--- a/contrib/ports/CMakeCommon.cmake
+++ /dev/null
@@ -1,128 +0,0 @@
-if(NOT ${CMAKE_VERSION} VERSION_LESS "3.10.0")
-    include_guard(GLOBAL)
-endif()
-
-if(NOT CMAKE_BUILD_TYPE)
-    message(STATUS  "CMAKE_BUILD_TYPE not set - defaulting to Debug build.")
-    set(CMAKE_BUILD_TYPE Debug CACHE STRING "Choose the type of build, options are: ${CMAKE_CONFIGURATION_TYPES}." FORCE)
-endif()
-message (STATUS "Build type: ${CMAKE_BUILD_TYPE}")
-
-set(LWIP_CONTRIB_DIR ${LWIP_DIR}/contrib)
-
-# ARM mbedtls support https://tls.mbed.org/
-if(NOT DEFINED LWIP_MBEDTLSDIR)
-    set(LWIP_MBEDTLSDIR ${LWIP_DIR}/../mbedtls)
-    message(STATUS "LWIP_MBEDTLSDIR not set - using default location ${LWIP_MBEDTLSDIR}")
-endif()
-if(EXISTS ${LWIP_MBEDTLSDIR}/CMakeLists.txt)
-    set(LWIP_HAVE_MBEDTLS ON BOOL)
-
-    # Prevent building MBEDTLS programs and tests
-    set(ENABLE_PROGRAMS OFF CACHE BOOL "")
-    set(ENABLE_TESTING  OFF CACHE BOOL "")
-
-    # mbedtls uses cmake. Sweet!
-    add_subdirectory(${LWIP_MBEDTLSDIR} mbedtls)
-
-    set (LWIP_MBEDTLS_DEFINITIONS
-        LWIP_HAVE_MBEDTLS=1
-    )
-    set (LWIP_MBEDTLS_INCLUDE_DIRS
-        ${LWIP_MBEDTLSDIR}/include
-    )
-    set (LWIP_MBEDTLS_LINK_LIBRARIES
-        mbedtls
-        mbedcrypto
-        mbedx509
-    )
-endif()
-
-set(LWIP_COMPILER_FLAGS_GNU_CLANG
-    $<$<CONFIG:Debug>:-Og>
-    $<$<CONFIG:Debug>:-g>
-    $<$<CONFIG:Release>:-O3>
-    -Wall
-    -pedantic
-    -Werror
-    -Wparentheses
-    -Wsequence-point
-    -Wswitch-default
-    -Wextra
-    -Wundef
-    -Wshadow
-    -Wpointer-arith
-    -Wcast-qual
-    -Wc++-compat
-    -Wwrite-strings
-    -Wold-style-definition
-    -Wcast-align
-    -Wmissing-prototypes
-    -Wnested-externs
-    -Wunreachable-code
-    -Wuninitialized
-    -Wmissing-prototypes
-    -Waggregate-return
-    -Wlogical-not-parentheses
-)
-
-if (NOT LWIP_HAVE_MBEDTLS)
-    list(APPEND LWIP_COMPILER_FLAGS_GNU_CLANG
-        -Wredundant-decls
-    )
-endif()
-
-if(CMAKE_C_COMPILER_ID STREQUAL "GNU")
-    list(APPEND LWIP_COMPILER_FLAGS_GNU_CLANG
-        -Wlogical-op
-        -Wtrampolines
-    )
-
-    if (NOT LWIP_HAVE_MBEDTLS)
-        list(APPEND LWIP_COMPILER_FLAGS_GNU_CLANG
-            -Wc90-c99-compat
-        )
-    endif()
-
-    if(NOT CMAKE_C_COMPILER_VERSION VERSION_LESS 4.9)
-        if(LWIP_USE_SANITIZERS)
-            list(APPEND LWIP_COMPILER_FLAGS_GNU_CLANG
-                -fsanitize=address
-                -fsanitize=undefined
-                -fno-sanitize=alignment
-                -fstack-protector
-                -fstack-check
-            )
-            set(LWIP_SANITIZER_LIBS asan ubsan)
-        endif()
-    endif()
-
-    set(LWIP_COMPILER_FLAGS ${LWIP_COMPILER_FLAGS_GNU_CLANG})
-endif()
-
-if(CMAKE_C_COMPILER_ID STREQUAL "Clang")
-    list(APPEND LWIP_COMPILER_FLAGS_GNU_CLANG
-        -Wdocumentation
-        -Wno-documentation-deprecated-sync
-    )
-
-    if(LWIP_USE_SANITIZERS)
-        list(APPEND LWIP_COMPILER_FLAGS_GNU_CLANG
-            -fsanitize=address
-            -fsanitize=undefined
-            -fno-sanitize=alignment
-        )
-        set(LWIP_SANITIZER_LIBS asan ubsan)
-    endif()
-
-    set(LWIP_COMPILER_FLAGS ${LWIP_COMPILER_FLAGS_GNU_CLANG})
-endif()
-
-if(CMAKE_C_COMPILER_ID STREQUAL "MSVC")
-    set(LWIP_COMPILER_FLAGS
-        $<$<CONFIG:Debug>:/Od>
-        $<$<CONFIG:Release>:/Ox>
-        /Wall
-        /WX
-    )
-endif()
diff --git a/contrib/ports/Common.allports.mk b/contrib/ports/Common.allports.mk
deleted file mode 100644
index 862324e9..00000000
--- a/contrib/ports/Common.allports.mk
+++ /dev/null
@@ -1,91 +0,0 @@
-#
-# Copyright (c) 2001, 2002 Swedish Institute of Computer Science.
-# All rights reserved. 
-# 
-# Redistribution and use in source and binary forms, with or without modification, 
-# are permitted provided that the following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice,
-#    this list of conditions and the following disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright notice,
-#    this list of conditions and the following disclaimer in the documentation
-#    and/or other materials provided with the distribution.
-# 3. The name of the author may not be used to endorse or promote products
-#    derived from this software without specific prior written permission. 
-#
-# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
-# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
-# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
-# SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
-# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
-# OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
-# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
-# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
-# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# This file is part of the lwIP TCP/IP stack.
-# 
-# Author: Adam Dunkels <adam@sics.se>
-#
-
-#CC=gcc
-#CC=clang
-CCDEP?=$(CC)
-
-CFLAGS+=-g -DLWIP_DEBUG -Wall -pedantic -Werror \
-	-Wparentheses -Wsequence-point -Wswitch-default \
-	-Wextra -Wundef -Wshadow -Wpointer-arith -Wcast-qual \
-	-Wc++-compat -Wwrite-strings -Wold-style-definition -Wcast-align \
-	-Wmissing-prototypes -Wredundant-decls -Wnested-externs \
-	-Wunreachable-code -Wuninitialized -Wmissing-prototypes \
-	-Wredundant-decls -Waggregate-return -Wlogical-not-parentheses
-#	-Wconversion -Wsign-compare -Wmissing-include-dirs
-
-ifeq (,$(findstring clang,$(CC)))
-CFLAGS+= -Wlogical-op -Wc90-c99-compat -Wtrampolines
-# if GCC is newer than 4.8/4.9 you may use:
-#CFLAGS:=$(CFLAGS) -fsanitize=address -fstack-protector -fstack-check -fsanitize=undefined -fno-sanitize=alignment
-else
-# we cannot sanitize alignment on x86-64 targets because clang wants 64 bit alignment
-CFLAGS+= -fsanitize=address -fsanitize=undefined -fno-sanitize=alignment -Wdocumentation -Wno-documentation-deprecated-sync
-endif
-
-CONTRIBDIR?=../../..
-ARFLAGS?=rs
-
-#Set this to where you have the lwip core module checked out from git
-#default assumes it's a dir above the contrib module
-LWIPDIR?=$(CONTRIBDIR)/..
-
-CFLAGS+=-I. \
-	-I$(CONTRIBDIR) \
-	-I$(LWIPDIR)/include \
-	-I$(LWIPARCH)/include
-
-# Add include path and link to mbedTLS lib if available
-MBEDTLSDIR?=$(LWIPDIR)/../mbedtls
-ifneq (,$(wildcard $(MBEDTLSDIR)/include/mbedtls/*.h))
-LDFLAGS+=-L$(MBEDTLSDIR)/library -lmbedtls -lmbedcrypto -lmbedx509
-CFLAGS+=-I$(MBEDTLSDIR)/include -Wno-redundant-decls -DLWIP_HAVE_MBEDTLS=1 -Wno-c90-c99-compat
-endif
-
-include $(CONTRIBDIR)/Filelists.mk
-include $(LWIPDIR)/Filelists.mk
-
-# LWIPFILES: All the above.
-LWIPFILES=$(LWIPNOAPPSFILES) $(ARCHFILES)
-LWIPOBJS=$(notdir $(LWIPFILES:.c=.o))
-
-LWIPLIBCOMMON=liblwipcommon.a
-$(LWIPLIBCOMMON): $(LWIPOBJS)
-	$(AR) $(ARFLAGS) $(LWIPLIBCOMMON) $?
-
-APPFILES=$(CONTRIBAPPFILES) $(LWIPAPPFILES)
-APPLIB=liblwipapps.a
-APPOBJS=$(notdir $(APPFILES:.c=.o))
-$(APPLIB): $(APPOBJS)
-	$(AR) $(ARFLAGS) $(APPLIB) $?
-
-%.o:
-	$(CC) $(CFLAGS) -c $<
diff --git a/contrib/ports/freertos/include/arch/sys_arch.h b/contrib/ports/freertos/include/arch/sys_arch.h
deleted file mode 100644
index 0cfc889d..00000000
--- a/contrib/ports/freertos/include/arch/sys_arch.h
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
- * Copyright (c) 2017 Simon Goldschmidt
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Simon Goldschmdit <goldsimon@gmx.de>
- *
- */
-#ifndef LWIP_ARCH_SYS_ARCH_H
-#define LWIP_ARCH_SYS_ARCH_H
-
-#include "lwip/opt.h"
-#include "lwip/arch.h"
-
-/** This is returned by _fromisr() sys functions to tell the outermost function
- * that a higher priority task was woken and the scheduler needs to be invoked.
- */
-#define ERR_NEED_SCHED 123
-
-/* This port includes FreeRTOS headers in sys_arch.c only.
- *  FreeRTOS uses pointers as object types. We use wrapper structs instead of
- * void pointers directly to get a tiny bit of type safety.
- */
-
-void sys_arch_msleep(u32_t delay_ms);
-#define sys_msleep(ms) sys_arch_msleep(ms)
-
-#if SYS_LIGHTWEIGHT_PROT
-typedef u32_t sys_prot_t;
-#endif /* SYS_LIGHTWEIGHT_PROT */
-
-#if !LWIP_COMPAT_MUTEX
-struct _sys_mut {
-  void *mut;
-};
-typedef struct _sys_mut sys_mutex_t;
-#define sys_mutex_valid_val(mutex)   ((mutex).mut != NULL)
-#define sys_mutex_valid(mutex)       (((mutex) != NULL) && sys_mutex_valid_val(*(mutex)))
-#define sys_mutex_set_invalid(mutex) ((mutex)->mut = NULL)
-#endif /* !LWIP_COMPAT_MUTEX */
-
-struct _sys_sem {
-  void *sem;
-};
-typedef struct _sys_sem sys_sem_t;
-#define sys_sem_valid_val(sema)   ((sema).sem != NULL)
-#define sys_sem_valid(sema)       (((sema) != NULL) && sys_sem_valid_val(*(sema)))
-#define sys_sem_set_invalid(sema) ((sema)->sem = NULL)
-
-struct _sys_mbox {
-  void *mbx;
-};
-typedef struct _sys_mbox sys_mbox_t;
-#define sys_mbox_valid_val(mbox)   ((mbox).mbx != NULL)
-#define sys_mbox_valid(mbox)       (((mbox) != NULL) && sys_mbox_valid_val(*(mbox)))
-#define sys_mbox_set_invalid(mbox) ((mbox)->mbx = NULL)
-
-struct _sys_thread {
-  void *thread_handle;
-};
-typedef struct _sys_thread sys_thread_t;
-
-#if LWIP_NETCONN_SEM_PER_THREAD
-sys_sem_t* sys_arch_netconn_sem_get(void);
-void sys_arch_netconn_sem_alloc(void);
-void sys_arch_netconn_sem_free(void);
-#define LWIP_NETCONN_THREAD_SEM_GET()   sys_arch_netconn_sem_get()
-#define LWIP_NETCONN_THREAD_SEM_ALLOC() sys_arch_netconn_sem_alloc()
-#define LWIP_NETCONN_THREAD_SEM_FREE()  sys_arch_netconn_sem_free()
-#endif /* LWIP_NETCONN_SEM_PER_THREAD */
-
-#endif /* LWIP_ARCH_SYS_ARCH_H */
diff --git a/contrib/ports/freertos/sys_arch.c b/contrib/ports/freertos/sys_arch.c
deleted file mode 100644
index 68a427fe..00000000
--- a/contrib/ports/freertos/sys_arch.c
+++ /dev/null
@@ -1,606 +0,0 @@
-/*
- * Copyright (c) 2017 Simon Goldschmidt
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Simon Goldschmidt <goldsimon@gmx.de>
- *
- */
-
-/* lwIP includes. */
-#include "lwip/debug.h"
-#include "lwip/def.h"
-#include "lwip/sys.h"
-#include "lwip/mem.h"
-#include "lwip/stats.h"
-#include "FreeRTOS.h"
-#include "semphr.h"
-#include "task.h"
-
-/** Set this to 1 if you want the stack size passed to sys_thread_new() to be
- * interpreted as number of stack words (FreeRTOS-like).
- * Default is that they are interpreted as byte count (lwIP-like).
- */
-#ifndef LWIP_FREERTOS_THREAD_STACKSIZE_IS_STACKWORDS
-#define LWIP_FREERTOS_THREAD_STACKSIZE_IS_STACKWORDS  0
-#endif
-
-/** Set this to 1 to use a mutex for SYS_ARCH_PROTECT() critical regions.
- * Default is 0 and locks interrupts/scheduler for SYS_ARCH_PROTECT().
- */
-#ifndef LWIP_FREERTOS_SYS_ARCH_PROTECT_USES_MUTEX
-#define LWIP_FREERTOS_SYS_ARCH_PROTECT_USES_MUTEX     0
-#endif
-
-/** Set this to 1 to include a sanity check that SYS_ARCH_PROTECT() and
- * SYS_ARCH_UNPROTECT() are called matching.
- */
-#ifndef LWIP_FREERTOS_SYS_ARCH_PROTECT_SANITY_CHECK
-#define LWIP_FREERTOS_SYS_ARCH_PROTECT_SANITY_CHECK   0
-#endif
-
-/** Set this to 1 to let sys_mbox_free check that queues are empty when freed */
-#ifndef LWIP_FREERTOS_CHECK_QUEUE_EMPTY_ON_FREE
-#define LWIP_FREERTOS_CHECK_QUEUE_EMPTY_ON_FREE       0
-#endif
-
-/** Set this to 1 to enable core locking check functions in this port.
- * For this to work, you'll have to define LWIP_ASSERT_CORE_LOCKED()
- * and LWIP_MARK_TCPIP_THREAD() correctly in your lwipopts.h! */
-#ifndef LWIP_FREERTOS_CHECK_CORE_LOCKING
-#define LWIP_FREERTOS_CHECK_CORE_LOCKING              0
-#endif
-
-/** Set this to 0 to implement sys_now() yourself, e.g. using a hw timer.
- * Default is 1, where FreeRTOS ticks are used to calculate back to ms.
- */
-#ifndef LWIP_FREERTOS_SYS_NOW_FROM_FREERTOS
-#define LWIP_FREERTOS_SYS_NOW_FROM_FREERTOS           1
-#endif
-
-#if !configSUPPORT_DYNAMIC_ALLOCATION
-# error "lwIP FreeRTOS port requires configSUPPORT_DYNAMIC_ALLOCATION"
-#endif
-#if !INCLUDE_vTaskDelay
-# error "lwIP FreeRTOS port requires INCLUDE_vTaskDelay"
-#endif
-#if !INCLUDE_vTaskSuspend
-# error "lwIP FreeRTOS port requires INCLUDE_vTaskSuspend"
-#endif
-#if LWIP_FREERTOS_SYS_ARCH_PROTECT_USES_MUTEX || !LWIP_COMPAT_MUTEX
-#if !configUSE_MUTEXES
-# error "lwIP FreeRTOS port requires configUSE_MUTEXES"
-#endif
-#endif
-
-#if SYS_LIGHTWEIGHT_PROT && LWIP_FREERTOS_SYS_ARCH_PROTECT_USES_MUTEX
-static SemaphoreHandle_t sys_arch_protect_mutex;
-#endif
-#if SYS_LIGHTWEIGHT_PROT && LWIP_FREERTOS_SYS_ARCH_PROTECT_SANITY_CHECK
-static sys_prot_t sys_arch_protect_nesting;
-#endif
-
-/* Initialize this module (see description in sys.h) */
-void
-sys_init(void)
-{
-#if SYS_LIGHTWEIGHT_PROT && LWIP_FREERTOS_SYS_ARCH_PROTECT_USES_MUTEX
-  /* initialize sys_arch_protect global mutex */
-  sys_arch_protect_mutex = xSemaphoreCreateRecursiveMutex();
-  LWIP_ASSERT("failed to create sys_arch_protect mutex",
-    sys_arch_protect_mutex != NULL);
-#endif /* SYS_LIGHTWEIGHT_PROT && LWIP_FREERTOS_SYS_ARCH_PROTECT_USES_MUTEX */
-}
-
-#if configUSE_16_BIT_TICKS == 1
-#error This port requires 32 bit ticks or timer overflow will fail
-#endif
-
-#if LWIP_FREERTOS_SYS_NOW_FROM_FREERTOS
-u32_t
-sys_now(void)
-{
-  return xTaskGetTickCount() * portTICK_PERIOD_MS;
-}
-#endif
-
-u32_t
-sys_jiffies(void)
-{
-  return xTaskGetTickCount();
-}
-
-#if SYS_LIGHTWEIGHT_PROT
-
-sys_prot_t
-sys_arch_protect(void)
-{
-#if LWIP_FREERTOS_SYS_ARCH_PROTECT_USES_MUTEX
-  BaseType_t ret;
-  LWIP_ASSERT("sys_arch_protect_mutex != NULL", sys_arch_protect_mutex != NULL);
-
-  ret = xSemaphoreTakeRecursive(sys_arch_protect_mutex, portMAX_DELAY);
-  LWIP_ASSERT("sys_arch_protect failed to take the mutex", ret == pdTRUE);
-#else /* LWIP_FREERTOS_SYS_ARCH_PROTECT_USES_MUTEX */
-  taskENTER_CRITICAL();
-#endif /* LWIP_FREERTOS_SYS_ARCH_PROTECT_USES_MUTEX */
-#if LWIP_FREERTOS_SYS_ARCH_PROTECT_SANITY_CHECK
-  {
-    /* every nested call to sys_arch_protect() returns an increased number */
-    sys_prot_t ret = sys_arch_protect_nesting;
-    sys_arch_protect_nesting++;
-    LWIP_ASSERT("sys_arch_protect overflow", sys_arch_protect_nesting > ret);
-    return ret;
-  }
-#else
-  return 1;
-#endif
-}
-
-void
-sys_arch_unprotect(sys_prot_t pval)
-{
-#if LWIP_FREERTOS_SYS_ARCH_PROTECT_USES_MUTEX
-  BaseType_t ret;
-#endif
-#if LWIP_FREERTOS_SYS_ARCH_PROTECT_SANITY_CHECK
-  LWIP_ASSERT("unexpected sys_arch_protect_nesting", sys_arch_protect_nesting > 0);
-  sys_arch_protect_nesting--;
-  LWIP_ASSERT("unexpected sys_arch_protect_nesting", sys_arch_protect_nesting == pval);
-#endif
-
-#if LWIP_FREERTOS_SYS_ARCH_PROTECT_USES_MUTEX
-  LWIP_ASSERT("sys_arch_protect_mutex != NULL", sys_arch_protect_mutex != NULL);
-
-  ret = xSemaphoreGiveRecursive(sys_arch_protect_mutex);
-  LWIP_ASSERT("sys_arch_unprotect failed to give the mutex", ret == pdTRUE);
-#else /* LWIP_FREERTOS_SYS_ARCH_PROTECT_USES_MUTEX */
-  taskEXIT_CRITICAL();
-#endif /* LWIP_FREERTOS_SYS_ARCH_PROTECT_USES_MUTEX */
-  LWIP_UNUSED_ARG(pval);
-}
-
-#endif /* SYS_LIGHTWEIGHT_PROT */
-
-void
-sys_arch_msleep(u32_t delay_ms)
-{
-  TickType_t delay_ticks = delay_ms / portTICK_RATE_MS;
-  vTaskDelay(delay_ticks);
-}
-
-#if !LWIP_COMPAT_MUTEX
-
-/* Create a new mutex*/
-err_t
-sys_mutex_new(sys_mutex_t *mutex)
-{
-  LWIP_ASSERT("mutex != NULL", mutex != NULL);
-
-  mutex->mut = xSemaphoreCreateRecursiveMutex();
-  if(mutex->mut == NULL) {
-    SYS_STATS_INC(mutex.err);
-    return ERR_MEM;
-  }
-  SYS_STATS_INC_USED(mutex);
-  return ERR_OK;
-}
-
-void
-sys_mutex_lock(sys_mutex_t *mutex)
-{
-  BaseType_t ret;
-  LWIP_ASSERT("mutex != NULL", mutex != NULL);
-  LWIP_ASSERT("mutex->mut != NULL", mutex->mut != NULL);
-
-  ret = xSemaphoreTakeRecursive(mutex->mut, portMAX_DELAY);
-  LWIP_ASSERT("failed to take the mutex", ret == pdTRUE);
-}
-
-void
-sys_mutex_unlock(sys_mutex_t *mutex)
-{
-  BaseType_t ret;
-  LWIP_ASSERT("mutex != NULL", mutex != NULL);
-  LWIP_ASSERT("mutex->mut != NULL", mutex->mut != NULL);
-
-  ret = xSemaphoreGiveRecursive(mutex->mut);
-  LWIP_ASSERT("failed to give the mutex", ret == pdTRUE);
-}
-
-void
-sys_mutex_free(sys_mutex_t *mutex)
-{
-  LWIP_ASSERT("mutex != NULL", mutex != NULL);
-  LWIP_ASSERT("mutex->mut != NULL", mutex->mut != NULL);
-
-  SYS_STATS_DEC(mutex.used);
-  vSemaphoreDelete(mutex->mut);
-  mutex->mut = NULL;
-}
-
-#endif /* !LWIP_COMPAT_MUTEX */
-
-err_t
-sys_sem_new(sys_sem_t *sem, u8_t initial_count)
-{
-  LWIP_ASSERT("sem != NULL", sem != NULL);
-  LWIP_ASSERT("initial_count invalid (not 0 or 1)",
-    (initial_count == 0) || (initial_count == 1));
-
-  sem->sem = xSemaphoreCreateBinary();
-  if(sem->sem == NULL) {
-    SYS_STATS_INC(sem.err);
-    return ERR_MEM;
-  }
-  SYS_STATS_INC_USED(sem);
-
-  if(initial_count == 1) {
-    BaseType_t ret = xSemaphoreGive(sem->sem);
-    LWIP_ASSERT("sys_sem_new: initial give failed", ret == pdTRUE);
-  }
-  return ERR_OK;
-}
-
-void
-sys_sem_signal(sys_sem_t *sem)
-{
-  BaseType_t ret;
-  LWIP_ASSERT("sem != NULL", sem != NULL);
-  LWIP_ASSERT("sem->sem != NULL", sem->sem != NULL);
-
-  ret = xSemaphoreGive(sem->sem);
-  /* queue full is OK, this is a signal only... */
-  LWIP_ASSERT("sys_sem_signal: sane return value",
-    (ret == pdTRUE) || (ret == errQUEUE_FULL));
-}
-
-u32_t
-sys_arch_sem_wait(sys_sem_t *sem, u32_t timeout_ms)
-{
-  BaseType_t ret;
-  LWIP_ASSERT("sem != NULL", sem != NULL);
-  LWIP_ASSERT("sem->sem != NULL", sem->sem != NULL);
-
-  if(!timeout_ms) {
-    /* wait infinite */
-    ret = xSemaphoreTake(sem->sem, portMAX_DELAY);
-    LWIP_ASSERT("taking semaphore failed", ret == pdTRUE);
-  } else {
-    TickType_t timeout_ticks = timeout_ms / portTICK_RATE_MS;
-    ret = xSemaphoreTake(sem->sem, timeout_ticks);
-    if (ret == errQUEUE_EMPTY) {
-      /* timed out */
-      return SYS_ARCH_TIMEOUT;
-    }
-    LWIP_ASSERT("taking semaphore failed", ret == pdTRUE);
-  }
-
-  /* Old versions of lwIP required us to return the time waited.
-     This is not the case any more. Just returning != SYS_ARCH_TIMEOUT
-     here is enough. */
-  return 1;
-}
-
-void
-sys_sem_free(sys_sem_t *sem)
-{
-  LWIP_ASSERT("sem != NULL", sem != NULL);
-  LWIP_ASSERT("sem->sem != NULL", sem->sem != NULL);
-
-  SYS_STATS_DEC(sem.used);
-  vSemaphoreDelete(sem->sem);
-  sem->sem = NULL;
-}
-
-err_t
-sys_mbox_new(sys_mbox_t *mbox, int size)
-{
-  LWIP_ASSERT("mbox != NULL", mbox != NULL);
-  LWIP_ASSERT("size > 0", size > 0);
-
-  mbox->mbx = xQueueCreate((UBaseType_t)size, sizeof(void *));
-  if(mbox->mbx == NULL) {
-    SYS_STATS_INC(mbox.err);
-    return ERR_MEM;
-  }
-  SYS_STATS_INC_USED(mbox);
-  return ERR_OK;
-}
-
-void
-sys_mbox_post(sys_mbox_t *mbox, void *msg)
-{
-  BaseType_t ret;
-  LWIP_ASSERT("mbox != NULL", mbox != NULL);
-  LWIP_ASSERT("mbox->mbx != NULL", mbox->mbx != NULL);
-
-  ret = xQueueSendToBack(mbox->mbx, &msg, portMAX_DELAY);
-  LWIP_ASSERT("mbox post failed", ret == pdTRUE);
-}
-
-err_t
-sys_mbox_trypost(sys_mbox_t *mbox, void *msg)
-{
-  BaseType_t ret;
-  LWIP_ASSERT("mbox != NULL", mbox != NULL);
-  LWIP_ASSERT("mbox->mbx != NULL", mbox->mbx != NULL);
-
-  ret = xQueueSendToBack(mbox->mbx, &msg, 0);
-  if (ret == pdTRUE) {
-    return ERR_OK;
-  } else {
-    LWIP_ASSERT("mbox trypost failed", ret == errQUEUE_FULL);
-    SYS_STATS_INC(mbox.err);
-    return ERR_MEM;
-  }
-}
-
-err_t
-sys_mbox_trypost_fromisr(sys_mbox_t *mbox, void *msg)
-{
-  BaseType_t ret;
-  BaseType_t xHigherPriorityTaskWoken = pdFALSE;
-  LWIP_ASSERT("mbox != NULL", mbox != NULL);
-  LWIP_ASSERT("mbox->mbx != NULL", mbox->mbx != NULL);
-
-  ret = xQueueSendToBackFromISR(mbox->mbx, &msg, &xHigherPriorityTaskWoken);
-  if (ret == pdTRUE) {
-    if (xHigherPriorityTaskWoken == pdTRUE) {
-      return ERR_NEED_SCHED;
-    }
-    return ERR_OK;
-  } else {
-    LWIP_ASSERT("mbox trypost failed", ret == errQUEUE_FULL);
-    SYS_STATS_INC(mbox.err);
-    return ERR_MEM;
-  }
-}
-
-u32_t
-sys_arch_mbox_fetch(sys_mbox_t *mbox, void **msg, u32_t timeout_ms)
-{
-  BaseType_t ret;
-  void *msg_dummy;
-  LWIP_ASSERT("mbox != NULL", mbox != NULL);
-  LWIP_ASSERT("mbox->mbx != NULL", mbox->mbx != NULL);
-
-  if (!msg) {
-    msg = &msg_dummy;
-  }
-
-  if (!timeout_ms) {
-    /* wait infinite */
-    ret = xQueueReceive(mbox->mbx, &(*msg), portMAX_DELAY);
-    LWIP_ASSERT("mbox fetch failed", ret == pdTRUE);
-  } else {
-    TickType_t timeout_ticks = timeout_ms / portTICK_RATE_MS;
-    ret = xQueueReceive(mbox->mbx, &(*msg), timeout_ticks);
-    if (ret == errQUEUE_EMPTY) {
-      /* timed out */
-      *msg = NULL;
-      return SYS_ARCH_TIMEOUT;
-    }
-    LWIP_ASSERT("mbox fetch failed", ret == pdTRUE);
-  }
-
-  /* Old versions of lwIP required us to return the time waited.
-     This is not the case any more. Just returning != SYS_ARCH_TIMEOUT
-     here is enough. */
-  return 1;
-}
-
-u32_t
-sys_arch_mbox_tryfetch(sys_mbox_t *mbox, void **msg)
-{
-  BaseType_t ret;
-  void *msg_dummy;
-  LWIP_ASSERT("mbox != NULL", mbox != NULL);
-  LWIP_ASSERT("mbox->mbx != NULL", mbox->mbx != NULL);
-
-  if (!msg) {
-    msg = &msg_dummy;
-  }
-
-  ret = xQueueReceive(mbox->mbx, &(*msg), 0);
-  if (ret == errQUEUE_EMPTY) {
-    *msg = NULL;
-    return SYS_MBOX_EMPTY;
-  }
-  LWIP_ASSERT("mbox fetch failed", ret == pdTRUE);
-
-  return 0;
-}
-
-void
-sys_mbox_free(sys_mbox_t *mbox)
-{
-  LWIP_ASSERT("mbox != NULL", mbox != NULL);
-  LWIP_ASSERT("mbox->mbx != NULL", mbox->mbx != NULL);
-
-#if LWIP_FREERTOS_CHECK_QUEUE_EMPTY_ON_FREE
-  {
-    UBaseType_t msgs_waiting = uxQueueMessagesWaiting(mbox->mbx);
-    LWIP_ASSERT("mbox quence not empty", msgs_waiting == 0);
-
-    if (msgs_waiting != 0) {
-      SYS_STATS_INC(mbox.err);
-    }
-  }
-#endif
-
-  vQueueDelete(mbox->mbx);
-
-  SYS_STATS_DEC(mbox.used);
-}
-
-sys_thread_t
-sys_thread_new(const char *name, lwip_thread_fn thread, void *arg, int stacksize, int prio)
-{
-  TaskHandle_t rtos_task;
-  BaseType_t ret;
-  sys_thread_t lwip_thread;
-  size_t rtos_stacksize;
-
-  LWIP_ASSERT("invalid stacksize", stacksize > 0);
-#if LWIP_FREERTOS_THREAD_STACKSIZE_IS_STACKWORDS
-  rtos_stacksize = (size_t)stacksize;
-#else
-  rtos_stacksize = (size_t)stacksize / sizeof(StackType_t);
-#endif
-
-  /* lwIP's lwip_thread_fn matches FreeRTOS' TaskFunction_t, so we can pass the
-     thread function without adaption here. */
-  ret = xTaskCreate(thread, name, (configSTACK_DEPTH_TYPE)rtos_stacksize, arg, prio, &rtos_task);
-  LWIP_ASSERT("task creation failed", ret == pdTRUE);
-
-  lwip_thread.thread_handle = rtos_task;
-  return lwip_thread;
-}
-
-#if LWIP_NETCONN_SEM_PER_THREAD
-#if configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0
-
-sys_sem_t *
-sys_arch_netconn_sem_get(void)
-{
-  void* ret;
-  TaskHandle_t task = xTaskGetCurrentTaskHandle();
-  LWIP_ASSERT("task != NULL", task != NULL);
-
-  ret = pvTaskGetThreadLocalStoragePointer(task, 0);
-  return ret;
-}
-
-void
-sys_arch_netconn_sem_alloc(void)
-{
-  void *ret;
-  TaskHandle_t task = xTaskGetCurrentTaskHandle();
-  LWIP_ASSERT("task != NULL", task != NULL);
-
-  ret = pvTaskGetThreadLocalStoragePointer(task, 0);
-  if(ret == NULL) {
-    sys_sem_t *sem;
-    err_t err;
-    /* need to allocate the memory for this semaphore */
-    sem = mem_malloc(sizeof(sys_sem_t));
-    LWIP_ASSERT("sem != NULL", sem != NULL);
-    err = sys_sem_new(sem, 0);
-    LWIP_ASSERT("err == ERR_OK", err == ERR_OK);
-    LWIP_ASSERT("sem invalid", sys_sem_valid(sem));
-    vTaskSetThreadLocalStoragePointer(task, 0, sem);
-  }
-}
-
-void sys_arch_netconn_sem_free(void)
-{
-  void* ret;
-  TaskHandle_t task = xTaskGetCurrentTaskHandle();
-  LWIP_ASSERT("task != NULL", task != NULL);
-
-  ret = pvTaskGetThreadLocalStoragePointer(task, 0);
-  if(ret != NULL) {
-    sys_sem_t *sem = ret;
-    sys_sem_free(sem);
-    mem_free(sem);
-    vTaskSetThreadLocalStoragePointer(task, 0, NULL);
-  }
-}
-
-#else /* configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 */
-#error LWIP_NETCONN_SEM_PER_THREAD needs configNUM_THREAD_LOCAL_STORAGE_POINTERS
-#endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 */
-
-#endif /* LWIP_NETCONN_SEM_PER_THREAD */
-
-#if LWIP_FREERTOS_CHECK_CORE_LOCKING
-#if LWIP_TCPIP_CORE_LOCKING
-
-/** Flag the core lock held. A counter for recursive locks. */
-static u8_t lwip_core_lock_count;
-static TaskHandle_t lwip_core_lock_holder_thread;
-
-void
-sys_lock_tcpip_core(void)
-{
-   sys_mutex_lock(&lock_tcpip_core);
-   if (lwip_core_lock_count == 0) {
-     lwip_core_lock_holder_thread = xTaskGetCurrentTaskHandle();
-   }
-   lwip_core_lock_count++;
-}
-
-void
-sys_unlock_tcpip_core(void)
-{
-   lwip_core_lock_count--;
-   if (lwip_core_lock_count == 0) {
-       lwip_core_lock_holder_thread = 0;
-   }
-   sys_mutex_unlock(&lock_tcpip_core);
-}
-
-#endif /* LWIP_TCPIP_CORE_LOCKING */
-
-#if !NO_SYS
-static TaskHandle_t lwip_tcpip_thread;
-#endif
-
-void
-sys_mark_tcpip_thread(void)
-{
-#if !NO_SYS
-  lwip_tcpip_thread = xTaskGetCurrentTaskHandle();
-#endif
-}
-
-void
-sys_check_core_locking(void)
-{
-  /* Embedded systems should check we are NOT in an interrupt context here */
-  /* E.g. core Cortex-M3/M4 ports:
-         configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
-
-     Instead, we use more generic FreeRTOS functions here, which should fail from ISR: */
-  taskENTER_CRITICAL();
-  taskEXIT_CRITICAL();
-
-#if !NO_SYS
-  if (lwip_tcpip_thread != 0) {
-    TaskHandle_t current_thread = xTaskGetCurrentTaskHandle();
-
-#if LWIP_TCPIP_CORE_LOCKING
-    LWIP_ASSERT("Function called without core lock",
-                current_thread == lwip_core_lock_holder_thread && lwip_core_lock_count > 0);
-#else /* LWIP_TCPIP_CORE_LOCKING */
-    LWIP_ASSERT("Function called from wrong thread", current_thread == lwip_tcpip_thread);
-#endif /* LWIP_TCPIP_CORE_LOCKING */
-  }
-#endif /* !NO_SYS */
-}
-
-#endif /* LWIP_FREERTOS_CHECK_CORE_LOCKING*/
diff --git a/contrib/ports/unix/Common.mk b/contrib/ports/unix/Common.mk
deleted file mode 100644
index f80a9807..00000000
--- a/contrib/ports/unix/Common.mk
+++ /dev/null
@@ -1,51 +0,0 @@
-#
-# Copyright (c) 2001, 2002 Swedish Institute of Computer Science.
-# All rights reserved. 
-# 
-# Redistribution and use in source and binary forms, with or without modification, 
-# are permitted provided that the following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice,
-#    this list of conditions and the following disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright notice,
-#    this list of conditions and the following disclaimer in the documentation
-#    and/or other materials provided with the distribution.
-# 3. The name of the author may not be used to endorse or promote products
-#    derived from this software without specific prior written permission. 
-#
-# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
-# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
-# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
-# SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
-# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
-# OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
-# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
-# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
-# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# This file is part of the lwIP TCP/IP stack.
-# 
-# Author: Adam Dunkels <adam@sics.se>
-#
-
-# Architecture specific files.
-LWIPARCH?=$(CONTRIBDIR)/ports/unix/port
-SYSARCH?=$(LWIPARCH)/sys_arch.c
-ARCHFILES=$(LWIPARCH)/perf.c \
-  $(SYSARCH) \
-	$(LWIPARCH)/netif/tapif.c \
-	$(LWIPARCH)/netif/list.c \
-	$(LWIPARCH)/netif/sio.c \
-	$(LWIPARCH)/netif/fifo.c
-
-UNIX_COMMON_MK_DIR := $(dir $(abspath $(lastword $(MAKEFILE_LIST))))
-include $(UNIX_COMMON_MK_DIR)../Common.allports.mk
-
-LDFLAGS+=-lutil
-
-UNAME_S:= $(shell uname -s)
-ifneq ($(UNAME_S),Darwin)
-# Darwin doesn't have pthreads or POSIX real-time extensions libs
-LDFLAGS+=-pthread -lrt
-endif
diff --git a/contrib/ports/unix/Filelists.cmake b/contrib/ports/unix/Filelists.cmake
deleted file mode 100644
index 84bfdedf..00000000
--- a/contrib/ports/unix/Filelists.cmake
+++ /dev/null
@@ -1,44 +0,0 @@
-# This file is indended to be included in end-user CMakeLists.txt
-# include(/path/to/Filelists.cmake)
-# It assumes the variable LWIP_CONTRIB_DIR is defined pointing to the
-# root path of lwIP/contrib sources.
-#
-# This file is NOT designed (on purpose) to be used as cmake
-# subdir via add_subdirectory()
-# The intention is to provide greater flexibility to users to
-# create their own targets using the *_SRCS variables.
-
-if(NOT ${CMAKE_VERSION} VERSION_LESS "3.10.0")
-    include_guard(GLOBAL)
-endif()
-
-set(lwipcontribportunix_SRCS
-    ${LWIP_CONTRIB_DIR}/ports/unix/port/sys_arch.c
-    ${LWIP_CONTRIB_DIR}/ports/unix/port/perf.c
-)
-
-set(lwipcontribportunixnetifs_SRCS
-    ${LWIP_CONTRIB_DIR}/ports/unix/port/netif/tapif.c
-    ${LWIP_CONTRIB_DIR}/ports/unix/port/netif/list.c
-    ${LWIP_CONTRIB_DIR}/ports/unix/port/netif/sio.c
-    ${LWIP_CONTRIB_DIR}/ports/unix/port/netif/fifo.c
-)
-
-add_library(lwipcontribportunix EXCLUDE_FROM_ALL ${lwipcontribportunix_SRCS} ${lwipcontribportunixnetifs_SRCS})
-target_include_directories(lwipcontribportunix PRIVATE ${LWIP_INCLUDE_DIRS} ${LWIP_MBEDTLS_INCLUDE_DIRS})
-target_compile_options(lwipcontribportunix PRIVATE ${LWIP_COMPILER_FLAGS})
-target_compile_definitions(lwipcontribportunix PRIVATE ${LWIP_DEFINITIONS} ${LWIP_MBEDTLS_DEFINITIONS})
-target_link_libraries(lwipcontribportunix PUBLIC ${LWIP_MBEDTLS_LINK_LIBRARIES})
-
-if (CMAKE_SYSTEM_NAME STREQUAL "Linux")
-    find_library(LIBUTIL util)
-    find_library(LIBPTHREAD pthread)
-    find_library(LIBRT rt)
-    target_link_libraries(lwipcontribportunix PUBLIC ${LIBUTIL} ${LIBPTHREAD} ${LIBRT})
-endif()
-
-if (CMAKE_SYSTEM_NAME STREQUAL "Darwin")
-    # Darwin doesn't have pthreads or POSIX real-time extensions libs
-    find_library(LIBUTIL util)
-    target_link_libraries(lwipcontribportunix PUBLIC ${LIBUTIL})
-endif()
diff --git a/contrib/ports/unix/README b/contrib/ports/unix/README
deleted file mode 100644
index 45d256dc..00000000
--- a/contrib/ports/unix/README
+++ /dev/null
@@ -1,25 +0,0 @@
-This port contains infrastructure and examples for running lwIP on Unix-like
-operating systems (Linux, OpenBSD, cygwin). Much of this is targetted towards
-testing lwIP applications.
-
-* port/sys_arch.c, port/perf.c, port/include/arch/: Generic platform porting,
-  for both states of NO_SYS. (Mapping debugging to printf, providing 
-  sys_now & co from the system time etc.)
-
-* check: Runs the unit tests shipped with main lwIP on the Unix port.
-
-* port/netif, port/include/netif: Various network interface implementations and
-  their helpers, some explicitly for Unix infrastructure, some generic (but most
-  useful on an easy to debug system):
-
-  * fifo: Helper for sio
-
-  * list: Helper for unixif
-
-  * pcapif: Network interface that replays packages from a PCAP dump file, and
-    discards packages sent out from it
-
-  * sio: Mapping Unix character devices to lwIP's sio mechanisms
-
-  * tapif: Network interface that is mapped to a tap interface (Unix user
-    space layer 2 network device). Uses lwIP threads.
diff --git a/contrib/ports/unix/check/CMakeLists.txt b/contrib/ports/unix/check/CMakeLists.txt
deleted file mode 100644
index 68833163..00000000
--- a/contrib/ports/unix/check/CMakeLists.txt
+++ /dev/null
@@ -1,59 +0,0 @@
-cmake_minimum_required(VERSION 3.8)
-
-set (CMAKE_CONFIGURATION_TYPES "Debug;Release")
-
-project(lwipunittests C)
-
-if (NOT CMAKE_SYSTEM_NAME STREQUAL "Linux" AND NOT CMAKE_SYSTEM_NAME STREQUAL "Darwin")
-    message(FATAL_ERROR "Unit test are currently only working on Linux or Darwin")
-endif()
-
-set(LWIP_DIR ${CMAKE_CURRENT_SOURCE_DIR}/../../../..)
-set(LWIP_USE_SANITIZERS true)
-include(${LWIP_DIR}/contrib/ports/CMakeCommon.cmake)
-
-if(CMAKE_C_COMPILER_ID STREQUAL "Clang")
-    # check.h causes 'error: token pasting of ',' and __VA_ARGS__ is a GNU extension' with clang 9.0.0
-    list(LWIP_COMPILER_FLAGS APPEND -Wno-gnu-zero-variadic-macro-arguments)
-endif()
-
-set (LWIP_DEFINITIONS -DLWIP_DEBUG -DLWIP_NOASSERT_ON_ERROR)
-set (LWIP_INCLUDE_DIRS
-    "${LWIP_DIR}/test/unit"
-    "${LWIP_DIR}/src/include"
-    "${LWIP_CONTRIB_DIR}/"
-    "${LWIP_CONTRIB_DIR}/ports/unix/port/include"
-    "${CMAKE_CURRENT_SOURCE_DIR}/"
-)
-
-include(${LWIP_CONTRIB_DIR}/ports/unix/Filelists.cmake)
-include(${LWIP_DIR}/src/Filelists.cmake)
-include(${LWIP_DIR}/test/unit/Filelists.cmake)
-
-add_executable(lwip_unittests ${LWIP_TESTFILES})
-target_include_directories(lwip_unittests PRIVATE ${LWIP_INCLUDE_DIRS})
-target_compile_options(lwip_unittests PRIVATE ${LWIP_COMPILER_FLAGS})
-target_compile_definitions(lwip_unittests PRIVATE ${LWIP_DEFINITIONS} ${LWIP_MBEDTLS_DEFINITIONS})
-
-find_library(LIBCHECK check)
-find_library(LIBM m)
-target_link_libraries(lwip_unittests ${LWIP_SANITIZER_LIBS} lwipallapps lwipcore ${LIBCHECK} ${LIBM})
-
-if (NOT CMAKE_SYSTEM_NAME STREQUAL "Darwin")
-    # check installed via brew on Darwin doesn't have a separate subunit library (must be statically linked)
-    find_library(LIBSUBUNIT subunit)
-    target_link_libraries(lwip_unittests ${LIBSUBUNIT})
-endif()
-
-if (CMAKE_SYSTEM_NAME STREQUAL "Linux")
-    find_library(LIBUTIL util)
-    find_library(LIBPTHREAD pthread)
-    find_library(LIBRT rt)
-    target_link_libraries(lwip_unittests ${LIBUTIL} ${LIBPTHREAD} ${LIBRT})
-endif()
-
-if (CMAKE_SYSTEM_NAME STREQUAL "Darwin")
-    # Darwin doesn't have pthreads or POSIX real-time extensions libs
-    find_library(LIBUTIL util)
-    target_link_libraries(lwip_unittests ${LIBUTIL})
-endif()
diff --git a/contrib/ports/unix/check/Makefile b/contrib/ports/unix/check/Makefile
deleted file mode 100644
index 01a6d05e..00000000
--- a/contrib/ports/unix/check/Makefile
+++ /dev/null
@@ -1,80 +0,0 @@
-#
-# Copyright (c) 2001, 2002 Swedish Institute of Computer Science.
-# All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without modification,
-# are permitted provided that the following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice,
-#    this list of conditions and the following disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright notice,
-#    this list of conditions and the following disclaimer in the documentation
-#    and/or other materials provided with the distribution.
-# 3. The name of the author may not be used to endorse or promote products
-#    derived from this software without specific prior written permission.
-#
-# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
-# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
-# SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
-# OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
-# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
-# OF SUCH DAMAGE.
-#
-# This file is part of the lwIP TCP/IP stack.
-#
-# Author: Adam Dunkels <adam@sics.se>
-#
-
-all compile: lwip_unittests
-.PHONY: all clean check
-
-LWIPDIR=../../../../src
-
-# The include path to sys_arch.h and lwipopts.h must be first, so this must be before Common.mk
-CFLAGS=-DLWIP_NOASSERT_ON_ERROR -I/usr/include/check -I$(LWIPDIR)/../test/unit
-
-ifeq (clang,$(findstring clang,$(CC)))
-# check.h causes 'error: token pasting of ',' and __VA_ARGS__ is a GNU extension' with clang 9.0.0
-CFLAGS+=-Wno-gnu-zero-variadic-macro-arguments
-endif
-
-# Prevent compiling sys_arch.c of unix port because unit test provide their own port
-SYSARCH?=
-include ../Common.mk
-
-LDFLAGS:=-lcheck -lm $(LDFLAGS)
-
-ifneq ($(UNAME_S),Darwin)
-# check installed via brew on Darwin doesn't have a separate subunit library (must be statically linked)
-LDFLAGS+=-lsubunit
-endif
-
-TESTDIR=$(LWIPDIR)/../test/unit
-include $(TESTDIR)/Filelists.mk
-TESTOBJS=$(notdir $(TESTFILES:.c=.o))
-
-clean:
-	@rm -f *.o $(LWIPLIBCOMMON) $(APPLIB) lwip_unittests *.s .depend* *.core core lwip_unittests.xml
-
-depend dep: .depend
-
-include .depend
-
-.depend: $(LWIPFILES) $(APPFILES) $(TESTFILES)
-	$(CCDEP) $(CFLAGS) -MM $^ > .depend || rm -f .depend
-
-ifneq ($(UNAME_S),Darwin)
-# clang on Darwin doesn't support --start-group
-lwip_unittests: .depend $(TESTOBJS) $(LWIPLIBCOMMON) $(APPLIB)
-	$(CC) $(CFLAGS) -o lwip_unittests $(TESTOBJS)  -Wl,--start-group $(LWIPLIBCOMMON) $(APPLIB) $(LDFLAGS) -Wl,--end-group
-else
-lwip_unittests: .depend $(TESTOBJS) $(LWIPLIBCOMMON) $(APPLIB)
-	$(CC) $(CFLAGS) -o lwip_unittests $(TESTOBJS) $(LWIPLIBCOMMON) $(APPLIB) $(LDFLAGS)
-endif
-
-check: lwip_unittests
-	@./lwip_unittests
diff --git a/contrib/ports/unix/check/README b/contrib/ports/unix/check/README
deleted file mode 100644
index 3d678663..00000000
--- a/contrib/ports/unix/check/README
+++ /dev/null
@@ -1,8 +0,0 @@
-
-Helper files to run lwIP unit tests on unix-like systems.
-
-1. Install the check library, through a package manager or from http://check.sourceforge.net/
-2. Put the lwip code in a directory called 'lwip'
-3. Run `make check`
-4. Make sure all tests pass
-
diff --git a/contrib/ports/unix/check/config.h b/contrib/ports/unix/check/config.h
deleted file mode 100644
index 0d84b36a..00000000
--- a/contrib/ports/unix/check/config.h
+++ /dev/null
@@ -1,2 +0,0 @@
-/* Enable this to simplify debugging */
-/* #define LWIP_UNITTESTS_NOFORK */
diff --git a/contrib/ports/unix/example_app/CMakeLists.txt b/contrib/ports/unix/example_app/CMakeLists.txt
deleted file mode 100644
index c5e94309..00000000
--- a/contrib/ports/unix/example_app/CMakeLists.txt
+++ /dev/null
@@ -1,23 +0,0 @@
-include(${LWIP_DIR}/contrib/ports/CMakeCommon.cmake)
-
-set (LWIP_INCLUDE_DIRS
-    "${LWIP_DIR}/src/include"
-    "${LWIP_DIR}/contrib/"
-    "${LWIP_DIR}/contrib/ports/unix/port/include"
-    "${LWIP_DIR}/contrib/examples/example_app"
-)
-
-include(${LWIP_DIR}/src/Filelists.cmake)
-include(${LWIP_DIR}/contrib/Filelists.cmake)
-include(${LWIP_DIR}/contrib/ports/unix/Filelists.cmake)
-
-add_executable(example_app ${LWIP_DIR}/contrib/examples/example_app/test.c default_netif.c)
-target_include_directories(example_app PRIVATE ${LWIP_INCLUDE_DIRS})
-target_compile_options(example_app PRIVATE ${LWIP_COMPILER_FLAGS})
-target_compile_definitions(example_app PRIVATE ${LWIP_DEFINITIONS} ${LWIP_MBEDTLS_DEFINITIONS})
-target_link_libraries(example_app ${LWIP_SANITIZER_LIBS} lwipcontribexamples lwipcontribapps lwipcontribaddons lwipallapps lwipcontribportunix lwipcore lwipmbedtls)
-
-add_executable(makefsdata ${lwipmakefsdata_SRCS})
-target_compile_options(makefsdata PRIVATE ${LWIP_COMPILER_FLAGS})
-target_include_directories(makefsdata PRIVATE ${LWIP_INCLUDE_DIRS})
-target_link_libraries(makefsdata ${LWIP_SANITIZER_LIBS})
diff --git a/contrib/ports/unix/example_app/Makefile b/contrib/ports/unix/example_app/Makefile
deleted file mode 100644
index 38aaba17..00000000
--- a/contrib/ports/unix/example_app/Makefile
+++ /dev/null
@@ -1,60 +0,0 @@
-#
-# Copyright (c) 2001, 2002 Swedish Institute of Computer Science.
-# All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without modification,
-# are permitted provided that the following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice,
-#    this list of conditions and the following disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright notice,
-#    this list of conditions and the following disclaimer in the documentation
-#    and/or other materials provided with the distribution.
-# 3. The name of the author may not be used to endorse or promote products
-#    derived from this software without specific prior written permission.
-#
-# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
-# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
-# SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
-# OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
-# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
-# OF SUCH DAMAGE.
-#
-# This file is part of the lwIP TCP/IP stack.
-#
-# Author: Adam Dunkels <adam@sics.se>
-#
-
-all compile: example_app makefsdata
-.PHONY: all
-
-LWIPDIR=../../../../src
-
-include ../Common.mk
-
-CFLAGS+=-I$(CONTRIBDIR)/examples/example_app
-
-TESTFLAGS?=
-CFLAGS+=$(TESTFLAGS)
-
-MAKEFSDATAOBJS=$(notdir $(MAKEFSDATAFILES:.c=.o))
-
-clean:
-	rm -f *.o $(LWIPLIBCOMMON) $(APPLIB) example_app makefsdata *.s .depend* *.core core
-
-depend dep: .depend
-
-include .depend
-
-.depend: $(CONTRIBDIR)/examples/example_app/test.c default_netif.c $(LWIPFILES) $(APPFILES) $(MAKEFSDATAFILES)
-	$(CCDEP) $(CFLAGS) -MM $^ > .depend || rm -f .depend
-
-example_app: .depend $(LWIPLIBCOMMON) $(APPLIB) default_netif.o test.o
-	$(CC) $(CFLAGS) -o example_app test.o default_netif.o -Wl,--start-group $(APPLIB) $(LWIPLIBCOMMON) -Wl,--end-group $(LDFLAGS)
-
-makefsdata: .depend $(MAKEFSDATAOBJS)
-	$(CC) $(CFLAGS) -o makefsdata $(MAKEFSDATAOBJS)
diff --git a/contrib/ports/unix/example_app/default_netif.c b/contrib/ports/unix/example_app/default_netif.c
deleted file mode 100644
index 4c7eb6a4..00000000
--- a/contrib/ports/unix/example_app/default_netif.c
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-
-#include "lwip/opt.h"
-
-#include "lwip/netif.h"
-#include "lwip/ip_addr.h"
-#include "lwip/tcpip.h"
-#include "netif/tapif.h"
-#include "examples/example_app/default_netif.h"
-
-static struct netif netif;
-
-#if LWIP_IPV4
-#define NETIF_ADDRS ipaddr, netmask, gw,
-void init_default_netif(const ip4_addr_t *ipaddr, const ip4_addr_t *netmask, const ip4_addr_t *gw)
-#else
-#define NETIF_ADDRS
-void init_default_netif(void)
-#endif
-{
-#if NO_SYS
-netif_add(&netif, NETIF_ADDRS NULL, tapif_init, netif_input);
-#else
-  netif_add(&netif, NETIF_ADDRS NULL, tapif_init, tcpip_input);
-#endif
-  netif_set_default(&netif);
-}
-
-void
-default_netif_poll(void)
-{
-  tapif_poll(&netif);
-}
-
-void
-default_netif_shutdown(void)
-{
-}
diff --git a/contrib/ports/unix/example_app/iteropts.sh b/contrib/ports/unix/example_app/iteropts.sh
deleted file mode 100755
index 05ec0314..00000000
--- a/contrib/ports/unix/example_app/iteropts.sh
+++ /dev/null
@@ -1,34 +0,0 @@
-#!/bin/bash
-
-LOGFILE=iteropts.log
-EXAPPDIR=../../../examples/example_app
-RETVAL=0
-
-pushd `dirname "$0"`
-pwd
-echo Starting Iteropts run >> $LOGFILE
-for f in $EXAPPDIR/test_configs/*.h
-do
-    echo Cleaning...
-    make clean > /dev/null
-    BUILDLOG=$(basename "$f" ".h").log
-    echo testing $f
-    echo testing $f >> $LOGFILE
-    rm $EXAPPDIR/lwipopts_test.h
-    # cat the file to update its timestamp
-    cat $f > $EXAPPDIR/lwipopts_test.h
-    make TESTFLAGS="-DLWIP_OPTTEST_FILE -Wno-documentation" -j 4 1> $BUILDLOG 2>&1
-    ERR=$?
-    if [ $ERR != 0 ]; then
-        cat $BUILDLOG
-        echo file $f failed with $ERR >> $LOGFILE
-        echo ++++++++ $f FAILED +++++++
-        RETVAL=1
-    fi
-    echo test $f done >> $LOGFILE
-done
-echo done, cleaning
-make clean > /dev/null
-popd
-echo Exit value: $RETVAL
-exit $RETVAL
diff --git a/contrib/ports/unix/lib/CMakeLists.txt b/contrib/ports/unix/lib/CMakeLists.txt
deleted file mode 100644
index 93d17bd0..00000000
--- a/contrib/ports/unix/lib/CMakeLists.txt
+++ /dev/null
@@ -1,32 +0,0 @@
-cmake_minimum_required(VERSION 3.8)
-
-project(lwip C)
-
-set (BUILD_SHARED_LIBS ON)
-
-if (NOT CMAKE_SYSTEM_NAME STREQUAL "Linux" AND NOT CMAKE_SYSTEM_NAME STREQUAL "GNU")
-    message(FATAL_ERROR "Lwip shared library is only working on Linux or the Hurd")
-endif()
-
-set(LWIP_DIR ${CMAKE_CURRENT_SOURCE_DIR}/../../../..)
-include(${LWIP_DIR}/contrib/ports/CMakeCommon.cmake)
-
-set (LWIP_DEFINITIONS -DLWIP_DEBUG)
-set (LWIP_INCLUDE_DIRS
-    "${LWIP_DIR}/src/include"
-    "${LWIP_CONTRIB_DIR}/"
-    "${LWIP_CONTRIB_DIR}/ports/unix/port/include"
-    "${CMAKE_CURRENT_SOURCE_DIR}/"
-)
-
-include(${LWIP_CONTRIB_DIR}/ports/unix/Filelists.cmake)
-include(${LWIP_DIR}/src/Filelists.cmake)
-
-add_library(lwip ${lwipnoapps_SRCS} ${lwipcontribportunix_SRCS} ${lwipcontribportunixnetifs_SRCS})
-target_compile_options(lwip PRIVATE ${LWIP_COMPILER_FLAGS})
-target_compile_definitions(lwip PRIVATE ${LWIP_DEFINITIONS} ${LWIP_MBEDTLS_DEFINITIONS})
-target_include_directories(lwip PRIVATE ${LWIP_INCLUDE_DIRS} ${LWIP_MBEDTLS_INCLUDE_DIRS})
-target_link_libraries(lwip ${LWIP_SANITIZER_LIBS})
-
-find_library(LIBPTHREAD pthread)
-target_link_libraries(lwip ${LIBPTHREAD})
diff --git a/contrib/ports/unix/lib/README b/contrib/ports/unix/lib/README
deleted file mode 100644
index 3e6d0b1a..00000000
--- a/contrib/ports/unix/lib/README
+++ /dev/null
@@ -1,28 +0,0 @@
-This directory contains an example of how to compile lwIP as a shared library
-on Linux.
-
-Some brief instructions:
-
-* Compile the code:
-
- > mkdir build
- > cd build
- > cmake ..
- > make clean all
-
- This should produce liblwip.so. This is the shared library.
-
-* Link an application against the shared library
-
- If you're using gcc you can do this by including -llwip in your link command.
-
-* Run your application
-
- Ensure that LD_LIBRARY_PATH includes the directory that contains liblwip.so
- (ie. this directory)
-
-
-If you are unsure about shared libraries and libraries on linux in
-general, you might find this HOWTO useful:
-
-<http://www.tldp.org/HOWTO/Program-Library-HOWTO/>
diff --git a/contrib/ports/unix/lib/lwipopts.h b/contrib/ports/unix/lib/lwipopts.h
deleted file mode 100644
index 660f7f70..00000000
--- a/contrib/ports/unix/lib/lwipopts.h
+++ /dev/null
@@ -1,445 +0,0 @@
-/**
- * @file
- *
- * lwIP Options Configuration
- */
-
-/*
- * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-#ifndef LWIP_LWIPOPTS_H
-#define LWIP_LWIPOPTS_H
-
-/*
- * Include user defined options first. Anything not defined in these files
- * will be set to standard values. Override anything you dont like!
- */
-#include "lwipopts.h"
-#include "lwip/debug.h"
-
-/*
-   -----------------------------------------------
-   ---------- Platform specific locking ----------
-   -----------------------------------------------
-*/
-
-/**
- * SYS_LIGHTWEIGHT_PROT==1: if you want inter-task protection for certain
- * critical regions during buffer allocation, deallocation and memory
- * allocation and deallocation.
- */
-#define SYS_LIGHTWEIGHT_PROT            0
-
-/**
- * NO_SYS==1: Provides VERY minimal functionality. Otherwise,
- * use lwIP facilities.
- */
-#define NO_SYS                          0
-
-/*
-   ------------------------------------
-   ---------- Memory options ----------
-   ------------------------------------
-*/
-
-/**
- * MEM_ALIGNMENT: should be set to the alignment of the CPU
- *    4 byte alignment -> #define MEM_ALIGNMENT 4
- *    2 byte alignment -> #define MEM_ALIGNMENT 2
- */
-#define MEM_ALIGNMENT                   1U
-
-/**
- * MEM_SIZE: the size of the heap memory. If the application will send
- * a lot of data that needs to be copied, this should be set high.
- */
-#define MEM_SIZE                        1600
-
-/*
-   ------------------------------------------------
-   ---------- Internal Memory Pool Sizes ----------
-   ------------------------------------------------
-*/
-/**
- * MEMP_NUM_PBUF: the number of memp struct pbufs (used for PBUF_ROM and PBUF_REF).
- * If the application sends a lot of data out of ROM (or other static memory),
- * this should be set high.
- */
-#define MEMP_NUM_PBUF                   16
-
-/**
- * MEMP_NUM_RAW_PCB: Number of raw connection PCBs
- * (requires the LWIP_RAW option)
- */
-#define MEMP_NUM_RAW_PCB                4
-
-/**
- * MEMP_NUM_UDP_PCB: the number of UDP protocol control blocks. One
- * per active UDP "connection".
- * (requires the LWIP_UDP option)
- */
-#define MEMP_NUM_UDP_PCB                4
-
-/**
- * MEMP_NUM_TCP_PCB: the number of simulatenously active TCP connections.
- * (requires the LWIP_TCP option)
- */
-#define MEMP_NUM_TCP_PCB                4
-
-/**
- * MEMP_NUM_TCP_PCB_LISTEN: the number of listening TCP connections.
- * (requires the LWIP_TCP option)
- */
-#define MEMP_NUM_TCP_PCB_LISTEN         4
-
-/**
- * MEMP_NUM_TCP_SEG: the number of simultaneously queued TCP segments.
- * (requires the LWIP_TCP option)
- */
-#define MEMP_NUM_TCP_SEG                16
-
-/**
- * MEMP_NUM_REASSDATA: the number of simultaneously IP packets queued for
- * reassembly (whole packets, not fragments!)
- */
-#define MEMP_NUM_REASSDATA              1
-
-/**
- * MEMP_NUM_ARP_QUEUE: the number of simulateously queued outgoing
- * packets (pbufs) that are waiting for an ARP request (to resolve
- * their destination address) to finish.
- * (requires the ARP_QUEUEING option)
- */
-#define MEMP_NUM_ARP_QUEUE              2
-
-/**
- * MEMP_NUM_SYS_TIMEOUT: the number of simulateously active timeouts.
- * (requires NO_SYS==0)
- */
-#define MEMP_NUM_SYS_TIMEOUT            8
-
-/**
- * MEMP_NUM_NETBUF: the number of struct netbufs.
- * (only needed if you use the sequential API, like api_lib.c)
- */
-#define MEMP_NUM_NETBUF                 2
-
-/**
- * MEMP_NUM_NETCONN: the number of struct netconns.
- * (only needed if you use the sequential API, like api_lib.c)
- */
-#define MEMP_NUM_NETCONN               32
-
-/**
- * MEMP_NUM_TCPIP_MSG_API: the number of struct tcpip_msg, which are used
- * for callback/timeout API communication.
- * (only needed if you use tcpip.c)
- */
-#define MEMP_NUM_TCPIP_MSG_API          8
-
-/**
- * MEMP_NUM_TCPIP_MSG_INPKT: the number of struct tcpip_msg, which are used
- * for incoming packets.
- * (only needed if you use tcpip.c)
- */
-#define MEMP_NUM_TCPIP_MSG_INPKT        8
-
-/**
- * PBUF_POOL_SIZE: the number of buffers in the pbuf pool.
- */
-#define PBUF_POOL_SIZE                  8
-
-/*
-   ---------------------------------
-   ---------- ARP options ----------
-   ---------------------------------
-*/
-/**
- * LWIP_ARP==1: Enable ARP functionality.
- */
-#define LWIP_ARP                        1
-
-/*
-   --------------------------------
-   ---------- IP options ----------
-   --------------------------------
-*/
-/**
- * IP_FORWARD==1: Enables the ability to forward IP packets across network
- * interfaces. If you are going to run lwIP on a device with only one network
- * interface, define this to 0.
- */
-#define IP_FORWARD                      0
-
-/**
- * IP_OPTIONS: Defines the behavior for IP options.
- *      IP_OPTIONS_ALLOWED==0: All packets with IP options are dropped.
- *      IP_OPTIONS_ALLOWED==1: IP options are allowed (but not parsed).
- */
-#define IP_OPTIONS_ALLOWED              1
-
-/**
- * IP_REASSEMBLY==1: Reassemble incoming fragmented IP packets. Note that
- * this option does not affect outgoing packet sizes, which can be controlled
- * via IP_FRAG.
- */
-#define IP_REASSEMBLY                   1
-
-/**
- * IP_FRAG==1: Fragment outgoing IP packets if their size exceeds MTU. Note
- * that this option does not affect incoming packet sizes, which can be
- * controlled via IP_REASSEMBLY.
- */
-#define IP_FRAG                         1
-
-/**
- * IP_REASS_MAXAGE: Maximum time (in multiples of IP_TMR_INTERVAL - so seconds, normally)
- * a fragmented IP packet waits for all fragments to arrive. If not all fragments arrived
- * in this time, the whole packet is discarded.
- */
-#define IP_REASS_MAXAGE                 3
-
-/**
- * IP_REASS_MAX_PBUFS: Total maximum amount of pbufs waiting to be reassembled.
- * Since the received pbufs are enqueued, be sure to configure
- * PBUF_POOL_SIZE > IP_REASS_MAX_PBUFS so that the stack is still able to receive
- * packets even if the maximum amount of fragments is enqueued for reassembly!
- */
-#define IP_REASS_MAX_PBUFS              4
-
-/**
- * IP_FRAG_USES_STATIC_BUF==1: Use a static MTU-sized buffer for IP
- * fragmentation. Otherwise pbufs are allocated and reference the original
-    * packet data to be fragmented.
-*/
-#define IP_FRAG_USES_STATIC_BUF         0
-
-/**
- * IP_DEFAULT_TTL: Default value for Time-To-Live used by transport layers.
- */
-#define IP_DEFAULT_TTL                  255
-
-/*
-   ----------------------------------
-   ---------- ICMP options ----------
-   ----------------------------------
-*/
-/**
- * LWIP_ICMP==1: Enable ICMP module inside the IP stack.
- * Be careful, disable that make your product non-compliant to RFC1122
- */
-#define LWIP_ICMP                       1
-
-/*
-   ---------------------------------
-   ---------- RAW options ----------
-   ---------------------------------
-*/
-/**
- * LWIP_RAW==1: Enable application layer to hook into the IP layer itself.
- */
-#define LWIP_RAW                        1
-
-/*
-   ----------------------------------
-   ---------- DHCP options ----------
-   ----------------------------------
-*/
-/**
- * LWIP_DHCP==1: Enable DHCP module.
- */
-#define LWIP_DHCP                       0
-
-
-/*
-   ------------------------------------
-   ---------- AUTOIP options ----------
-   ------------------------------------
-*/
-/**
- * LWIP_AUTOIP==1: Enable AUTOIP module.
- */
-#define LWIP_AUTOIP                     0
-
-/*
-   ----------------------------------
-   ---------- SNMP options ----------
-   ----------------------------------
-*/
-/**
- * LWIP_SNMP==1: Turn on SNMP module. UDP must be available for SNMP
- * transport.
- */
-#define LWIP_SNMP                       0
-
-/*
-   ----------------------------------
-   ---------- IGMP options ----------
-   ----------------------------------
-*/
-/**
- * LWIP_IGMP==1: Turn on IGMP module.
- */
-#define LWIP_IGMP                       0
-
-/*
-   ----------------------------------
-   ---------- DNS options -----------
-   ----------------------------------
-*/
-/**
- * LWIP_DNS==1: Turn on DNS module. UDP must be available for DNS
- * transport.
- */
-#define LWIP_DNS                        0
-
-/*
-   ---------------------------------
-   ---------- UDP options ----------
-   ---------------------------------
-*/
-/**
- * LWIP_UDP==1: Turn on UDP.
- */
-#define LWIP_UDP                        1
-
-/*
-   ---------------------------------
-   ---------- TCP options ----------
-   ---------------------------------
-*/
-/**
- * LWIP_TCP==1: Turn on TCP.
- */
-#define LWIP_TCP                        1
-
-#define LWIP_LISTEN_BACKLOG             0
-
-/*
-   ----------------------------------
-   ---------- Pbuf options ----------
-   ----------------------------------
-*/
-/**
- * PBUF_LINK_HLEN: the number of bytes that should be allocated for a
- * link level header. The default is 14, the standard value for
- * Ethernet.
- */
-#define PBUF_LINK_HLEN                  16
-
-/**
- * PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. The default is
- * designed to accomodate single full size TCP frame in one pbuf, including
- * TCP_MSS, IP header, and link header.
-*
- */
-#define PBUF_POOL_BUFSIZE               LWIP_MEM_ALIGN_SIZE(TCP_MSS+40+PBUF_LINK_HLEN)
-
-/*
-   ------------------------------------
-   ---------- LOOPIF options ----------
-   ------------------------------------
-*/
-/**
- * LWIP_HAVE_LOOPIF==1: Support loop interface (127.0.0.1) and loopif.c
- */
-#define LWIP_HAVE_LOOPIF                0
-
-/*
-   ----------------------------------------------
-   ---------- Sequential layer options ----------
-   ----------------------------------------------
-*/
-
-/**
- * LWIP_NETCONN==1: Enable Netconn API (require to use api_lib.c)
- */
-#define LWIP_NETCONN                    1
-
-/*
-   ------------------------------------
-   ---------- Socket options ----------
-   ------------------------------------
-*/
-/**
- * LWIP_SOCKET==1: Enable Socket API (require to use sockets.c)
- */
-#define LWIP_SOCKET                     1
-
-/**
- * SO_REUSE==1: Enable SO_REUSEADDR
- */
-#define SO_REUSE                        1
-
-/*
-   ----------------------------------------
-   ---------- Statistics options ----------
-   ----------------------------------------
-*/
-/**
- * LWIP_STATS==1: Enable statistics collection in lwip_stats.
- */
-#define LWIP_STATS                      0
-/*
-   ---------------------------------
-   ---------- PPP options ----------
-   ---------------------------------
-*/
-/**
- * PPP_SUPPORT==1: Enable PPP.
- */
-#define PPP_SUPPORT                     0
-
-
-
-/*
-   ---------------------------------------
-   ---------- Threading options ----------
-   ---------------------------------------
-*/
-
-#define LWIP_TCPIP_CORE_LOCKING    1
-
-#if !NO_SYS
-void sys_check_core_locking(void);
-#define LWIP_ASSERT_CORE_LOCKED()  sys_check_core_locking()
-void sys_mark_tcpip_thread(void);
-#define LWIP_MARK_TCPIP_THREAD()   sys_mark_tcpip_thread()
-
-#if LWIP_TCPIP_CORE_LOCKING
-void sys_lock_tcpip_core(void);
-#define LOCK_TCPIP_CORE()          sys_lock_tcpip_core()
-void sys_unlock_tcpip_core(void);
-#define UNLOCK_TCPIP_CORE()        sys_unlock_tcpip_core()
-#endif
-#endif
-
-#endif /* LWIP_LWIPOPTS_H */
diff --git a/contrib/ports/unix/port/include/arch/cc.h b/contrib/ports/unix/port/include/arch/cc.h
deleted file mode 100644
index 3c44a099..00000000
--- a/contrib/ports/unix/port/include/arch/cc.h
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-#ifndef LWIP_ARCH_CC_H
-#define LWIP_ARCH_CC_H
-
-/* see https://sourceforge.net/p/predef/wiki/OperatingSystems/ */
-#if defined __ANDROID__
-#define LWIP_UNIX_ANDROID
-#elif defined __linux__
-#define LWIP_UNIX_LINUX
-#elif defined __APPLE__
-#define LWIP_UNIX_MACH
-#elif defined __OpenBSD__
-#define LWIP_UNIX_OPENBSD
-#elif defined __CYGWIN__
-#define LWIP_UNIX_CYGWIN
-#elif defined __GNU__
-#define LWIP_UNIX_HURD
-#endif
-
-#define LWIP_TIMEVAL_PRIVATE 0
-#include <sys/time.h>
-
-#define LWIP_ERRNO_INCLUDE <errno.h>
-
-#if defined(LWIP_UNIX_LINUX) || defined(LWIP_UNIX_HURD)
-#define LWIP_ERRNO_STDINCLUDE	1
-#endif
-
-extern unsigned int lwip_port_rand(void);
-#define LWIP_RAND() (lwip_port_rand())
-
-/* different handling for unit test, normally not needed */
-#ifdef LWIP_NOASSERT_ON_ERROR
-#define LWIP_ERROR(message, expression, handler) do { if (!(expression)) { \
-  handler;}} while(0)
-#endif
-
-#if defined(LWIP_UNIX_ANDROID) && defined(FD_SET)
-typedef __kernel_fd_set fd_set;
-#endif
-
-#if defined(LWIP_UNIX_MACH)
-/* sys/types.h and signal.h bring in Darwin byte order macros. pull the
-   header here and disable LwIP's version so that apps still can get
-   the macros via LwIP headers and use system headers */
-#include <sys/types.h>
-#define LWIP_DONT_PROVIDE_BYTEORDER_FUNCTIONS
-#endif
-
-struct sio_status_s;
-typedef struct sio_status_s sio_status_t;
-#define sio_fd_t sio_status_t*
-#define __sio_fd_t_defined
-
-typedef unsigned int sys_prot_t;
-
-#endif /* LWIP_ARCH_CC_H */
diff --git a/contrib/ports/unix/port/include/arch/perf.h b/contrib/ports/unix/port/include/arch/perf.h
deleted file mode 100644
index 364f3164..00000000
--- a/contrib/ports/unix/port/include/arch/perf.h
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-#ifndef LWIP_ARCH_PERF_H
-#define LWIP_ARCH_PERF_H
-
-#include <sys/times.h>
-
-#ifdef PERF
-#define PERF_START  { \
-                         unsigned long __c1l, __c1h, __c2l, __c2h; \
-                         __asm__(".byte 0x0f, 0x31" : "=a" (__c1l), "=d" (__c1h))
-#define PERF_STOP(x)   __asm__(".byte 0x0f, 0x31" : "=a" (__c2l), "=d" (__c2h)); \
-                       perf_print(__c1l, __c1h, __c2l, __c2h, x);}
-
-/*#define PERF_START do { \
-                     struct tms __perf_start, __perf_end; \
-                     times(&__perf_start)
-#define PERF_STOP(x) times(&__perf_end); \
-                     perf_print_times(&__perf_start, &__perf_end, x);\
-                     } while(0)*/
-#else /* PERF */
-#define PERF_START    /* null definition */
-#define PERF_STOP(x)  /* null definition */
-#endif /* PERF */
-
-void perf_print(unsigned long c1l, unsigned long c1h,
-		unsigned long c2l, unsigned long c2h,
-		char *key);
-
-void perf_print_times(struct tms *start, struct tms *end, char *key);
-
-void perf_init(char *fname);
-
-#endif /* LWIP_ARCH_PERF_H */
diff --git a/contrib/ports/unix/port/include/arch/sys_arch.h b/contrib/ports/unix/port/include/arch/sys_arch.h
deleted file mode 100644
index 416b716c..00000000
--- a/contrib/ports/unix/port/include/arch/sys_arch.h
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-#ifndef LWIP_ARCH_SYS_ARCH_H
-#define LWIP_ARCH_SYS_ARCH_H
-
-#define SYS_MBOX_NULL NULL
-#define SYS_SEM_NULL  NULL
-
-/*typedef u32_t sys_prot_t;*/
-
-struct sys_sem;
-typedef struct sys_sem * sys_sem_t;
-#define sys_sem_valid(sem)             (((sem) != NULL) && (*(sem) != NULL))
-#define sys_sem_valid_val(sem)         ((sem) != NULL)
-#define sys_sem_set_invalid(sem)       do { if((sem) != NULL) { *(sem) = NULL; }}while(0)
-#define sys_sem_set_invalid_val(sem)   do { (sem) = NULL; }while(0)
-
-struct sys_mutex;
-typedef struct sys_mutex * sys_mutex_t;
-#define sys_mutex_valid(mutex)         sys_sem_valid(mutex)
-#define sys_mutex_set_invalid(mutex)   sys_sem_set_invalid(mutex)
-
-struct sys_mbox;
-typedef struct sys_mbox * sys_mbox_t;
-#define sys_mbox_valid(mbox)           sys_sem_valid(mbox)
-#define sys_mbox_valid_val(mbox)       sys_sem_valid_val(mbox)
-#define sys_mbox_set_invalid(mbox)     sys_sem_set_invalid(mbox)
-#define sys_mbox_set_invalid_val(mbox) sys_sem_set_invalid_val(mbox)
-
-struct sys_thread;
-typedef struct sys_thread * sys_thread_t;
-
-#define LWIP_EXAMPLE_APP_ABORT() lwip_unix_keypressed()
-int lwip_unix_keypressed(void);
-
-#endif /* LWIP_ARCH_SYS_ARCH_H */
diff --git a/contrib/ports/unix/port/include/netif/fifo.h b/contrib/ports/unix/port/include/netif/fifo.h
deleted file mode 100644
index 6c2ad207..00000000
--- a/contrib/ports/unix/port/include/netif/fifo.h
+++ /dev/null
@@ -1,54 +0,0 @@
-#ifndef FIFO_H
-#define FIFO_H
-
-#include "lwip/sys.h"
-
-/** How many bytes in fifo */
-#define FIFOSIZE 2048
-
-/** fifo data structure, this one is passed to all fifo functions */
-typedef struct fifo_t {
-  u8_t data[FIFOSIZE+10]; /* data segment, +10 is a hack probably not needed.. FIXME! */
-  int dataslot;			  /* index to next char to be read */
-  int emptyslot;		  /* index to next empty slot */
-  int len;				  /* len probably not needed, may be calculated from dataslot and emptyslot in conjunction with FIFOSIZE */
-
-  sys_sem_t sem;		/* semaphore protecting simultaneous data manipulation */
-  sys_sem_t getSem;		/* sepaphore used to signal new data if getWaiting is set */
-  u8_t getWaiting;		/* flag used to indicate that fifoget is waiting for data. fifoput is suposed to clear */
-  						/* this flag prior to signaling the getSem semaphore */
-} fifo_t;
-
-
-/**
-*   Get a character from fifo
-*   Blocking call.
-*	@param 	fifo pointer to fifo data structure
-*	@return	character read from fifo
-*/
-u8_t fifoGet(fifo_t * fifo);
-
-/**
-*   Get a character from fifo
-*   Non blocking call.
-*	@param 	fifo pointer to fifo data structure
-*	@return	character read from fifo, or < zero if non was available
-*/
-s16_t fifoGetNonBlock(fifo_t * fifo);
-
-/**
-*	fifoput is called by the signalhandler when new data has arrived (or some other event is indicated)
-*   fifoput reads directly from the serialport and is thus highly dependent on unix arch at this moment
-*	@param 	fifo pointer to fifo data structure
-*	@param	fd	unix file descriptor
-*/
-void fifoPut(fifo_t * fifo, int fd);
-
-/**
-*   fifoinit initiate fifo
-*	@param 	fifo	pointer to fifo data structure, allocated by the user
-*/
-void fifoInit(fifo_t * fifo);
-
-#endif
-
diff --git a/contrib/ports/unix/port/include/netif/list.h b/contrib/ports/unix/port/include/netif/list.h
deleted file mode 100644
index 2c4d142a..00000000
--- a/contrib/ports/unix/port/include/netif/list.h
+++ /dev/null
@@ -1,26 +0,0 @@
-
-#ifndef LWIP_LIST_H
-#define LWIP_LIST_H
-
-struct elem;
-
-struct list {
-  struct elem *first, *last;
-  int size, elems;
-};
-
-struct elem {
-  struct elem *next;
-  void *data;
-};
-
-struct list *list_new(int size);
-int list_push(struct list *list, void *data);
-void *list_pop(struct list *list);
-void *list_first(struct list *list);
-int list_elems(struct list *list);
-void list_delete(struct list *list);
-int list_remove(struct list *list, void *elem);
-void list_map(struct list *list, void (* func)(void *arg));
-
-#endif
diff --git a/contrib/ports/unix/port/include/netif/pcapif.h b/contrib/ports/unix/port/include/netif/pcapif.h
deleted file mode 100644
index ef7abd5f..00000000
--- a/contrib/ports/unix/port/include/netif/pcapif.h
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
- * All rights reserved. 
- * 
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-#ifndef LWIP_PCAPIF_H
-#define LWIP_PCAPIF_H
-
-#include "lwip/netif.h"
-
-err_t pcapif_init(struct netif *netif);
-
-#endif /* LWIP_PCAPIF_H */
diff --git a/contrib/ports/unix/port/include/netif/sio.h b/contrib/ports/unix/port/include/netif/sio.h
deleted file mode 100644
index 4822b536..00000000
--- a/contrib/ports/unix/port/include/netif/sio.h
+++ /dev/null
@@ -1,60 +0,0 @@
-#ifndef SIO_UNIX_H
-#define SIO_UNIX_H
-
-#include "lwip/sys.h"
-#include "lwip/netif.h"
-#include "netif/fifo.h"
-/*#include "netif/pppif.h"*/
-
-struct sio_status_s {
-	int fd;
-	fifo_t myfifo;
-};
-
-/* BAUDRATE is defined in sio.c as it is implementation specific */
-/** Baudrates */
-typedef enum sioBaudrates {
-	SIO_BAUD_9600,
-	SIO_BAUD_19200,
-	SIO_BAUD_38400,
-	SIO_BAUD_57600,	
-	SIO_BAUD_115200	
-} sioBaudrates;
-
-/**
-* Poll for a new character from incoming data stream
-* @param 	siostat siostatus struct, contains sio instance data, given by sio_open
-* @return 	char read from input stream, or < 0 if no char was available
-*/
-s16_t sio_poll(sio_status_t * siostat);
-
-/**
-*	Parse incoming characters until a string str is recieved, blocking call
-* @param	str		zero terminated string to expect
-* @param 	siostat siostatus struct, contains sio instance data, given by sio_open
-*/
-void sio_expect_string(u8_t *str, sio_status_t * siostat);
-
-/**
-* Write a char to output data stream
-* @param 	str		pointer to a zero terminated string
-* @param	siostat siostatus struct, contains sio instance data, given by sio_open
-*/
-void sio_send_string(u8_t *str, sio_status_t * siostat);
-
-/**
-*	Flush outbuffer (send everything in buffer now), useful if some layer below is 
-*	holding on to data, waitng to fill a buffer
-* @param 	siostat siostatus struct, contains sio instance data, given by sio_open
-*/
-void sio_flush( sio_status_t * siostat );
-
-/**
-*	Change baudrate of port, may close and reopen port
-* @param 	baud	new baudrate
-* @param 	siostat siostatus struct, contains sio instance data, given by sio_open
-*/
-void sio_change_baud( sioBaudrates baud, sio_status_t * siostat );
-
-#endif
-
diff --git a/contrib/ports/unix/port/include/netif/tapif.h b/contrib/ports/unix/port/include/netif/tapif.h
deleted file mode 100644
index 4c0fa6b3..00000000
--- a/contrib/ports/unix/port/include/netif/tapif.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-#ifndef LWIP_TAPIF_H
-#define LWIP_TAPIF_H
-
-#include "lwip/netif.h"
-
-err_t tapif_init(struct netif *netif);
-void tapif_poll(struct netif *netif);
-#if NO_SYS
-int tapif_select(struct netif *netif);
-#endif /* NO_SYS */
-
-#endif /* LWIP_TAPIF_H */
diff --git a/contrib/ports/unix/port/netif/fifo.c b/contrib/ports/unix/port/netif/fifo.c
deleted file mode 100644
index 350d3eae..00000000
--- a/contrib/ports/unix/port/netif/fifo.c
+++ /dev/null
@@ -1,139 +0,0 @@
-/* Author: Magnus Ivarsson <magnus.ivarsson@volvo.com> */
-
-/* ---------------------------------------------- */
-/* --- fifo 4 unix ------------------------------ */
-/* ---------------------------------------------- */
-#include "lwip/err.h"
-#include "netif/fifo.h"
-#include "lwip/debug.h"
-#include "lwip/def.h"
-#include "lwip/sys.h"
-#include "lwip/arch.h"
-#include <unistd.h>
-
-#ifndef TRUE
-#define TRUE  1
-#endif
-#ifndef FALSE
-#define FALSE 0
-#endif
-
-#ifndef SIO_FIFO_DEBUG
-#define SIO_FIFO_DEBUG LWIP_DBG_OFF
-#endif
-
-u8_t fifoGet(fifo_t * fifo)
-{
-	u8_t c;
-
-	sys_sem_wait(&fifo->sem);      /* enter critical section */
-
-	if (fifo->dataslot == fifo->emptyslot)
-	{
-            fifo->getWaiting = TRUE;    /* tell putFifo to signal us when data is available */
-            sys_sem_signal(&fifo->sem);  /* leave critical section (allow input from serial port..) */
-            sys_sem_wait(&fifo->getSem); /* wait 4 data */
-            sys_sem_wait(&fifo->sem);    /* reenter critical section */
-	}
-
-	c = fifo->data[fifo->dataslot++];
-	fifo->len--;
-
-	if (fifo->dataslot == FIFOSIZE)
-	{
-		fifo->dataslot = 0;
-	}
-	sys_sem_signal(&fifo->sem);    /* leave critical section */
-	return c;
-}
-
-
-s16_t fifoGetNonBlock(fifo_t * fifo)
-{
-	u16_t c;
-
-	sys_sem_wait(&fifo->sem);      /* enter critical section */
-
-	if (fifo->dataslot == fifo->emptyslot)
-	{
-            /* empty fifo */
-		c = -1;
-	}
-	else
-	{
-		c = fifo->data[fifo->dataslot++];
-		fifo->len--;
-
-		if (fifo->dataslot == FIFOSIZE)
-		{
-			fifo->dataslot = 0;
-		}
-	}
-	sys_sem_signal(&fifo->sem);    /* leave critical section */
-	return c;
-}
-
-
-void fifoPut(fifo_t * fifo, int fd)
-{
-	/* FIXME: mutex around struct data.. */
-	int cnt=0;
-
-	sys_sem_wait(&fifo->sem ); /* enter critical */
-
-	LWIP_DEBUGF( SIO_FIFO_DEBUG,("fifoput: len%d dat%d empt%d --> ", fifo->len, fifo->dataslot, fifo->emptyslot ) );
-
-	if ( fifo->emptyslot < fifo->dataslot )
-	{
-		cnt = read( fd, &fifo->data[fifo->emptyslot], fifo->dataslot - fifo->emptyslot );
-	}
-	else
-	{
-		cnt = read( fd, &fifo->data[fifo->emptyslot], FIFOSIZE-fifo->emptyslot );
-	}
-	fifo->emptyslot += cnt;
-	fifo->len += cnt;
-
-	LWIP_DEBUGF( SIO_FIFO_DEBUG,("len%d dat%d empt%d\n", fifo->len, fifo->dataslot, fifo->emptyslot ) );
-
-	if ( fifo->len > FIFOSIZE )
-	{
-		printf( "ERROR: fifo overrun detected len=%d, flushing\n", fifo->len );
-		fifo->dataslot  = 0;
-		fifo->emptyslot = 0;
-		fifo->len = 0;
-	}
-
-	if ( fifo->emptyslot == FIFOSIZE )
-	{
-		fifo->emptyslot = 0;
-		LWIP_DEBUGF( SIO_FIFO_DEBUG, ("(WRAP) ") );
-
-		sys_sem_signal(&fifo->sem ); /* leave critical */
-		fifoPut( fifo, fd );
-		return;
-	}
-	if ( fifo->getWaiting )
-	{
-		fifo->getWaiting = FALSE;
-		sys_sem_signal(&fifo->getSem );
-	}
-
-	sys_sem_signal(&fifo->sem ); /* leave critical */
-	return;
-}
-
-
-void fifoInit(fifo_t * fifo)
-{
-  fifo->dataslot  = 0;
-  fifo->emptyslot = 0;
-  fifo->len       = 0;
-  if(sys_sem_new(&fifo->sem, 1) != ERR_OK) {  /* critical section 1=free to enter */
-    LWIP_ASSERT("Failed to create semaphore", 0);
-  }
-  if(sys_sem_new(&fifo->getSem, 0) != ERR_OK) {  /* 0 = no one waiting */
-    LWIP_ASSERT("Failed to create semaphore", 0);
-  }
-  fifo->getWaiting = FALSE;
-}
diff --git a/contrib/ports/unix/port/netif/list.c b/contrib/ports/unix/port/netif/list.c
deleted file mode 100644
index 77faab5d..00000000
--- a/contrib/ports/unix/port/netif/list.c
+++ /dev/null
@@ -1,152 +0,0 @@
-/*
- * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-
-
-
-#include <stdlib.h>
-#include <netif/list.h>
-
-
-/*-----------------------------------------------------------------------------------*/
-struct list *
-list_new(int size)
-{
-  struct list *list;
-  list = (struct list *)malloc(sizeof(struct list));
-  list->first = list->last = NULL;
-  list->size = size;
-  list->elems = 0;
-  return list;
-}
-/*-----------------------------------------------------------------------------------*/
-int
-list_push(struct list *list, void *data)
-{
-  struct elem *elem;
-
-  if (list->elems < list->size) {
-    elem = (struct elem *)malloc(sizeof(struct elem));
-    elem->data = data;
-    elem->next = NULL;
-    if (list->last != NULL) {
-      list->last->next = elem;
-    }
-    list->last = elem;
-    if (list->first == NULL) {
-      list->first = elem;
-    }
-    list->elems++;
-    return 1;
-  }
-  return 0;
-}
-/*-----------------------------------------------------------------------------------*/
-void *
-list_pop(struct list *list)
-{
-  struct elem *elem;
-  void *data;
-
-  if (list->elems > 0) {
-    elem = list->first;
-    if (elem == list->last) {
-      list->last = elem->next;
-    }
-    list->first = elem->next;
-
-    list->elems--;
-
-    data = elem->data;
-    free(elem);
-
-    return data;
-  }
-  return NULL;
-}
-/*-----------------------------------------------------------------------------------*/
-void *
-list_first(struct list *list)
-{
-  return list->first;
-}
-/*-----------------------------------------------------------------------------------*/
-int
-list_elems(struct list *list)
-{
-  return list->elems;
-}
-/*-----------------------------------------------------------------------------------*/
-void
-list_delete(struct list *list)
-{
-  while (list_pop(list) != NULL);
-  free(list);
-}
-/*-----------------------------------------------------------------------------------*/
-int
-list_remove(struct list *list, void *elem)
-{
-  struct elem *e, *p;
-
-  p = NULL;
-  for(e = list->first; e != NULL; e = e->next) {
-    if (e->data == elem) {
-      if (p != NULL) {
-        p->next = e->next;
-      } else {
-        list->first = e->next;
-      }
-      if (list->last == e) {
-        list->last = p;
-        if (p != NULL) {
-          p->next = NULL;
-        }
-      }
-      free(e);
-      list->elems--;
-      return 1;
-    }
-    p = e;
-  }
-  return 0;
-}
-/*-----------------------------------------------------------------------------------*/
-void
-list_map(struct list *list, void (* func)(void *arg))
-{
-  struct elem *e;
-
-  for(e = list->first; e != NULL; e = e->next) {
-    func(e->data);
-  }
-}
-/*-----------------------------------------------------------------------------------*/
diff --git a/contrib/ports/unix/port/netif/pcapif.c b/contrib/ports/unix/port/netif/pcapif.c
deleted file mode 100644
index 2851c822..00000000
--- a/contrib/ports/unix/port/netif/pcapif.c
+++ /dev/null
@@ -1,207 +0,0 @@
-/*
- * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-
-#ifndef linux  /* Apparently, this doesn't work under Linux. */
-
-#include "lwip/debug.h"
-
-#include <fcntl.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <unistd.h>
-#include <sys/types.h>
-#include <sys/uio.h>
-#include <sys/socket.h>
-#include <sys/un.h>
-#include <sys/stat.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-
-#include <pcap.h>
-
-#include "netif/etharp.h"
-
-#include "lwip/stats.h"
-
-#include "lwip/def.h"
-#include "lwip/mem.h"
-#include "lwip/pbuf.h"
-#include "lwip/sys.h"
-
-#include "lwip/ip.h"
-
-
-struct pcapif {
-  pcap_t *pd;
-  sys_sem_t sem;
-  u8_t pkt[2048];
-  u32_t len;
-  u32_t lasttime;
-  struct pbuf *p;
-  struct eth_addr *ethaddr;
-};
-
-static char errbuf[PCAP_ERRBUF_SIZE];
-
-/*-----------------------------------------------------------------------------------*/
-static err_t
-pcapif_output(struct netif *netif, struct pbuf *p,
-	      ip_addr_t *ipaddr)
-{
-  return ERR_OK;
-}
-/*-----------------------------------------------------------------------------------*/
-static void
-timeout(void *arg)
-{
-  struct netif *netif;
-  struct pcapif *pcapif;
-  struct pbuf *p;
-  struct eth_hdr *ethhdr;
-
-  netif = (struct netif *)arg;
-  pcapif = netif->state;
-  ethhdr = (struct eth_hdr *)pcapif->pkt;
-
-
-  if (lwip_htons(ethhdr->type) != ETHTYPE_IP ||
-     ip_lookup(pcapif->pkt + 14, netif)) {
-
-    /* We allocate a pbuf chain of pbufs from the pool. */
-    p = pbuf_alloc(PBUF_LINK, pcapif->len, PBUF_POOL);
-
-    if (p != NULL) {
-      pbuf_take(p, pcapif->pkt, pcapif->len);
-
-      ethhdr = p->payload;
-      switch (lwip_htons(ethhdr->type)) {
-      /* IP or ARP packet? */
-      case ETHTYPE_IP:
-      case ETHTYPE_ARP:
-#if PPPOE_SUPPORT
-      /* PPPoE packet? */
-      case ETHTYPE_PPPOEDISC:
-      case ETHTYPE_PPPOE:
-#endif /* PPPOE_SUPPORT */
-        /* full packet send to tcpip_thread to process */
-        if (netif->input(p, netif) != ERR_OK) {
-          LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_input: IP input error\n"));
-          pbuf_free(p);
-          p = NULL;
-        }
-        break;
-      default:
-        pbuf_free(p);
-        break;
-      }
-    }
-  } else {
-    printf("ip_lookup dropped\n");
-  }
-
-  sys_sem_signal(&pcapif->sem);
-}
-/*-----------------------------------------------------------------------------------*/
-static void
-callback(u_char *arg, const struct pcap_pkthdr *hdr, const u_char *pkt)
-{
-  struct netif *netif;
-  struct pcapif *pcapif;
-  u32_t time, lasttime;
-
-  netif = (struct netif *)arg;
-  pcapif = netif->state;
-
-  pcapif->len = hdr->len;
-
-  bcopy(pkt, pcapif->pkt, hdr->len);
-
-  time = hdr->ts.tv_sec * 1000 + hdr->ts.tv_usec / 1000;
-
-  lasttime = pcapif->lasttime;
-  pcapif->lasttime = time;
-
-
-  if (lasttime == 0) {
-    sys_timeout(1000, timeout, netif);
-  } else {
-    sys_timeout(time - lasttime, timeout, netif);
-  }
-}
-/*-----------------------------------------------------------------------------------*/
-static void
-pcapif_thread(void *arg)
-{
-  struct netif *netif;
-  struct pcapif *pcapif;
-  netif = arg;
-  pcapif = netif->state;
-
-  while (1) {
-    pcap_loop(pcapif->pd, 1, callback, (u_char *)netif);
-    sys_sem_wait(&pcapif->sem);
-    if (pcapif->p != NULL) {
-      netif->input(pcapif->p, netif);
-    }
-  }
-}
-/*-----------------------------------------------------------------------------------*/
-err_t
-pcapif_init(struct netif *netif)
-{
-  struct pcapif *p;
-
-  p = malloc(sizeof(struct pcapif));
-  if (p == NULL)
-      return ERR_MEM;
-  netif->state = p;
-  netif->name[0] = 'p';
-  netif->name[1] = 'c';
-  netif->output = pcapif_output;
-
-  p->pd = pcap_open_offline("pcapdump", errbuf);
-  if (p->pd == NULL) {
-    printf("pcapif_init: failed %s\n", errbuf);
-    return ERR_IF;
-  }
-
-  if(sys_sem_new(&p->sem, 0) != ERR_OK) {
-    LWIP_ASSERT("Failed to create semaphore", 0);
-  }
-  p->p = NULL;
-  p->lasttime = 0;
-
-  sys_thread_new("pcapif_thread", pcapif_thread, netif, DEFAULT_THREAD_STACKSIZE, DEFAULT_THREAD_PRIO);
-  return ERR_OK;
-}
-/*-----------------------------------------------------------------------------------*/
-#endif /* linux */
diff --git a/contrib/ports/unix/port/netif/sio.c b/contrib/ports/unix/port/netif/sio.c
deleted file mode 100644
index d5a38af1..00000000
--- a/contrib/ports/unix/port/netif/sio.c
+++ /dev/null
@@ -1,488 +0,0 @@
-/* Author: Magnus Ivarsson <magnus.ivarsson@volvo.com> */
-
-/* to get rid of implicit function declarations */
-#define _XOPEN_SOURCE 600
-#define _GNU_SOURCE
-
-/* build with Darwin C extensions not part of POSIX, i.e. FASYNC, SIGIO.
-   we can't use LWIP_UNIX_MACH because extensions need to be turned
-   on before any system headers (which are pulled in through cc.h)
-   are included */
-#if defined(__APPLE__)
-#define _DARWIN_C_SOURCE
-#endif
-
-#include "netif/sio.h"
-#include "netif/fifo.h"
-#include "lwip/debug.h"
-#include "lwip/def.h"
-#include "lwip/sys.h"
-#include "lwip/arch.h"
-#include "lwip/sio.h"
-#include "netif/ppp/ppp_opts.h"
-
-/* Following #undefs are here to keep compiler from issuing warnings
-   about them being double defined. (They are defined in lwip/inet.h
-   as well as the Unix #includes below.) */
-#undef htonl
-#undef ntohl
-#undef htons
-#undef ntohs
-#undef HTONL
-#undef NTOHL
-#undef HTONS
-#undef NTOHS
-
-#include <stdlib.h>
-#include <stdio.h>
-#if defined(LWIP_UNIX_OPENBSD)
-#include <util.h>
-#endif
-#include <termios.h>
-#include <stdio.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <signal.h>
-#include <string.h>
-#include <sys/signal.h>
-#include <sys/types.h>
-
-#ifndef LWIP_HAVE_SLIPIF
-#define LWIP_HAVE_SLIPIF 0
-#endif
-
-#if (PPP_SUPPORT || LWIP_HAVE_SLIPIF) && defined(LWIP_UNIX_LINUX)
-#include <pty.h>
-#endif
-
-/*#define BAUDRATE B19200 */
-/*#define BAUDRATE B57600 */
-#define BAUDRATE B115200
-
-#ifndef TRUE
-#define TRUE  1
-#endif
-#ifndef FALSE
-#define FALSE 0
-#endif
-
-/* for all of you who dont define SIO_DEBUG in debug.h */
-#ifndef SIO_DEBUG
-#define SIO_DEBUG 0
-#endif
-
-
-/*  typedef struct siostruct_t */
-/*  {  */
-/*  	sio_status_t *sio; */
-/*  } siostruct_t; */
-
-/** array of ((siostruct*)netif->state)->sio structs */
-static sio_status_t statusar[4];
-
-#if ! (PPP_SUPPORT || LWIP_HAVE_SLIPIF)
-/* --private-functions----------------------------------------------------------------- */
-/**
- * Signal handler for ttyXX0 to indicate bytes received
- * one per interface is needed since we cannot send a instance number / pointer as callback argument (?)
- */
-static void	signal_handler_IO_0( int status )
-{
-	LWIP_UNUSED_ARG(status);
-	LWIP_DEBUGF(SIO_DEBUG, ("SigHand: rxSignal channel 0\n"));
-	fifoPut( &statusar[0].myfifo, statusar[0].fd );
-}
-
-/**
- * Signal handler for ttyXX1 to indicate bytes received
- * one per interface is needed since we cannot send a instance number / pointer as callback argument (?)
- */
-static void signal_handler_IO_1( int status )
-{
-	LWIP_UNUSED_ARG(status);
-	LWIP_DEBUGF(SIO_DEBUG, ("SigHand: rxSignal channel 1\n"));
-	fifoPut( &statusar[1].myfifo, statusar[1].fd );
-}
-#endif /* ! (PPP_SUPPORT || LWIP_HAVE_SLIPIF) */
-
-/**
-* Initiation of serial device
-* @param device string with the device name and path, eg. "/dev/ttyS0"
-* @param devnum device number
-* @param siostat status
-* @return file handle to serial dev.
-*/
-static int sio_init( char * device, int devnum, sio_status_t * siostat )
-{
-	struct termios oldtio,newtio;
-#if ! (PPP_SUPPORT || LWIP_HAVE_SLIPIF)
-	struct sigaction saio;           /* definition of signal action */
-#endif
-	int fd;
-	LWIP_UNUSED_ARG(siostat);
-	LWIP_UNUSED_ARG(devnum);
-
-	/* open the device to be non-blocking (read will return immediately) */
-	fd = open( device, O_RDWR | O_NOCTTY | O_NONBLOCK );
-	if ( fd < 0 )
-	{
-		perror( device );
-		exit( -1 );
-	}
-
-#if ! (PPP_SUPPORT || LWIP_HAVE_SLIPIF)
-	/* install the signal handler before making the device asynchronous */
-	switch ( devnum )
-	{
-		case 0:
-			LWIP_DEBUGF( SIO_DEBUG, ("sioinit, signal_handler_IO_0\n") );
-			saio.sa_handler = signal_handler_IO_0;
-			break;
-		case 1:
-			LWIP_DEBUGF( SIO_DEBUG, ("sioinit, signal_handler_IO_1\n") );
-			saio.sa_handler = signal_handler_IO_1;
-			break;
-		default:
-			LWIP_DEBUGF( SIO_DEBUG,("sioinit, devnum not allowed\n") );
-			break;
-	}
-
-	saio.sa_flags = 0;
-#if defined(LWIP_UNIX_LINUX)
-	saio.sa_restorer = NULL;
-#endif /* LWIP_UNIX_LINUX */
-	sigaction( SIGIO,&saio,NULL );
-
-	/* allow the process to receive SIGIO */
-       	if ( fcntl( fd, F_SETOWN, getpid( ) ) != 0)
-	{
-		perror( device );
-		exit( -1 );
-	}
-	/* Make the file descriptor asynchronous (the manual page says only
-	O_APPEND and O_NONBLOCK, will work with F_SETFL...) */
-       	if ( fcntl( fd, F_SETFL, FASYNC ) != 0)
-	{
-		perror( device );
-		exit( -1 );
-	}
-#else
-       	if ( fcntl( fd, F_SETFL, 0 ) != 0)
-	{
-		perror( device );
-		exit( -1 );
-	}
-
-#endif /* ! (PPP_SUPPORT || LWIP_HAVE_SLIPIF) */
-
-	tcgetattr( fd,&oldtio ); /* save current port settings */
-	/* set new port settings */
-	/* see 'man termios' for further settings */
-        memset(&newtio, 0, sizeof(newtio));
-	newtio.c_cflag = BAUDRATE | CS8 | CLOCAL | CREAD | CRTSCTS;
-	newtio.c_iflag = 0;
-	newtio.c_oflag = 0;
-	newtio.c_lflag = 0; /*ECHO; */
-	newtio.c_cc[VMIN] = 1; /* Read 1 byte at a time, no timer */
-	newtio.c_cc[VTIME] = 0;
-
-	tcsetattr( fd,TCSANOW,&newtio );
-	tcflush( fd, TCIOFLUSH );
-
-	return fd;
-}
-
-/**
-*
-*/
-static void sio_speed( int fd, int speed )
-{
-	struct termios oldtio,newtio;
-	/*  int fd; */
-
-	LWIP_DEBUGF(SIO_DEBUG, ("sio_speed[%d]: baudcode:%d enter\n", fd, speed));
-
-	if ( fd < 0 )
-	{
-		LWIP_DEBUGF(SIO_DEBUG, ("sio_speed[%d]: fd ERROR\n", fd));
-		exit( -1 );
-	}
-
-	tcgetattr( fd,&oldtio ); /* get current port settings */
-
-	/* set new port settings
-	* see 'man termios' for further settings */
-        memset(&newtio, 0, sizeof(newtio));
-	newtio.c_cflag = speed | CS8 | CLOCAL | CREAD; /* | CRTSCTS; */
-	newtio.c_iflag = 0;
-	newtio.c_oflag = 0;
-	newtio.c_lflag = 0; /*ECHO; */
-	newtio.c_cc[VMIN] = 1; /* Read 1 byte at a time, no timer */
-	newtio.c_cc[VTIME] = 0;
-
-	tcsetattr( fd,TCSANOW,&newtio );
-	tcflush( fd, TCIOFLUSH );
-
-	LWIP_DEBUGF(SIO_DEBUG, ("sio_speed[%d]: leave\n", fd));
-}
-
-/* --public-functions----------------------------------------------------------------------------- */
-void sio_send( u8_t c, sio_status_t * siostat )
-{
-    /*	sio_status_t * siostat = ((siostruct_t*)netif->state)->sio; */
-
-	if ( write( siostat->fd, &c, 1 ) <= 0 )
-	{
-		LWIP_DEBUGF(SIO_DEBUG, ("sio_send[%d]: write refused\n", siostat->fd));
-	}
-}
-
-void sio_send_string( u8_t *str, sio_status_t * siostat )
-{
-    /*	sio_status_t * siostat = ((siostruct_t*)netif->state)->sio; */
-	int len = strlen( (const char *)str );
-
-	if ( write( siostat->fd, str, len ) <= 0 )
-	{
-		LWIP_DEBUGF(SIO_DEBUG, ("sio_send_string[%d]: write refused\n", siostat->fd));
-	}
-	LWIP_DEBUGF(SIO_DEBUG, ("sio_send_string[%d]: sent: %s\n", siostat->fd, str));
-}
-
-
-void sio_flush( sio_status_t * siostat )
-{
-	LWIP_UNUSED_ARG(siostat);
-	/* not implemented in unix as it is not needed */
- 	/*sio_status_t * siostat = ((siostruct_t*)netif->state)->sio; */
-}
-
-
-#if ! (PPP_SUPPORT || LWIP_HAVE_SLIPIF)
-/*u8_t sio_recv( struct netif * netif )*/
-u8_t sio_recv( sio_status_t * siostat )
-{
-    /*	sio_status_t * siostat = ((siostruct_t*)netif->state)->sio; */
-	return fifoGet( &(siostat->myfifo) );
-}
-
-s16_t sio_poll(sio_status_t * siostat)
-{
-    /*	sio_status_t * siostat = ((siostruct_t*)netif->state)->sio;*/
-	return fifoGetNonBlock( &(siostat->myfifo) );
-}
-
-
-void sio_expect_string( u8_t *str, sio_status_t * siostat )
-{
-    /*	sio_status_t * siostat = ((siostruct_t*)netif->state)->sio;*/
-	u8_t c;
- 	int finger=0;
-
-	LWIP_DEBUGF(SIO_DEBUG, ("sio_expect_string[%d]: %s\n", siostat->fd, str));
-	while ( 1 )
-	{
-		c=fifoGet( &(siostat->myfifo) );
-		LWIP_DEBUGF(SIO_DEBUG, ("_%c", c));
-		if ( c==str[finger] )
-		{
-			finger++;
-		} else if ( finger > 0 )
-		{
-                    /*it might fit in the beginning? */
-			if ( str[0] == c )
-			{
-				finger = 1;
-			}
-		}
-		if ( 0 == str[finger] )
-                    break;	/* done, we have a match */
-	}
-	LWIP_DEBUGF(SIO_DEBUG, ("sio_expect_string[%d]: [match]\n", siostat->fd));
-}
-#endif /* ! (PPP_SUPPORT || LWIP_HAVE_SLIPIF) */
-
-#if (PPP_SUPPORT || LWIP_HAVE_SLIPIF)
-u32_t sio_write(sio_status_t * siostat, u8_t *buf, u32_t size)
-{
-    ssize_t wsz = write( siostat->fd, buf, size );
-    return wsz < 0 ? 0 : wsz;
-}
-
-u32_t sio_read(sio_status_t * siostat, u8_t *buf, u32_t size)
-{
-    ssize_t rsz = read( siostat->fd, buf, size );
-    return rsz < 0 ? 0 : rsz;
-}
-
-void sio_read_abort(sio_status_t * siostat)
-{
-    LWIP_UNUSED_ARG(siostat);
-    printf("sio_read_abort[%d]: not yet implemented for unix\n", siostat->fd);
-}
-#endif /* (PPP_SUPPORT || LWIP_HAVE_SLIPIF) */
-
-sio_fd_t sio_open(u8_t devnum)
-{
-	char dev[20];
-
-	/* would be nice with dynamic memory alloc */
-	sio_status_t * siostate = &statusar[ devnum ];
-/* 	siostruct_t * tmp; */
-
-
-/* 	tmp = (siostruct_t*)(netif->state); */
-/* 	tmp->sio = siostate; */
-
-/* 	tmp = (siostruct_t*)(netif->state); */
-
-/* 	((sio_status_t*)(tmp->sio))->fd = 0; */
-
-	LWIP_DEBUGF(SIO_DEBUG, ("sio_open: for devnum %d\n", devnum));
-
-#if ! (PPP_SUPPORT || LWIP_HAVE_SLIPIF)
-	fifoInit( &siostate->myfifo );
-#endif /* ! PPP_SUPPORT */
-
-	snprintf( dev, sizeof(dev), "/dev/ttyS%d", devnum );
-
-	if ( (devnum == 1) || (devnum == 0) )
-	{
-		if ( ( siostate->fd = sio_init( dev, devnum, siostate ) ) == 0 )
-		{
-			LWIP_DEBUGF(SIO_DEBUG, ("sio_open: ERROR opening serial device dev=%s\n", dev));
-			abort( );
-			return NULL;
-		}
-		LWIP_DEBUGF(SIO_DEBUG, ("sio_open[%d]: dev=%s open.\n", siostate->fd, dev));
-	}
-#if PPP_SUPPORT
-	else if (devnum == 2) {
-	    pid_t childpid;
-	    char name[256];
-	    childpid = forkpty(&siostate->fd, name, NULL, NULL);
-	    if(childpid < 0) {
-		perror("forkpty");
-		exit (1);
-	    }
-	    if(childpid == 0) {
-		execl("/usr/sbin/pppd", "pppd",
-			"ms-dns", "198.168.100.7",
-			"local", "crtscts",
-			"debug",
-#ifdef LWIP_PPP_CHAP_TEST
-			"auth",
-			"require-chap",
-			"remotename", "lwip",
-#else
-			"noauth",
-#endif
-#if LWIP_IPV6
-			"+ipv6",
-#endif
-			"192.168.1.1:192.168.1.2",
-			NULL);
-		perror("execl pppd");
-		exit (1);
-	    } else {
-		LWIP_DEBUGF(SIO_DEBUG, ("sio_open[%d]: spawned pppd pid %d on %s\n",
-			siostate->fd, childpid, name));
-	    }
-
-	}
-#endif
-#if LWIP_HAVE_SLIPIF
-	else if (devnum == 3) {
-	    pid_t childpid;
-	    /* create PTY pair */
-	    siostate->fd = posix_openpt(O_RDWR | O_NOCTTY);
-	    if (siostate->fd < 0) {
-		perror("open pty master");
-		exit (1);
-	    }
-	    if (grantpt(siostate->fd) != 0) {
-		perror("grant pty master");
-		exit (1);
-	    }
-	    if (unlockpt(siostate->fd) != 0) {
-		perror("unlock pty master");
-		exit (1);
-	    }
-	    LWIP_DEBUGF(SIO_DEBUG, ("sio_open[%d]: for %s\n",
-		    siostate->fd, ptsname(siostate->fd)));
-	    /* fork for slattach */
-	    childpid = fork();
-	    if(childpid < 0) {
-		perror("fork");
-		exit (1);
-	    }
-	    if(childpid == 0) {
-		/* esteblish SLIP interface on host side connected to PTY slave */
-		execl("/sbin/slattach", "slattach",
-			"-d", "-v", "-L", "-p", "slip",
-			ptsname(siostate->fd),
-			NULL);
-		perror("execl slattach");
-		exit (1);
-	    } else {
-		int ret;
-		char buf[1024];
-		LWIP_DEBUGF(SIO_DEBUG, ("sio_open[%d]: spawned slattach pid %d on %s\n",
-			siostate->fd, childpid, ptsname(siostate->fd)));
-		/* wait a moment for slattach startup */
-		sleep(1);
-		/* configure SLIP interface on host side as P2P interface */
-		snprintf(buf, sizeof(buf),
-			"/sbin/ifconfig sl0 mtu %d %s pointopoint %s up",
-			SLIP_MAX_SIZE, "192.168.2.1", "192.168.2.2");
-		LWIP_DEBUGF(SIO_DEBUG, ("sio_open[%d]: system(\"%s\");\n", siostate->fd, buf));
-		ret = system(buf);
-		if (ret < 0) {
-		    perror("ifconfig failed");
-		    exit(1);
-		}
-	    }
-	}
-#endif /* LWIP_HAVE_SLIPIF */
-	else
-	{
-		LWIP_DEBUGF(SIO_DEBUG, ("sio_open: device %s (%d) is not supported\n", dev, devnum));
-		return NULL;
-	}
-
-	return siostate;
-}
-
-/**
-*
-*/
-void sio_change_baud( sioBaudrates baud, sio_status_t * siostat )
-{
-    /*	sio_status_t * siostat = ((siostruct_t*)netif->state)->sio;*/
-
-	LWIP_DEBUGF(SIO_DEBUG, ("sio_change_baud[%d]\n", siostat->fd));
-
-	switch ( baud )
-	{
-		case SIO_BAUD_9600:
-			sio_speed( siostat->fd, B9600 );
-			break;
-		case SIO_BAUD_19200:
-			sio_speed( siostat->fd, B19200 );
-			break;
-		case SIO_BAUD_38400:
-			sio_speed( siostat->fd, B38400 );
-			break;
-		case SIO_BAUD_57600:
-			sio_speed( siostat->fd, B57600 );
-			break;
-		case SIO_BAUD_115200:
-			sio_speed( siostat->fd, B115200 );
-			break;
-
-		default:
-			LWIP_DEBUGF(SIO_DEBUG, ("sio_change_baud[%d]: Unknown baudrate, code:%d\n",
-					siostat->fd, baud));
-			break;
-	}
-}
diff --git a/contrib/ports/unix/port/netif/tapif.c b/contrib/ports/unix/port/netif/tapif.c
deleted file mode 100644
index b5f8ad20..00000000
--- a/contrib/ports/unix/port/netif/tapif.c
+++ /dev/null
@@ -1,432 +0,0 @@
-/*
- * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-
-#include <fcntl.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <unistd.h>
-#include <string.h>
-#include <sys/ioctl.h>
-#include <sys/socket.h>
-#include <sys/types.h>
-#include <sys/time.h>
-#include <sys/uio.h>
-#include <sys/socket.h>
-
-#include "lwip/opt.h"
-
-#include "lwip/debug.h"
-#include "lwip/def.h"
-#include "lwip/ip.h"
-#include "lwip/mem.h"
-#include "lwip/stats.h"
-#include "lwip/snmp.h"
-#include "lwip/pbuf.h"
-#include "lwip/sys.h"
-#include "lwip/timeouts.h"
-#include "netif/etharp.h"
-#include "lwip/ethip6.h"
-
-#include "netif/tapif.h"
-
-#define IFCONFIG_BIN "/sbin/ifconfig "
-
-#if defined(LWIP_UNIX_LINUX)
-#include <sys/ioctl.h>
-#include <linux/if.h>
-#include <linux/if_tun.h>
-/*
- * Creating a tap interface requires special privileges. If the interfaces
- * is created in advance with `tunctl -u <user>` it can be opened as a regular
- * user. The network must already be configured. If DEVTAP_IF is defined it
- * will be opened instead of creating a new tap device.
- *
- * You can also use PRECONFIGURED_TAPIF environment variable to do so.
- */
-#ifndef DEVTAP_DEFAULT_IF
-#define DEVTAP_DEFAULT_IF "tap0"
-#endif
-#ifndef DEVTAP
-#define DEVTAP "/dev/net/tun"
-#endif
-#define NETMASK_ARGS "netmask %d.%d.%d.%d"
-#define IFCONFIG_ARGS "tap0 inet %d.%d.%d.%d " NETMASK_ARGS
-#elif defined(LWIP_UNIX_OPENBSD)
-#define DEVTAP "/dev/tun0"
-#define NETMASK_ARGS "netmask %d.%d.%d.%d"
-#define IFCONFIG_ARGS "tun0 inet %d.%d.%d.%d " NETMASK_ARGS " link0"
-#else /* others */
-#define DEVTAP "/dev/tap0"
-#define NETMASK_ARGS "netmask %d.%d.%d.%d"
-#define IFCONFIG_ARGS "tap0 inet %d.%d.%d.%d " NETMASK_ARGS
-#endif
-
-/* Define those to better describe your network interface. */
-#define IFNAME0 't'
-#define IFNAME1 'p'
-
-#ifndef TAPIF_DEBUG
-#define TAPIF_DEBUG LWIP_DBG_OFF
-#endif
-
-struct tapif {
-  /* Add whatever per-interface state that is needed here. */
-  int fd;
-};
-
-/* Forward declarations. */
-static void tapif_input(struct netif *netif);
-#if !NO_SYS
-static void tapif_thread(void *arg);
-#endif /* !NO_SYS */
-
-/*-----------------------------------------------------------------------------------*/
-static void
-low_level_init(struct netif *netif)
-{
-  struct tapif *tapif;
-#if LWIP_IPV4
-  int ret;
-  char buf[1024];
-#endif /* LWIP_IPV4 */
-  char *preconfigured_tapif = getenv("PRECONFIGURED_TAPIF");
-
-  tapif = (struct tapif *)netif->state;
-
-  /* Obtain MAC address from network interface. */
-
-  /* (We just fake an address...) */
-  netif->hwaddr[0] = 0x02;
-  netif->hwaddr[1] = 0x12;
-  netif->hwaddr[2] = 0x34;
-  netif->hwaddr[3] = 0x56;
-  netif->hwaddr[4] = 0x78;
-  netif->hwaddr[5] = 0xab;
-  netif->hwaddr_len = 6;
-
-  /* device capabilities */
-  netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_IGMP;
-
-  tapif->fd = open(DEVTAP, O_RDWR);
-  LWIP_DEBUGF(TAPIF_DEBUG, ("tapif_init: fd %d\n", tapif->fd));
-  if (tapif->fd == -1) {
-#ifdef LWIP_UNIX_LINUX
-    perror("tapif_init: try running \"modprobe tun\" or rebuilding your kernel with CONFIG_TUN; cannot open "DEVTAP);
-#else /* LWIP_UNIX_LINUX */
-    perror("tapif_init: cannot open "DEVTAP);
-#endif /* LWIP_UNIX_LINUX */
-    exit(1);
-  }
-
-#ifdef LWIP_UNIX_LINUX
-  {
-    struct ifreq ifr;
-    memset(&ifr, 0, sizeof(ifr));
-
-    if (preconfigured_tapif) {
-      strncpy(ifr.ifr_name, preconfigured_tapif, sizeof(ifr.ifr_name));
-    } else {
-      strncpy(ifr.ifr_name, DEVTAP_DEFAULT_IF, sizeof(ifr.ifr_name));
-    }
-    ifr.ifr_name[sizeof(ifr.ifr_name)-1] = 0; /* ensure \0 termination */
-
-    ifr.ifr_flags = IFF_TAP|IFF_NO_PI;
-    if (ioctl(tapif->fd, TUNSETIFF, (void *) &ifr) < 0) {
-      perror("tapif_init: "DEVTAP" ioctl TUNSETIFF");
-      exit(1);
-    }
-  }
-#endif /* LWIP_UNIX_LINUX */
-
-  netif_set_link_up(netif);
-
-  if (preconfigured_tapif == NULL) {
-#if LWIP_IPV4
-    snprintf(buf, 1024, IFCONFIG_BIN IFCONFIG_ARGS,
-             ip4_addr1(netif_ip4_gw(netif)),
-             ip4_addr2(netif_ip4_gw(netif)),
-             ip4_addr3(netif_ip4_gw(netif)),
-             ip4_addr4(netif_ip4_gw(netif))
-#ifdef NETMASK_ARGS
-             ,
-             ip4_addr1(netif_ip4_netmask(netif)),
-             ip4_addr2(netif_ip4_netmask(netif)),
-             ip4_addr3(netif_ip4_netmask(netif)),
-             ip4_addr4(netif_ip4_netmask(netif))
-#endif /* NETMASK_ARGS */
-             );
-
-    LWIP_DEBUGF(TAPIF_DEBUG, ("tapif_init: system(\"%s\");\n", buf));
-    ret = system(buf);
-    if (ret < 0) {
-      perror("ifconfig failed");
-      exit(1);
-    }
-    if (ret != 0) {
-      printf("ifconfig returned %d\n", ret);
-    }
-#else /* LWIP_IPV4 */
-    perror("todo: support IPv6 support for non-preconfigured tapif");
-    exit(1);
-#endif /* LWIP_IPV4 */
-  }
-
-#if !NO_SYS
-  sys_thread_new("tapif_thread", tapif_thread, netif, DEFAULT_THREAD_STACKSIZE, DEFAULT_THREAD_PRIO);
-#endif /* !NO_SYS */
-}
-/*-----------------------------------------------------------------------------------*/
-/*
- * low_level_output():
- *
- * Should do the actual transmission of the packet. The packet is
- * contained in the pbuf that is passed to the function. This pbuf
- * might be chained.
- *
- */
-/*-----------------------------------------------------------------------------------*/
-
-static err_t
-low_level_output(struct netif *netif, struct pbuf *p)
-{
-  struct tapif *tapif = (struct tapif *)netif->state;
-  char buf[1518]; /* max packet size including VLAN excluding CRC */
-  ssize_t written;
-
-#if 0
-  if (((double)rand()/(double)RAND_MAX) < 0.2) {
-    printf("drop output\n");
-    return ERR_OK; /* ERR_OK because we simulate packet loss on cable */
-  }
-#endif
-
-  if (p->tot_len > sizeof(buf)) {
-    MIB2_STATS_NETIF_INC(netif, ifoutdiscards);
-    perror("tapif: packet too large");
-    return ERR_IF;
-  }
-
-  /* initiate transfer(); */
-  pbuf_copy_partial(p, buf, p->tot_len, 0);
-
-  /* signal that packet should be sent(); */
-  written = write(tapif->fd, buf, p->tot_len);
-  if (written < p->tot_len) {
-    MIB2_STATS_NETIF_INC(netif, ifoutdiscards);
-    perror("tapif: write");
-    return ERR_IF;
-  } else {
-    MIB2_STATS_NETIF_ADD(netif, ifoutoctets, (u32_t)written);
-    return ERR_OK;
-  }
-}
-/*-----------------------------------------------------------------------------------*/
-/*
- * low_level_input():
- *
- * Should allocate a pbuf and transfer the bytes of the incoming
- * packet from the interface into the pbuf.
- *
- */
-/*-----------------------------------------------------------------------------------*/
-static struct pbuf *
-low_level_input(struct netif *netif)
-{
-  struct pbuf *p;
-  u16_t len;
-  ssize_t readlen;
-  char buf[1518]; /* max packet size including VLAN excluding CRC */
-  struct tapif *tapif = (struct tapif *)netif->state;
-
-  /* Obtain the size of the packet and put it into the "len"
-     variable. */
-  readlen = read(tapif->fd, buf, sizeof(buf));
-  if (readlen < 0) {
-    perror("read returned -1");
-    exit(1);
-  }
-  len = (u16_t)readlen;
-
-  MIB2_STATS_NETIF_ADD(netif, ifinoctets, len);
-
-#if 0
-  if (((double)rand()/(double)RAND_MAX) < 0.2) {
-    printf("drop\n");
-    return NULL;
-  }
-#endif
-
-  /* We allocate a pbuf chain of pbufs from the pool. */
-  p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
-  if (p != NULL) {
-    pbuf_take(p, buf, len);
-    /* acknowledge that packet has been read(); */
-  } else {
-    /* drop packet(); */
-    MIB2_STATS_NETIF_INC(netif, ifindiscards);
-    LWIP_DEBUGF(NETIF_DEBUG, ("tapif_input: could not allocate pbuf\n"));
-  }
-
-  return p;
-}
-
-/*-----------------------------------------------------------------------------------*/
-/*
- * tapif_input():
- *
- * This function should be called when a packet is ready to be read
- * from the interface. It uses the function low_level_input() that
- * should handle the actual reception of bytes from the network
- * interface.
- *
- */
-/*-----------------------------------------------------------------------------------*/
-static void
-tapif_input(struct netif *netif)
-{
-  struct pbuf *p = low_level_input(netif);
-
-  if (p == NULL) {
-#if LINK_STATS
-    LINK_STATS_INC(link.recv);
-#endif /* LINK_STATS */
-    LWIP_DEBUGF(TAPIF_DEBUG, ("tapif_input: low_level_input returned NULL\n"));
-    return;
-  }
-
-  if (netif->input(p, netif) != ERR_OK) {
-    LWIP_DEBUGF(NETIF_DEBUG, ("tapif_input: netif input error\n"));
-    pbuf_free(p);
-  }
-}
-/*-----------------------------------------------------------------------------------*/
-/*
- * tapif_init():
- *
- * Should be called at the beginning of the program to set up the
- * network interface. It calls the function low_level_init() to do the
- * actual setup of the hardware.
- *
- */
-/*-----------------------------------------------------------------------------------*/
-err_t
-tapif_init(struct netif *netif)
-{
-  struct tapif *tapif = (struct tapif *)mem_malloc(sizeof(struct tapif));
-
-  if (tapif == NULL) {
-    LWIP_DEBUGF(NETIF_DEBUG, ("tapif_init: out of memory for tapif\n"));
-    return ERR_MEM;
-  }
-  netif->state = tapif;
-  MIB2_INIT_NETIF(netif, snmp_ifType_other, 100000000);
-
-  netif->name[0] = IFNAME0;
-  netif->name[1] = IFNAME1;
-#if LWIP_IPV4
-  netif->output = etharp_output;
-#endif /* LWIP_IPV4 */
-#if LWIP_IPV6
-  netif->output_ip6 = ethip6_output;
-#endif /* LWIP_IPV6 */
-  netif->linkoutput = low_level_output;
-  netif->mtu = 1500;
-
-  low_level_init(netif);
-
-  return ERR_OK;
-}
-
-
-/*-----------------------------------------------------------------------------------*/
-void
-tapif_poll(struct netif *netif)
-{
-  tapif_input(netif);
-}
-
-#if NO_SYS
-
-int
-tapif_select(struct netif *netif)
-{
-  fd_set fdset;
-  int ret;
-  struct timeval tv;
-  struct tapif *tapif;
-  u32_t msecs = sys_timeouts_sleeptime();
-
-  tapif = (struct tapif *)netif->state;
-
-  tv.tv_sec = msecs / 1000;
-  tv.tv_usec = (msecs % 1000) * 1000;
-
-  FD_ZERO(&fdset);
-  FD_SET(tapif->fd, &fdset);
-
-  ret = select(tapif->fd + 1, &fdset, NULL, NULL, &tv);
-  if (ret > 0) {
-    tapif_input(netif);
-  }
-  return ret;
-}
-
-#else /* NO_SYS */
-
-static void
-tapif_thread(void *arg)
-{
-  struct netif *netif;
-  struct tapif *tapif;
-  fd_set fdset;
-  int ret;
-
-  netif = (struct netif *)arg;
-  tapif = (struct tapif *)netif->state;
-
-  while(1) {
-    FD_ZERO(&fdset);
-    FD_SET(tapif->fd, &fdset);
-
-    /* Wait for a packet to arrive. */
-    ret = select(tapif->fd + 1, &fdset, NULL, NULL, NULL);
-
-    if(ret == 1) {
-      /* Handle incoming packet. */
-      tapif_input(netif);
-    } else if(ret == -1) {
-      perror("tapif_thread: select");
-    }
-  }
-}
-
-#endif /* NO_SYS */
diff --git a/contrib/ports/unix/port/perf.c b/contrib/ports/unix/port/perf.c
deleted file mode 100644
index bed4614a..00000000
--- a/contrib/ports/unix/port/perf.c
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
- * All rights reserved. 
- * 
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- * 
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-
-#include "arch/perf.h"
-
-#include <stdio.h>
-
-static FILE *f;
-
-void
-perf_print(unsigned long c1l, unsigned long c1h,
-	   unsigned long c2l, unsigned long c2h,
-	   char *key)
-{
-  unsigned long sub_ms, sub_ls;
-  
-  sub_ms = c2h - c1h;
-  sub_ls = c2l - c1l;
-  if (c2l < c1l) sub_ms--;
-  fprintf(f, "%s: %.8lu%.8lu\n", key, sub_ms, sub_ls);
-  fflush(NULL);
-}
-
-void
-perf_print_times(struct tms *start, struct tms *end, char *key)
-{
-  fprintf(f, "%s: %lu\n", key, end->tms_stime - start->tms_stime);
-  fflush(NULL);  
-}
-
-void
-perf_init(char *fname)
-{
-  f = fopen(fname, "w");  
-}
-	
diff --git a/contrib/ports/unix/port/sys_arch.c b/contrib/ports/unix/port/sys_arch.c
deleted file mode 100644
index a56d7de1..00000000
--- a/contrib/ports/unix/port/sys_arch.c
+++ /dev/null
@@ -1,742 +0,0 @@
-/*
- * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-
-/*
- * Wed Apr 17 16:05:29 EDT 2002 (James Roth)
- *
- *  - Fixed an unlikely sys_thread_new() race condition.
- *
- *  - Made current_thread() work with threads which where
- *    not created with sys_thread_new().  This includes
- *    the main thread and threads made with pthread_create().
- *
- *  - Catch overflows where more than SYS_MBOX_SIZE messages
- *    are waiting to be read.  The sys_mbox_post() routine
- *    will block until there is more room instead of just
- *    leaking messages.
- */
-#define _GNU_SOURCE /* pull in pthread_setname_np() on Linux */
-
-#include "lwip/debug.h"
-
-#include <string.h>
-#include <sys/time.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <pthread.h>
-#include <errno.h>
-
-#include "lwip/def.h"
-
-#ifdef LWIP_UNIX_MACH
-#include <mach/mach.h>
-#include <mach/mach_time.h>
-#endif
-
-#include "lwip/sys.h"
-#include "lwip/opt.h"
-#include "lwip/stats.h"
-#include "lwip/tcpip.h"
-
-u32_t
-lwip_port_rand(void)
-{
-  return (u32_t)rand();
-}
-
-static void
-get_monotonic_time(struct timespec *ts)
-{
-#ifdef LWIP_UNIX_MACH
-  /* darwin impl (no CLOCK_MONOTONIC) */
-  u64_t t = mach_absolute_time();
-  mach_timebase_info_data_t timebase_info = {0, 0};
-  mach_timebase_info(&timebase_info);
-  u64_t nano = (t * timebase_info.numer) / (timebase_info.denom);
-  u64_t sec = nano/1000000000L;
-  nano -= sec * 1000000000L;
-  ts->tv_sec = sec;
-  ts->tv_nsec = nano;
-#else
-  clock_gettime(CLOCK_MONOTONIC, ts);
-#endif
-}
-
-#if SYS_LIGHTWEIGHT_PROT
-static pthread_mutex_t lwprot_mutex = PTHREAD_MUTEX_INITIALIZER;
-static pthread_t lwprot_thread = (pthread_t)0xDEAD;
-static int lwprot_count = 0;
-#endif /* SYS_LIGHTWEIGHT_PROT */
-
-#if !NO_SYS
-
-static struct sys_thread *threads = NULL;
-static pthread_mutex_t threads_mutex = PTHREAD_MUTEX_INITIALIZER;
-
-struct sys_mbox_msg {
-  struct sys_mbox_msg *next;
-  void *msg;
-};
-
-#define SYS_MBOX_SIZE 128
-
-struct sys_mbox {
-  int first, last;
-  void *msgs[SYS_MBOX_SIZE];
-  struct sys_sem *not_empty;
-  struct sys_sem *not_full;
-  struct sys_sem *mutex;
-  int wait_send;
-};
-
-struct sys_sem {
-  unsigned int c;
-  pthread_condattr_t condattr;
-  pthread_cond_t cond;
-  pthread_mutex_t mutex;
-};
-
-struct sys_mutex {
-  pthread_mutex_t mutex;
-};
-
-struct sys_thread {
-  struct sys_thread *next;
-  pthread_t pthread;
-};
-
-static struct sys_sem *sys_sem_new_internal(u8_t count);
-static void sys_sem_free_internal(struct sys_sem *sem);
-
-static u32_t cond_wait(pthread_cond_t * cond, pthread_mutex_t * mutex,
-                       u32_t timeout);
-
-/*-----------------------------------------------------------------------------------*/
-/* Threads */
-static struct sys_thread *
-introduce_thread(pthread_t id)
-{
-  struct sys_thread *thread;
-
-  thread = (struct sys_thread *)malloc(sizeof(struct sys_thread));
-
-  if (thread != NULL) {
-    pthread_mutex_lock(&threads_mutex);
-    thread->next = threads;
-    thread->pthread = id;
-    threads = thread;
-    pthread_mutex_unlock(&threads_mutex);
-  }
-
-  return thread;
-}
-
-struct thread_wrapper_data
-{
-  lwip_thread_fn function;
-  void *arg;
-};
-
-static void *
-thread_wrapper(void *arg)
-{
-  struct thread_wrapper_data *thread_data = (struct thread_wrapper_data *)arg;
-
-  thread_data->function(thread_data->arg);
-
-  /* we should never get here */
-  free(arg);
-  return NULL;
-}
-
-sys_thread_t
-sys_thread_new(const char *name, lwip_thread_fn function, void *arg, int stacksize, int prio)
-{
-  int code;
-  pthread_t tmp;
-  struct sys_thread *st = NULL;
-  struct thread_wrapper_data *thread_data;
-  LWIP_UNUSED_ARG(name);
-  LWIP_UNUSED_ARG(stacksize);
-  LWIP_UNUSED_ARG(prio);
-
-  thread_data = (struct thread_wrapper_data *)malloc(sizeof(struct thread_wrapper_data));
-  thread_data->arg = arg;
-  thread_data->function = function;
-  code = pthread_create(&tmp,
-                        NULL,
-                        thread_wrapper,
-                        thread_data);
-
-#ifdef LWIP_UNIX_LINUX
-  pthread_setname_np(tmp, name);
-#endif
-
-  if (0 == code) {
-    st = introduce_thread(tmp);
-  }
-
-  if (NULL == st) {
-    LWIP_DEBUGF(SYS_DEBUG, ("sys_thread_new: pthread_create %d, st = 0x%lx",
-                       code, (unsigned long)st));
-    abort();
-  }
-  return st;
-}
-
-#if LWIP_TCPIP_CORE_LOCKING
-static pthread_t lwip_core_lock_holder_thread_id;
-void sys_lock_tcpip_core(void)
-{
-  sys_mutex_lock(&lock_tcpip_core);
-  lwip_core_lock_holder_thread_id = pthread_self();
-}
-
-void sys_unlock_tcpip_core(void)
-{
-  lwip_core_lock_holder_thread_id = 0;
-  sys_mutex_unlock(&lock_tcpip_core);
-}
-#endif /* LWIP_TCPIP_CORE_LOCKING */
-
-static pthread_t lwip_tcpip_thread_id;
-void sys_mark_tcpip_thread(void)
-{
-  lwip_tcpip_thread_id = pthread_self();
-}
-
-void sys_check_core_locking(void)
-{
-  /* Embedded systems should check we are NOT in an interrupt context here */
-
-  if (lwip_tcpip_thread_id != 0) {
-    pthread_t current_thread_id = pthread_self();
-
-#if LWIP_TCPIP_CORE_LOCKING
-    LWIP_ASSERT("Function called without core lock", current_thread_id == lwip_core_lock_holder_thread_id);
-#else /* LWIP_TCPIP_CORE_LOCKING */
-    LWIP_ASSERT("Function called from wrong thread", current_thread_id == lwip_tcpip_thread_id);
-#endif /* LWIP_TCPIP_CORE_LOCKING */
-  }
-}
-
-/*-----------------------------------------------------------------------------------*/
-/* Mailbox */
-err_t
-sys_mbox_new(struct sys_mbox **mb, int size)
-{
-  struct sys_mbox *mbox;
-  LWIP_UNUSED_ARG(size);
-
-  mbox = (struct sys_mbox *)malloc(sizeof(struct sys_mbox));
-  if (mbox == NULL) {
-    return ERR_MEM;
-  }
-  mbox->first = mbox->last = 0;
-  mbox->not_empty = sys_sem_new_internal(0);
-  mbox->not_full = sys_sem_new_internal(0);
-  mbox->mutex = sys_sem_new_internal(1);
-  mbox->wait_send = 0;
-
-  SYS_STATS_INC_USED(mbox);
-  *mb = mbox;
-  return ERR_OK;
-}
-
-void
-sys_mbox_free(struct sys_mbox **mb)
-{
-  if ((mb != NULL) && (*mb != SYS_MBOX_NULL)) {
-    struct sys_mbox *mbox = *mb;
-    SYS_STATS_DEC(mbox.used);
-    sys_arch_sem_wait(&mbox->mutex, 0);
-
-    sys_sem_free_internal(mbox->not_empty);
-    sys_sem_free_internal(mbox->not_full);
-    sys_sem_free_internal(mbox->mutex);
-    mbox->not_empty = mbox->not_full = mbox->mutex = NULL;
-    /*  LWIP_DEBUGF("sys_mbox_free: mbox 0x%lx\n", mbox); */
-    free(mbox);
-  }
-}
-
-err_t
-sys_mbox_trypost(struct sys_mbox **mb, void *msg)
-{
-  u8_t first;
-  struct sys_mbox *mbox;
-  LWIP_ASSERT("invalid mbox", (mb != NULL) && (*mb != NULL));
-  mbox = *mb;
-
-  sys_arch_sem_wait(&mbox->mutex, 0);
-
-  LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_trypost: mbox %p msg %p\n",
-                          (void *)mbox, (void *)msg));
-
-  if ((mbox->last + 1) >= (mbox->first + SYS_MBOX_SIZE)) {
-    sys_sem_signal(&mbox->mutex);
-    return ERR_MEM;
-  }
-
-  mbox->msgs[mbox->last % SYS_MBOX_SIZE] = msg;
-
-  if (mbox->last == mbox->first) {
-    first = 1;
-  } else {
-    first = 0;
-  }
-
-  mbox->last++;
-
-  if (first) {
-    sys_sem_signal(&mbox->not_empty);
-  }
-
-  sys_sem_signal(&mbox->mutex);
-
-  return ERR_OK;
-}
-
-err_t
-sys_mbox_trypost_fromisr(sys_mbox_t *q, void *msg)
-{
-  return sys_mbox_trypost(q, msg);
-}
-
-void
-sys_mbox_post(struct sys_mbox **mb, void *msg)
-{
-  u8_t first;
-  struct sys_mbox *mbox;
-  LWIP_ASSERT("invalid mbox", (mb != NULL) && (*mb != NULL));
-  mbox = *mb;
-
-  sys_arch_sem_wait(&mbox->mutex, 0);
-
-  LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_post: mbox %p msg %p\n", (void *)mbox, (void *)msg));
-
-  while ((mbox->last + 1) >= (mbox->first + SYS_MBOX_SIZE)) {
-    mbox->wait_send++;
-    sys_sem_signal(&mbox->mutex);
-    sys_arch_sem_wait(&mbox->not_full, 0);
-    sys_arch_sem_wait(&mbox->mutex, 0);
-    mbox->wait_send--;
-  }
-
-  mbox->msgs[mbox->last % SYS_MBOX_SIZE] = msg;
-
-  if (mbox->last == mbox->first) {
-    first = 1;
-  } else {
-    first = 0;
-  }
-
-  mbox->last++;
-
-  if (first) {
-    sys_sem_signal(&mbox->not_empty);
-  }
-
-  sys_sem_signal(&mbox->mutex);
-}
-
-u32_t
-sys_arch_mbox_tryfetch(struct sys_mbox **mb, void **msg)
-{
-  struct sys_mbox *mbox;
-  LWIP_ASSERT("invalid mbox", (mb != NULL) && (*mb != NULL));
-  mbox = *mb;
-
-  sys_arch_sem_wait(&mbox->mutex, 0);
-
-  if (mbox->first == mbox->last) {
-    sys_sem_signal(&mbox->mutex);
-    return SYS_MBOX_EMPTY;
-  }
-
-  if (msg != NULL) {
-    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_tryfetch: mbox %p msg %p\n", (void *)mbox, *msg));
-    *msg = mbox->msgs[mbox->first % SYS_MBOX_SIZE];
-  }
-  else{
-    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_tryfetch: mbox %p, null msg\n", (void *)mbox));
-  }
-
-  mbox->first++;
-
-  if (mbox->wait_send) {
-    sys_sem_signal(&mbox->not_full);
-  }
-
-  sys_sem_signal(&mbox->mutex);
-
-  return 0;
-}
-
-u32_t
-sys_arch_mbox_fetch(struct sys_mbox **mb, void **msg, u32_t timeout)
-{
-  u32_t time_needed = 0;
-  struct sys_mbox *mbox;
-  LWIP_ASSERT("invalid mbox", (mb != NULL) && (*mb != NULL));
-  mbox = *mb;
-
-  /* The mutex lock is quick so we don't bother with the timeout
-     stuff here. */
-  sys_arch_sem_wait(&mbox->mutex, 0);
-
-  while (mbox->first == mbox->last) {
-    sys_sem_signal(&mbox->mutex);
-
-    /* We block while waiting for a mail to arrive in the mailbox. We
-       must be prepared to timeout. */
-    if (timeout != 0) {
-      time_needed = sys_arch_sem_wait(&mbox->not_empty, timeout);
-
-      if (time_needed == SYS_ARCH_TIMEOUT) {
-        return SYS_ARCH_TIMEOUT;
-      }
-    } else {
-      sys_arch_sem_wait(&mbox->not_empty, 0);
-    }
-
-    sys_arch_sem_wait(&mbox->mutex, 0);
-  }
-
-  if (msg != NULL) {
-    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_fetch: mbox %p msg %p\n", (void *)mbox, *msg));
-    *msg = mbox->msgs[mbox->first % SYS_MBOX_SIZE];
-  }
-  else{
-    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_fetch: mbox %p, null msg\n", (void *)mbox));
-  }
-
-  mbox->first++;
-
-  if (mbox->wait_send) {
-    sys_sem_signal(&mbox->not_full);
-  }
-
-  sys_sem_signal(&mbox->mutex);
-
-  return time_needed;
-}
-
-/*-----------------------------------------------------------------------------------*/
-/* Semaphore */
-static struct sys_sem *
-sys_sem_new_internal(u8_t count)
-{
-  struct sys_sem *sem;
-
-  sem = (struct sys_sem *)malloc(sizeof(struct sys_sem));
-  if (sem != NULL) {
-    sem->c = count;
-    pthread_condattr_init(&(sem->condattr));
-#if !(defined(LWIP_UNIX_MACH) || (defined(LWIP_UNIX_ANDROID) && __ANDROID_API__ < 21))
-    pthread_condattr_setclock(&(sem->condattr), CLOCK_MONOTONIC);
-#endif
-    pthread_cond_init(&(sem->cond), &(sem->condattr));
-    pthread_mutex_init(&(sem->mutex), NULL);
-  }
-  return sem;
-}
-
-err_t
-sys_sem_new(struct sys_sem **sem, u8_t count)
-{
-  SYS_STATS_INC_USED(sem);
-  *sem = sys_sem_new_internal(count);
-  if (*sem == NULL) {
-    return ERR_MEM;
-  }
-  return ERR_OK;
-}
-
-static u32_t
-cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex, u32_t timeout)
-{
-  struct timespec rtime1, rtime2, ts;
-  int ret;
-
-#ifdef __GNU__
-  #define pthread_cond_wait pthread_hurd_cond_wait_np
-  #define pthread_cond_timedwait pthread_hurd_cond_timedwait_np
-#endif
-
-  if (timeout == 0) {
-    pthread_cond_wait(cond, mutex);
-    return 0;
-  }
-
-  /* Get a timestamp and add the timeout value. */
-  get_monotonic_time(&rtime1);
-#if defined(LWIP_UNIX_MACH) || (defined(LWIP_UNIX_ANDROID) && __ANDROID_API__ < 21)
-  ts.tv_sec = timeout / 1000L;
-  ts.tv_nsec = (timeout % 1000L) * 1000000L;
-  ret = pthread_cond_timedwait_relative_np(cond, mutex, &ts);
-#else
-  ts.tv_sec = rtime1.tv_sec + timeout / 1000L;
-  ts.tv_nsec = rtime1.tv_nsec + (timeout % 1000L) * 1000000L;
-  if (ts.tv_nsec >= 1000000000L) {
-    ts.tv_sec++;
-    ts.tv_nsec -= 1000000000L;
-  }
-
-  ret = pthread_cond_timedwait(cond, mutex, &ts);
-#endif
-  if (ret == ETIMEDOUT) {
-    return SYS_ARCH_TIMEOUT;
-  }
-
-  /* Calculate for how long we waited for the cond. */
-  get_monotonic_time(&rtime2);
-  ts.tv_sec = rtime2.tv_sec - rtime1.tv_sec;
-  ts.tv_nsec = rtime2.tv_nsec - rtime1.tv_nsec;
-  if (ts.tv_nsec < 0) {
-    ts.tv_sec--;
-    ts.tv_nsec += 1000000000L;
-  }
-  return (u32_t)(ts.tv_sec * 1000L + ts.tv_nsec / 1000000L);
-}
-
-u32_t
-sys_arch_sem_wait(struct sys_sem **s, u32_t timeout)
-{
-  u32_t time_needed = 0;
-  struct sys_sem *sem;
-  LWIP_ASSERT("invalid sem", (s != NULL) && (*s != NULL));
-  sem = *s;
-
-  pthread_mutex_lock(&(sem->mutex));
-  while (sem->c <= 0) {
-    if (timeout > 0) {
-      time_needed = cond_wait(&(sem->cond), &(sem->mutex), timeout);
-
-      if (time_needed == SYS_ARCH_TIMEOUT) {
-        pthread_mutex_unlock(&(sem->mutex));
-        return SYS_ARCH_TIMEOUT;
-      }
-      /*      pthread_mutex_unlock(&(sem->mutex));
-              return time_needed; */
-    } else {
-      cond_wait(&(sem->cond), &(sem->mutex), 0);
-    }
-  }
-  sem->c--;
-  pthread_mutex_unlock(&(sem->mutex));
-  return (u32_t)time_needed;
-}
-
-void
-sys_sem_signal(struct sys_sem **s)
-{
-  struct sys_sem *sem;
-  LWIP_ASSERT("invalid sem", (s != NULL) && (*s != NULL));
-  sem = *s;
-
-  pthread_mutex_lock(&(sem->mutex));
-  sem->c++;
-
-  if (sem->c > 1) {
-    sem->c = 1;
-  }
-
-  pthread_cond_broadcast(&(sem->cond));
-  pthread_mutex_unlock(&(sem->mutex));
-}
-
-static void
-sys_sem_free_internal(struct sys_sem *sem)
-{
-  pthread_cond_destroy(&(sem->cond));
-  pthread_condattr_destroy(&(sem->condattr));
-  pthread_mutex_destroy(&(sem->mutex));
-  free(sem);
-}
-
-void
-sys_sem_free(struct sys_sem **sem)
-{
-  if ((sem != NULL) && (*sem != SYS_SEM_NULL)) {
-    SYS_STATS_DEC(sem.used);
-    sys_sem_free_internal(*sem);
-  }
-}
-
-/*-----------------------------------------------------------------------------------*/
-/* Mutex */
-/** Create a new mutex
- * @param mutex pointer to the mutex to create
- * @return a new mutex */
-err_t
-sys_mutex_new(struct sys_mutex **mutex)
-{
-  struct sys_mutex *mtx;
-
-  mtx = (struct sys_mutex *)malloc(sizeof(struct sys_mutex));
-  if (mtx != NULL) {
-    pthread_mutex_init(&(mtx->mutex), NULL);
-    *mutex = mtx;
-    return ERR_OK;
-  }
-  else {
-    return ERR_MEM;
-  }
-}
-
-/** Lock a mutex
- * @param mutex the mutex to lock */
-void
-sys_mutex_lock(struct sys_mutex **mutex)
-{
-  pthread_mutex_lock(&((*mutex)->mutex));
-}
-
-/** Unlock a mutex
- * @param mutex the mutex to unlock */
-void
-sys_mutex_unlock(struct sys_mutex **mutex)
-{
-  pthread_mutex_unlock(&((*mutex)->mutex));
-}
-
-/** Delete a mutex
- * @param mutex the mutex to delete */
-void
-sys_mutex_free(struct sys_mutex **mutex)
-{
-  pthread_mutex_destroy(&((*mutex)->mutex));
-  free(*mutex);
-}
-
-#endif /* !NO_SYS */
-
-/*-----------------------------------------------------------------------------------*/
-/* Time */
-u32_t
-sys_now(void)
-{
-  struct timespec ts;
-
-  get_monotonic_time(&ts);
-  return (u32_t)(ts.tv_sec * 1000L + ts.tv_nsec / 1000000L);
-}
-
-u32_t
-sys_jiffies(void)
-{
-  struct timespec ts;
-
-  get_monotonic_time(&ts);
-  return (u32_t)(ts.tv_sec * 1000000000L + ts.tv_nsec);
-}
-
-/*-----------------------------------------------------------------------------------*/
-/* Init */
-
-void
-sys_init(void)
-{
-}
-
-/*-----------------------------------------------------------------------------------*/
-/* Critical section */
-#if SYS_LIGHTWEIGHT_PROT
-/** sys_prot_t sys_arch_protect(void)
-
-This optional function does a "fast" critical region protection and returns
-the previous protection level. This function is only called during very short
-critical regions. An embedded system which supports ISR-based drivers might
-want to implement this function by disabling interrupts. Task-based systems
-might want to implement this by using a mutex or disabling tasking. This
-function should support recursive calls from the same task or interrupt. In
-other words, sys_arch_protect() could be called while already protected. In
-that case the return value indicates that it is already protected.
-
-sys_arch_protect() is only required if your port is supporting an operating
-system.
-*/
-sys_prot_t
-sys_arch_protect(void)
-{
-    /* Note that for the UNIX port, we are using a lightweight mutex, and our
-     * own counter (which is locked by the mutex). The return code is not actually
-     * used. */
-    if (lwprot_thread != pthread_self())
-    {
-        /* We are locking the mutex where it has not been locked before *
-        * or is being locked by another thread */
-        pthread_mutex_lock(&lwprot_mutex);
-        lwprot_thread = pthread_self();
-        lwprot_count = 1;
-    }
-    else
-        /* It is already locked by THIS thread */
-        lwprot_count++;
-    return 0;
-}
-
-/** void sys_arch_unprotect(sys_prot_t pval)
-
-This optional function does a "fast" set of critical region protection to the
-value specified by pval. See the documentation for sys_arch_protect() for
-more information. This function is only required if your port is supporting
-an operating system.
-*/
-void
-sys_arch_unprotect(sys_prot_t pval)
-{
-    LWIP_UNUSED_ARG(pval);
-    if (lwprot_thread == pthread_self())
-    {
-        lwprot_count--;
-        if (lwprot_count == 0)
-        {
-            lwprot_thread = (pthread_t) 0xDEAD;
-            pthread_mutex_unlock(&lwprot_mutex);
-        }
-    }
-}
-#endif /* SYS_LIGHTWEIGHT_PROT */
-
-/* get keyboard state to terminate the debug app by using select */
-int
-lwip_unix_keypressed(void)
-{
-  struct timeval tv = { 0L, 0L };
-  fd_set fds;
-  FD_ZERO(&fds);
-  FD_SET(0, &fds);
-  return select(1, &fds, NULL, NULL, &tv);
-}
diff --git a/contrib/ports/unix/setup-tapif b/contrib/ports/unix/setup-tapif
deleted file mode 100755
index d5c4935d..00000000
--- a/contrib/ports/unix/setup-tapif
+++ /dev/null
@@ -1,22 +0,0 @@
-#!/bin/bash
-
-# This script needs bridge-util debian package or similar
-# for other distros.
-
-# Run using "source setup-tapif" to get exported PRECONFIGURED_TAPIF variable
-# Alternatively, add "export PRECONFIGURED_TAPIF=tap0" to ~/.bashrc
-
-# http://backreference.org/2010/03/26/tuntap-interface-tutorial/
-
-# After executing this script, start example_app.
-# Enter 192.168.1.200 or "http://lwip.local/" (Zeroconf)
-# in your webbrowser to see example_app webpage.
-
-export PRECONFIGURED_TAPIF=tap0
-
-sudo ip tuntap add dev $PRECONFIGURED_TAPIF mode tap user `whoami`
-sudo ip link set $PRECONFIGURED_TAPIF up
-sudo brctl addbr lwipbridge
-sudo brctl addif lwipbridge $PRECONFIGURED_TAPIF
-sudo ip addr add 192.168.1.1/24 dev lwipbridge
-sudo ip link set dev lwipbridge up
diff --git a/contrib/ports/win32/Common.mk b/contrib/ports/win32/Common.mk
deleted file mode 100644
index 22601621..00000000
--- a/contrib/ports/win32/Common.mk
+++ /dev/null
@@ -1,51 +0,0 @@
-#
-# Copyright (c) 2001, 2002 Swedish Institute of Computer Science.
-# All rights reserved. 
-# 
-# Redistribution and use in source and binary forms, with or without modification, 
-# are permitted provided that the following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice,
-#    this list of conditions and the following disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright notice,
-#    this list of conditions and the following disclaimer in the documentation
-#    and/or other materials provided with the distribution.
-# 3. The name of the author may not be used to endorse or promote products
-#    derived from this software without specific prior written permission. 
-#
-# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
-# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
-# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
-# SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
-# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
-# OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
-# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
-# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
-# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# This file is part of the lwIP TCP/IP stack.
-# 
-# Author: Adam Dunkels <adam@sics.se>
-#
-
-CC=gcc
-
-# Architecture specific files.
-LWIPARCH?=$(CONTRIBDIR)/ports/win32
-SYSARCH?=$(LWIPARCH)/sys_arch.c
-ARCHFILES=$(SYSARCH) $(LWIPARCH)/pcapif.c \
-	$(LWIPARCH)/pcapif_helper.c $(LWIPARCH)/sio.c
-
-WIN32_COMMON_MK_DIR := $(dir $(abspath $(lastword $(MAKEFILE_LIST))))
-include $(WIN32_COMMON_MK_DIR)/../Common.allports.mk
-
-PCAPDIR=$(PCAP_DIR)/Include
-LDFLAGS+=-L$(PCAP_DIR)/lib -lwpcap -lpacket
-# -Wno-format: GCC complains about non-standard 64 bit modifier needed for MSVC runtime
-CFLAGS+=-I$(PCAPDIR) -Wno-format
-
-pcapif.o:
-	$(CC) $(CFLAGS) -Wno-error -Wno-redundant-decls -c $(<:.o=.c)
-pcapif_helper.o:
-	$(CC) $(CFLAGS) -std=c99 -Wno-redundant-decls -c $(<:.o=.c)
diff --git a/contrib/ports/win32/Filelists.cmake b/contrib/ports/win32/Filelists.cmake
deleted file mode 100644
index 7010b431..00000000
--- a/contrib/ports/win32/Filelists.cmake
+++ /dev/null
@@ -1,34 +0,0 @@
-# This file is indended to be included in end-user CMakeLists.txt
-# include(/path/to/Filelists.cmake)
-# It assumes the variable LWIP_CONTRIB_DIR is defined pointing to the
-# root path of lwIP/contrib sources.
-#
-# This file is NOT designed (on purpose) to be used as cmake
-# subdir via add_subdirectory()
-# The intention is to provide greater flexibility to users to
-# create their own targets using the *_SRCS variables.
-
-if(NOT ${CMAKE_VERSION} VERSION_LESS "3.10.0")
-    include_guard(GLOBAL)
-endif()
-
-set(lwipcontribportwindows_SRCS
-    ${LWIP_CONTRIB_DIR}/ports/win32/sys_arch.c
-    ${LWIP_CONTRIB_DIR}/ports/win32/sio.c
-    ${LWIP_CONTRIB_DIR}/ports/win32/pcapif.c
-    ${LWIP_CONTRIB_DIR}/ports/win32/pcapif_helper.c
-)
-
-# pcapif needs WinPcap developer package: https://www.winpcap.org/devel.htm
-if(NOT DEFINED WPDPACK_DIR)
-    set(WPDPACK_DIR ${LWIP_DIR}/../WpdPack)
-    message(STATUS "WPDPACK_DIR not set - using default location ${WPDPACK_DIR}")
-endif()
-find_library(WPCAP  wpcap  HINTS ${WPDPACK_DIR}/lib)
-find_library(PACKET packet HINTS ${WPDPACK_DIR}/lib)
-
-add_library(lwipcontribportwindows EXCLUDE_FROM_ALL ${lwipcontribportwindows_SRCS})
-target_include_directories(lwipcontribportwindows PRIVATE ${LWIP_INCLUDE_DIRS} "${WPDPACK_DIR}/include" ${LWIP_MBEDTLS_INCLUDE_DIRS})
-target_compile_options(lwipcontribportwindows PRIVATE ${LWIP_COMPILER_FLAGS})
-target_compile_definitions(lwipcontribaddons PRIVATE ${LWIP_DEFINITIONS} ${LWIP_MBEDTLS_DEFINITIONS})
-target_link_libraries(lwipcontribportwindows PUBLIC ${WPCAP} ${PACKET} ${LWIP_MBEDTLS_LINK_LIBRARIES})
diff --git a/contrib/ports/win32/check/check_stdint.h b/contrib/ports/win32/check/check_stdint.h
deleted file mode 100644
index c2c100d5..00000000
--- a/contrib/ports/win32/check/check_stdint.h
+++ /dev/null
@@ -1 +0,0 @@
-/* deliberateliy empty */
diff --git a/contrib/ports/win32/check/config.h b/contrib/ports/win32/check/config.h
deleted file mode 100644
index 69c04f9b..00000000
--- a/contrib/ports/win32/check/config.h
+++ /dev/null
@@ -1,30 +0,0 @@
-/* config.h for check-0.11.0 on win32 under MSVC/MinGW */
-
-#ifdef _MSC_VER
-
-typedef unsigned int pid_t;
-typedef unsigned int uint32_t;
-
-typedef int ssize_t;
-#define snprintf _snprintf
-
-#define HAVE_DECL_STRDUP 1
-#define HAVE_DECL_FILENO 1
-#define HAVE_DECL_PUTENV 1
-
-#define _CRT_SECURE_NO_WARNINGS
-
-/* disable some warnings */
-#pragma warning (disable: 4090) /* const assigned to non-const */
-#pragma warning (disable: 4996) /* fileno is deprecated */
-
-#endif /* _ MSC_VER */
-
-
-#define LWIP_UNITTESTS_NOFORK
-
-#include <io.h>
-
-typedef unsigned int clockid_t;
-typedef unsigned int timer_t;
-#define STRUCT_TIMESPEC_DEFINITION_MISSING
diff --git a/contrib/ports/win32/check/stdbool.h b/contrib/ports/win32/check/stdbool.h
deleted file mode 100644
index 1f504d91..00000000
--- a/contrib/ports/win32/check/stdbool.h
+++ /dev/null
@@ -1,9 +0,0 @@
-#ifndef MY_STDBOOL_H
-#define MY_STDBOOL_H
-
-typedef int bool;
-#define true 1
-#define false 0
-#define __bool_true_false_are_defined 1
-
-#endif
diff --git a/contrib/ports/win32/check/sys/time.h b/contrib/ports/win32/check/sys/time.h
deleted file mode 100644
index d71d827d..00000000
--- a/contrib/ports/win32/check/sys/time.h
+++ /dev/null
@@ -1,12 +0,0 @@
-#ifndef LWIP_SYS__TIME_H
-#define LWIP_SYS__TIME_H
-
-#include <stdlib.h> /* time_t */
-
-struct timeval {
-  time_t    tv_sec;         /* seconds */
-  long    tv_usec;        /* and microseconds */
-};
-int gettimeofday(struct timeval* tp, void* tzp);
-
-#endif
diff --git a/contrib/ports/win32/check/time.c b/contrib/ports/win32/check/time.c
deleted file mode 100644
index b5947cd9..00000000
--- a/contrib/ports/win32/check/time.c
+++ /dev/null
@@ -1,66 +0,0 @@
-#include <time.h>
-
-#include <windows.h>
-#if defined(_MSC_VER) || defined(_MSC_EXTENSIONS)
-  #define DELTA_EPOCH_IN_MICROSECS  11644473600000000Ui64
-#else
-  #define DELTA_EPOCH_IN_MICROSECS  11644473600000000ULL
-#endif
-
-#include "config.h"
-
-struct timezone
-{
-  int tz_minuteswest; /* minutes W of Greenwich */
-  int tz_dsttime;     /* type of dst correction */
-};
-
-int gettimeofday(struct timeval *tv, struct timezone *tz)
-{
-  FILETIME ft;
-  unsigned __int64 tmpres = 0;
-  static int tzflag;
-
-  if (NULL != tv) {
-    GetSystemTimeAsFileTime(&ft);
-
-    tmpres |= ft.dwHighDateTime;
-    tmpres <<= 32;
-    tmpres |= ft.dwLowDateTime;
-
-    /*converting file time to unix epoch*/
-    tmpres -= DELTA_EPOCH_IN_MICROSECS;
-    tmpres /= 10;  /*convert into microseconds*/
-    tv->tv_sec = (long)(tmpres / 1000000UL);
-    tv->tv_usec = (long)(tmpres % 1000000UL);
-  }
-
-  if (NULL != tz) {
-    if (!tzflag) {
-      _tzset();
-      tzflag++;
-    }
-    tz->tz_minuteswest = _timezone / 60;
-    tz->tz_dsttime = _daylight;
-  }
-
-  return 0;
-}
-
-struct tm *
-localtime_r(const time_t *timer, struct tm *result)
-{
-  struct tm *local_result;
-
-  if (result == NULL) {
-    return NULL;
-  }
-
-  local_result = localtime (timer);
-  if (local_result == NULL) {
-    return NULL;
-  }
-
-  memcpy(result, local_result, sizeof(*result));
-  return result;
-}
diff --git a/contrib/ports/win32/check/unistd.h b/contrib/ports/win32/check/unistd.h
deleted file mode 100644
index 332e6e12..00000000
--- a/contrib/ports/win32/check/unistd.h
+++ /dev/null
@@ -1,7 +0,0 @@
-#ifndef LWIP_UNISTD_H
-#define LWIP_UNISTD_H
-
-/* include io.h for read() and write() */
-#include <io.h>
-
-#endif
diff --git a/contrib/ports/win32/example_app/CMakeLists.txt b/contrib/ports/win32/example_app/CMakeLists.txt
deleted file mode 100644
index 417e2a48..00000000
--- a/contrib/ports/win32/example_app/CMakeLists.txt
+++ /dev/null
@@ -1,23 +0,0 @@
-include(${LWIP_DIR}/contrib/ports/CMakeCommon.cmake)
-
-set (LWIP_INCLUDE_DIRS
-    "${LWIP_DIR}/src/include"
-    "${LWIP_DIR}/contrib/"
-    "${LWIP_DIR}/contrib/ports/win32/include"
-    "${LWIP_DIR}/contrib/examples/example_app"
-)
-
-include(${LWIP_DIR}/src/Filelists.cmake)
-include(${LWIP_DIR}/contrib/Filelists.cmake)
-include(${LWIP_DIR}/contrib/ports/win32/Filelists.cmake)
-
-add_executable(example_app ${LWIP_DIR}/contrib/examples/example_app/test.c default_netif.c)
-target_include_directories(example_app PRIVATE ${LWIP_INCLUDE_DIRS})
-target_compile_options(example_app PRIVATE ${LWIP_COMPILER_FLAGS})
-target_compile_definitions(example_app PRIVATE ${LWIP_DEFINITIONS} ${LWIP_MBEDTLS_DEFINITIONS})
-target_link_libraries(example_app ${LWIP_SANITIZER_LIBS} lwipcontribexamples lwipcontribapps lwipcontribaddons lwipallapps lwipcore lwipcontribportwindows lwipmbedtls)
-
-add_executable(makefsdata ${lwipmakefsdata_SRCS})
-target_compile_options(makefsdata PRIVATE ${LWIP_COMPILER_FLAGS})
-target_include_directories(makefsdata PRIVATE ${LWIP_INCLUDE_DIRS})
-target_link_libraries(makefsdata ${LWIP_SANITIZER_LIBS} lwipcore lwipcontribportwindows)
diff --git a/contrib/ports/win32/example_app/Makefile b/contrib/ports/win32/example_app/Makefile
deleted file mode 100644
index 452af7a9..00000000
--- a/contrib/ports/win32/example_app/Makefile
+++ /dev/null
@@ -1,55 +0,0 @@
-#
-# Copyright (c) 2001, 2002 Swedish Institute of Computer Science.
-# All rights reserved. 
-# 
-# Redistribution and use in source and binary forms, with or without modification, 
-# are permitted provided that the following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice,
-#    this list of conditions and the following disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright notice,
-#    this list of conditions and the following disclaimer in the documentation
-#    and/or other materials provided with the distribution.
-# 3. The name of the author may not be used to endorse or promote products
-#    derived from this software without specific prior written permission. 
-#
-# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
-# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
-# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
-# SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
-# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
-# OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
-# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
-# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
-# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
-# OF SUCH DAMAGE.
-#
-# This file is part of the lwIP TCP/IP stack.
-# 
-# Author: Adam Dunkels <adam@sics.se>
-#
-
-all compile: example_app makefsdata
-.PHONY: all
-
-include ../Common.mk
-
-CFLAGS+=-I$(CONTRIBDIR)/examples/example_app
-
-MAKEFSDATAOBJS=$(notdir $(MAKEFSDATAFILES:.c=.o))
-
-clean:
-	cmd /c del /q *.o $(LWIPLIBCOMMON) $(APPLIB) test.exe *.s .depend* *.map
-
-depend dep: .depend
-
-include .depend
-
-.depend: $(CONTRIBDIR)/examples/example_app/test.c default_netif.c $(LWIPFILES) $(APPFILES) $(MAKEFSDATAFILES)
-	$(CCDEP) $(CFLAGS) -MM $^ > .depend || cmd /c del .depend
-
-example_app: .depend $(LWIPLIBCOMMON) $(APPLIB) default_netif.o test.o
-	$(CC) $(CFLAGS) -o example_app test.o default_netif.o -Wl,--start-group $(APPLIB) $(LWIPLIBCOMMON) -Wl,--end-group $(LDFLAGS) -Xlinker -Map=test.map
-
-makefsdata: .depend $(MAKEFSDATAOBJS)
-	$(CC) $(CFLAGS) -o makefsdata $(MAKEFSDATAOBJS)
diff --git a/contrib/ports/win32/example_app/default_netif.c b/contrib/ports/win32/example_app/default_netif.c
deleted file mode 100644
index 89083c51..00000000
--- a/contrib/ports/win32/example_app/default_netif.c
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-
-#include "lwip/opt.h"
-
-#include "lwip/netif.h"
-#include "lwip/ip_addr.h"
-#include "lwip/tcpip.h"
-#include "../pcapif.h"
-#include "examples/example_app/default_netif.h"
-
-static struct netif netif;
-
-#if LWIP_IPV4
-#define NETIF_ADDRS ipaddr, netmask, gw,
-void init_default_netif(const ip4_addr_t *ipaddr, const ip4_addr_t *netmask, const ip4_addr_t *gw)
-#else
-#define NETIF_ADDRS
-void init_default_netif(void)
-#endif
-{
-#if NO_SYS
-  netif_add(&netif, NETIF_ADDRS NULL, pcapif_init, netif_input);
-#else  /* NO_SYS */
-  netif_add(&netif, NETIF_ADDRS NULL, pcapif_init, tcpip_input);
-#endif /* NO_SYS */
-  netif_set_default(&netif);
-}
-
-void
-default_netif_poll(void)
-{
-#if !PCAPIF_RX_USE_THREAD
-  /* check for packets and link status*/
-  pcapif_poll(&netif);
-  /* When pcapif_poll comes back, there are not packets, so sleep to
-     prevent 100% CPU load. Don't do this in an embedded system since it
-     increases latency! */
-  sys_msleep(1);
-#else /* !PCAPIF_RX_USE_THREAD */
-  sys_msleep(50);
-#endif /* !PCAPIF_RX_USE_THREAD */
-}
-
-void
-default_netif_shutdown(void)
-{
-  /* release the pcap library... */
-  pcapif_shutdown(&netif);
-}
diff --git a/contrib/ports/win32/include/arch/bpstruct.h b/contrib/ports/win32/include/arch/bpstruct.h
deleted file mode 100644
index 1d81e3f7..00000000
--- a/contrib/ports/win32/include/arch/bpstruct.h
+++ /dev/null
@@ -1 +0,0 @@
-#pragma pack(push,1)
diff --git a/contrib/ports/win32/include/arch/cc.h b/contrib/ports/win32/include/arch/cc.h
deleted file mode 100644
index 37ed83d6..00000000
--- a/contrib/ports/win32/include/arch/cc.h
+++ /dev/null
@@ -1,110 +0,0 @@
-/*
- * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-#ifndef LWIP_ARCH_CC_H
-#define LWIP_ARCH_CC_H
-
-#ifdef _MSC_VER
-#pragma warning (disable: 4127) /* conditional expression is constant */
-#pragma warning (disable: 4996) /* 'strncpy' was declared deprecated */
-#pragma warning (disable: 4103) /* structure packing changed by including file */
-#pragma warning (disable: 4820) /* 'x' bytes padding added after data member 'y' */
-#pragma warning (disable: 4711) /* The compiler performed inlining on the given function, although it was not marked for inlining */
-#endif
-
-#ifdef _MSC_VER
-#if _MSC_VER >= 1910
-#include <errno.h> /* use MSVC errno for >= 2017 */
-#else
-#define LWIP_PROVIDE_ERRNO /* provide errno for MSVC pre-2017 */
-#endif
-#else /* _MSC_VER */
-#define LWIP_PROVIDE_ERRNO /* provide errno for non-MSVC */
-#endif /* _MSC_VER */
-
-/* Define platform endianness (might already be defined) */
-#ifndef BYTE_ORDER
-#define BYTE_ORDER LITTLE_ENDIAN
-#endif /* BYTE_ORDER */
-
-typedef int sys_prot_t;
-
-#ifdef _MSC_VER
-/* define _INTPTR for Win32 MSVC stdint.h */
-#define _INTPTR 2
-
-/* Do not use lwIP default definitions for format strings
- * because these do not work with MSVC 2010 compiler (no inttypes.h)
- */
-#define LWIP_NO_INTTYPES_H 1
-
-/* Define (sn)printf formatters for these lwIP types */
-#define X8_F  "02x"
-#define U16_F "hu"
-#define U32_F "lu"
-#define S32_F "ld"
-#define X32_F "lx"
-
-#define S16_F "hd"
-#define X16_F "hx"
-#define SZT_F "lu"
-#endif /* _MSC_VER */
-
-/* Compiler hints for packing structures */
-#define PACK_STRUCT_USE_INCLUDES
-
-#define LWIP_ERROR(message, expression, handler) do { if (!(expression)) { \
-  LWIP_PLATFORM_DIAG(("Assertion \"%s\" failed at line %d in %s\n", message, __LINE__, __FILE__)); \
-  handler;} } while(0)
-
-#ifdef _MSC_VER
-/* C runtime functions redefined */
-#if _MSC_VER < 1910
-#define snprintf _snprintf
-#endif
-#define strdup   _strdup
-#endif
-
-/* Define an example for LWIP_PLATFORM_DIAG: since this uses varargs and the old
-* C standard lwIP targets does not support this in macros, we have extra brackets
-* around the arguments, which are left out in the following macro definition:
-*/
-#if !defined(LWIP_TESTMODE) || !LWIP_TESTMODE
-void lwip_win32_platform_diag(const char *format, ...);
-#define LWIP_PLATFORM_DIAG(x) lwip_win32_platform_diag x
-#endif
-
-extern unsigned int lwip_port_rand(void);
-#define LWIP_RAND() (lwip_port_rand())
-
-#define PPP_INCLUDE_SETTINGS_HEADER
-
-#endif /* LWIP_ARCH_CC_H */
diff --git a/contrib/ports/win32/include/arch/epstruct.h b/contrib/ports/win32/include/arch/epstruct.h
deleted file mode 100644
index 65898b54..00000000
--- a/contrib/ports/win32/include/arch/epstruct.h
+++ /dev/null
@@ -1 +0,0 @@
-#pragma pack(pop)
diff --git a/contrib/ports/win32/include/arch/perf.h b/contrib/ports/win32/include/arch/perf.h
deleted file mode 100644
index d1150b1d..00000000
--- a/contrib/ports/win32/include/arch/perf.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright (c) 2001, Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the Institute nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-#ifndef LWIP_PERF_H
-#define LWIP_PERF_H
-
-#define PERF_START    /* null definition */
-#define PERF_STOP(x)  /* null definition */
-
-#endif /* LWIP_PERF_H */
diff --git a/contrib/ports/win32/include/arch/sys_arch.h b/contrib/ports/win32/include/arch/sys_arch.h
deleted file mode 100644
index 037f9783..00000000
--- a/contrib/ports/win32/include/arch/sys_arch.h
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Adam Dunkels <adam@sics.se>
- *
- */
-#ifndef LWIP_ARCH_SYS_ARCH_H
-#define LWIP_ARCH_SYS_ARCH_H
-
-/* HANDLE is used for sys_sem_t but we won't include windows.h */
-struct _sys_sem {
-  void *sem;
-};
-typedef struct _sys_sem sys_sem_t;
-#define sys_sem_valid_val(sema) (((sema).sem != NULL)  && ((sema).sem != (void*)-1))
-#define sys_sem_valid(sema) (((sema) != NULL) && sys_sem_valid_val(*(sema)))
-#define sys_sem_set_invalid(sema) ((sema)->sem = NULL)
-
-/* HANDLE is used for sys_mutex_t but we won't include windows.h */
-struct _sys_mut {
-  void *mut;
-};
-typedef struct _sys_mut sys_mutex_t;
-#define sys_mutex_valid_val(mutex) (((mutex).mut != NULL)  && ((mutex).mut != (void*)-1))
-#define sys_mutex_valid(mutex) (((mutex) != NULL) && sys_mutex_valid_val(*(mutex)))
-#define sys_mutex_set_invalid(mutex) ((mutex)->mut = NULL)
-
-#ifndef MAX_QUEUE_ENTRIES
-#define MAX_QUEUE_ENTRIES 100
-#endif
-struct lwip_mbox {
-  void* sem;
-  void* q_mem[MAX_QUEUE_ENTRIES];
-  u32_t head, tail;
-};
-typedef struct lwip_mbox sys_mbox_t;
-#define SYS_MBOX_NULL NULL
-#define sys_mbox_valid_val(mbox) (((mbox).sem != NULL)  && ((mbox).sem != (void*)-1))
-#define sys_mbox_valid(mbox) ((mbox != NULL) && sys_mbox_valid_val(*(mbox)))
-#define sys_mbox_set_invalid(mbox) ((mbox)->sem = NULL)
-
-/* DWORD (thread id) is used for sys_thread_t but we won't include windows.h */
-typedef u32_t sys_thread_t;
-
-sys_sem_t* sys_arch_netconn_sem_get(void);
-void sys_arch_netconn_sem_alloc(void);
-void sys_arch_netconn_sem_free(void);
-#define LWIP_NETCONN_THREAD_SEM_GET()   sys_arch_netconn_sem_get()
-#define LWIP_NETCONN_THREAD_SEM_ALLOC() sys_arch_netconn_sem_alloc()
-#define LWIP_NETCONN_THREAD_SEM_FREE()  sys_arch_netconn_sem_free()
-
-#define LWIP_EXAMPLE_APP_ABORT() lwip_win32_keypressed()
-int lwip_win32_keypressed(void);
-
-#endif /* LWIP_ARCH_SYS_ARCH_H */
diff --git a/contrib/ports/win32/msvc/build_coverity.cmd b/contrib/ports/win32/msvc/build_coverity.cmd
deleted file mode 100644
index f96cc632..00000000
--- a/contrib/ports/win32/msvc/build_coverity.cmd
+++ /dev/null
@@ -1,26 +0,0 @@
-@echo off
-rem Usage: pass the path to cov-build.exe (with trailing backslash, without the exe) as first parameter
-rem ATTENTION: this deletes the output folder "cov-int" and the output file "cov-int.zip" first!
-
-set devenv="%ProgramFiles%\Microsoft Visual Studio 10.0\Common7\IDE\devenv.exe"
-if not exist %devenv% set devenv="%ProgramFiles%\Microsoft Visual Studio 10.0\Common7\IDE\vcexpress.exe"
-if not exist %devenv% set devenv="%ProgramFiles(x86)%\Microsoft Visual Studio 10.0\Common7\IDE\devenv.exe"
-if not exist %devenv% set devenv="%ProgramFiles(x86)%\Microsoft Visual Studio 10.0\Common7\IDE\vcexpress.exe"
-set covbuild=%1cov-build.exe
-set covoutput=cov-int
-set zip7="c:\Program Files\7-Zip\7z.exe"
-
-pushd %~dp0
-
-if exist %covoutput% rd /s /q %covoutput%
-if exist %covoutput%.zip del %covoutput%.zip
-
-%covbuild% --dir %covoutput% %devenv% lwip_test.sln /build Debug || goto error
-
-if exist %zip7% goto dozip
-echo error: 7zip not found at \"%zip7%
-goto error
-:dozip
-%zip7% a %covoutput%.zip %covoutput%
-:error
-popd
\ No newline at end of file
diff --git a/contrib/ports/win32/msvc/libcheck.vcxproj b/contrib/ports/win32/msvc/libcheck.vcxproj
deleted file mode 100644
index e63731e8..00000000
--- a/contrib/ports/win32/msvc/libcheck.vcxproj
+++ /dev/null
@@ -1,100 +0,0 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup Label="ProjectConfigurations">
-    <ProjectConfiguration Include="Debug|Win32">
-      <Configuration>Debug</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|Win32">
-      <Configuration>Release</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-  </ItemGroup>
-  <PropertyGroup Label="Globals">
-    <ProjectGuid>{EBB156DC-01BF-47B2-B69C-1A750B6B5F09}</ProjectGuid>
-    <RootNamespace>libcheck</RootNamespace>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
-    <ConfigurationType>StaticLibrary</ConfigurationType>
-    <CharacterSet>MultiByte</CharacterSet>
-    <WholeProgramOptimization>true</WholeProgramOptimization>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
-    <ConfigurationType>StaticLibrary</ConfigurationType>
-    <CharacterSet>MultiByte</CharacterSet>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
-  <ImportGroup Label="ExtensionSettings">
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <PropertyGroup Label="UserMacros" />
-  <PropertyGroup>
-    <_ProjectFileVersion>10.0.40219.1</_ProjectFileVersion>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(Configuration)\$(ProjectName)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(Configuration)\$(ProjectName)\</IntDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(Configuration)\$(ProjectName)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(Configuration)\$(ProjectName)\</IntDir>
-  </PropertyGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
-    <ClCompile>
-      <Optimization>Disabled</Optimization>
-      <AdditionalIncludeDirectories>..\check;..\..\..\..\..\check\src;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>_LIB;WIN32;_DEBUG;HAVE_CONFIG_H;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <MinimalRebuild>true</MinimalRebuild>
-      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
-      <WarningLevel>Level3</WarningLevel>
-      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
-    </ClCompile>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
-    <ClCompile>
-      <Optimization>MaxSpeed</Optimization>
-      <IntrinsicFunctions>true</IntrinsicFunctions>
-      <AdditionalIncludeDirectories>..\check;..\..\..\..\..\check\src;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;HAVE_CONFIG_H;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
-      <FunctionLevelLinking>true</FunctionLevelLinking>
-      <WarningLevel>Level3</WarningLevel>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-    </ClCompile>
-  </ItemDefinitionGroup>
-  <ItemGroup>
-    <ClInclude Include="..\..\..\..\..\check\lib\libcompat.h" />
-    <ClInclude Include="..\check\config.h" />
-    <ClInclude Include="..\check\unistd.h" />
-    <ClInclude Include="..\check\sys\time.h" />
-    <ClInclude Include="..\..\..\..\..\check\src\check.h" />
-    <ClInclude Include="..\..\..\..\..\check\src\check_error.h" />
-    <ClInclude Include="..\..\..\..\..\check\src\check_impl.h" />
-    <ClInclude Include="..\..\..\..\..\check\src\check_list.h" />
-    <ClInclude Include="..\..\..\..\..\check\src\check_log.h" />
-    <ClInclude Include="..\..\..\..\..\check\src\check_msg.h" />
-    <ClInclude Include="..\..\..\..\..\check\src\check_pack.h" />
-    <ClInclude Include="..\..\..\..\..\check\src\check_print.h" />
-    <ClInclude Include="..\..\..\..\..\check\src\check_str.h" />
-  </ItemGroup>
-  <ItemGroup>
-    <ClCompile Include="..\..\..\..\..\check\lib\clock_gettime.c" />
-    <ClCompile Include="..\..\..\..\..\check\lib\libcompat.c" />
-    <ClCompile Include="..\check\time.c" />
-    <ClCompile Include="..\..\..\..\..\check\src\check.c" />
-    <ClCompile Include="..\..\..\..\..\check\src\check_error.c" />
-    <ClCompile Include="..\..\..\..\..\check\src\check_list.c" />
-    <ClCompile Include="..\..\..\..\..\check\src\check_log.c" />
-    <ClCompile Include="..\..\..\..\..\check\src\check_msg.c" />
-    <ClCompile Include="..\..\..\..\..\check\src\check_pack.c" />
-    <ClCompile Include="..\..\..\..\..\check\src\check_print.c" />
-    <ClCompile Include="..\..\..\..\..\check\src\check_run.c" />
-    <ClCompile Include="..\..\..\..\..\check\src\check_str.c" />
-  </ItemGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
-  <ImportGroup Label="ExtensionTargets">
-  </ImportGroup>
-</Project>
\ No newline at end of file
diff --git a/contrib/ports/win32/msvc/libcheck.vcxproj.filters b/contrib/ports/win32/msvc/libcheck.vcxproj.filters
deleted file mode 100644
index d8bfdfce..00000000
--- a/contrib/ports/win32/msvc/libcheck.vcxproj.filters
+++ /dev/null
@@ -1,96 +0,0 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup>
-    <Filter Include="Win32">
-      <UniqueIdentifier>{05d172f9-8ca6-4d9c-96e4-2b0480a8222f}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="Win32\sys">
-      <UniqueIdentifier>{eb9ccf88-7e08-4202-bb4f-5a51443fa480}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="src">
-      <UniqueIdentifier>{3f044d95-ab52-45ce-b4ae-27797eb221b2}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="libcompat">
-      <UniqueIdentifier>{abb21abe-51c2-45df-bdc9-8e00ce7fe404}</UniqueIdentifier>
-    </Filter>
-  </ItemGroup>
-  <ItemGroup>
-    <ClInclude Include="..\check\config.h">
-      <Filter>Win32</Filter>
-    </ClInclude>
-    <ClInclude Include="..\check\unistd.h">
-      <Filter>Win32</Filter>
-    </ClInclude>
-    <ClInclude Include="..\check\sys\time.h">
-      <Filter>Win32\sys</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\..\check\src\check.h">
-      <Filter>src</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\..\check\src\check_error.h">
-      <Filter>src</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\..\check\src\check_impl.h">
-      <Filter>src</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\..\check\src\check_list.h">
-      <Filter>src</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\..\check\src\check_log.h">
-      <Filter>src</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\..\check\src\check_msg.h">
-      <Filter>src</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\..\check\src\check_pack.h">
-      <Filter>src</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\..\check\src\check_print.h">
-      <Filter>src</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\..\check\src\check_str.h">
-      <Filter>src</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\..\check\lib\libcompat.h">
-      <Filter>libcompat</Filter>
-    </ClInclude>
-  </ItemGroup>
-  <ItemGroup>
-    <ClCompile Include="..\check\time.c">
-      <Filter>Win32</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\..\check\src\check.c">
-      <Filter>src</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\..\check\src\check_error.c">
-      <Filter>src</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\..\check\src\check_list.c">
-      <Filter>src</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\..\check\src\check_log.c">
-      <Filter>src</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\..\check\src\check_msg.c">
-      <Filter>src</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\..\check\src\check_pack.c">
-      <Filter>src</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\..\check\src\check_print.c">
-      <Filter>src</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\..\check\src\check_run.c">
-      <Filter>src</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\..\check\src\check_str.c">
-      <Filter>src</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\..\check\lib\libcompat.c">
-      <Filter>libcompat</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\..\check\lib\clock_gettime.c">
-      <Filter>libcompat</Filter>
-    </ClCompile>
-  </ItemGroup>
-</Project>
\ No newline at end of file
diff --git a/contrib/ports/win32/msvc/lwIP.vcxproj b/contrib/ports/win32/msvc/lwIP.vcxproj
deleted file mode 100644
index 00045921..00000000
--- a/contrib/ports/win32/msvc/lwIP.vcxproj
+++ /dev/null
@@ -1,589 +0,0 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup Label="ProjectConfigurations">
-    <ProjectConfiguration Include="Debug unittests|Win32">
-      <Configuration>Debug unittests</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Debug|Win32">
-      <Configuration>Debug</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Release unittests|Win32">
-      <Configuration>Release unittests</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|Win32">
-      <Configuration>Release</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-  </ItemGroup>
-  <PropertyGroup Label="Globals">
-    <ProjectGuid>{2CC276FA-B226-49C9-8F82-7FCD5A228E28}</ProjectGuid>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release unittests|Win32'" Label="Configuration">
-    <ConfigurationType>StaticLibrary</ConfigurationType>
-    <UseOfMfc>false</UseOfMfc>
-    <CharacterSet>MultiByte</CharacterSet>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug unittests|Win32'" Label="Configuration">
-    <ConfigurationType>StaticLibrary</ConfigurationType>
-    <UseOfMfc>false</UseOfMfc>
-    <CharacterSet>MultiByte</CharacterSet>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
-    <ConfigurationType>StaticLibrary</ConfigurationType>
-    <UseOfMfc>false</UseOfMfc>
-    <CharacterSet>MultiByte</CharacterSet>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
-    <ConfigurationType>StaticLibrary</ConfigurationType>
-    <UseOfMfc>false</UseOfMfc>
-    <CharacterSet>MultiByte</CharacterSet>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
-  <ImportGroup Label="ExtensionSettings">
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release unittests|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug unittests|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
-  </ImportGroup>
-  <PropertyGroup Label="UserMacros" />
-  <PropertyGroup>
-    <_ProjectFileVersion>10.0.40219.1</_ProjectFileVersion>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(Configuration)\$(ProjectName)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(Configuration)\$(ProjectName)\</IntDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug unittests|Win32'">$(Configuration)\$(ProjectName)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug unittests|Win32'">$(Configuration)\$(ProjectName)\</IntDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release unittests|Win32'">$(Configuration)\$(ProjectName)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release unittests|Win32'">$(Configuration)\$(ProjectName)\</IntDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(Configuration)\$(ProjectName)\</IntDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(Configuration)\$(ProjectName)\</OutDir>
-  </PropertyGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
-    <ClCompile>
-      <Optimization>MaxSpeed</Optimization>
-      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
-      <AdditionalIncludeDirectories>..\..\..\..\src\include;..\..\..\..\src\include\ipv4;..\..\..\..\src\include\ipv6;..\include;..\..\..\examples\example_app;..\..\..\apps\snmp_private_mib;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
-      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
-      <FunctionLevelLinking>true</FunctionLevelLinking>
-      <ProgramDataBaseFileName>$(IntDir)$(ProjectName).pdb</ProgramDataBaseFileName>
-      <WarningLevel>EnableAllWarnings</WarningLevel>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-      <CompileAs>Default</CompileAs>
-      <TreatWarningAsError>true</TreatWarningAsError>
-    </ClCompile>
-    <ResourceCompile>
-      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <Culture>0x0407</Culture>
-    </ResourceCompile>
-    <Lib>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-    </Lib>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
-    <ClCompile>
-      <Optimization>Disabled</Optimization>
-      <AdditionalIncludeDirectories>..\..\..\..\src\include;..\..\..\..\src\include\ipv4;..\..\..\..\src\include\ipv6;..\include;..\..\..\examples\example_app;..\..\..\apps\snmp_private_mib;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>_LIB;WIN32;_DEBUG;LWIP_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <ProgramDataBaseFileName>$(IntDir)$(ProjectName).pdb</ProgramDataBaseFileName>
-      <WarningLevel>EnableAllWarnings</WarningLevel>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
-      <CompileAs>Default</CompileAs>
-      <TreatWarningAsError>true</TreatWarningAsError>
-    </ClCompile>
-    <ResourceCompile>
-      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <Culture>0x0407</Culture>
-    </ResourceCompile>
-    <Lib>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-    </Lib>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug unittests|Win32'">
-    <ClCompile>
-      <Optimization>Disabled</Optimization>
-      <AdditionalIncludeDirectories>..\..\..\..\test\unit;..\..\..\..\src\include;..\..\..\..\src\include\ipv4;..\..\..\..\src\include\ipv6;..\include;..\..\..\examples\example_app;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>_LIB;WIN32;_DEBUG;LWIP_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <ProgramDataBaseFileName>$(IntDir)$(ProjectName).pdb</ProgramDataBaseFileName>
-      <WarningLevel>EnableAllWarnings</WarningLevel>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
-      <CompileAs>Default</CompileAs>
-      <TreatWarningAsError>true</TreatWarningAsError>
-    </ClCompile>
-    <ResourceCompile>
-      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <Culture>0x0407</Culture>
-    </ResourceCompile>
-    <Lib>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-    </Lib>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release unittests|Win32'">
-    <ClCompile>
-      <Optimization>MaxSpeed</Optimization>
-      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
-      <AdditionalIncludeDirectories>..\..\..\..\test\unit;..\..\..\..\src\include;..\..\..\..\src\include\ipv4;..\..\..\..\src\include\ipv6;..\include;..\..\..\examples\example_app;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
-      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
-      <FunctionLevelLinking>true</FunctionLevelLinking>
-      <ProgramDataBaseFileName>$(IntDir)$(ProjectName).pdb</ProgramDataBaseFileName>
-      <WarningLevel>EnableAllWarnings</WarningLevel>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-      <CompileAs>Default</CompileAs>
-      <TreatWarningAsError>true</TreatWarningAsError>
-    </ClCompile>
-    <ResourceCompile>
-      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <Culture>0x0407</Culture>
-    </ResourceCompile>
-    <Lib>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-    </Lib>
-  </ItemDefinitionGroup>
-  <ItemGroup>
-    <CustomBuildStep Include="..\..\..\..\doc\contrib.txt">
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug unittests|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release unittests|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
-    </CustomBuildStep>
-    <CustomBuildStep Include="..\..\..\..\doc\FILES">
-      <FileType>Document</FileType>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug unittests|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release unittests|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
-    </CustomBuildStep>
-    <CustomBuildStep Include="..\..\..\..\doc\rawapi.txt">
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug unittests|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release unittests|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
-    </CustomBuildStep>
-    <CustomBuildStep Include="..\..\..\..\doc\savannah.txt">
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug unittests|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release unittests|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
-    </CustomBuildStep>
-    <CustomBuildStep Include="..\..\..\..\doc\snmp_agent.txt">
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug unittests|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release unittests|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
-    </CustomBuildStep>
-    <CustomBuildStep Include="..\..\..\..\doc\sys_arch.txt">
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug unittests|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release unittests|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
-    </CustomBuildStep>
-    <CustomBuildStep Include="..\..\..\..\src\core\ipv6\README">
-      <FileType>Document</FileType>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug unittests|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release unittests|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
-    </CustomBuildStep>
-    <CustomBuildStep Include="..\..\..\..\src\netif\FILES">
-      <FileType>Document</FileType>
-    </CustomBuildStep>
-    <CustomBuildStep Include="..\lwipcfg_msvc.h.example">
-      <FileType>Document</FileType>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug unittests|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release unittests|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
-    </CustomBuildStep>
-    <None Include="..\..\..\..\CHANGELOG" />
-    <None Include="..\..\..\..\COPYING" />
-    <None Include="..\..\..\..\doc\contrib.txt" />
-    <None Include="..\..\..\..\doc\doxygen\generate.bat" />
-    <None Include="..\..\..\..\doc\doxygen\generate.sh" />
-    <None Include="..\..\..\..\doc\doxygen\lwip.Doxyfile" />
-    <None Include="..\..\..\..\doc\FILES" />
-    <None Include="..\..\..\..\doc\mdns.txt" />
-    <None Include="..\..\..\..\doc\ppp.txt" />
-    <None Include="..\..\..\..\doc\savannah.txt" />
-    <None Include="..\..\..\..\FILES" />
-    <None Include="..\..\..\..\README" />
-    <None Include="..\..\..\..\UPGRADING" />
-    <None Include="..\..\..\examples\example_app\lwipcfg.h.example">
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug unittests|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release unittests|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
-    </None>
-  </ItemGroup>
-  <ItemGroup>
-    <ClCompile Include="..\..\..\..\doc\NO_SYS_SampleCode.c">
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug unittests|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release unittests|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\api\api_lib.c" />
-    <ClCompile Include="..\..\..\..\src\api\api_msg.c" />
-    <ClCompile Include="..\..\..\..\src\api\err.c" />
-    <ClCompile Include="..\..\..\..\src\api\if_api.c" />
-    <ClCompile Include="..\..\..\..\src\api\netbuf.c" />
-    <ClCompile Include="..\..\..\..\src\api\netdb.c" />
-    <ClCompile Include="..\..\..\..\src\api\netifapi.c" />
-    <ClCompile Include="..\..\..\..\src\api\sockets.c" />
-    <ClCompile Include="..\..\..\..\src\api\tcpip.c" />
-    <ClCompile Include="..\..\..\..\src\apps\altcp_tls\altcp_tls_mbedtls.c">
-      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\..\..\..\mbedtls\include;..\..\..\..\src\include;..\..\..\..\src\include\ipv4;..\..\..\..\src\include\ipv6;..\include;..;..\..\..\apps\snmp_private_mib;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\..\..\..\mbedtls\include;..\..\..\..\src\include;..\..\..\..\src\include\ipv4;..\..\..\..\src\include\ipv6;..\include;..;..\..\..\apps\snmp_private_mib;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Debug unittests|Win32'">..\..\..\..\..\mbedtls\include;..\..\..\..\test\unit;..\..\..\..\src\include;..\..\..\..\src\include\ipv4;..\..\..\..\src\include\ipv6;..\include;..;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Release unittests|Win32'">..\..\..\..\..\mbedtls\include;..\..\..\..\test\unit;..\..\..\..\src\include;..\..\..\..\src\include\ipv4;..\..\..\..\src\include\ipv6;..\include;..;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\apps\altcp_tls\altcp_tls_mbedtls_mem.c">
-      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\..\..\..\mbedtls\include;..\..\..\..\src\include;..\..\..\..\src\include\ipv4;..\..\..\..\src\include\ipv6;..\include;..;..\..\..\apps\snmp_private_mib;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\..\..\..\mbedtls\include;..\..\..\..\src\include;..\..\..\..\src\include\ipv4;..\..\..\..\src\include\ipv6;..\include;..;..\..\..\apps\snmp_private_mib;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Debug unittests|Win32'">..\..\..\..\..\mbedtls\include;..\..\..\..\test\unit;..\..\..\..\src\include;..\..\..\..\src\include\ipv4;..\..\..\..\src\include\ipv6;..\include;..;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Release unittests|Win32'">..\..\..\..\..\mbedtls\include;..\..\..\..\test\unit;..\..\..\..\src\include;..\..\..\..\src\include\ipv4;..\..\..\..\src\include\ipv6;..\include;..;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\apps\http\altcp_proxyconnect.c" />
-    <ClCompile Include="..\..\..\..\src\apps\http\http_client.c" />
-    <ClCompile Include="..\..\..\..\src\apps\lwiperf\lwiperf.c" />
-    <ClCompile Include="..\..\..\..\src\apps\mdns\mdns_domain.c" />
-    <ClCompile Include="..\..\..\..\src\apps\mdns\mdns_out.c" />
-    <ClCompile Include="..\..\..\..\src\apps\mqtt\mqtt.c" />
-    <ClCompile Include="..\..\..\..\src\apps\netbiosns\netbiosns.c" />
-    <ClCompile Include="..\..\..\..\src\apps\smtp\smtp.c" />
-    <ClCompile Include="..\..\..\..\src\apps\snmp\snmp_snmpv2_framework.c" />
-    <ClCompile Include="..\..\..\..\src\apps\snmp\snmp_snmpv2_usm.c" />
-    <ClCompile Include="..\..\..\..\src\apps\sntp\sntp.c" />
-    <ClCompile Include="..\..\..\..\src\apps\tftp\tftp.c" />
-    <ClCompile Include="..\..\..\..\src\core\altcp.c" />
-    <ClCompile Include="..\..\..\..\src\core\altcp_alloc.c" />
-    <ClCompile Include="..\..\..\..\src\core\altcp_tcp.c" />
-    <ClCompile Include="..\..\..\..\src\core\def.c" />
-    <ClCompile Include="..\..\..\..\src\core\dns.c" />
-    <ClCompile Include="..\..\..\..\src\core\inet_chksum.c" />
-    <ClCompile Include="..\..\..\..\src\core\init.c" />
-    <ClCompile Include="..\..\..\..\src\core\mem.c" />
-    <ClCompile Include="..\..\..\..\src\core\memp.c" />
-    <ClCompile Include="..\..\..\..\src\core\netif.c" />
-    <ClCompile Include="..\..\..\..\src\core\pbuf.c" />
-    <ClCompile Include="..\..\..\..\src\core\raw.c" />
-    <ClCompile Include="..\..\..\..\src\core\stats.c" />
-    <ClCompile Include="..\..\..\..\src\core\sys.c" />
-    <ClCompile Include="..\..\..\..\src\core\tcp.c" />
-    <ClCompile Include="..\..\..\..\src\core\tcp_in.c" />
-    <ClCompile Include="..\..\..\..\src\core\tcp_out.c" />
-    <ClCompile Include="..\..\..\..\src\core\udp.c" />
-    <ClCompile Include="..\..\..\..\src\core\ipv4\acd.c" />
-    <ClCompile Include="..\..\..\..\src\core\ipv4\autoip.c" />
-    <ClCompile Include="..\..\..\..\src\core\ipv4\dhcp.c" />
-    <ClCompile Include="..\..\..\..\src\core\ipv4\etharp.c" />
-    <ClCompile Include="..\..\..\..\src\core\ipv4\icmp.c" />
-    <ClCompile Include="..\..\..\..\src\core\ipv4\igmp.c" />
-    <ClCompile Include="..\..\..\..\src\core\ipv4\ip4.c" />
-    <ClCompile Include="..\..\..\..\src\core\ipv4\ip4_addr.c" />
-    <ClCompile Include="..\..\..\..\src\core\ipv6\dhcp6.c" />
-    <ClCompile Include="..\..\..\..\src\core\ipv6\ethip6.c" />
-    <ClCompile Include="..\..\..\..\src\core\ipv6\icmp6.c" />
-    <ClCompile Include="..\..\..\..\src\core\ipv6\inet6.c" />
-    <ClCompile Include="..\..\..\..\src\core\ipv6\ip6.c" />
-    <ClCompile Include="..\..\..\..\src\core\ipv6\ip6_addr.c" />
-    <ClCompile Include="..\..\..\..\src\core\ipv6\ip6_frag.c" />
-    <ClCompile Include="..\..\..\..\src\core\ipv6\mld6.c" />
-    <ClCompile Include="..\..\..\..\src\core\ipv6\nd6.c" />
-    <ClCompile Include="..\..\..\..\src\netif\bridgeif.c" />
-    <ClCompile Include="..\..\..\..\src\netif\bridgeif_fdb.c" />
-    <ClCompile Include="..\..\..\..\src\netif\ethernet.c" />
-    <ClCompile Include="..\..\..\..\src\netif\lowpan6.c" />
-    <ClCompile Include="..\..\..\..\src\netif\lowpan6_ble.c" />
-    <ClCompile Include="..\..\..\..\src\netif\lowpan6_common.c" />
-    <ClCompile Include="..\..\..\..\src\netif\slipif.c" />
-    <ClCompile Include="..\..\..\..\src\netif\ppp\auth.c" />
-    <ClCompile Include="..\..\..\..\src\netif\ppp\ccp.c" />
-    <ClCompile Include="..\..\..\..\src\netif\ppp\chap-md5.c" />
-    <ClCompile Include="..\..\..\..\src\netif\ppp\chap-new.c" />
-    <ClCompile Include="..\..\..\..\src\netif\ppp\chap_ms.c" />
-    <ClCompile Include="..\..\..\..\src\netif\ppp\demand.c" />
-    <ClCompile Include="..\..\..\..\src\netif\ppp\eap.c" />
-    <ClCompile Include="..\..\..\..\src\netif\ppp\ecp.c" />
-    <ClCompile Include="..\..\..\..\src\netif\ppp\eui64.c" />
-    <ClCompile Include="..\..\..\..\src\netif\ppp\fsm.c" />
-    <ClCompile Include="..\..\..\..\src\netif\ppp\ipcp.c" />
-    <ClCompile Include="..\..\..\..\src\netif\ppp\ipv6cp.c" />
-    <ClCompile Include="..\..\..\..\src\netif\ppp\lcp.c" />
-    <ClCompile Include="..\..\..\..\src\netif\ppp\magic.c" />
-    <ClCompile Include="..\..\..\..\src\netif\ppp\mppe.c" />
-    <ClCompile Include="..\..\..\..\src\netif\ppp\multilink.c" />
-    <ClCompile Include="..\..\..\..\src\netif\ppp\ppp.c" />
-    <ClCompile Include="..\..\..\..\src\netif\ppp\pppcrypt.c" />
-    <ClCompile Include="..\..\..\..\src\netif\ppp\pppoe.c" />
-    <ClCompile Include="..\..\..\..\src\netif\ppp\pppol2tp.c" />
-    <ClCompile Include="..\..\..\..\src\netif\ppp\pppos.c" />
-    <ClCompile Include="..\..\..\..\src\netif\ppp\upap.c" />
-    <ClCompile Include="..\..\..\..\src\netif\ppp\utils.c" />
-    <ClCompile Include="..\..\..\..\src\netif\ppp\vj.c" />
-    <ClCompile Include="..\..\..\..\src\netif\ppp\polarssl\arc4.c" />
-    <ClCompile Include="..\..\..\..\src\netif\ppp\polarssl\des.c" />
-    <ClCompile Include="..\..\..\..\src\netif\ppp\polarssl\md4.c" />
-    <ClCompile Include="..\..\..\..\src\netif\ppp\polarssl\md5.c" />
-    <ClCompile Include="..\..\..\..\src\netif\ppp\polarssl\sha1.c" />
-    <ClCompile Include="..\..\..\..\src\apps\http\fs.c" />
-    <ClCompile Include="..\..\..\..\src\apps\http\fsdata.c">
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug unittests|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release unittests|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\apps\http\httpd.c" />
-    <ClCompile Include="..\..\..\..\src\apps\snmp\snmp_asn1.c" />
-    <ClCompile Include="..\..\..\..\src\apps\snmp\snmp_core.c" />
-    <ClCompile Include="..\..\..\..\src\apps\snmp\snmp_mib2.c" />
-    <ClCompile Include="..\..\..\..\src\apps\snmp\snmp_msg.c" />
-    <ClCompile Include="..\..\..\..\src\apps\snmp\snmp_netconn.c" />
-    <ClCompile Include="..\..\..\..\src\apps\snmp\snmp_pbuf_stream.c" />
-    <ClCompile Include="..\..\..\..\src\apps\snmp\snmp_raw.c" />
-    <ClCompile Include="..\..\..\..\src\apps\snmp\snmp_scalar.c" />
-    <ClCompile Include="..\..\..\..\src\apps\snmp\snmp_table.c" />
-    <ClCompile Include="..\..\..\..\src\apps\snmp\snmp_threadsync.c" />
-    <ClCompile Include="..\..\..\..\src\apps\snmp\snmp_traps.c" />
-    <ClCompile Include="..\..\..\..\src\core\ip.c" />
-    <ClCompile Include="..\..\..\..\src\apps\snmp\snmpv3.c" />
-    <ClCompile Include="..\..\..\..\src\apps\snmp\snmp_mib2_icmp.c" />
-    <ClCompile Include="..\..\..\..\src\apps\snmp\snmp_mib2_interfaces.c" />
-    <ClCompile Include="..\..\..\..\src\apps\snmp\snmp_mib2_ip.c" />
-    <ClCompile Include="..\..\..\..\src\apps\snmp\snmp_mib2_snmp.c" />
-    <ClCompile Include="..\..\..\..\src\apps\snmp\snmp_mib2_system.c" />
-    <ClCompile Include="..\..\..\..\src\apps\snmp\snmp_mib2_tcp.c" />
-    <ClCompile Include="..\..\..\..\src\apps\snmp\snmp_mib2_udp.c" />
-    <ClCompile Include="..\..\..\..\src\netif\ppp\pppapi.c" />
-    <ClCompile Include="..\..\..\..\src\core\ipv4\ip4_frag.c" />
-    <ClCompile Include="..\..\..\..\src\core\timeouts.c" />
-    <ClCompile Include="..\..\..\..\src\apps\mdns\mdns.c" />
-    <ClCompile Include="..\..\..\..\src\apps\snmp\snmpv3_mbedtls.c">
-      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Debug unittests|Win32'">..\..\..\..\..\mbedtls\include;..\..\..\..\src\include;..\..\..\..\src\include\ipv4;..\..\..\..\src\include\ipv6;..\include;..;..\..\..\apps\snmp_private_mib;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\..\..\..\mbedtls\include;..\..\..\..\src\include;..\..\..\..\src\include\ipv4;..\..\..\..\src\include\ipv6;..\include;..;..\..\..\apps\snmp_private_mib;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Release unittests|Win32'">..\..\..\..\..\mbedtls\include;..\..\..\..\src\include;..\..\..\..\src\include\ipv4;..\..\..\..\src\include\ipv6;..\include;..;..\..\..\apps\snmp_private_mib;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\..\..\..\mbedtls\include;..\..\..\..\src\include;..\..\..\..\src\include\ipv4;..\..\..\..\src\include\ipv6;..\include;..;..\..\..\apps\snmp_private_mib;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\netif\zepif.c" />
-    <ClCompile Include="..\sio.c" />
-    <ClCompile Include="..\sys_arch.c">
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug unittests|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release unittests|Win32'">true</ExcludedFromBuild>
-    </ClCompile>
-  </ItemGroup>
-  <ItemGroup>
-    <ClInclude Include="..\..\..\..\doc\doxygen\main_page.h" />
-    <ClInclude Include="..\..\..\..\src\apps\altcp_tls\altcp_tls_mbedtls_mem.h" />
-    <ClInclude Include="..\..\..\..\src\apps\altcp_tls\altcp_tls_mbedtls_structs.h" />
-    <ClInclude Include="..\..\..\..\src\apps\snmp\snmp_msg.h" />
-    <ClInclude Include="..\..\..\..\src\include\compat\stdc\errno.h" />
-    <ClInclude Include="..\..\..\..\src\include\compat\posix\arpa\inet.h" />
-    <ClInclude Include="..\..\..\..\src\include\compat\posix\netdb.h" />
-    <ClInclude Include="..\..\..\..\src\include\compat\posix\net\if.h" />
-    <ClInclude Include="..\..\..\..\src\include\compat\posix\sys\socket.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\altcp.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\altcp_tcp.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\altcp_tls.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\altcp_proxyconnect.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\altcp_tls_mbedtls_opts.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\http_client.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\lwiperf.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\mdns_domain.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\mdns_out.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\mdns_priv.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\mqtt.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\mqtt_opts.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\mqtt_priv.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\netbiosns.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\netbiosns_opts.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\smtp.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\smtp_opts.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\snmp.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\snmp_opts.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\snmp_snmpv2_framework.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\snmp_snmpv2_usm.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\sntp.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\sntp_opts.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\tftp_client.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\tftp_common.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\tftp_opts.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\tftp_server.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\errno.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\if_api.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\ip6_zone.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\priv\altcp_priv.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\priv\api_msg.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\priv\memp_priv.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\priv\memp_std.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\priv\mem_priv.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\priv\nd6_priv.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\priv\raw_priv.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\priv\sockets_priv.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\priv\tcpip_priv.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\priv\tcp_priv.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\acd.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\api.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\arch.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\autoip.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\debug.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\def.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\dhcp.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\dhcp6.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\dns.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\err.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\ethip6.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\icmp.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\icmp6.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\igmp.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\inet.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\inet_chksum.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\init.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\ip.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\ip4.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\ip4_addr.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\ip6.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\ip6_addr.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\ip6_frag.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\ip_addr.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\mem.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\memp.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\mld6.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\nd6.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\netbuf.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\netdb.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\netif.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\netifapi.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\opt.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\pbuf.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\prot\dhcp6.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\prot\etharp.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\prot\iana.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\prot\ieee.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\prot\igmp.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\raw.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\sio.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\snmp.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\sockets.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\stats.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\sys.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\tcp.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\tcpip.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\udp.h" />
-    <ClInclude Include="..\..\..\..\src\include\netif\bridgeif.h" />
-    <ClInclude Include="..\..\..\..\src\include\netif\bridgeif_opts.h" />
-    <ClInclude Include="..\..\..\..\src\include\netif\etharp.h" />
-    <ClInclude Include="..\..\..\..\src\include\netif\ethernet.h" />
-    <ClInclude Include="..\..\..\..\src\include\netif\ieee802154.h" />
-    <ClInclude Include="..\..\..\..\src\include\netif\lowpan6.h" />
-    <ClInclude Include="..\..\..\..\src\include\netif\lowpan6_ble.h" />
-    <ClInclude Include="..\..\..\..\src\include\netif\lowpan6_common.h" />
-    <ClInclude Include="..\..\..\..\src\include\netif\lowpan6_opts.h" />
-    <ClInclude Include="..\..\..\..\src\include\netif\slipif.h" />
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\ccp.h" />
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\chap-md5.h" />
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\chap-new.h" />
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\chap_ms.h" />
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\eap.h" />
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\ecp.h" />
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\eui64.h" />
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\fsm.h" />
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\ipcp.h" />
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\ipv6cp.h" />
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\lcp.h" />
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\magic.h" />
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\mppe.h" />
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\ppp.h" />
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\ppp_impl.h" />
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\ppp_opts.h" />
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\pppcrypt.h" />
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\pppdebug.h" />
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\pppoe.h" />
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\pppol2tp.h" />
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\pppos.h" />
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\upap.h" />
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\vj.h" />
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\polarssl\arc4.h" />
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\polarssl\des.h" />
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\polarssl\md4.h" />
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\polarssl\md5.h" />
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\polarssl\sha1.h" />
-    <ClInclude Include="..\..\..\..\src\apps\http\fsdata.h" />
-    <ClInclude Include="..\..\..\..\src\apps\http\httpd_structs.h" />
-    <ClInclude Include="..\..\..\..\src\apps\snmp\snmp_asn1.h" />
-    <ClInclude Include="..\..\..\..\src\apps\snmp\snmp_core_priv.h" />
-    <ClInclude Include="..\..\..\..\src\apps\snmp\snmp_pbuf_stream.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\snmp_core.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\snmp_mib2.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\snmp_scalar.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\snmp_table.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\snmp_threadsync.h" />
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\pppapi.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\fs.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\httpd.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\httpd_opts.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\snmpv3.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\etharp.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\ip4_frag.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\timeouts.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\mdns.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\mdns_opts.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\prot\acd.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\prot\autoip.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\prot\dhcp.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\prot\dns.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\prot\ip.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\prot\ip4.h" />
-    <ClInclude Include="..\..\..\..\src\apps\snmp\snmpv3_priv.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\prot\ethernet.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\prot\icmp.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\prot\icmp6.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\prot\ip6.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\prot\mld6.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\prot\nd6.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\prot\tcp.h" />
-    <ClInclude Include="..\..\..\..\src\include\lwip\prot\udp.h" />
-    <ClInclude Include="..\..\..\..\src\include\netif\zepif.h" />
-    <ClInclude Include="..\..\..\examples\example_app\default_netif.h" />
-    <ClInclude Include="..\..\..\examples\example_app\lwipcfg.h" />
-    <ClInclude Include="..\..\..\examples\example_app\lwipopts.h" />
-    <ClInclude Include="..\..\..\examples\example_app\lwippools.h" />
-    <ClInclude Include="..\..\..\examples\example_app\ppp_settings.h" />
-    <ClInclude Include="..\include\arch\bpstruct.h" />
-    <ClInclude Include="..\include\arch\cc.h" />
-    <ClInclude Include="..\include\arch\epstruct.h" />
-    <ClInclude Include="..\include\arch\perf.h" />
-    <ClInclude Include="..\include\arch\sys_arch.h" />
-  </ItemGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
-  <ImportGroup Label="ExtensionTargets">
-  </ImportGroup>
-</Project>
\ No newline at end of file
diff --git a/contrib/ports/win32/msvc/lwIP.vcxproj.filters b/contrib/ports/win32/msvc/lwIP.vcxproj.filters
deleted file mode 100644
index bb90c3eb..00000000
--- a/contrib/ports/win32/msvc/lwIP.vcxproj.filters
+++ /dev/null
@@ -1,1075 +0,0 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup>
-    <Filter Include="doc">
-      <UniqueIdentifier>{51757ae3-05ca-4e6a-a745-19c9ffc62278}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="src">
-      <UniqueIdentifier>{e40d58ed-58be-4618-9664-6df29e27f835}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="src\api">
-      <UniqueIdentifier>{5752fd8f-90c3-4381-8b6a-86c09a2f9859}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="src\apps">
-      <UniqueIdentifier>{48a805a9-e5d2-4eed-b29c-02b57140a03d}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="src\apps\lwiperf">
-      <UniqueIdentifier>{8a8dba58-934c-4292-aa8d-d20e2b801bd4}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="src\apps\netbiosns">
-      <UniqueIdentifier>{20594706-d6e1-4503-bc38-f297892d752a}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="src\apps\snmp">
-      <UniqueIdentifier>{1075aec7-b001-47bd-9846-ed635687e26e}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="src\apps\sntp">
-      <UniqueIdentifier>{9b7b3b39-f3b0-4915-81d9-d66c3443c348}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="src\core">
-      <UniqueIdentifier>{75f75ac5-73a4-4458-bc23-eaed529c37e1}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="src\core\ipv4">
-      <UniqueIdentifier>{97772339-4210-4a32-82d0-d25269d3e3d6}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="src\core\ipv6">
-      <UniqueIdentifier>{06467ead-0683-44db-bc41-6aa5a82490f0}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="src\include">
-      <UniqueIdentifier>{166a3203-ccc3-4eff-9eaa-1e5648a7fb5b}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="src\include\lwip">
-      <UniqueIdentifier>{6b889738-b59a-450a-b4dd-0d1986bffca1}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="src\include\lwip\apps">
-      <UniqueIdentifier>{c64c0664-acd9-4f2f-8bd7-78250f4b7b4b}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="src\include\lwip\priv">
-      <UniqueIdentifier>{56e8d041-f1e0-4b02-a173-563190c0eb4a}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="src\include\netif">
-      <UniqueIdentifier>{dc783ea8-63ed-4de6-b576-a87c318a7ad1}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="src\include\netif\ppp">
-      <UniqueIdentifier>{7822191b-1cd0-4ce8-a852-da0474977fc4}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="src\include\netif\ppp\polarssl">
-      <UniqueIdentifier>{b22a3b7a-d076-44a5-9a16-1e6f49cd5a94}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="src\netif">
-      <UniqueIdentifier>{0109fdbb-3aed-45fa-a308-493988755364}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="src\netif\ppp">
-      <UniqueIdentifier>{32a9c4ed-7687-48bb-8b9d-482c2f6c7554}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="src\netif\ppp\polarssl">
-      <UniqueIdentifier>{c6c4a1a7-dab8-4463-b155-07e7303b54e4}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="arch">
-      <UniqueIdentifier>{2e87d0f7-38a3-45f8-870d-f8622c20e9d9}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="src\apps\http">
-      <UniqueIdentifier>{45f6a578-1f4b-4741-9b55-5b5084ecc1d9}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="src\apps\mdns">
-      <UniqueIdentifier>{92215272-cad9-4cf0-a2e1-705f6220e2a9}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="src\include\lwip\prot">
-      <UniqueIdentifier>{bdd3995a-aa34-4a4e-891e-a13c5373d618}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="doc\doxygen">
-      <UniqueIdentifier>{d0ce6e8b-4b30-498b-a1bb-aecee958df42}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="src\apps\tftp">
-      <UniqueIdentifier>{6db73869-23f6-48ab-8d92-c8e478e55892}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="src\apps\mqtt">
-      <UniqueIdentifier>{65542a97-c588-47b3-b1f6-ae51645c736e}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="src\apps\altcp_tls">
-      <UniqueIdentifier>{ffd283f4-44f0-4be2-83a3-8bd55f29e80f}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="src\apps\smtp">
-      <UniqueIdentifier>{d9456888-d299-48ff-8165-ff499e5a0ba3}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="src\include\compat">
-      <UniqueIdentifier>{5aa786e4-df26-432c-b32c-9c4fac00b951}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="src\include\compat\posix">
-      <UniqueIdentifier>{8fb42d78-1e77-4208-b457-44f41c4cc901}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="src\include\compat\posix\sys">
-      <UniqueIdentifier>{81578f11-9d3c-4bc8-a518-6f78f082fe0e}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="src\include\compat\posix\net">
-      <UniqueIdentifier>{f8d65087-0cee-46de-8d8c-dca719bf2a4b}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="src\include\compat\posix\arpa">
-      <UniqueIdentifier>{91d8473a-deb5-4943-8b63-b43d86c7fa1c}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="src\include\compat\stdc">
-      <UniqueIdentifier>{15855a74-48c6-473c-b4cb-40ec065698d4}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="example_app">
-      <UniqueIdentifier>{2c795490-531d-4a03-b30d-73760b09975a}</UniqueIdentifier>
-    </Filter>
-  </ItemGroup>
-  <ItemGroup>
-    <None Include="..\..\..\..\CHANGELOG" />
-    <None Include="..\..\..\..\COPYING" />
-    <None Include="..\..\..\..\FILES" />
-    <None Include="..\..\..\..\README" />
-    <None Include="..\..\..\..\UPGRADING" />
-    <None Include="..\..\..\..\doc\contrib.txt">
-      <Filter>doc</Filter>
-    </None>
-    <None Include="..\..\..\..\doc\FILES">
-      <Filter>doc</Filter>
-    </None>
-    <None Include="..\..\..\..\doc\mdns.txt">
-      <Filter>doc</Filter>
-    </None>
-    <None Include="..\..\..\..\doc\ppp.txt">
-      <Filter>doc</Filter>
-    </None>
-    <None Include="..\..\..\..\doc\savannah.txt">
-      <Filter>doc</Filter>
-    </None>
-    <None Include="..\..\..\..\doc\doxygen\generate.bat">
-      <Filter>doc\doxygen</Filter>
-    </None>
-    <None Include="..\..\..\..\doc\doxygen\generate.sh">
-      <Filter>doc\doxygen</Filter>
-    </None>
-    <None Include="..\..\..\..\doc\doxygen\lwip.Doxyfile">
-      <Filter>doc\doxygen</Filter>
-    </None>
-    <None Include="..\..\..\examples\example_app\lwipcfg.h.example">
-      <Filter>example_app</Filter>
-    </None>
-  </ItemGroup>
-  <ItemGroup>
-    <ClCompile Include="..\..\..\..\src\api\api_lib.c">
-      <Filter>src\api</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\api\api_msg.c">
-      <Filter>src\api</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\api\err.c">
-      <Filter>src\api</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\api\netbuf.c">
-      <Filter>src\api</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\api\netdb.c">
-      <Filter>src\api</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\api\netifapi.c">
-      <Filter>src\api</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\api\sockets.c">
-      <Filter>src\api</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\api\tcpip.c">
-      <Filter>src\api</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\apps\lwiperf\lwiperf.c">
-      <Filter>src\apps\lwiperf</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\apps\netbiosns\netbiosns.c">
-      <Filter>src\apps\netbiosns</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\apps\sntp\sntp.c">
-      <Filter>src\apps\sntp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\core\def.c">
-      <Filter>src\core</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\core\dns.c">
-      <Filter>src\core</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\core\inet_chksum.c">
-      <Filter>src\core</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\core\init.c">
-      <Filter>src\core</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\core\mem.c">
-      <Filter>src\core</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\core\memp.c">
-      <Filter>src\core</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\core\netif.c">
-      <Filter>src\core</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\core\pbuf.c">
-      <Filter>src\core</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\core\raw.c">
-      <Filter>src\core</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\core\stats.c">
-      <Filter>src\core</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\core\sys.c">
-      <Filter>src\core</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\core\tcp.c">
-      <Filter>src\core</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\core\tcp_in.c">
-      <Filter>src\core</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\core\tcp_out.c">
-      <Filter>src\core</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\core\udp.c">
-      <Filter>src\core</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\core\ipv4\acd.c">
-      <Filter>src\core\ipv4</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\core\ipv4\autoip.c">
-      <Filter>src\core\ipv4</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\core\ipv4\dhcp.c">
-      <Filter>src\core\ipv4</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\core\ipv4\icmp.c">
-      <Filter>src\core\ipv4</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\core\ipv4\igmp.c">
-      <Filter>src\core\ipv4</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\core\ipv4\ip4.c">
-      <Filter>src\core\ipv4</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\core\ipv4\ip4_addr.c">
-      <Filter>src\core\ipv4</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\core\ipv6\dhcp6.c">
-      <Filter>src\core\ipv6</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\core\ipv6\ethip6.c">
-      <Filter>src\core\ipv6</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\core\ipv6\icmp6.c">
-      <Filter>src\core\ipv6</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\core\ipv6\inet6.c">
-      <Filter>src\core\ipv6</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\core\ipv6\ip6.c">
-      <Filter>src\core\ipv6</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\core\ipv6\ip6_addr.c">
-      <Filter>src\core\ipv6</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\core\ipv6\ip6_frag.c">
-      <Filter>src\core\ipv6</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\core\ipv6\mld6.c">
-      <Filter>src\core\ipv6</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\core\ipv6\nd6.c">
-      <Filter>src\core\ipv6</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\netif\ethernet.c">
-      <Filter>src\netif</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\netif\lowpan6.c">
-      <Filter>src\netif</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\netif\slipif.c">
-      <Filter>src\netif</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\netif\ppp\auth.c">
-      <Filter>src\netif\ppp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\netif\ppp\ccp.c">
-      <Filter>src\netif\ppp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\netif\ppp\chap-md5.c">
-      <Filter>src\netif\ppp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\netif\ppp\chap-new.c">
-      <Filter>src\netif\ppp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\netif\ppp\chap_ms.c">
-      <Filter>src\netif\ppp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\netif\ppp\demand.c">
-      <Filter>src\netif\ppp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\netif\ppp\eap.c">
-      <Filter>src\netif\ppp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\netif\ppp\ecp.c">
-      <Filter>src\netif\ppp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\netif\ppp\eui64.c">
-      <Filter>src\netif\ppp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\netif\ppp\fsm.c">
-      <Filter>src\netif\ppp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\netif\ppp\ipcp.c">
-      <Filter>src\netif\ppp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\netif\ppp\ipv6cp.c">
-      <Filter>src\netif\ppp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\netif\ppp\lcp.c">
-      <Filter>src\netif\ppp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\netif\ppp\magic.c">
-      <Filter>src\netif\ppp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\netif\ppp\mppe.c">
-      <Filter>src\netif\ppp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\netif\ppp\multilink.c">
-      <Filter>src\netif\ppp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\netif\ppp\ppp.c">
-      <Filter>src\netif\ppp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\netif\ppp\pppcrypt.c">
-      <Filter>src\netif\ppp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\netif\ppp\pppoe.c">
-      <Filter>src\netif\ppp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\netif\ppp\pppol2tp.c">
-      <Filter>src\netif\ppp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\netif\ppp\pppos.c">
-      <Filter>src\netif\ppp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\netif\ppp\upap.c">
-      <Filter>src\netif\ppp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\netif\ppp\utils.c">
-      <Filter>src\netif\ppp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\netif\ppp\vj.c">
-      <Filter>src\netif\ppp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\netif\ppp\polarssl\arc4.c">
-      <Filter>src\netif\ppp\polarssl</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\netif\ppp\polarssl\des.c">
-      <Filter>src\netif\ppp\polarssl</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\netif\ppp\polarssl\md4.c">
-      <Filter>src\netif\ppp\polarssl</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\netif\ppp\polarssl\md5.c">
-      <Filter>src\netif\ppp\polarssl</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\netif\ppp\polarssl\sha1.c">
-      <Filter>src\netif\ppp\polarssl</Filter>
-    </ClCompile>
-    <ClCompile Include="..\sio.c">
-      <Filter>arch</Filter>
-    </ClCompile>
-    <ClCompile Include="..\sys_arch.c">
-      <Filter>arch</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\apps\http\httpd.c">
-      <Filter>src\apps\http</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\apps\http\fsdata.c">
-      <Filter>src\apps\http</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\apps\http\fs.c">
-      <Filter>src\apps\http</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\apps\snmp\snmp_asn1.c">
-      <Filter>src\apps\snmp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\apps\snmp\snmp_core.c">
-      <Filter>src\apps\snmp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\apps\snmp\snmp_mib2.c">
-      <Filter>src\apps\snmp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\apps\snmp\snmp_msg.c">
-      <Filter>src\apps\snmp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\apps\snmp\snmp_netconn.c">
-      <Filter>src\apps\snmp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\apps\snmp\snmp_pbuf_stream.c">
-      <Filter>src\apps\snmp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\apps\snmp\snmp_raw.c">
-      <Filter>src\apps\snmp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\apps\snmp\snmp_scalar.c">
-      <Filter>src\apps\snmp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\apps\snmp\snmp_table.c">
-      <Filter>src\apps\snmp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\apps\snmp\snmp_threadsync.c">
-      <Filter>src\apps\snmp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\apps\snmp\snmp_traps.c">
-      <Filter>src\apps\snmp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\core\ip.c">
-      <Filter>src\core</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\apps\snmp\snmp_mib2_icmp.c">
-      <Filter>src\apps\snmp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\apps\snmp\snmp_mib2_interfaces.c">
-      <Filter>src\apps\snmp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\apps\snmp\snmp_mib2_ip.c">
-      <Filter>src\apps\snmp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\apps\snmp\snmp_mib2_snmp.c">
-      <Filter>src\apps\snmp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\apps\snmp\snmp_mib2_system.c">
-      <Filter>src\apps\snmp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\apps\snmp\snmp_mib2_tcp.c">
-      <Filter>src\apps\snmp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\apps\snmp\snmp_mib2_udp.c">
-      <Filter>src\apps\snmp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\apps\snmp\snmpv3.c">
-      <Filter>src\apps\snmp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\netif\ppp\pppapi.c">
-      <Filter>src\netif\ppp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\core\ipv4\etharp.c">
-      <Filter>src\core\ipv4</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\core\ipv4\ip4_frag.c">
-      <Filter>src\core\ipv4</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\core\timeouts.c">
-      <Filter>src\core</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\apps\mdns\mdns.c">
-      <Filter>src\apps\mdns</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\apps\snmp\snmpv3_mbedtls.c">
-      <Filter>src\apps\snmp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\doc\NO_SYS_SampleCode.c">
-      <Filter>doc</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\apps\tftp\tftp.c">
-      <Filter>src\apps\tftp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\apps\mqtt\mqtt.c">
-      <Filter>src\apps\mqtt</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\api\if_api.c">
-      <Filter>src\api</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\netif\bridgeif.c">
-      <Filter>src\netif</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\apps\snmp\snmp_snmpv2_framework.c">
-      <Filter>src\apps\snmp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\apps\snmp\snmp_snmpv2_usm.c">
-      <Filter>src\apps\snmp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\core\altcp.c">
-      <Filter>src\core</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\core\altcp_tcp.c">
-      <Filter>src\core</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\apps\altcp_tls\altcp_tls_mbedtls.c">
-      <Filter>src\apps\altcp_tls</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\apps\altcp_tls\altcp_tls_mbedtls_mem.c">
-      <Filter>src\apps\altcp_tls</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\apps\smtp\smtp.c">
-      <Filter>src\apps\smtp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\netif\bridgeif_fdb.c">
-      <Filter>src\netif</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\apps\http\http_client.c">
-      <Filter>src\apps\http</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\core\altcp_alloc.c">
-      <Filter>src\core</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\apps\http\altcp_proxyconnect.c">
-      <Filter>src\apps\http</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\netif\lowpan6_ble.c">
-      <Filter>src\netif</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\netif\zepif.c">
-      <Filter>src\netif</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\netif\lowpan6_common.c">
-      <Filter>src\netif</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\apps\mdns\mdns_domain.c">
-      <Filter>src\apps\mdns</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\apps\mdns\mdns_out.c">
-      <Filter>src\apps\mdns</Filter>
-    </ClCompile>
-  </ItemGroup>
-  <ItemGroup>
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\lwiperf.h">
-      <Filter>src\include\lwip\apps</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\netbiosns.h">
-      <Filter>src\include\lwip\apps</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\netbiosns_opts.h">
-      <Filter>src\include\lwip\apps</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\snmp.h">
-      <Filter>src\include\lwip\apps</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\snmp_opts.h">
-      <Filter>src\include\lwip\apps</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\sntp.h">
-      <Filter>src\include\lwip\apps</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\sntp_opts.h">
-      <Filter>src\include\lwip\apps</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\acd.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\api.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\arch.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\autoip.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\debug.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\def.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\dhcp.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\dhcp6.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\dns.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\err.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\ethip6.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\icmp.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\icmp6.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\igmp.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\inet.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\inet_chksum.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\init.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\ip.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\ip4.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\ip4_addr.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\ip6.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\ip6_addr.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\ip6_frag.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\ip_addr.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\mem.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\memp.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\mld6.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\nd6.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\netbuf.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\netdb.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\netif.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\netifapi.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\opt.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\pbuf.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\raw.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\sio.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\snmp.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\sockets.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\stats.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\sys.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\tcp.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\tcpip.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\udp.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\netif\etharp.h">
-      <Filter>src\include\netif</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\netif\ethernet.h">
-      <Filter>src\include\netif</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\netif\lowpan6.h">
-      <Filter>src\include\netif</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\netif\lowpan6_opts.h">
-      <Filter>src\include\netif</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\netif\slipif.h">
-      <Filter>src\include\netif</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\ccp.h">
-      <Filter>src\include\netif\ppp</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\chap-md5.h">
-      <Filter>src\include\netif\ppp</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\chap-new.h">
-      <Filter>src\include\netif\ppp</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\chap_ms.h">
-      <Filter>src\include\netif\ppp</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\eap.h">
-      <Filter>src\include\netif\ppp</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\ecp.h">
-      <Filter>src\include\netif\ppp</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\eui64.h">
-      <Filter>src\include\netif\ppp</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\fsm.h">
-      <Filter>src\include\netif\ppp</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\ipcp.h">
-      <Filter>src\include\netif\ppp</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\ipv6cp.h">
-      <Filter>src\include\netif\ppp</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\lcp.h">
-      <Filter>src\include\netif\ppp</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\magic.h">
-      <Filter>src\include\netif\ppp</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\mppe.h">
-      <Filter>src\include\netif\ppp</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\ppp.h">
-      <Filter>src\include\netif\ppp</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\ppp_impl.h">
-      <Filter>src\include\netif\ppp</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\ppp_opts.h">
-      <Filter>src\include\netif\ppp</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\pppcrypt.h">
-      <Filter>src\include\netif\ppp</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\pppdebug.h">
-      <Filter>src\include\netif\ppp</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\pppoe.h">
-      <Filter>src\include\netif\ppp</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\pppol2tp.h">
-      <Filter>src\include\netif\ppp</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\pppos.h">
-      <Filter>src\include\netif\ppp</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\upap.h">
-      <Filter>src\include\netif\ppp</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\vj.h">
-      <Filter>src\include\netif\ppp</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\polarssl\arc4.h">
-      <Filter>src\include\netif\ppp\polarssl</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\polarssl\des.h">
-      <Filter>src\include\netif\ppp\polarssl</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\polarssl\md4.h">
-      <Filter>src\include\netif\ppp\polarssl</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\polarssl\md5.h">
-      <Filter>src\include\netif\ppp\polarssl</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\polarssl\sha1.h">
-      <Filter>src\include\netif\ppp\polarssl</Filter>
-    </ClInclude>
-    <ClInclude Include="..\include\arch\bpstruct.h">
-      <Filter>arch</Filter>
-    </ClInclude>
-    <ClInclude Include="..\include\arch\cc.h">
-      <Filter>arch</Filter>
-    </ClInclude>
-    <ClInclude Include="..\include\arch\epstruct.h">
-      <Filter>arch</Filter>
-    </ClInclude>
-    <ClInclude Include="..\include\arch\perf.h">
-      <Filter>arch</Filter>
-    </ClInclude>
-    <ClInclude Include="..\include\arch\sys_arch.h">
-      <Filter>arch</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\priv\tcp_priv.h">
-      <Filter>src\include\lwip\priv</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\priv\tcpip_priv.h">
-      <Filter>src\include\lwip\priv</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\priv\memp_priv.h">
-      <Filter>src\include\lwip\priv</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\priv\memp_std.h">
-      <Filter>src\include\lwip\priv</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\priv\api_msg.h">
-      <Filter>src\include\lwip\priv</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\apps\http\httpd_structs.h">
-      <Filter>src\apps\http</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\apps\http\fsdata.h">
-      <Filter>src\apps\http</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\apps\snmp\snmp_asn1.h">
-      <Filter>src\apps\snmp</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\apps\snmp\snmp_core_priv.h">
-      <Filter>src\apps\snmp</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\apps\snmp\snmp_pbuf_stream.h">
-      <Filter>src\apps\snmp</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\snmp_core.h">
-      <Filter>src\include\lwip\apps</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\snmp_mib2.h">
-      <Filter>src\include\lwip\apps</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\snmp_scalar.h">
-      <Filter>src\include\lwip\apps</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\snmp_table.h">
-      <Filter>src\include\lwip\apps</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\snmp_threadsync.h">
-      <Filter>src\include\lwip\apps</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\apps\snmp\snmp_msg.h">
-      <Filter>src\apps\snmp</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\netif\ppp\pppapi.h">
-      <Filter>src\include\netif\ppp</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\fs.h">
-      <Filter>src\include\lwip\apps</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\httpd.h">
-      <Filter>src\include\lwip\apps</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\httpd_opts.h">
-      <Filter>src\include\lwip\apps</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\snmpv3.h">
-      <Filter>src\include\lwip\apps</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\etharp.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\ip4_frag.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\timeouts.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\mdns.h">
-      <Filter>src\include\lwip\apps</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\mdns_opts.h">
-      <Filter>src\include\lwip\apps</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\prot\acd.h">
-      <Filter>src\include\lwip\prot</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\prot\autoip.h">
-      <Filter>src\include\lwip\prot</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\prot\dhcp.h">
-      <Filter>src\include\lwip\prot</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\prot\dns.h">
-      <Filter>src\include\lwip\prot</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\prot\ip.h">
-      <Filter>src\include\lwip\prot</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\prot\ip4.h">
-      <Filter>src\include\lwip\prot</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\apps\snmp\snmpv3_priv.h">
-      <Filter>src\apps\snmp</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\prot\ethernet.h">
-      <Filter>src\include\lwip\prot</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\prot\icmp.h">
-      <Filter>src\include\lwip\prot</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\prot\icmp6.h">
-      <Filter>src\include\lwip\prot</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\prot\ip6.h">
-      <Filter>src\include\lwip\prot</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\prot\mld6.h">
-      <Filter>src\include\lwip\prot</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\prot\nd6.h">
-      <Filter>src\include\lwip\prot</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\prot\tcp.h">
-      <Filter>src\include\lwip\prot</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\prot\udp.h">
-      <Filter>src\include\lwip\prot</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\mdns_priv.h">
-      <Filter>src\include\lwip\apps</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\prot\igmp.h">
-      <Filter>src\include\lwip\prot</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\prot\etharp.h">
-      <Filter>src\include\lwip\prot</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\doc\doxygen\main_page.h">
-      <Filter>doc\doxygen</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\tftp_client.h">
-      <Filter>src\include\lwip\apps</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\tftp_common.h">
-      <Filter>src\include\lwip\apps</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\tftp_opts.h">
-      <Filter>src\include\lwip\apps</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\tftp_server.h">
-      <Filter>src\include\lwip\apps</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\errno.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\priv\nd6_priv.h">
-      <Filter>src\include\lwip\priv</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\mqtt.h">
-      <Filter>src\include\lwip\apps</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\if_api.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\ip6_zone.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\priv\sockets_priv.h">
-      <Filter>src\include\lwip\priv</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\netif\bridgeif.h">
-      <Filter>src\include\netif</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\netif\bridgeif_opts.h">
-      <Filter>src\include\netif</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\altcp.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\altcp_tcp.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\apps\altcp_tls\altcp_tls_mbedtls_mem.h">
-      <Filter>src\apps\altcp_tls</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\apps\altcp_tls\altcp_tls_mbedtls_structs.h">
-      <Filter>src\apps\altcp_tls</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\altcp_tls.h">
-      <Filter>src\include\lwip</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\altcp_tls_mbedtls_opts.h">
-      <Filter>src\include\lwip\apps</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\snmp_snmpv2_framework.h">
-      <Filter>src\include\lwip\apps</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\snmp_snmpv2_usm.h">
-      <Filter>src\include\lwip\apps</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\smtp.h">
-      <Filter>src\include\lwip\apps</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\smtp_opts.h">
-      <Filter>src\include\lwip\apps</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\priv\altcp_priv.h">
-      <Filter>src\include\lwip\priv</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\mqtt_priv.h">
-      <Filter>src\include\lwip\apps</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\mqtt_opts.h">
-      <Filter>src\include\lwip\apps</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\compat\posix\sys\socket.h">
-      <Filter>src\include\compat\posix\sys</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\compat\posix\netdb.h">
-      <Filter>src\include\compat\posix</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\compat\posix\net\if.h">
-      <Filter>src\include\compat\posix\net</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\compat\posix\arpa\inet.h">
-      <Filter>src\include\compat\posix\arpa</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\compat\stdc\errno.h">
-      <Filter>src\include\compat\stdc</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\prot\iana.h">
-      <Filter>src\include\lwip\prot</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\prot\ieee.h">
-      <Filter>src\include\lwip\prot</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\priv\raw_priv.h">
-      <Filter>src\include\lwip\priv</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\priv\mem_priv.h">
-      <Filter>src\include\lwip\priv</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\http_client.h">
-      <Filter>src\include\lwip\apps</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\altcp_proxyconnect.h">
-      <Filter>src\include\lwip\apps</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\prot\dhcp6.h">
-      <Filter>src\include\lwip\prot</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\netif\lowpan6_ble.h">
-      <Filter>src\include\netif</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\netif\ieee802154.h">
-      <Filter>src\include\netif</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\netif\zepif.h">
-      <Filter>src\include\netif</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\netif\lowpan6_common.h">
-      <Filter>src\include\netif</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\examples\example_app\default_netif.h">
-      <Filter>example_app</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\examples\example_app\lwipcfg.h">
-      <Filter>example_app</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\examples\example_app\lwipopts.h">
-      <Filter>example_app</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\examples\example_app\lwippools.h">
-      <Filter>example_app</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\examples\example_app\ppp_settings.h">
-      <Filter>example_app</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\mdns_domain.h">
-      <Filter>src\include\lwip\apps</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\include\lwip\apps\mdns_out.h">
-      <Filter>src\include\lwip\apps</Filter>
-    </ClInclude>
-  </ItemGroup>
-</Project>
\ No newline at end of file
diff --git a/contrib/ports/win32/msvc/lwIP_Test.sln b/contrib/ports/win32/msvc/lwIP_Test.sln
deleted file mode 100644
index ce59abd2..00000000
--- a/contrib/ports/win32/msvc/lwIP_Test.sln
+++ /dev/null
@@ -1,37 +0,0 @@
-Microsoft Visual Studio Solution File, Format Version 11.00
-# Visual C++ Express 2010
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "lwIP_Test", "lwIP_Test.vcxproj", "{8CC0CE51-32CF-4585-BFAF-A9343BC5A96D}"
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "lwIP pcapif", "lwIP_pcapif.vcxproj", "{6F44E49E-9F21-4144-91EC-53B92AEF62CE}"
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "lwIP", "lwIP.vcxproj", "{2CC276FA-B226-49C9-8F82-7FCD5A228E28}"
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "makefsdata", "makefsdata.vcxproj", "{0BFC0F21-8E84-4E68-A9E1-CE2A09B72F6D}"
-EndProject
-Global
-	GlobalSection(SolutionConfigurationPlatforms) = preSolution
-		Debug|Win32 = Debug|Win32
-		Release|Win32 = Release|Win32
-	EndGlobalSection
-	GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		{8CC0CE51-32CF-4585-BFAF-A9343BC5A96D}.Debug|Win32.ActiveCfg = Debug|Win32
-		{8CC0CE51-32CF-4585-BFAF-A9343BC5A96D}.Debug|Win32.Build.0 = Debug|Win32
-		{8CC0CE51-32CF-4585-BFAF-A9343BC5A96D}.Release|Win32.ActiveCfg = Release|Win32
-		{8CC0CE51-32CF-4585-BFAF-A9343BC5A96D}.Release|Win32.Build.0 = Release|Win32
-		{6F44E49E-9F21-4144-91EC-53B92AEF62CE}.Debug|Win32.ActiveCfg = Debug|Win32
-		{6F44E49E-9F21-4144-91EC-53B92AEF62CE}.Debug|Win32.Build.0 = Debug|Win32
-		{6F44E49E-9F21-4144-91EC-53B92AEF62CE}.Release|Win32.ActiveCfg = Release|Win32
-		{6F44E49E-9F21-4144-91EC-53B92AEF62CE}.Release|Win32.Build.0 = Release|Win32
-		{2CC276FA-B226-49C9-8F82-7FCD5A228E28}.Debug|Win32.ActiveCfg = Debug|Win32
-		{2CC276FA-B226-49C9-8F82-7FCD5A228E28}.Debug|Win32.Build.0 = Debug|Win32
-		{2CC276FA-B226-49C9-8F82-7FCD5A228E28}.Release|Win32.ActiveCfg = Release|Win32
-		{2CC276FA-B226-49C9-8F82-7FCD5A228E28}.Release|Win32.Build.0 = Release|Win32
-		{0BFC0F21-8E84-4E68-A9E1-CE2A09B72F6D}.Debug|Win32.ActiveCfg = Debug|Win32
-		{0BFC0F21-8E84-4E68-A9E1-CE2A09B72F6D}.Debug|Win32.Build.0 = Debug|Win32
-		{0BFC0F21-8E84-4E68-A9E1-CE2A09B72F6D}.Release|Win32.ActiveCfg = Release|Win32
-		{0BFC0F21-8E84-4E68-A9E1-CE2A09B72F6D}.Release|Win32.Build.0 = Release|Win32
-	EndGlobalSection
-	GlobalSection(SolutionProperties) = preSolution
-		HideSolutionNode = FALSE
-	EndGlobalSection
-EndGlobal
diff --git a/contrib/ports/win32/msvc/lwIP_Test.vcxproj b/contrib/ports/win32/msvc/lwIP_Test.vcxproj
deleted file mode 100644
index 41b2a24b..00000000
--- a/contrib/ports/win32/msvc/lwIP_Test.vcxproj
+++ /dev/null
@@ -1,203 +0,0 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup Label="ProjectConfigurations">
-    <ProjectConfiguration Include="Debug|Win32">
-      <Configuration>Debug</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|Win32">
-      <Configuration>Release</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-  </ItemGroup>
-  <PropertyGroup Label="Globals">
-    <ProjectGuid>{8CC0CE51-32CF-4585-BFAF-A9343BC5A96D}</ProjectGuid>
-    <RootNamespace>lwIP_test</RootNamespace>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <UseOfMfc>false</UseOfMfc>
-    <CharacterSet>MultiByte</CharacterSet>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <UseOfMfc>false</UseOfMfc>
-    <CharacterSet>MultiByte</CharacterSet>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
-  <ImportGroup Label="ExtensionSettings">
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
-  </ImportGroup>
-  <PropertyGroup Label="UserMacros" />
-  <PropertyGroup>
-    <_ProjectFileVersion>10.0.40219.1</_ProjectFileVersion>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">.\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">.\$(Configuration)\$(ProjectName)\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</LinkIncremental>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</LinkIncremental>
-  </PropertyGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
-    <Midl>
-      <TypeLibraryName>.\Release/test.tlb</TypeLibraryName>
-      <HeaderFileName>
-      </HeaderFileName>
-    </Midl>
-    <ClCompile>
-      <Optimization>MaxSpeed</Optimization>
-      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
-      <AdditionalIncludeDirectories>..\..\..\..\src\include;..\..\..\..\src\include\ipv4;..\..\..\..\src\include\ipv6;..\include;..\..\..\examples\example_app;..\..\..;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
-      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
-      <FunctionLevelLinking>true</FunctionLevelLinking>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
-      <ProgramDataBaseFileName>$(IntDir)$(ProjectName).pdb</ProgramDataBaseFileName>
-      <WarningLevel>EnableAllWarnings</WarningLevel>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <CompileAs>Default</CompileAs>
-      <TreatWarningAsError>true</TreatWarningAsError>
-    </ClCompile>
-    <ResourceCompile>
-      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <Culture>0x0407</Culture>
-    </ResourceCompile>
-    <Link>
-      <AdditionalDependencies>Packet.lib;wpcap.lib;%(AdditionalDependencies)</AdditionalDependencies>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <AdditionalLibraryDirectories>$(PCAP_DIR)\Lib;..\..\..\..\..\winpcap\WpdPack\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
-      <ProgramDatabaseFile>.\Release/test.pdb</ProgramDatabaseFile>
-      <SubSystem>Console</SubSystem>
-      <RandomizedBaseAddress>false</RandomizedBaseAddress>
-      <DataExecutionPrevention>
-      </DataExecutionPrevention>
-      <TargetMachine>MachineX86</TargetMachine>
-      <GenerateMapFile>true</GenerateMapFile>
-      <MapFileName>$(TargetDir)$(TargetName).map</MapFileName>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
-    <Midl>
-      <TypeLibraryName>.\Debug/test.tlb</TypeLibraryName>
-      <HeaderFileName>
-      </HeaderFileName>
-    </Midl>
-    <ClCompile>
-      <Optimization>Disabled</Optimization>
-      <AdditionalIncludeDirectories>..\..\..\..\src\include;..\..\..\..\src\include\ipv4;..\..\..\..\src\include\ipv6;..\include;..\..\..\examples\example_app;..\..\..;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>_CONSOLE;WIN32;_DEBUG;LWIP_DEBUG;_CRT_SECURE_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
-      <ProgramDataBaseFileName>$(IntDir)$(ProjectName).pdb</ProgramDataBaseFileName>
-      <WarningLevel>EnableAllWarnings</WarningLevel>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
-      <CompileAs>Default</CompileAs>
-      <TreatWarningAsError>true</TreatWarningAsError>
-    </ClCompile>
-    <ResourceCompile>
-      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <Culture>0x0407</Culture>
-    </ResourceCompile>
-    <Link>
-      <AdditionalDependencies>Packet.lib;wpcap.lib;%(AdditionalDependencies)</AdditionalDependencies>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <AdditionalLibraryDirectories>$(PCAP_DIR)\Lib;..\..\..\..\..\winpcap\WpdPack\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <SubSystem>Console</SubSystem>
-      <RandomizedBaseAddress>false</RandomizedBaseAddress>
-      <DataExecutionPrevention>
-      </DataExecutionPrevention>
-      <TargetMachine>MachineX86</TargetMachine>
-      <GenerateMapFile>false</GenerateMapFile>
-      <MapFileName>$(TargetDir)$(TargetName).map</MapFileName>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemGroup>
-    <ClCompile Include="..\..\..\addons\ipv6_static_routing\ip6_route_table.c" />
-    <ClCompile Include="..\..\..\addons\tcp_isn\tcp_isn.c" />
-    <ClCompile Include="..\..\..\apps\tcpecho_raw\tcpecho_raw.c" />
-    <ClCompile Include="..\..\..\apps\udpecho_raw\udpecho_raw.c" />
-    <ClCompile Include="..\..\..\examples\example_app\test.c" />
-    <ClCompile Include="..\..\..\examples\httpd\cgi_example\cgi_example.c" />
-    <ClCompile Include="..\..\..\examples\httpd\fs_example\fs_example.c" />
-    <ClCompile Include="..\..\..\examples\httpd\genfiles_example\genfiles_example.c" />
-    <ClCompile Include="..\..\..\examples\httpd\post_example\post_example.c" />
-    <ClCompile Include="..\..\..\examples\httpd\ssi_example\ssi_example.c" />
-    <ClCompile Include="..\..\..\examples\lwiperf\lwiperf_example.c" />
-    <ClCompile Include="..\..\..\examples\mdns\mdns_example.c" />
-    <ClCompile Include="..\..\..\examples\mqtt\mqtt_example.c" />
-    <ClCompile Include="..\..\..\examples\ppp\pppos_example.c" />
-    <ClCompile Include="..\..\..\examples\snmp\snmp_example.c" />
-    <ClCompile Include="..\..\..\examples\snmp\snmp_private_mib\lwip_prvmib.c" />
-    <ClCompile Include="..\..\..\examples\snmp\snmp_v3\snmpv3_dummy.c" />
-    <ClCompile Include="..\..\..\examples\sntp\sntp_example.c" />
-    <ClCompile Include="..\..\..\examples\tftp\tftp_example.c" />
-    <ClCompile Include="..\..\..\apps\chargen\chargen.c" />
-    <ClCompile Include="..\..\..\apps\httpserver\httpserver-netconn.c" />
-    <ClCompile Include="..\..\..\apps\netio\netio.c" />
-    <ClCompile Include="..\..\..\apps\ping\ping.c" />
-    <ClCompile Include="..\..\..\apps\rtp\rtp.c" />
-    <ClCompile Include="..\..\..\apps\shell\shell.c" />
-    <ClCompile Include="..\..\..\apps\socket_examples\socket_examples.c" />
-    <ClCompile Include="..\..\..\apps\tcpecho\tcpecho.c" />
-    <ClCompile Include="..\..\..\apps\udpecho\udpecho.c" />
-    <ClCompile Include="..\example_app\default_netif.c" />
-  </ItemGroup>
-  <ItemGroup>
-    <ClInclude Include="..\..\..\addons\ipv6_static_routing\ip6_route_table.h" />
-    <ClInclude Include="..\..\..\addons\tcp_isn\tcp_isn.h" />
-    <ClInclude Include="..\..\..\apps\chargen\chargen.h" />
-    <ClInclude Include="..\..\..\apps\httpserver\httpserver-netconn.h" />
-    <ClInclude Include="..\..\..\apps\netio\netio.h" />
-    <ClInclude Include="..\..\..\apps\ping\ping.h" />
-    <ClInclude Include="..\..\..\apps\rtp\rtp.h" />
-    <ClInclude Include="..\..\..\apps\shell\shell.h" />
-    <ClInclude Include="..\..\..\apps\socket_examples\socket_examples.h" />
-    <ClInclude Include="..\..\..\apps\tcpecho\tcpecho.h" />
-    <ClInclude Include="..\..\..\apps\tcpecho_raw\tcpecho_raw.h" />
-    <ClInclude Include="..\..\..\apps\udpecho\udpecho.h" />
-    <ClInclude Include="..\..\..\apps\udpecho_raw\udpecho_raw.h" />
-    <ClInclude Include="..\..\..\examples\httpd\cgi_example\cgi_example.h" />
-    <ClInclude Include="..\..\..\examples\httpd\fs_example\fs_example.h" />
-    <ClInclude Include="..\..\..\examples\httpd\genfiles_example\genfiles_example.h" />
-    <ClInclude Include="..\..\..\examples\httpd\ssi_example\ssi_example.h" />
-    <ClInclude Include="..\..\..\examples\lwiperf\lwiperf_example.h" />
-    <ClInclude Include="..\..\..\examples\mdns\mdns_example.h" />
-    <ClInclude Include="..\..\..\examples\mqtt\mqtt_example.h" />
-    <ClInclude Include="..\..\..\examples\ppp\pppos_example.h" />
-    <ClInclude Include="..\..\..\examples\snmp\snmp_example.h" />
-    <ClInclude Include="..\..\..\examples\snmp\snmp_private_mib\private_mib.h" />
-    <ClInclude Include="..\..\..\examples\snmp\snmp_v3\snmpv3_dummy.h" />
-    <ClInclude Include="..\..\..\examples\sntp\sntp_example.h" />
-    <ClInclude Include="..\..\..\examples\tftp\tftp_example.h" />
-  </ItemGroup>
-  <ItemGroup>
-    <None Include="..\..\..\addons\ipv6_static_routing\README" />
-  </ItemGroup>
-  <ItemGroup>
-    <ProjectReference Include="lwIP.vcxproj">
-      <Project>{2cc276fa-b226-49c9-8f82-7fcd5a228e28}</Project>
-      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
-    </ProjectReference>
-    <ProjectReference Include="lwIP_pcapif.vcxproj">
-      <Project>{6f44e49e-9f21-4144-91ec-53b92aef62ce}</Project>
-      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
-    </ProjectReference>
-  </ItemGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
-  <ImportGroup Label="ExtensionTargets">
-  </ImportGroup>
-</Project>
\ No newline at end of file
diff --git a/contrib/ports/win32/msvc/lwIP_Test.vcxproj.filters b/contrib/ports/win32/msvc/lwIP_Test.vcxproj.filters
deleted file mode 100644
index 499334bc..00000000
--- a/contrib/ports/win32/msvc/lwIP_Test.vcxproj.filters
+++ /dev/null
@@ -1,243 +0,0 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup>
-    <Filter Include="Source Files">
-      <UniqueIdentifier>{e858c3d0-1558-4d47-bc6a-9d4a55ce3d3a}</UniqueIdentifier>
-      <Extensions>cpp;c;cxx;rc;def;r;odl;idl;hpj;bat</Extensions>
-    </Filter>
-    <Filter Include="Source Files\apps">
-      <UniqueIdentifier>{0582eefd-a68e-45f8-b93c-f828c4794f30}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="Source Files\addons">
-      <UniqueIdentifier>{ed0627c2-099a-4da8-af0c-142003828f9f}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="Source Files\addons\tcp_isn">
-      <UniqueIdentifier>{4ffb2268-6fc6-44d7-8e3b-2a3f68b8d5a3}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="Source Files\addons\ipv6_static_routing">
-      <UniqueIdentifier>{93b36161-88b2-448c-9c45-ac6f27b98290}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="Source Files\examples">
-      <UniqueIdentifier>{6456d2d6-61e6-4c99-9f1f-1f225437a642}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="Source Files\examples\httpd">
-      <UniqueIdentifier>{75bb877e-aa45-4e2e-82fe-946ddadc6a64}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="Source Files\examples\snmp">
-      <UniqueIdentifier>{78411edf-fe39-4edb-a6bd-2833755e0342}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="Source Files\examples\httpd\fs_example">
-      <UniqueIdentifier>{531dd0cf-ec13-42b7-a3bb-b837382d4ecd}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="Source Files\examples\httpd\ssi_example">
-      <UniqueIdentifier>{d71bdb12-c5ed-4823-99f0-2d537765a2eb}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="Source Files\examples\snmp\snmp_private_mib">
-      <UniqueIdentifier>{0b9db8c7-f352-4ca6-86c6-1a6c58482c5d}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="Source Files\examples\snmp\snmp_v3">
-      <UniqueIdentifier>{97f0ea5c-16cf-4640-a6b3-ace059ed2388}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="Source Files\examples\httpd\cgi_example">
-      <UniqueIdentifier>{24079d2d-aab1-49f9-b0fa-57910a18b93a}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="Source Files\examples\httpd\genfiles_example">
-      <UniqueIdentifier>{d38ed32b-9498-429e-a02c-08332c463725}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="Source Files\examples\httpd\post_example">
-      <UniqueIdentifier>{672a49fd-94ff-4126-8de3-e96c9c32dfb8}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="Source Files\examples\mdns">
-      <UniqueIdentifier>{e5276e3f-3e2a-4376-aee3-85aafd12c77b}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="Source Files\examples\tftp">
-      <UniqueIdentifier>{f6d95ce0-df4f-4988-8654-624468dd4ecd}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="Source Files\examples\sntp">
-      <UniqueIdentifier>{a37e5539-232e-4d91-9c10-3d7a851b8c4c}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="Source Files\examples\ppp">
-      <UniqueIdentifier>{a2a65260-5055-4a0d-bd0b-4a3ca3560918}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="Source Files\examples\lwiperf">
-      <UniqueIdentifier>{aa359e5e-131e-4f20-9e5d-416f9ae76abd}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="Source Files\examples\mqtt">
-      <UniqueIdentifier>{bd6f1fcc-c88f-4b96-a267-401f6bf9898b}</UniqueIdentifier>
-    </Filter>
-  </ItemGroup>
-  <ItemGroup>
-    <ClCompile Include="..\..\..\apps\chargen\chargen.c">
-      <Filter>Source Files\apps</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\apps\httpserver\httpserver-netconn.c">
-      <Filter>Source Files\apps</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\apps\netio\netio.c">
-      <Filter>Source Files\apps</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\apps\ping\ping.c">
-      <Filter>Source Files\apps</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\apps\rtp\rtp.c">
-      <Filter>Source Files\apps</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\apps\shell\shell.c">
-      <Filter>Source Files\apps</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\apps\socket_examples\socket_examples.c">
-      <Filter>Source Files\apps</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\apps\tcpecho\tcpecho.c">
-      <Filter>Source Files\apps</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\apps\udpecho\udpecho.c">
-      <Filter>Source Files\apps</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\apps\tcpecho_raw\tcpecho_raw.c">
-      <Filter>Source Files\apps</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\apps\udpecho_raw\udpecho_raw.c">
-      <Filter>Source Files\apps</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\addons\tcp_isn\tcp_isn.c">
-      <Filter>Source Files\addons\tcp_isn</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\addons\ipv6_static_routing\ip6_route_table.c">
-      <Filter>Source Files\addons\ipv6_static_routing</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\examples\httpd\fs_example\fs_example.c">
-      <Filter>Source Files\examples\httpd\fs_example</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\examples\httpd\ssi_example\ssi_example.c">
-      <Filter>Source Files\examples\httpd\ssi_example</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\examples\snmp\snmp_private_mib\lwip_prvmib.c">
-      <Filter>Source Files\examples\snmp\snmp_private_mib</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\examples\snmp\snmp_v3\snmpv3_dummy.c">
-      <Filter>Source Files\examples\snmp\snmp_v3</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\examples\httpd\cgi_example\cgi_example.c">
-      <Filter>Source Files\examples\httpd\cgi_example</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\examples\httpd\genfiles_example\genfiles_example.c">
-      <Filter>Source Files\examples\httpd\genfiles_example</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\examples\httpd\post_example\post_example.c">
-      <Filter>Source Files\examples\httpd\post_example</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\examples\mdns\mdns_example.c">
-      <Filter>Source Files\examples\mdns</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\examples\tftp\tftp_example.c">
-      <Filter>Source Files\examples\tftp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\examples\snmp\snmp_example.c">
-      <Filter>Source Files\examples\snmp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\examples\sntp\sntp_example.c">
-      <Filter>Source Files\examples\sntp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\examples\ppp\pppos_example.c">
-      <Filter>Source Files\examples\ppp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\examples\lwiperf\lwiperf_example.c">
-      <Filter>Source Files\examples\lwiperf</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\examples\mqtt\mqtt_example.c">
-      <Filter>Source Files\examples\mqtt</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\examples\example_app\test.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\example_app\default_netif.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-  </ItemGroup>
-  <ItemGroup>
-    <ClInclude Include="..\..\..\apps\chargen\chargen.h">
-      <Filter>Source Files\apps</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\apps\httpserver\httpserver-netconn.h">
-      <Filter>Source Files\apps</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\apps\netio\netio.h">
-      <Filter>Source Files\apps</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\apps\ping\ping.h">
-      <Filter>Source Files\apps</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\apps\rtp\rtp.h">
-      <Filter>Source Files\apps</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\apps\shell\shell.h">
-      <Filter>Source Files\apps</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\apps\socket_examples\socket_examples.h">
-      <Filter>Source Files\apps</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\apps\tcpecho\tcpecho.h">
-      <Filter>Source Files\apps</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\apps\udpecho\udpecho.h">
-      <Filter>Source Files\apps</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\apps\tcpecho_raw\tcpecho_raw.h">
-      <Filter>Source Files\apps</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\apps\udpecho_raw\udpecho_raw.h">
-      <Filter>Source Files\apps</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\addons\tcp_isn\tcp_isn.h">
-      <Filter>Source Files\addons\tcp_isn</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\addons\ipv6_static_routing\ip6_route_table.h">
-      <Filter>Source Files\addons\ipv6_static_routing</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\examples\httpd\fs_example\fs_example.h">
-      <Filter>Source Files\examples\httpd\fs_example</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\examples\httpd\ssi_example\ssi_example.h">
-      <Filter>Source Files\examples\httpd\ssi_example</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\examples\snmp\snmp_private_mib\private_mib.h">
-      <Filter>Source Files\examples\snmp\snmp_private_mib</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\examples\snmp\snmp_v3\snmpv3_dummy.h">
-      <Filter>Source Files\examples\snmp\snmp_v3</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\examples\httpd\cgi_example\cgi_example.h">
-      <Filter>Source Files\examples\httpd\cgi_example</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\examples\httpd\genfiles_example\genfiles_example.h">
-      <Filter>Source Files\examples\httpd\genfiles_example</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\examples\mdns\mdns_example.h">
-      <Filter>Source Files\examples\mdns</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\examples\tftp\tftp_example.h">
-      <Filter>Source Files\examples\tftp</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\examples\snmp\snmp_example.h">
-      <Filter>Source Files\examples\snmp</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\examples\sntp\sntp_example.h">
-      <Filter>Source Files\examples\sntp</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\examples\ppp\pppos_example.h">
-      <Filter>Source Files\examples\ppp</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\examples\lwiperf\lwiperf_example.h">
-      <Filter>Source Files\examples\lwiperf</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\examples\mqtt\mqtt_example.h">
-      <Filter>Source Files\examples\mqtt</Filter>
-    </ClInclude>
-  </ItemGroup>
-  <ItemGroup>
-    <None Include="..\..\..\addons\ipv6_static_routing\README">
-      <Filter>Source Files\addons\ipv6_static_routing</Filter>
-    </None>
-  </ItemGroup>
-</Project>
\ No newline at end of file
diff --git a/contrib/ports/win32/msvc/lwIP_pcapif.vcxproj b/contrib/ports/win32/msvc/lwIP_pcapif.vcxproj
deleted file mode 100644
index 193c9ca4..00000000
--- a/contrib/ports/win32/msvc/lwIP_pcapif.vcxproj
+++ /dev/null
@@ -1,111 +0,0 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup Label="ProjectConfigurations">
-    <ProjectConfiguration Include="Debug|Win32">
-      <Configuration>Debug</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|Win32">
-      <Configuration>Release</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-  </ItemGroup>
-  <PropertyGroup Label="Globals">
-    <ProjectName>lwIP pcapif</ProjectName>
-    <ProjectGuid>{6F44E49E-9F21-4144-91EC-53B92AEF62CE}</ProjectGuid>
-    <RootNamespace>lwIP pcapif</RootNamespace>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
-    <ConfigurationType>StaticLibrary</ConfigurationType>
-    <UseOfMfc>false</UseOfMfc>
-    <CharacterSet>MultiByte</CharacterSet>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
-    <ConfigurationType>StaticLibrary</ConfigurationType>
-    <UseOfMfc>false</UseOfMfc>
-    <CharacterSet>MultiByte</CharacterSet>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
-  <ImportGroup Label="ExtensionSettings">
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
-  </ImportGroup>
-  <PropertyGroup Label="UserMacros" />
-  <PropertyGroup>
-    <_ProjectFileVersion>10.0.40219.1</_ProjectFileVersion>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">.\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">.\$(Configuration)\$(ProjectName)\</IntDir>
-  </PropertyGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
-    <ClCompile>
-      <Optimization>Disabled</Optimization>
-      <AdditionalIncludeDirectories>..\..\..\..\src\include;..\..\..\..\src\include\ipv4;..\..\..\..\src\include\ipv6;..\include;..\..\..\examples\example_app;.\;$(PCAP_DIR)\Include;..\..\..\..\..\winpcap\WpdPack\Include\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>_LIB;WIN32;_DEBUG;LWIP_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <ProgramDataBaseFileName>$(IntDir)$(ProjectName).pdb</ProgramDataBaseFileName>
-      <WarningLevel>EnableAllWarnings</WarningLevel>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
-      <CompileAs>Default</CompileAs>
-      <TreatWarningAsError>true</TreatWarningAsError>
-    </ClCompile>
-    <ResourceCompile>
-      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <Culture>0x0407</Culture>
-    </ResourceCompile>
-    <Lib />
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
-    <ClCompile>
-      <Optimization>MaxSpeed</Optimization>
-      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
-      <AdditionalIncludeDirectories>..\..\..\..\src\include;..\..\..\..\src\include\ipv4;..\..\..\..\src\include\ipv6;..\include;..\..\..\examples\example_app;.\;$(PCAP_DIR)\Include;..\..\..\..\..\winpcap\WpdPack\Include\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
-      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
-      <FunctionLevelLinking>true</FunctionLevelLinking>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
-      <ProgramDataBaseFileName>$(IntDir)$(ProjectName).pdb</ProgramDataBaseFileName>
-      <WarningLevel>EnableAllWarnings</WarningLevel>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <CompileAs>Default</CompileAs>
-      <TreatWarningAsError>true</TreatWarningAsError>
-    </ClCompile>
-    <ResourceCompile>
-      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <Culture>0x0407</Culture>
-    </ResourceCompile>
-    <Lib>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-    </Lib>
-  </ItemDefinitionGroup>
-  <ItemGroup>
-    <ClCompile Include="..\pcapif.c" />
-    <ClCompile Include="..\pcapif_helper.c" />
-  </ItemGroup>
-  <ItemGroup>
-    <ClInclude Include="..\pcapif.h" />
-    <ClInclude Include="..\pcapif_helper.h" />
-  </ItemGroup>
-  <ItemGroup>
-    <ProjectReference Include="lwIP.vcxproj">
-      <Project>{2cc276fa-b226-49c9-8f82-7fcd5a228e28}</Project>
-      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
-    </ProjectReference>
-  </ItemGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
-  <ImportGroup Label="ExtensionTargets">
-  </ImportGroup>
-</Project>
\ No newline at end of file
diff --git a/contrib/ports/win32/msvc/lwIP_pcapif.vcxproj.filters b/contrib/ports/win32/msvc/lwIP_pcapif.vcxproj.filters
deleted file mode 100644
index f933f17a..00000000
--- a/contrib/ports/win32/msvc/lwIP_pcapif.vcxproj.filters
+++ /dev/null
@@ -1,28 +0,0 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup>
-    <Filter Include="Source Files">
-      <UniqueIdentifier>{0d38b8c3-e694-4572-89b8-fc6e825a092d}</UniqueIdentifier>
-      <Extensions>cpp;c;cxx;rc;def;r;odl;idl;hpj;bat</Extensions>
-    </Filter>
-    <Filter Include="Header Files">
-      <UniqueIdentifier>{e5ce29d5-319e-4e99-978b-b88e8d6167e4}</UniqueIdentifier>
-    </Filter>
-  </ItemGroup>
-  <ItemGroup>
-    <ClCompile Include="..\pcapif.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\pcapif_helper.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-  </ItemGroup>
-  <ItemGroup>
-    <ClInclude Include="..\pcapif.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\pcapif_helper.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-  </ItemGroup>
-</Project>
\ No newline at end of file
diff --git a/contrib/ports/win32/msvc/lwIP_unittests.sln b/contrib/ports/win32/msvc/lwIP_unittests.sln
deleted file mode 100644
index 2dfefb06..00000000
--- a/contrib/ports/win32/msvc/lwIP_unittests.sln
+++ /dev/null
@@ -1,31 +0,0 @@
-Microsoft Visual Studio Solution File, Format Version 11.00
-# Visual C++ Express 2010
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "lwip_unittests", "lwip_unittests.vcxproj", "{6CCABAA4-F86F-4119-AFF8-43C9A4A234C2}"
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "lwIP", "lwIP.vcxproj", "{2CC276FA-B226-49C9-8F82-7FCD5A228E28}"
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libcheck", "libcheck.vcxproj", "{EBB156DC-01BF-47B2-B69C-1A750B6B5F09}"
-EndProject
-Global
-	GlobalSection(SolutionConfigurationPlatforms) = preSolution
-		Debug|Win32 = Debug|Win32
-		Release|Win32 = Release|Win32
-	EndGlobalSection
-	GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		{6CCABAA4-F86F-4119-AFF8-43C9A4A234C2}.Debug|Win32.ActiveCfg = Debug|Win32
-		{6CCABAA4-F86F-4119-AFF8-43C9A4A234C2}.Debug|Win32.Build.0 = Debug|Win32
-		{6CCABAA4-F86F-4119-AFF8-43C9A4A234C2}.Release|Win32.ActiveCfg = Release|Win32
-		{6CCABAA4-F86F-4119-AFF8-43C9A4A234C2}.Release|Win32.Build.0 = Release|Win32
-		{2CC276FA-B226-49C9-8F82-7FCD5A228E28}.Debug|Win32.ActiveCfg = Debug unittests|Win32
-		{2CC276FA-B226-49C9-8F82-7FCD5A228E28}.Debug|Win32.Build.0 = Debug unittests|Win32
-		{2CC276FA-B226-49C9-8F82-7FCD5A228E28}.Release|Win32.ActiveCfg = Release unittests|Win32
-		{2CC276FA-B226-49C9-8F82-7FCD5A228E28}.Release|Win32.Build.0 = Release unittests|Win32
-		{EBB156DC-01BF-47B2-B69C-1A750B6B5F09}.Debug|Win32.ActiveCfg = Debug|Win32
-		{EBB156DC-01BF-47B2-B69C-1A750B6B5F09}.Debug|Win32.Build.0 = Debug|Win32
-		{EBB156DC-01BF-47B2-B69C-1A750B6B5F09}.Release|Win32.ActiveCfg = Release|Win32
-		{EBB156DC-01BF-47B2-B69C-1A750B6B5F09}.Release|Win32.Build.0 = Release|Win32
-	EndGlobalSection
-	GlobalSection(SolutionProperties) = preSolution
-		HideSolutionNode = FALSE
-	EndGlobalSection
-EndGlobal
diff --git a/contrib/ports/win32/msvc/lwip_unittests.vcxproj b/contrib/ports/win32/msvc/lwip_unittests.vcxproj
deleted file mode 100644
index f859eaf8..00000000
--- a/contrib/ports/win32/msvc/lwip_unittests.vcxproj
+++ /dev/null
@@ -1,137 +0,0 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup Label="ProjectConfigurations">
-    <ProjectConfiguration Include="Debug|Win32">
-      <Configuration>Debug</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|Win32">
-      <Configuration>Release</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-  </ItemGroup>
-  <PropertyGroup Label="Globals">
-    <ProjectGuid>{6CCABAA4-F86F-4119-AFF8-43C9A4A234C2}</ProjectGuid>
-    <RootNamespace>lwip_unittests</RootNamespace>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <CharacterSet>MultiByte</CharacterSet>
-    <WholeProgramOptimization>true</WholeProgramOptimization>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <CharacterSet>MultiByte</CharacterSet>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
-  <ImportGroup Label="ExtensionSettings">
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <PropertyGroup Label="UserMacros" />
-  <PropertyGroup>
-    <_ProjectFileVersion>10.0.40219.1</_ProjectFileVersion>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(Configuration)\$(ProjectName)\</IntDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(Configuration)\$(ProjectName)\</IntDir>
-  </PropertyGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
-    <ClCompile>
-      <Optimization>Disabled</Optimization>
-      <AdditionalIncludeDirectories>..\check;..\..\..\..\..\check\src;..\..\..\..\test\unit;..\..\..\..\src\include;..\..\..\..\src\include\ipv4;..\..\..\..\src\include\ipv6;..\include;..;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>_LIB;WIN32;_DEBUG;LWIP_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <MinimalRebuild>true</MinimalRebuild>
-      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
-      <WarningLevel>EnableAllWarnings</WarningLevel>
-      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
-      <DisableSpecificWarnings>4820</DisableSpecificWarnings>
-    </ClCompile>
-    <Link>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <RandomizedBaseAddress>false</RandomizedBaseAddress>
-      <DataExecutionPrevention>
-      </DataExecutionPrevention>
-      <TargetMachine>MachineX86</TargetMachine>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
-    <ClCompile>
-      <Optimization>MaxSpeed</Optimization>
-      <IntrinsicFunctions>true</IntrinsicFunctions>
-      <AdditionalIncludeDirectories>..\check;..\..\..\..\..\check\src;..\..\..\..\test\unit;..\..\..\..\src\include;..\..\..\..\src\include\ipv4;..\..\..\..\src\include\ipv6;..\include;..;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
-      <FunctionLevelLinking>true</FunctionLevelLinking>
-      <WarningLevel>Level4</WarningLevel>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-    </ClCompile>
-    <Link>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <OptimizeReferences>true</OptimizeReferences>
-      <EnableCOMDATFolding>true</EnableCOMDATFolding>
-      <RandomizedBaseAddress>false</RandomizedBaseAddress>
-      <DataExecutionPrevention>
-      </DataExecutionPrevention>
-      <TargetMachine>MachineX86</TargetMachine>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemGroup>
-    <ClCompile Include="..\..\..\..\test\unit\api\test_sockets.c" />
-    <ClCompile Include="..\..\..\..\test\unit\arch\sys_arch.c" />
-    <ClCompile Include="..\..\..\..\test\unit\core\test_def.c" />
-    <ClCompile Include="..\..\..\..\test\unit\core\test_mem.c" />
-    <ClCompile Include="..\..\..\..\test\unit\core\test_netif.c" />
-    <ClCompile Include="..\..\..\..\test\unit\core\test_pbuf.c" />
-    <ClCompile Include="..\..\..\..\test\unit\core\test_timers.c" />
-    <ClCompile Include="..\..\..\..\test\unit\ip4\test_ip4.c" />
-    <ClCompile Include="..\..\..\..\test\unit\ip6\test_ip6.c" />
-    <ClCompile Include="..\..\..\..\test\unit\mdns\test_mdns.c" />
-    <ClCompile Include="..\..\..\..\test\unit\mqtt\test_mqtt.c" />
-    <ClCompile Include="..\..\..\..\test\unit\tcp\tcp_helper.c" />
-    <ClCompile Include="..\..\..\..\test\unit\tcp\test_tcp.c" />
-    <ClCompile Include="..\..\..\..\test\unit\tcp\test_tcp_oos.c" />
-    <ClCompile Include="..\..\..\..\test\unit\udp\test_udp.c" />
-    <ClCompile Include="..\..\..\..\test\unit\etharp\test_etharp.c" />
-    <ClCompile Include="..\..\..\..\test\unit\dhcp\test_dhcp.c" />
-    <ClCompile Include="..\..\..\..\test\unit\lwip_unittests.c" />
-  </ItemGroup>
-  <ItemGroup>
-    <ClInclude Include="..\..\..\..\test\unit\api\test_sockets.h" />
-    <ClInclude Include="..\..\..\..\test\unit\arch\sys_arch.h" />
-    <ClInclude Include="..\..\..\..\test\unit\core\test_def.h" />
-    <ClInclude Include="..\..\..\..\test\unit\core\test_mem.h" />
-    <ClInclude Include="..\..\..\..\test\unit\core\test_netif.h" />
-    <ClInclude Include="..\..\..\..\test\unit\core\test_pbuf.h" />
-    <ClInclude Include="..\..\..\..\test\unit\core\test_timers.h" />
-    <ClInclude Include="..\..\..\..\test\unit\ip4\test_ip4.h" />
-    <ClInclude Include="..\..\..\..\test\unit\ip6\test_ip6.h" />
-    <ClInclude Include="..\..\..\..\test\unit\mdns\test_mdns.h" />
-    <ClInclude Include="..\..\..\..\test\unit\mqtt\test_mqtt.h" />
-    <ClInclude Include="..\..\..\..\test\unit\tcp\tcp_helper.h" />
-    <ClInclude Include="..\..\..\..\test\unit\tcp\test_tcp.h" />
-    <ClInclude Include="..\..\..\..\test\unit\tcp\test_tcp_oos.h" />
-    <ClInclude Include="..\..\..\..\test\unit\udp\test_udp.h" />
-    <ClInclude Include="..\..\..\..\test\unit\etharp\test_etharp.h" />
-    <ClInclude Include="..\..\..\..\test\unit\dhcp\test_dhcp.h" />
-    <ClInclude Include="..\..\..\..\test\unit\lwip_check.h" />
-    <ClInclude Include="..\..\..\..\test\unit\lwipopts.h" />
-  </ItemGroup>
-  <ItemGroup>
-    <ProjectReference Include="libcheck.vcxproj">
-      <Project>{ebb156dc-01bf-47b2-b69c-1a750b6b5f09}</Project>
-      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
-    </ProjectReference>
-    <ProjectReference Include="lwIP.vcxproj">
-      <Project>{2cc276fa-b226-49c9-8f82-7fcd5a228e28}</Project>
-      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
-    </ProjectReference>
-  </ItemGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
-  <ImportGroup Label="ExtensionTargets">
-  </ImportGroup>
-</Project>
\ No newline at end of file
diff --git a/contrib/ports/win32/msvc/lwip_unittests.vcxproj.filters b/contrib/ports/win32/msvc/lwip_unittests.vcxproj.filters
deleted file mode 100644
index 09455da9..00000000
--- a/contrib/ports/win32/msvc/lwip_unittests.vcxproj.filters
+++ /dev/null
@@ -1,147 +0,0 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup>
-    <Filter Include="core">
-      <UniqueIdentifier>{e351c538-9f2b-4a01-bf46-3ee8873cbc0f}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="tcp">
-      <UniqueIdentifier>{5805c4bc-32c1-49cf-a35e-af58757e2d7a}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="udp">
-      <UniqueIdentifier>{173ba4ab-b194-4933-8e02-319044c2a8fa}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="etharp">
-      <UniqueIdentifier>{70c655a7-f40f-4728-b586-33fd9598b355}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="dhcp">
-      <UniqueIdentifier>{a6b60d4e-4b81-44f2-9408-2e45cc769391}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="mdns">
-      <UniqueIdentifier>{d454902e-ce5b-48ae-a690-e6490bdbbf17}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="api">
-      <UniqueIdentifier>{d9501476-6102-4f14-90bd-35322fbd2fb2}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="arch">
-      <UniqueIdentifier>{b04f182c-1910-456d-9388-397dfe82dbc9}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="mqtt">
-      <UniqueIdentifier>{fd48ae04-ec85-478f-a97c-a7c8384a2d94}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="ip4">
-      <UniqueIdentifier>{fe93fc95-f1af-4a1f-a086-c1771dbf4d79}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="ipv6">
-      <UniqueIdentifier>{924d29be-e5e4-4b25-8bc4-92db91ce4c49}</UniqueIdentifier>
-    </Filter>
-  </ItemGroup>
-  <ItemGroup>
-    <ClCompile Include="..\..\..\..\test\unit\core\test_mem.c">
-      <Filter>core</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\test\unit\core\test_pbuf.c">
-      <Filter>core</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\test\unit\tcp\tcp_helper.c">
-      <Filter>tcp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\test\unit\tcp\test_tcp.c">
-      <Filter>tcp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\test\unit\tcp\test_tcp_oos.c">
-      <Filter>tcp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\test\unit\udp\test_udp.c">
-      <Filter>udp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\test\unit\etharp\test_etharp.c">
-      <Filter>etharp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\test\unit\dhcp\test_dhcp.c">
-      <Filter>dhcp</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\test\unit\lwip_unittests.c" />
-    <ClCompile Include="..\..\..\..\test\unit\mdns\test_mdns.c">
-      <Filter>mdns</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\test\unit\api\test_sockets.c">
-      <Filter>api</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\test\unit\arch\sys_arch.c">
-      <Filter>arch</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\test\unit\mqtt\test_mqtt.c">
-      <Filter>mqtt</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\test\unit\ip4\test_ip4.c">
-      <Filter>ip4</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\test\unit\core\test_def.c">
-      <Filter>core</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\test\unit\core\test_timers.c">
-      <Filter>core</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\test\unit\core\test_netif.c">
-      <Filter>core</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\test\unit\ip6\test_ip6.c">
-      <Filter>ipv6</Filter>
-    </ClCompile>
-  </ItemGroup>
-  <ItemGroup>
-    <ClInclude Include="..\..\..\..\test\unit\core\test_mem.h">
-      <Filter>core</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\test\unit\core\test_pbuf.h">
-      <Filter>core</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\test\unit\tcp\tcp_helper.h">
-      <Filter>tcp</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\test\unit\tcp\test_tcp.h">
-      <Filter>tcp</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\test\unit\tcp\test_tcp_oos.h">
-      <Filter>tcp</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\test\unit\udp\test_udp.h">
-      <Filter>udp</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\test\unit\etharp\test_etharp.h">
-      <Filter>etharp</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\test\unit\dhcp\test_dhcp.h">
-      <Filter>dhcp</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\test\unit\lwip_check.h" />
-    <ClInclude Include="..\..\..\..\test\unit\lwipopts.h" />
-    <ClInclude Include="..\..\..\..\test\unit\mdns\test_mdns.h">
-      <Filter>mdns</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\test\unit\api\test_sockets.h">
-      <Filter>api</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\test\unit\arch\sys_arch.h">
-      <Filter>arch</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\test\unit\mqtt\test_mqtt.h">
-      <Filter>mqtt</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\test\unit\ip4\test_ip4.h">
-      <Filter>ip4</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\test\unit\core\test_def.h">
-      <Filter>core</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\test\unit\core\test_timers.h">
-      <Filter>core</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\test\unit\core\test_netif.h">
-      <Filter>core</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\test\unit\ip6\test_ip6.h">
-      <Filter>ipv6</Filter>
-    </ClInclude>
-  </ItemGroup>
-</Project>
\ No newline at end of file
diff --git a/contrib/ports/win32/msvc/makefsdata.vcxproj b/contrib/ports/win32/msvc/makefsdata.vcxproj
deleted file mode 100644
index adb1d7e2..00000000
--- a/contrib/ports/win32/msvc/makefsdata.vcxproj
+++ /dev/null
@@ -1,99 +0,0 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup Label="ProjectConfigurations">
-    <ProjectConfiguration Include="Debug|Win32">
-      <Configuration>Debug</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|Win32">
-      <Configuration>Release</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-  </ItemGroup>
-  <ItemGroup>
-    <ClCompile Include="..\..\..\..\src\apps\http\makefsdata\makefsdata.c" />
-  </ItemGroup>
-  <PropertyGroup Label="Globals">
-    <ProjectGuid>{0BFC0F21-8E84-4E68-A9E1-CE2A09B72F6D}</ProjectGuid>
-    <RootNamespace>makefsdata</RootNamespace>
-    <Keyword>Win32Proj</Keyword>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <CharacterSet>Unicode</CharacterSet>
-    <WholeProgramOptimization>true</WholeProgramOptimization>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <CharacterSet>Unicode</CharacterSet>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
-  <ImportGroup Label="ExtensionSettings">
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <PropertyGroup Label="UserMacros" />
-  <PropertyGroup>
-    <_ProjectFileVersion>10.0.40219.1</_ProjectFileVersion>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(Configuration)\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</LinkIncremental>
-  </PropertyGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
-    <ClCompile>
-      <Optimization>Disabled</Optimization>
-      <AdditionalIncludeDirectories>..\..\..\..\src\include;..\..\..\..\src\include\ipv4;..\..\..\..\src\include\ipv6;..\include;..\..\..\examples\example_app;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <MinimalRebuild>true</MinimalRebuild>
-      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <WarningLevel>Level4</WarningLevel>
-      <TreatWarningAsError>true</TreatWarningAsError>
-      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
-    </ClCompile>
-    <Link>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <SubSystem>Console</SubSystem>
-      <RandomizedBaseAddress>false</RandomizedBaseAddress>
-      <DataExecutionPrevention>
-      </DataExecutionPrevention>
-      <TargetMachine>MachineX86</TargetMachine>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
-    <ClCompile>
-      <Optimization>MaxSpeed</Optimization>
-      <IntrinsicFunctions>true</IntrinsicFunctions>
-      <AdditionalIncludeDirectories>..\..\..\..\src\include;..\..\..\..\src\include\ipv4;..\..\..\..\src\include\ipv6;..\include;..\..\..\examples\example_app;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
-      <FunctionLevelLinking>true</FunctionLevelLinking>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <WarningLevel>Level4</WarningLevel>
-      <TreatWarningAsError>true</TreatWarningAsError>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-    </ClCompile>
-    <Link>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <SubSystem>Console</SubSystem>
-      <OptimizeReferences>true</OptimizeReferences>
-      <EnableCOMDATFolding>true</EnableCOMDATFolding>
-      <RandomizedBaseAddress>false</RandomizedBaseAddress>
-      <DataExecutionPrevention>
-      </DataExecutionPrevention>
-      <TargetMachine>MachineX86</TargetMachine>
-    </Link>
-  </ItemDefinitionGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
-  <ImportGroup Label="ExtensionTargets">
-  </ImportGroup>
-</Project>
\ No newline at end of file
diff --git a/contrib/ports/win32/msvc/makefsdata.vcxproj.filters b/contrib/ports/win32/msvc/makefsdata.vcxproj.filters
deleted file mode 100644
index 0f0210dc..00000000
--- a/contrib/ports/win32/msvc/makefsdata.vcxproj.filters
+++ /dev/null
@@ -1,14 +0,0 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup>
-    <Filter Include="Quelldateien">
-      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
-      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
-    </Filter>
-  </ItemGroup>
-  <ItemGroup>
-    <ClCompile Include="..\..\..\..\src\apps\http\makefsdata\makefsdata.c">
-      <Filter>Quelldateien</Filter>
-    </ClCompile>
-  </ItemGroup>
-</Project>
\ No newline at end of file
diff --git a/contrib/ports/win32/pcapif.c b/contrib/ports/win32/pcapif.c
deleted file mode 100644
index 36356ca5..00000000
--- a/contrib/ports/win32/pcapif.c
+++ /dev/null
@@ -1,1091 +0,0 @@
-/**
- * pcapif.c - This file is part of lwIP pcapif
- *
- ****************************************************************************
- *
- * This file is derived from an example in lwIP with the following license:
- *
- * Copyright (c) 2001, Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the Institute nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- */
-
-/* include the port-dependent configuration */
-#include "lwipcfg.h"
-
-#include <stdlib.h>
-#include <stdio.h>
-
-#ifdef _MSC_VER
-#pragma warning( push, 3 )
-#include "pcap.h"
-#pragma warning ( pop )
-#else
-/* e.g. mingw */
-#define _MSC_VER 1500
-#include "pcap.h"
-#undef _MSC_VER
-#endif
-
-#include "lwip/opt.h"
-
-#if LWIP_ETHERNET
-
-#include "pcapif.h"
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-
-#include "lwip/debug.h"
-
-#include "lwip/def.h"
-#include "lwip/mem.h"
-#include "lwip/pbuf.h"
-#include "lwip/stats.h"
-#include "lwip/sys.h"
-#include "lwip/ip.h"
-#include "lwip/snmp.h"
-#include "lwip/tcpip.h"
-#include "lwip/timeouts.h"
-#include "lwip/ethip6.h"
-
-#include "lwip/etharp.h"
-
-/* For compatibility with old pcap */
-#ifndef PCAP_OPENFLAG_PROMISCUOUS
-#define PCAP_OPENFLAG_PROMISCUOUS     1
-#endif
-
-/** Set this to 0 to receive all multicast ethernet destination addresses */
-#ifndef PCAPIF_FILTER_GROUP_ADDRESSES
-#define PCAPIF_FILTER_GROUP_ADDRESSES 1
-#endif
-
-/** Set this to 1 to receive all frames (also unicast to other addresses)
- * In this mode, filtering out our own tx packets from loopback receiving
- * is done via matching rx against recent tx (memcmp).
- */
-#ifndef PCAPIF_RECEIVE_PROMISCUOUS
-#define PCAPIF_RECEIVE_PROMISCUOUS    0
-#endif
-
-/* Define those to better describe your network interface.
-   For now, we use 'e0', 'e1', 'e2' and so on */
-#define IFNAME0                       'e'
-#define IFNAME1                       '0'
-
-/** index of the network adapter to use for lwIP */
-#ifndef PACKET_LIB_ADAPTER_NR
-#define PACKET_LIB_ADAPTER_NR         0
-#endif
-
-/** If 1, check link state and report it to lwIP.
- *  If 0, don't check link state (lwIP link state is always UP).
- */
-#ifndef PCAPIF_HANDLE_LINKSTATE
-#define PCAPIF_HANDLE_LINKSTATE       1
-#endif
-
-/** If 1, use PBUF_REF for RX (for testing purposes mainly).
- * For this, LWIP_SUPPORT_CUSTOM_PBUF must be enabled.
- */
-#ifndef PCAPIF_RX_REF
-#define PCAPIF_RX_REF                 0
-#endif
-
-/** This can be used when netif->state is used for something else in your
- * application (e.g. when wrapping a class around this interface). Just
- * make sure this define returns the state pointer set by
- * pcapif_low_level_init() (e.g. by using an offset or a callback).
- */
-#ifndef PCAPIF_GET_STATE_PTR
-#define PCAPIF_GET_STATE_PTR(netif)   ((netif)->state)
-#endif
-
-#if PCAPIF_HANDLE_LINKSTATE
-#include "pcapif_helper.h"
-
-/* Define "PHY" delay when "link up" */
-#ifndef PCAPIF_LINKUP_DELAY
-#define PCAPIF_LINKUP_DELAY           0
-#endif
-
-#define PCAPIF_LINKCHECK_INTERVAL_MS 500
-
-/* link state notification macro */
-#if PCAPIF_LINKUP_DELAY
-#define PCAPIF_NOTIFY_LINKSTATE(netif, linkfunc) sys_timeout(PCAPIF_LINKUP_DELAY, (sys_timeout_handler)linkfunc, netif)
-#else /* PHY_LINKUP_DELAY */
-#define PCAPIF_NOTIFY_LINKSTATE(netif, linkfunc) linkfunc(netif)
-#endif /* PHY_LINKUP_DELAY */
-
-#endif /* PCAPIF_HANDLE_LINKSTATE */
-
-/* Define PCAPIF_RX_LOCK_LWIP and PCAPIF_RX_UNLOCK_LWIP if you need to lock the lwIP core
-   before/after pbuf_alloc() or netif->input() are called on RX. */
-#ifndef PCAPIF_RX_LOCK_LWIP
-#define PCAPIF_RX_LOCK_LWIP()
-#endif
-#ifndef PCAPIF_RX_UNLOCK_LWIP
-#define PCAPIF_RX_UNLOCK_LWIP()
-#endif
-
-#define ETH_MIN_FRAME_LEN      60U
-#define ETH_MAX_FRAME_LEN      1518U
-
-#define ADAPTER_NAME_LEN       128
-#define ADAPTER_DESC_LEN       128
-
-#if PCAPIF_RECEIVE_PROMISCUOUS
-#ifndef PCAPIF_LOOPBACKFILTER_NUM_TX_PACKETS
-#define PCAPIF_LOOPBACKFILTER_NUM_TX_PACKETS  128
-#endif
-struct pcapipf_pending_packet {
-  struct pcapipf_pending_packet *next;
-  u16_t len;
-  u8_t data[ETH_MAX_FRAME_LEN];
-};
-#endif /* PCAPIF_RECEIVE_PROMISCUOUS */
-
-/* Packet Adapter informations */
-struct pcapif_private {
-  void            *input_fn_arg;
-  pcap_t          *adapter;
-  char             name[ADAPTER_NAME_LEN];
-  char             description[ADAPTER_DESC_LEN];
-  int              shutdown_called;
-#if PCAPIF_RX_USE_THREAD
-  volatile int     rx_run;
-  volatile int     rx_running;
-#endif /* PCAPIF_RX_USE_THREAD */
-#if PCAPIF_HANDLE_LINKSTATE
-  struct pcapifh_linkstate *link_state;
-  enum pcapifh_link_event last_link_event;
-#endif /* PCAPIF_HANDLE_LINKSTATE */
-#if PCAPIF_RECEIVE_PROMISCUOUS
-  struct pcapipf_pending_packet packets[PCAPIF_LOOPBACKFILTER_NUM_TX_PACKETS];
-  struct pcapipf_pending_packet *tx_packets;
-  struct pcapipf_pending_packet *free_packets;
-#endif /* PCAPIF_RECEIVE_PROMISCUOUS */
-};
-
-#if PCAPIF_RECEIVE_PROMISCUOUS
-static void
-pcapif_init_tx_packets(struct pcapif_private *priv)
-{
-  int i;
-  priv->tx_packets = NULL;
-  priv->free_packets = NULL;
-  for (i = 0; i < PCAPIF_LOOPBACKFILTER_NUM_TX_PACKETS; i++) {
-    struct pcapipf_pending_packet *pack = &priv->packets[i];
-    pack->len = 0;
-    pack->next = priv->free_packets;
-    priv->free_packets = pack;
-  }
-}
-
-static void
-pcapif_add_tx_packet(struct pcapif_private *priv, unsigned char *buf, u16_t tot_len)
-{
-  struct pcapipf_pending_packet *tx;
-  struct pcapipf_pending_packet *pack;
-  SYS_ARCH_DECL_PROTECT(lev);
-
-  /* get a free packet (locked) */
-  SYS_ARCH_PROTECT(lev);
-  pack = priv->free_packets;
-  if ((pack == NULL) && (priv->tx_packets != NULL)) {
-    /* no free packets, reuse the oldest */
-    pack = priv->tx_packets;
-    priv->tx_packets = pack->next;
-  }
-  LWIP_ASSERT("no free packet", pack != NULL);
-  priv->free_packets = pack->next;
-  pack->next = NULL;
-  SYS_ARCH_UNPROTECT(lev);
-
-  /* set up the packet (unlocked) */
-  pack->len = tot_len;
-  memcpy(pack->data, buf, tot_len);
-
-  /* put the packet on the list (locked) */
-  SYS_ARCH_PROTECT(lev);
-  if (priv->tx_packets != NULL) {
-    for (tx = priv->tx_packets; tx->next != NULL; tx = tx->next);
-    LWIP_ASSERT("bug", tx != NULL);
-    tx->next = pack;
-  } else {
-    priv->tx_packets = pack;
-  }
-  SYS_ARCH_UNPROTECT(lev);
-}
-
-static int
-pcapif_compare_packets(struct pcapipf_pending_packet *pack, const void *packet, int packet_len)
-{
-  if (pack->len == packet_len) {
-    if (!memcmp(pack->data, packet, packet_len)) {
-      return 1;
-    }
-  }
-  return 0;
-}
-
-static int
-pcaipf_is_tx_packet(struct netif *netif, const void *packet, int packet_len)
-{
-  struct pcapif_private *priv = (struct pcapif_private*)PCAPIF_GET_STATE_PTR(netif);
-  struct pcapipf_pending_packet *iter, *last;
-  SYS_ARCH_DECL_PROTECT(lev);
-
-  last = priv->tx_packets;
-  if (last == NULL) {
-    /* list is empty */
-    return 0;
-  }
-  /* compare the first packet */
-  if (pcapif_compare_packets(last, packet, packet_len)) {
-    SYS_ARCH_PROTECT(lev);
-    LWIP_ASSERT("list has changed", last == priv->tx_packets);
-    priv->tx_packets = last->next;
-    last->next = priv->free_packets;
-    priv->free_packets = last;
-    last->len = 0;
-    SYS_ARCH_UNPROTECT(lev);
-    return 1;
-  }
-  SYS_ARCH_PROTECT(lev);
-  for (iter = last->next; iter != NULL; last = iter, iter = iter->next) {
-    /* unlock while comparing (this works because we have a clean threading separation
-       of adding and removing items and adding is only done at the end) */
-    SYS_ARCH_UNPROTECT(lev);
-    if (pcapif_compare_packets(iter, packet, packet_len)) {
-      SYS_ARCH_PROTECT(lev);
-      LWIP_ASSERT("last != NULL", last != NULL);
-      last->next = iter->next;
-      iter->next = priv->free_packets;
-      priv->free_packets = iter;
-      last->len = 0;
-      SYS_ARCH_UNPROTECT(lev);
-      return 1;
-    }
-    SYS_ARCH_PROTECT(lev);
-  }
-  SYS_ARCH_UNPROTECT(lev);
-  return 0;
-}
-#else /* PCAPIF_RECEIVE_PROMISCUOUS */
-#define pcapif_init_tx_packets(priv)
-#define pcapif_add_tx_packet(priv, buf, tot_len)
-static int
-pcaipf_is_tx_packet(struct netif *netif, const void *packet, int packet_len)
-{
-  const struct eth_addr *src = (const struct eth_addr *)packet + 1;
-  if (packet_len >= (ETH_HWADDR_LEN * 2)) {
-    /* Don't let feedback packets through (limitation in winpcap?) */
-    if(!memcmp(src, netif->hwaddr, ETH_HWADDR_LEN)) {
-      return 1;
-    }
-  }
-  return 0;
-}
-#endif /* PCAPIF_RECEIVE_PROMISCUOUS */
-
-#if PCAPIF_RX_REF
-struct pcapif_pbuf_custom
-{
-   struct pbuf_custom pc;
-   struct pbuf* p;
-};
-#endif /* PCAPIF_RX_REF */
-
-/* Forward declarations. */
-static void pcapif_input(u_char *user, const struct pcap_pkthdr *pkt_header, const u_char *packet);
-
-#ifdef PACKET_LIB_GET_ADAPTER_NETADDRESS
-/** Get the index of an adapter by its network address
- *
- * @param netaddr network address of the adapter (e.g. 192.168.1.0)
- * @return index of the adapter or negative on error
- */
-static int
-get_adapter_index_from_addr(struct in_addr *netaddr, char *guid, size_t guid_len)
-{
-   pcap_if_t *alldevs;
-   pcap_if_t *d;
-   char errbuf[PCAP_ERRBUF_SIZE+1];
-   int index = 0;
-
-   memset(guid, 0, guid_len);
-
-   /* Retrieve the interfaces list */
-   if (pcap_findalldevs(&alldevs, errbuf) == -1) {
-      printf("Error in pcap_findalldevs: %s\n", errbuf);
-      return -1;
-   }
-   /* Scan the list printing every entry */
-   for (d = alldevs; d != NULL; d = d->next, index++) {
-      pcap_addr_t *a;
-      for(a = d->addresses; a != NULL; a = a->next) {
-         if (a->addr->sa_family == AF_INET) {
-            ULONG a_addr = ((struct sockaddr_in *)a->addr)->sin_addr.s_addr;
-            ULONG a_netmask = ((struct sockaddr_in *)a->netmask)->sin_addr.s_addr;
-            ULONG a_netaddr = a_addr & a_netmask;
-            ULONG addr = (*netaddr).s_addr;
-            if (a_netaddr == addr) {
-               int ret = -1;
-               char name[128];
-               char *start, *end;
-               size_t len = strlen(d->name);
-               if(len > 127) {
-                  len = 127;
-               }
-               MEMCPY(name, d->name, len);
-               name[len] = 0;
-               start = strstr(name, "{");
-               if (start != NULL) {
-                  end = strstr(start, "}");
-                  if (end != NULL) {
-                     size_t len = end - start + 1;
-                     MEMCPY(guid, start, len);
-                     ret = index;
-                  }
-               }
-               pcap_freealldevs(alldevs);
-               return ret;
-            }
-         }
-      }
-   }
-   printf("Network address not found.\n");
-
-   pcap_freealldevs(alldevs);
-   return -1;
-}
-#endif /* PACKET_LIB_GET_ADAPTER_NETADDRESS */
-
-#if defined(PACKET_LIB_GET_ADAPTER_NETADDRESS) || defined(PACKET_LIB_ADAPTER_GUID)
-/** Get the index of an adapter by its GUID
- *
- * @param adapter_guid GUID of the adapter
- * @return index of the adapter or negative on error
- */
-static int
-get_adapter_index(const char* adapter_guid)
-{
-  pcap_if_t *alldevs;
-  pcap_if_t *d;
-  char errbuf[PCAP_ERRBUF_SIZE+1];
-  int idx = 0;
-
-  /* Retrieve the interfaces list */
-  if (pcap_findalldevs(&alldevs, errbuf) == -1) {
-    printf("Error in pcap_findalldevs: %s\n", errbuf);
-    return -1;
-  }
-  /* Scan the list and compare name vs. adapter_guid */
-  for (d = alldevs; d != NULL; d = d->next, idx++) {
-    if(strstr(d->name, adapter_guid)) {
-      pcap_freealldevs(alldevs);
-      return idx;
-    }
-  }
-  /* not found, dump all adapters */
-  printf("%d available adapters:\n", idx);
-  for (d = alldevs, idx = 0; d != NULL; d = d->next, idx++) {
-    printf("- %d: %s\n", idx, d->name);
-  }
-  pcap_freealldevs(alldevs);
-  return -1;
-}
-#endif /* defined(PACKET_LIB_GET_ADAPTER_NETADDRESS) || defined(PACKET_LIB_ADAPTER_GUID) */
-
-static pcap_t*
-pcapif_open_adapter(const char* adapter_name, char* errbuf)
-{
-  pcap_t* adapter = pcap_open_live(adapter_name,/* name of the device */
-                               65536,             /* portion of the packet to capture */
-                                                  /* 65536 guarantees that the whole packet will be captured on all the link layers */
-                               PCAP_OPENFLAG_PROMISCUOUS,/* promiscuous mode */
-#if PCAPIF_RX_USE_THREAD
-                               /*-*/1,                /* don't wait at all for lower latency */
-#else
-                               1,                /* wait 1 ms in ethernetif_poll */
-#endif
-                               errbuf);           /* error buffer */
-  return adapter;
-}
-
-#if !PCAPIF_RX_USE_THREAD
-static void
-pcap_reopen_adapter(struct pcapif_private *pa)
-{
-  char errbuf[PCAP_ERRBUF_SIZE+1];
-  pcap_if_t *alldevs;
-  if (pa->adapter != NULL) {
-    pcap_close(pa->adapter);
-    pa->adapter = NULL;
-  }
-  if (pcap_findalldevs(&alldevs, errbuf) != -1) {
-    pcap_if_t *d;
-    for (d = alldevs; d != NULL; d = d->next) {
-      if (!strcmp(d->name, pa->name)) {
-        pa->adapter = pcapif_open_adapter(pa->name, errbuf);
-        if (pa->adapter == NULL) {
-          printf("failed to reopen pcap adapter after failure: %s\n", errbuf);
-        }
-        break;
-      }
-    }
-    pcap_freealldevs(alldevs);
-  }
-}
-#endif
-
-/**
- * Open a network adapter and set it up for packet input
- *
- * @param adapter_num the index of the adapter to use
- * @param arg argument to pass to input
- * @return an adapter handle on success, NULL on failure
- */
-static struct pcapif_private*
-pcapif_init_adapter(int adapter_num, void *arg)
-{
-  int i;
-  int number_of_adapters;
-  struct pcapif_private *pa;
-  char errbuf[PCAP_ERRBUF_SIZE+1];
-
-  pcap_if_t *alldevs;
-  pcap_if_t *d;
-  pcap_if_t *used_adapter = NULL;
-
-  pa = (struct pcapif_private *)malloc(sizeof(struct pcapif_private));
-  if (!pa) {
-    printf("Unable to alloc the adapter!\n");
-    return NULL;
-  }
-
-  memset(pa, 0, sizeof(struct pcapif_private));
-  pcapif_init_tx_packets(pa);
-  pa->input_fn_arg = arg;
-
-  /* Retrieve the interfaces list */
-  if (pcap_findalldevs(&alldevs, errbuf) == -1) {
-    free(pa);
-    return NULL; /* no adapters found */
-  }
-  /* get number of adapters and adapter pointer */
-  for (d = alldevs, number_of_adapters = 0; d != NULL; d = d->next, number_of_adapters++) {
-    if (number_of_adapters == adapter_num) {
-      char *desc = d->description;
-      size_t len;
-
-      len = strlen(d->name);
-      LWIP_ASSERT("len < ADAPTER_NAME_LEN", len < ADAPTER_NAME_LEN);
-      strcpy(pa->name, d->name);
-
-      used_adapter = d;
-      /* format vendor description */
-      if (desc != NULL) {
-        len = strlen(desc);
-        if (strstr(desc, " ' on local host") != NULL) {
-          len -= 16;
-        }
-        else if (strstr(desc, "' on local host") != NULL) {
-          len -= 15;
-        }
-        if (strstr(desc, "Network adapter '") == desc) {
-          len -= 17;
-          desc += 17;
-        }
-        len = LWIP_MIN(len, ADAPTER_DESC_LEN-1);
-        while ((desc[len-1] == ' ') || (desc[len-1] == '\t')) {
-          /* don't copy trailing whitespace */
-          len--;
-        }
-        strncpy(pa->description, desc, len);
-        pa->description[len] = 0;
-      } else {
-        strcpy(pa->description, "<no_desc>");
-      }
-    }
-  }
-
-#ifndef PCAPIF_LIB_QUIET
-  /* Scan the list printing every entry */
-  for (d = alldevs, i = 0; d != NULL; d = d->next, i++) {
-    char *desc = d->description;
-    char descBuf[128];
-    size_t len;
-    const char* devname = d->name;
-    if (d->name == NULL) {
-      devname = "<unnamed>";
-    } else {
-      if (strstr(devname, "\\Device\\") == devname) {
-        /* windows: strip the first part */
-        devname += 8;
-      }
-    }
-    printf("%2i: %s\n", i, devname);
-    if (desc != NULL) {
-      /* format vendor description */
-      len = strlen(desc);
-      if (strstr(desc, " ' on local host") != NULL) {
-        len -= 16;
-      }
-      else if (strstr(desc, "' on local host") != NULL) {
-        len -= 15;
-      }
-      if (strstr(desc, "Network adapter '") == desc) {
-        len -= 17;
-        desc += 17;
-      }
-      len = LWIP_MIN(len, 127);
-      while ((desc[len-1] == ' ') || (desc[len-1] == '\t')) {
-        /* don't copy trailing whitespace */
-        len--;
-      }
-      strncpy(descBuf, desc, len);
-      descBuf[len] = 0;
-      printf("     Desc: \"%s\"\n", descBuf);
-    }
-  }
-#endif /* PCAPIF_LIB_QUIET */
-
-  /* invalid adapter index -> check this after printing the adapters */
-  if (adapter_num < 0) {
-    printf("Invalid adapter_num: %d\n", adapter_num);
-    free(pa);
-    pcap_freealldevs(alldevs);
-    return NULL;
-  }
-  /* adapter index out of range */
-  if (adapter_num >= number_of_adapters) {
-    printf("Invalid adapter_num: %d\n", adapter_num);
-    free(pa);
-    pcap_freealldevs(alldevs);
-    return NULL;
-  }
-#ifndef PCAPIF_LIB_QUIET
-  printf("Using adapter_num: %d\n", adapter_num);
-#endif /* PCAPIF_LIB_QUIET */
-  /* set up the selected adapter */
-
-  LWIP_ASSERT("used_adapter != NULL", used_adapter != NULL);
-
-  /* Open the device */
-  pa->adapter = pcapif_open_adapter(used_adapter->name, errbuf);
-  if (pa->adapter == NULL) {
-    printf("\nUnable to open the adapter. %s is not supported by pcap (\"%s\").\n", used_adapter->name, errbuf);
-    /* Free the device list */
-    pcap_freealldevs(alldevs);
-    free(pa);
-    return NULL;
-  }
-  printf("Using adapter: \"%s\"\n", pa->description);
-  pcap_freealldevs(alldevs);
-
-#if PCAPIF_HANDLE_LINKSTATE
-  pa->link_state = pcapifh_linkstate_init(pa->name);
-  pa->last_link_event = PCAPIF_LINKEVENT_UNKNOWN;
-#endif /* PCAPIF_HANDLE_LINKSTATE */
-
-  return pa;
-}
-
-#if PCAPIF_HANDLE_LINKSTATE
-static void
-pcapif_check_linkstate(void *netif_ptr)
-{
-  struct netif *netif = (struct netif*)netif_ptr;
-  struct pcapif_private *pa = (struct pcapif_private*)PCAPIF_GET_STATE_PTR(netif);
-  enum pcapifh_link_event le;
-
-  le = pcapifh_linkstate_get(pa->link_state);
-
-  if (pa->last_link_event != le) {
-    pa->last_link_event = le;
-    switch (le) {
-      case PCAPIF_LINKEVENT_UP: {
-        PCAPIF_NOTIFY_LINKSTATE(netif, netif_set_link_up);
-        break;
-      }
-      case PCAPIF_LINKEVENT_DOWN: {
-        PCAPIF_NOTIFY_LINKSTATE(netif, netif_set_link_down);
-        break;
-      }
-      case PCAPIF_LINKEVENT_UNKNOWN: /* fall through */
-      default:
-        break;
-    }
-  }
-  sys_timeout(PCAPIF_LINKCHECK_INTERVAL_MS, pcapif_check_linkstate, netif);
-}
-#endif /* PCAPIF_HANDLE_LINKSTATE */
-
-
-/**
- * Close the adapter (no more packets can be sent or received)
- *
- * @param netif netif to shutdown
- */
-void
-pcapif_shutdown(struct netif *netif)
-{
-  struct pcapif_private *pa = (struct pcapif_private*)PCAPIF_GET_STATE_PTR(netif);
-  if (pa) {
-#if PCAPIF_RX_USE_THREAD
-    pa->rx_run = 0;
-#endif /* PCAPIF_RX_USE_THREAD */
-    if (pa->adapter) {
-      pcap_breakloop(pa->adapter);
-      pcap_close(pa->adapter);
-    }
-#if PCAPIF_RX_USE_THREAD
-    /* wait for rxthread to end */
-    while(pa->rx_running);
-#endif /* PCAPIF_RX_USE_THREAD */
-#if PCAPIF_HANDLE_LINKSTATE
-    pcapifh_linkstate_close(pa->link_state);
-#endif /* PCAPIF_HANDLE_LINKSTATE */
-    free(pa);
-  }
-}
-
-#if PCAPIF_RX_USE_THREAD
-/** RX running in its own thread */
-static void
-pcapif_input_thread(void *arg)
-{
-  struct netif *netif = (struct netif *)arg;
-  struct pcapif_private *pa = (struct pcapif_private*)PCAPIF_GET_STATE_PTR(netif);
-  do
-  {
-    struct pcap_pkthdr pkt_header;
-    const u_char *packet = pcap_next(pa->adapter, &pkt_header);
-    if(packet != NULL) {
-      pcapif_input((u_char*)pa, &pkt_header, packet);
-    }
-  } while (pa->rx_run);
-  pa->rx_running = 0;
-}
-#endif /* PCAPIF_RX_USE_THREAD */
-
-/** Low-level initialization: find the correct adapter and initialize it.
- */
-static void
-pcapif_low_level_init(struct netif *netif)
-{
-  u8_t my_mac_addr[ETH_HWADDR_LEN] = LWIP_MAC_ADDR_BASE;
-  int adapter_num = PACKET_LIB_ADAPTER_NR;
-  struct pcapif_private *pa;
-#ifdef PACKET_LIB_GET_ADAPTER_NETADDRESS
-  ip4_addr_t netaddr;
-#define GUID_LEN 128
-  char guid[GUID_LEN + 1];
-#endif /* PACKET_LIB_GET_ADAPTER_NETADDRESS */
-
-  /* If 'state' is != NULL at this point, we assume it is an 'int' giving
-     the index of the adapter to use (+ 1 because 0==NULL is invalid).
-     This can be used to instantiate multiple PCAP drivers. */
-  if (netif->state != NULL) {
-    adapter_num = (LWIP_PTR_NUMERIC_CAST(int, netif->state)) - 1;
-    if (adapter_num < 0) {
-      printf("ERROR: invalid adapter index \"%d\"!\n", adapter_num);
-      LWIP_ASSERT("ERROR initializing network adapter!\n", 0);
-      return;
-    }
-  }
-
-#ifdef PACKET_LIB_GET_ADAPTER_NETADDRESS
-  memset(&guid, 0, sizeof(guid));
-  PACKET_LIB_GET_ADAPTER_NETADDRESS(&netaddr);
-  if (get_adapter_index_from_addr((struct in_addr *)&netaddr, guid, GUID_LEN) < 0) {
-     printf("ERROR initializing network adapter, failed to get GUID for network address %s\n", ip4addr_ntoa(&netaddr));
-     LWIP_ASSERT("ERROR initializing network adapter, failed to get GUID for network address!", 0);
-     return;
-  }
-  adapter_num = get_adapter_index(guid);
-  if (adapter_num < 0) {
-     printf("ERROR finding network adapter with GUID \"%s\"!\n", guid);
-     LWIP_ASSERT("ERROR finding network adapter with expected GUID!", 0);
-     return;
-  }
-
-#else /* PACKET_LIB_GET_ADAPTER_NETADDRESS */
-#ifdef PACKET_LIB_ADAPTER_GUID
-  /* get adapter index for guid string */
-  adapter_num = get_adapter_index(PACKET_LIB_ADAPTER_GUID);
-  if (adapter_num < 0) {
-    printf("ERROR finding network adapter with GUID \"%s\"!\n", PACKET_LIB_ADAPTER_GUID);
-    LWIP_ASSERT("ERROR initializing network adapter!\n", 0);
-    return;
-  }
-#endif /* PACKET_LIB_ADAPTER_GUID */
-#endif /* PACKET_LIB_GET_ADAPTER_NETADDRESS */
-
-  /* Do whatever else is needed to initialize interface. */
-  pa = pcapif_init_adapter(adapter_num, netif);
-  if (pa == NULL) {
-    printf("ERROR initializing network adapter %d!\n", adapter_num);
-    LWIP_ASSERT("ERROR initializing network adapter!", 0);
-    return;
-  }
-  netif->state = pa;
-
-  /* change the MAC address to a unique value
-     so that multiple ethernetifs are supported */
-  /* @todo: this does NOT support multiple processes using this adapter! */
-  my_mac_addr[ETH_HWADDR_LEN - 1] += netif->num;
-  /* Copy MAC addr */
-  SMEMCPY(&netif->hwaddr, my_mac_addr, ETH_HWADDR_LEN);
-
-  /* get the initial link state of the selected interface */
-#if PCAPIF_HANDLE_LINKSTATE
-  pa->last_link_event = pcapifh_linkstate_get(pa->link_state);
-  if (pa->last_link_event == PCAPIF_LINKEVENT_DOWN) {
-    netif_set_link_down(netif);
-  } else {
-    netif_set_link_up(netif);
-  }
-  sys_timeout(PCAPIF_LINKCHECK_INTERVAL_MS, pcapif_check_linkstate, netif);
-#else /* PCAPIF_HANDLE_LINKSTATE */
-  /* just set the link up so that lwIP can transmit */
-  netif_set_link_up(netif);
-#endif /* PCAPIF_HANDLE_LINKSTATE */
-
-#if PCAPIF_RX_USE_THREAD
-  pa->rx_run = 1;
-  pa->rx_running = 1;
-  sys_thread_new("pcapif_rxthread", pcapif_input_thread, netif, 0, 0);
-#endif
-
-  LWIP_DEBUGF(NETIF_DEBUG, ("pcapif: eth_addr %02X%02X%02X%02X%02X%02X\n",netif->hwaddr[0],netif->hwaddr[1],netif->hwaddr[2],netif->hwaddr[3],netif->hwaddr[4],netif->hwaddr[5]));
-}
-
-/** low_level_output():
- * Transmit a packet. The packet is contained in the pbuf that is passed to
- * the function. This pbuf might be chained.
- */
-static err_t
-pcapif_low_level_output(struct netif *netif, struct pbuf *p)
-{
-  struct pbuf *q;
-  unsigned char buffer[ETH_MAX_FRAME_LEN + ETH_PAD_SIZE];
-  unsigned char *buf = buffer;
-  unsigned char *ptr;
-  struct eth_hdr *ethhdr;
-  u16_t tot_len = p->tot_len - ETH_PAD_SIZE;
-  struct pcapif_private *pa = (struct pcapif_private*)PCAPIF_GET_STATE_PTR(netif);
-
-#if defined(LWIP_DEBUG) && LWIP_NETIF_TX_SINGLE_PBUF && !(LWIP_IPV4 && IP_FRAG) && (LWIP_IPV6 && LWIP_IPV6_FRAG)
-  LWIP_ASSERT("p->next == NULL && p->len == p->tot_len", p->next == NULL && p->len == p->tot_len);
-#endif
-
-  /* initiate transfer */
-  if ((p->len == p->tot_len) && (p->len >= ETH_MIN_FRAME_LEN + ETH_PAD_SIZE)) {
-    /* no pbuf chain, don't have to copy -> faster */
-    buf = &((unsigned char*)p->payload)[ETH_PAD_SIZE];
-  } else {
-    /* pbuf chain, copy into contiguous buffer */
-    if (p->tot_len >= sizeof(buffer)) {
-      LINK_STATS_INC(link.lenerr);
-      LINK_STATS_INC(link.drop);
-      MIB2_STATS_NETIF_INC(netif, ifoutdiscards);
-      return ERR_BUF;
-    }
-    ptr = buffer;
-    for(q = p; q != NULL; q = q->next) {
-      /* Send the data from the pbuf to the interface, one pbuf at a
-         time. The size of the data in each pbuf is kept in the ->len
-         variable. */
-      /* send data from(q->payload, q->len); */
-      LWIP_DEBUGF(NETIF_DEBUG, ("netif: send ptr %p q->payload %p q->len %i q->next %p\n", ptr, q->payload, (int)q->len, (void*)q->next));
-      if (q == p) {
-        MEMCPY(ptr, &((char*)q->payload)[ETH_PAD_SIZE], q->len - ETH_PAD_SIZE);
-        ptr += q->len - ETH_PAD_SIZE;
-      } else {
-        MEMCPY(ptr, q->payload, q->len);
-        ptr += q->len;
-      }
-    }
-  }
-
-  if (tot_len < ETH_MIN_FRAME_LEN) {
-    /* ensure minimal frame length */
-    memset(&buf[tot_len], 0, ETH_MIN_FRAME_LEN - tot_len);
-    tot_len = ETH_MIN_FRAME_LEN;
-  }
-
-  /* signal that packet should be sent */
-  if (pcap_sendpacket(pa->adapter, buf, tot_len) < 0) {
-    LINK_STATS_INC(link.memerr);
-    LINK_STATS_INC(link.drop);
-    MIB2_STATS_NETIF_INC(netif, ifoutdiscards);
-    return ERR_BUF;
-  }
-  if (netif_is_link_up(netif)) {
-    pcapif_add_tx_packet(pa, buf, tot_len);
-  }
-
-  LINK_STATS_INC(link.xmit);
-  MIB2_STATS_NETIF_ADD(netif, ifoutoctets, tot_len);
-  ethhdr = (struct eth_hdr *)p->payload;
-  if ((ethhdr->dest.addr[0] & 1) != 0) {
-    /* broadcast or multicast packet*/
-    MIB2_STATS_NETIF_INC(netif, ifoutnucastpkts);
-  } else {
-    /* unicast packet */
-    MIB2_STATS_NETIF_INC(netif, ifoutucastpkts);
-  }
-  return ERR_OK;
-}
-
-/** low_level_input(): Allocate a pbuf and transfer the bytes of the incoming
- * packet from the interface into the pbuf.
- */
-static struct pbuf *
-pcapif_low_level_input(struct netif *netif, const void *packet, int packet_len)
-{
-  struct pbuf *p, *q;
-  int start;
-  int length = packet_len;
-  const struct eth_addr *dest = (const struct eth_addr*)packet;
-  int unicast;
-#if PCAPIF_FILTER_GROUP_ADDRESSES && !PCAPIF_RECEIVE_PROMISCUOUS
-  const u8_t bcast[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
-  const u8_t ipv4mcast[] = {0x01, 0x00, 0x5e};
-  const u8_t ipv6mcast[] = {0x33, 0x33};
-#endif /* PCAPIF_FILTER_GROUP_ADDRESSES && !PCAPIF_RECEIVE_PROMISCUOUS */
-
-  if (pcaipf_is_tx_packet(netif, packet, packet_len)) {
-    /* don't update counters here! */
-    return NULL;
-  }
-
-  unicast = ((dest->addr[0] & 0x01) == 0);
-#if !PCAPIF_RECEIVE_PROMISCUOUS
-  /* MAC filter: only let my MAC or non-unicast through (pcap receives loopback traffic, too) */
-  if (memcmp(dest, &netif->hwaddr, ETH_HWADDR_LEN) &&
-#if PCAPIF_FILTER_GROUP_ADDRESSES
-    (memcmp(dest, ipv4mcast, 3) || ((dest->addr[3] & 0x80) != 0)) &&
-    memcmp(dest, ipv6mcast, 2) &&
-    memcmp(dest, bcast, 6)
-#else /* PCAPIF_FILTER_GROUP_ADDRESSES */
-     unicast
-#endif /* PCAPIF_FILTER_GROUP_ADDRESSES */
-    ) {
-    /* don't update counters here! */
-    return NULL;
-  }
-#endif /* !PCAPIF_RECEIVE_PROMISCUOUS */
-
-  /* We allocate a pbuf chain of pbufs from the pool. */
-  p = pbuf_alloc(PBUF_RAW, (u16_t)length + ETH_PAD_SIZE, PBUF_POOL);
-  LWIP_DEBUGF(NETIF_DEBUG, ("netif: recv length %i p->tot_len %i\n", length, (int)p->tot_len));
-
-  if (p != NULL) {
-    /* We iterate over the pbuf chain until we have read the entire
-       packet into the pbuf. */
-    start = 0;
-    for (q = p; q != NULL; q = q->next) {
-      u16_t copy_len = q->len;
-      /* Read enough bytes to fill this pbuf in the chain. The
-         available data in the pbuf is given by the q->len
-         variable. */
-      /* read data into(q->payload, q->len); */
-      LWIP_DEBUGF(NETIF_DEBUG, ("netif: recv start %i length %i q->payload %p q->len %i q->next %p\n", start, length, q->payload, (int)q->len, (void*)q->next));
-      if (q == p) {
-#if ETH_PAD_SIZE
-        LWIP_ASSERT("q->len >= ETH_PAD_SIZE", q->len >= ETH_PAD_SIZE);
-        copy_len -= ETH_PAD_SIZE;
-#endif /* ETH_PAD_SIZE*/
-        MEMCPY(&((char*)q->payload)[ETH_PAD_SIZE], &((const char*)packet)[start], copy_len);
-      } else {
-        MEMCPY(q->payload, &((const char*)packet)[start], copy_len);
-      }
-      start += copy_len;
-      length -= copy_len;
-      if (length <= 0) {
-        break;
-      }
-    }
-    LINK_STATS_INC(link.recv);
-    MIB2_STATS_NETIF_ADD(netif, ifinoctets, p->tot_len - ETH_PAD_SIZE);
-    if (unicast) {
-      MIB2_STATS_NETIF_INC(netif, ifinucastpkts);
-    } else {
-      MIB2_STATS_NETIF_INC(netif, ifinnucastpkts);
-    }
-  } else {
-    /* drop packet */
-    LINK_STATS_INC(link.memerr);
-    LINK_STATS_INC(link.drop);
-    MIB2_STATS_NETIF_INC(netif, ifindiscards);
-  }
-
-  return p;
-}
-
-#if PCAPIF_RX_REF
-static void
-pcapif_rx_pbuf_free_custom(struct pbuf *p)
-{
-  struct pcapif_pbuf_custom* ppc;
-  LWIP_ASSERT("NULL pointer", p != NULL);
-  ppc = (struct pcapif_pbuf_custom*)p;
-  LWIP_ASSERT("NULL pointer", ppc->p != NULL);
-  pbuf_free(ppc->p);
-  ppc->p = NULL;
-  mem_free(p);
-}
-
-static struct pbuf*
-pcapif_rx_ref(struct pbuf* p)
-{
-  struct pcapif_pbuf_custom* ppc;
-  struct pbuf* q;
-
-  LWIP_ASSERT("NULL pointer", p != NULL);
-  LWIP_ASSERT("chained pbuf not supported here", p->next == NULL);
-
-  ppc = (struct pcapif_pbuf_custom*)mem_malloc(sizeof(struct pcapif_pbuf_custom));
-  LWIP_ASSERT("out of memory for RX", ppc != NULL);
-  ppc->pc.custom_free_function = pcapif_rx_pbuf_free_custom;
-  ppc->p = p;
-
-  q = pbuf_alloced_custom(PBUF_RAW, p->tot_len, PBUF_REF, &ppc->pc, p->payload, p->tot_len);
-  LWIP_ASSERT("pbuf_alloced_custom returned NULL", q != NULL);
-  return q;
-}
-#endif /* PCAPIF_RX_REF */
-
-/** pcapif_input: This function is called when a packet is ready to be read
- * from the interface. It uses the function low_level_input() that should
- * handle the actual reception of bytes from the network interface.
- */
-static void
-pcapif_input(u_char *user, const struct pcap_pkthdr *pkt_header, const u_char *packet)
-{
-  struct pcapif_private *pa = (struct pcapif_private*)user;
-  int packet_len = pkt_header->caplen;
-  struct netif *netif = (struct netif *)pa->input_fn_arg;
-  struct pbuf *p;
-
-  PCAPIF_RX_LOCK_LWIP();
-
-  /* move received packet into a new pbuf */
-  p = pcapif_low_level_input(netif, packet, packet_len);
-  /* if no packet could be read, silently ignore this */
-  if (p != NULL) {
-#if PCAPIF_RX_REF
-    p = pcapif_rx_ref(p);
-#endif
-    /* pass all packets to ethernet_input, which decides what packets it supports */
-    if (netif->input(p, netif) != ERR_OK) {
-      LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_input: IP input error\n"));
-      pbuf_free(p);
-    }
-  }
-  PCAPIF_RX_UNLOCK_LWIP();
-}
-
-/**
- * pcapif_init(): initialization function, pass to netif_add().
- */
-err_t
-pcapif_init(struct netif *netif)
-{
-  static int ethernetif_index;
-
-  int local_index;
-  SYS_ARCH_DECL_PROTECT(lev);
-  SYS_ARCH_PROTECT(lev);
-  local_index = ethernetif_index++;
-  SYS_ARCH_UNPROTECT(lev);
-
-  LWIP_ASSERT("pcapif needs an input callback", netif->input != NULL);
-
-  netif->name[0] = IFNAME0;
-  netif->name[1] = (char)(IFNAME1 + local_index);
-  netif->linkoutput = pcapif_low_level_output;
-#if LWIP_IPV4
-#if LWIP_ARP
-  netif->output = etharp_output;
-#else /* LWIP_ARP */
-  netif->output = NULL; /* not used for PPPoE */
-#endif /* LWIP_ARP */
-#endif /* LWIP_IPV4 */
-#if LWIP_IPV6
-  netif->output_ip6 = ethip6_output;
-#endif /* LWIP_IPV6 */
-#if LWIP_NETIF_HOSTNAME
-  /* Initialize interface hostname */
-  netif_set_hostname(netif, "lwip");
-#endif /* LWIP_NETIF_HOSTNAME */
-
-  netif->mtu = 1500;
-  netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_ETHERNET | NETIF_FLAG_IGMP;
-#if LWIP_IPV6 && LWIP_IPV6_MLD
-  netif->flags |= NETIF_FLAG_MLD6;
-#endif /* LWIP_IPV6 && LWIP_IPV6_MLD */
-  netif->hwaddr_len = ETH_HWADDR_LEN;
-
-  NETIF_INIT_SNMP(netif, snmp_ifType_ethernet_csmacd, 100000000);
-
-  /* sets link up or down based on current status */
-  pcapif_low_level_init(netif);
-
-  return ERR_OK;
-}
-
-#if !PCAPIF_RX_USE_THREAD
-void
-pcapif_poll(struct netif *netif)
-{
-  struct pcapif_private *pa = (struct pcapif_private*)PCAPIF_GET_STATE_PTR(netif);
-
-  int ret;
-  do {
-    if (pa->adapter != NULL) {
-      ret = pcap_dispatch(pa->adapter, -1, pcapif_input, (u_char*)pa);
-    } else {
-      ret = -1;
-    }
-    if (ret < 0) {
-      /* error (e.g. adapter removed or resume from standby), try to reopen the adapter */
-      pcap_reopen_adapter(pa);
-    }
-  } while (ret > 0);
-
-}
-#endif /* !PCAPIF_RX_USE_THREAD */
-
-#endif /* LWIP_ETHERNET */
diff --git a/contrib/ports/win32/pcapif.h b/contrib/ports/win32/pcapif.h
deleted file mode 100644
index 8d67ea42..00000000
--- a/contrib/ports/win32/pcapif.h
+++ /dev/null
@@ -1,32 +0,0 @@
-#ifndef LWIP_PCAPIF_H
-#define LWIP_PCAPIF_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include "lwip/err.h"
-
-/** Set to 1 to let rx use an own thread (only for NO_SYS==0).
- * If set to 0, ethernetif_poll is used to poll for packets.
- */
-#ifndef PCAPIF_RX_USE_THREAD
-#define PCAPIF_RX_USE_THREAD !NO_SYS
-#endif
-#if PCAPIF_RX_USE_THREAD && NO_SYS
-#error "Can't create a dedicated RX thread with NO_SYS==1"
-#endif
-
-struct netif;
-
-err_t pcapif_init    (struct netif *netif);
-void  pcapif_shutdown(struct netif *netif);
-#if !PCAPIF_RX_USE_THREAD
-void  pcapif_poll    (struct netif *netif);
-#endif /* !PCAPIF_RX_USE_THREAD */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* LWIP_PCAPIF_H */
diff --git a/contrib/ports/win32/pcapif_helper.c b/contrib/ports/win32/pcapif_helper.c
deleted file mode 100644
index 52670b16..00000000
--- a/contrib/ports/win32/pcapif_helper.c
+++ /dev/null
@@ -1,105 +0,0 @@
-/**
- * pcapif_helper.c - This file is part of lwIP pcapif and provides helper functions
- * for managing the link state.
- */
-
-#include "pcapif_helper.h"
-
-#include <stdlib.h>
-#include <stdio.h>
-
-#include "lwip/arch.h"
-
-#ifdef WIN32
-
-#define WIN32_LEAN_AND_MEAN
-
-#ifdef _MSC_VER
-#pragma warning( push, 3 )
-#endif
-#include <windows.h>
-#include <packet32.h>
-#include <ntddndis.h>
-#ifdef _MSC_VER
-#pragma warning ( pop )
-#endif
-
-struct pcapifh_linkstate {
-  LPADAPTER        lpAdapter;
-  PPACKET_OID_DATA ppacket_oid_data;
-};
-
-struct pcapifh_linkstate* pcapifh_linkstate_init(char *adapter_name)
-{
-  struct pcapifh_linkstate* state = (struct pcapifh_linkstate*)malloc(sizeof(struct pcapifh_linkstate));
-  if (state != NULL) {
-    memset(state, 0, sizeof(struct pcapifh_linkstate));
-    state->ppacket_oid_data = (PPACKET_OID_DATA)malloc(sizeof(PACKET_OID_DATA) + sizeof(NDIS_MEDIA_STATE));
-    if (state->ppacket_oid_data == NULL) {
-      free(state);
-      state = NULL;
-    } else {
-      state->lpAdapter = PacketOpenAdapter((char*)adapter_name);
-      if ((state->lpAdapter == NULL) || (state->lpAdapter->hFile == INVALID_HANDLE_VALUE)) {
-        /* failed to open adapter */
-        free(state);
-        state = NULL;
-      }
-    }
-  }
-  return state;
-}
-
-enum pcapifh_link_event pcapifh_linkstate_get(struct pcapifh_linkstate* state)
-{
-  enum pcapifh_link_event ret = PCAPIF_LINKEVENT_UNKNOWN;
-  if (state != NULL) {
-    state->ppacket_oid_data->Oid    = OID_GEN_MEDIA_CONNECT_STATUS;
-    state->ppacket_oid_data->Length = sizeof(NDIS_MEDIA_STATE);
-    if (PacketRequest(state->lpAdapter, FALSE, state->ppacket_oid_data)) {
-      NDIS_MEDIA_STATE fNdisMediaState;
-      fNdisMediaState = (*((PNDIS_MEDIA_STATE)(state->ppacket_oid_data->Data)));
-      ret = ((fNdisMediaState == NdisMediaStateConnected) ? PCAPIF_LINKEVENT_UP : PCAPIF_LINKEVENT_DOWN);
-    }
-  }
-  return ret;
-}
-
-void pcapifh_linkstate_close(struct pcapifh_linkstate* state)
-{
-  if (state != NULL) {
-    if (state->lpAdapter != NULL) {
-      PacketCloseAdapter(state->lpAdapter);
-    }
-    if (state->ppacket_oid_data != NULL) {
-      free(state->ppacket_oid_data);
-    }
-    free(state);
-  }
-}
-
-#else /* WIN32 */
-
-/* @todo: add linux/unix implementation? */
-
-struct pcapifh_linkstate {
-  u8_t empty;
-};
-
-struct pcapifh_linkstate* pcapifh_linkstate_init(char *adapter_name)
-{
-  LWIP_UNUSED_ARG(adapter_name);
-  return NULL;
-}
-
-enum pcapifh_link_event pcapifh_linkstate_get(struct pcapifh_linkstate* state)
-{
-  LWIP_UNUSED_ARG(state);
-  return PCAPIF_LINKEVENT_UP;
-}
-void pcapifh_linkstate_close(struct pcapifh_linkstate* state)
-{
-  LWIP_UNUSED_ARG(state);
-}
-
-#endif /* WIN32 */
diff --git a/contrib/ports/win32/pcapif_helper.h b/contrib/ports/win32/pcapif_helper.h
deleted file mode 100644
index f2e7fa4b..00000000
--- a/contrib/ports/win32/pcapif_helper.h
+++ /dev/null
@@ -1,25 +0,0 @@
-#ifndef LWIP_PCAPIF_HELPER_H
-#define LWIP_PCAPIF_HELPER_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-struct pcapifh_linkstate;
-
-enum pcapifh_link_event {
-  PCAPIF_LINKEVENT_UNKNOWN,
-  PCAPIF_LINKEVENT_UP,
-  PCAPIF_LINKEVENT_DOWN
-};
-
-struct pcapifh_linkstate* pcapifh_linkstate_init(char *adapter_name);
-enum pcapifh_link_event pcapifh_linkstate_get(struct pcapifh_linkstate* state);
-void pcapifh_linkstate_close(struct pcapifh_linkstate* state);
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* LWIP_PCAPIF_HELPER_H */
diff --git a/contrib/ports/win32/readme.txt b/contrib/ports/win32/readme.txt
deleted file mode 100644
index 02a79e25..00000000
--- a/contrib/ports/win32/readme.txt
+++ /dev/null
@@ -1,26 +0,0 @@
-lwIP for Win32
-
-This is an example port of lwIP for Win32. It uses WinPCAP to send & receive packets.
-To compile it, use the MSVC projects in the 'msvc' subdir or the Makefile in the 'mingw' subdir.
-
-For both compilers:
-- the lwIP core repository must be in a folder "lwip" next to the "contrib" folder
-- you have to set an environment variable PCAP_DIR pointing to the WinPcap Developer's
-  Pack (containing 'include' and 'lib')
-  alternatively, place the WinPcap Developer's pack next to the "lwip" and "contrib" folders:
-  "winpcap\WpdPack"
-
-You also will have to copy the file 'lwipcfg_msvc.h.example' to
-'lwipcfg_msvc.h' and modify to suit your needs (WinPcap adapter number,
-IP configuration, applications...).
-
-Included in the contrib\ports\win32 directory is the network interface driver
-using the winpcap library.
-
-lwIP: http://savannah.nongnu.org/projects/lwip/
-WinPCap: https://www.winpcap.org/devel.htm
-Visual C++: http://www.microsoft.com/express/download/
-
-To compile the unittests (msvc\lwIP_unittests.sln), download check (tested with v0.11.0) from
-https://github.com/libcheck/check/releases/
-and place it in a folder "check" next to the "contrib" folder.
diff --git a/contrib/ports/win32/sio.c b/contrib/ports/win32/sio.c
deleted file mode 100644
index 1cf1ef5e..00000000
--- a/contrib/ports/win32/sio.c
+++ /dev/null
@@ -1,304 +0,0 @@
-/*
- * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- */
-
-#include <lwip/opt.h>
-#include <lwip/sys.h>
-#include <lwip/sio.h>
-
-#include <stdio.h>
-#include <stdarg.h>
-
-#ifdef _MSC_VER
-#pragma warning (push, 3)
-#endif
-#include <windows.h>
-#ifdef _MSC_VER
-#pragma warning (pop)
-#endif
-#include "lwipcfg.h"
-
-/** When 1, use COM ports, when 0, use named pipes (for simulation). */
-#ifndef SIO_USE_COMPORT
-#define SIO_USE_COMPORT 1
-#endif
-
-/** If SIO_USE_COMPORT==1, use COMx, if 0, use a pipe (default) */
-#if SIO_USE_COMPORT
-#define SIO_DEVICENAME "\\\\.\\COM"
-#else
-#define SIO_DEVICENAME "\\\\.\\pipe\\lwip"
-#endif
-
-#if SIO_USE_COMPORT
-#ifndef SIO_COMPORT_SPEED
-#define SIO_COMPORT_SPEED 115200
-#endif
-#ifndef SIO_COMPORT_BYTESIZE
-#define SIO_COMPORT_BYTESIZE 8
-#endif
-#ifndef SIO_COMPORT_STOPBITS
-#define SIO_COMPORT_STOPBITS 0 /* ONESTOPBIT */
-#endif
-#ifndef SIO_COMPORT_PARITY
-#define SIO_COMPORT_PARITY 0 /* NOPARITY */
-#endif
-#endif /* SIO_USE_COMPORT */
-
-static int sio_abort = 0;
-
-/* \\.\pipe\lwip0 */
-/* pppd /dev/ttyS0 logfile mylog debug nocrtscts local noauth noccp ms-dns 212.27.54.252 192.168.0.4:192.168.0.5
- */
-
-/**
- * SIO_DEBUG: Enable debugging for SIO.
- */
-#ifndef SIO_DEBUG
-#define SIO_DEBUG    LWIP_DBG_OFF
-#endif
-
-#if SIO_USE_COMPORT
-/** When using a real COM port, set up the
- * serial line settings (baudrate etc.)
- */
-static BOOL
-sio_setup(HANDLE fd)
-{
-  COMMTIMEOUTS cto;
-  DCB dcb;
-
-  /* set up baudrate and other communication settings */
-  memset(&dcb, 0, sizeof(dcb));
-  /* Obtain the DCB structure for the device */
-  if (!GetCommState(fd, &dcb)) {
-    return FALSE;
-  }
-  /* Set the new data */
-  dcb.BaudRate = SIO_COMPORT_SPEED;
-  dcb.ByteSize = SIO_COMPORT_BYTESIZE;
-  dcb.StopBits = 0; /* ONESTOPBIT */
-  dcb.Parity   = 0; /* NOPARITY */
-  dcb.fParity  = 0; /* parity is not used */
-  /* do not use flow control */
-  /*dcb.fOutxDsrFlow = dcb.fDtrControl = 0;
-  dcb.fOutxCtsFlow = dcb.fRtsControl = 0;
-  dcb.fErrorChar = dcb.fNull = 0;
-  dcb.fInX = dcb.fOutX = 0;
-  dcb.XonChar = dcb.XoffChar = 0;
-  dcb.XonLim = dcb.XoffLim = 100;*/
-
-  /* Set the new DCB structure */
-  if (!SetCommState(fd, &dcb)) {
-    return FALSE;
-  }
-
-  memset(&cto, 0, sizeof(cto));
-  if(!GetCommTimeouts(fd, &cto))
-  {
-    return FALSE;
-  }
-  /* change read timeout, leave write timeout as it is */
-  cto.ReadIntervalTimeout = 1;
-  cto.ReadTotalTimeoutMultiplier = 0;
-  cto.ReadTotalTimeoutConstant = 1; /* 1 ms */
-  if(!SetCommTimeouts(fd, &cto)) {
-    return FALSE;
-  }
-
-  return TRUE;
-}
-#endif /* SIO_USE_COMPORT */
-
-/**
- * Opens a serial device for communication.
- *
- * @param devnum device number
- * @return handle to serial device if successful, NULL otherwise
- */
-sio_fd_t sio_open(u8_t devnum)
-{
-  HANDLE fileHandle = INVALID_HANDLE_VALUE;
-  CHAR   fileName[256];
-  LWIP_DEBUGF(SIO_DEBUG, ("sio_open(%lu)\n", (DWORD)devnum));
-#if SIO_USE_COMPORT
-  snprintf(fileName, 255, SIO_DEVICENAME"%lu", (DWORD)(devnum));
-#else /* SIO_USE_COMPORT */
-  snprintf(fileName, 255, SIO_DEVICENAME"%lu", (DWORD)(devnum & ~1));
-  if ((devnum & 1) == 0) {
-    fileHandle = CreateNamedPipeA(fileName, PIPE_ACCESS_DUPLEX, PIPE_TYPE_BYTE | PIPE_NOWAIT,
-      PIPE_UNLIMITED_INSTANCES, 102400, 102400, 100, NULL);
-  } else
-#endif /* SIO_USE_COMPORT */
-  {
-    fileHandle = CreateFileA(fileName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
-  }
-  if (fileHandle != INVALID_HANDLE_VALUE) {
-    sio_abort = 0;
-#if !SIO_USE_COMPORT
-    if (devnum & 1) {
-      DWORD mode = PIPE_NOWAIT;
-      if (!SetNamedPipeHandleState(fileHandle, &mode, NULL, NULL)) {
-        LWIP_DEBUGF(SIO_DEBUG, ("sio_open(%lu): SetNamedPipeHandleState failed. GetLastError() returns %d\n",
-                  (DWORD)devnum, GetLastError()));
-      }
-    } else
-#endif /* !SIO_USE_COMPORT */
-    {
-      FlushFileBuffers(fileHandle);
-    }
-#if SIO_USE_COMPORT
-    if(!sio_setup(fileHandle)) {
-      CloseHandle(fileHandle);
-      LWIP_DEBUGF(SIO_DEBUG, ("sio_open(%lu): sio_setup failed. GetLastError() returns %lu\n",
-                  (DWORD)devnum, GetLastError()));
-      return NULL;
-    }
-#endif /* SIO_USE_COMPORT */
-    LWIP_DEBUGF(SIO_DEBUG, ("sio_open: file \"%s\" successfully opened.\n", fileName));
-    printf("sio_open: file \"%s\" (%d) successfully opened: 0x%08x\n", fileName, devnum, LWIP_PTR_NUMERIC_CAST(unsigned int, fileHandle));
-    return (sio_fd_t)(fileHandle);
-  }
-  LWIP_DEBUGF(SIO_DEBUG, ("sio_open(%lu) failed. GetLastError() returns %lu\n",
-              (DWORD)devnum, GetLastError()));
-  printf("sio_open(%lu) failed. GetLastError() returns %lu\n",
-              (DWORD)devnum, GetLastError());
-  return NULL;
-}
-
-/**
- * Sends a single character to the serial device.
- *
- * @param c character to send
- * @param fd serial device handle
- *
- * @note This function will block until the character can be sent.
- */
-void sio_send(u8_t c, sio_fd_t fd)
-{
-  DWORD dwNbBytesWritten = 0;
-  LWIP_DEBUGF(SIO_DEBUG, ("sio_send(%lu)\n", (DWORD)c));
-  while ((!WriteFile((HANDLE)(fd), &c, 1, &dwNbBytesWritten, NULL)) || (dwNbBytesWritten < 1)) {
-  }
-}
-
-/**
- * Receives a single character from the serial device.
- *
- * @param fd serial device handle
- *
- * @note This function will block until a character is received.
- */
-u8_t sio_recv(sio_fd_t fd)
-{
-  DWORD dwNbBytesReadden = 0;
-  u8_t byte = 0;
-  LWIP_DEBUGF(SIO_DEBUG, ("sio_recv()\n"));
-  while ((sio_abort == 0) && ((!ReadFile((HANDLE)(fd), &byte, 1, &dwNbBytesReadden, NULL)) || (dwNbBytesReadden < 1)));
-  LWIP_DEBUGF(SIO_DEBUG, ("sio_recv()=%lu\n", (DWORD)byte));
-  return byte;
-}
-
-/**
- * Reads from the serial device.
- *
- * @param fd serial device handle
- * @param data pointer to data buffer for receiving
- * @param len maximum length (in bytes) of data to receive
- * @return number of bytes actually received - may be 0 if aborted by sio_read_abort
- *
- * @note This function will block until data can be received. The blocking
- * can be cancelled by calling sio_read_abort().
- */
-u32_t sio_read(sio_fd_t fd, u8_t* data, u32_t len)
-{
-  BOOL ret;
-  DWORD dwNbBytesReadden = 0;
-  LWIP_DEBUGF(SIO_DEBUG, ("sio_read()...\n"));
-  ret = ReadFile((HANDLE)(fd), data, len, &dwNbBytesReadden, NULL);
-  LWIP_DEBUGF(SIO_DEBUG, ("sio_read()=%lu bytes -> %d\n", dwNbBytesReadden, ret));
-  LWIP_UNUSED_ARG(ret);
-  return dwNbBytesReadden;
-}
-
-/**
- * Tries to read from the serial device. Same as sio_read but returns
- * immediately if no data is available and never blocks.
- *
- * @param fd serial device handle
- * @param data pointer to data buffer for receiving
- * @param len maximum length (in bytes) of data to receive
- * @return number of bytes actually received
- */
-u32_t sio_tryread(sio_fd_t fd, u8_t* data, u32_t len)
-{
-  /* @todo: implement non-blocking read */
-  BOOL ret;
-  DWORD dwNbBytesReadden = 0;
-  LWIP_DEBUGF(SIO_DEBUG, ("sio_read()...\n"));
-  ret = ReadFile((HANDLE)(fd), data, len, &dwNbBytesReadden, NULL);
-  LWIP_DEBUGF(SIO_DEBUG, ("sio_read()=%lu bytes -> %d\n", dwNbBytesReadden, ret));
-  LWIP_UNUSED_ARG(ret);
-  return dwNbBytesReadden;
-}
-
-/**
- * Writes to the serial device.
- *
- * @param fd serial device handle
- * @param data pointer to data to send
- * @param len length (in bytes) of data to send
- * @return number of bytes actually sent
- *
- * @note This function will block until all data can be sent.
- */
-u32_t sio_write(sio_fd_t fd, u8_t* data, u32_t len)
-{
-  BOOL ret;
-  DWORD dwNbBytesWritten = 0;
-  LWIP_DEBUGF(SIO_DEBUG, ("sio_write()...\n"));
-  ret = WriteFile((HANDLE)(fd), data, len, &dwNbBytesWritten, NULL);
-  LWIP_DEBUGF(SIO_DEBUG, ("sio_write()=%lu bytes -> %d\n", dwNbBytesWritten, ret));
-  LWIP_UNUSED_ARG(ret);
-  return dwNbBytesWritten;
-}
-
-/**
- * Aborts a blocking sio_read() call.
- * @todo: This currently ignores fd and aborts all reads
- *
- * @param fd serial device handle
- */
-void sio_read_abort(sio_fd_t fd)
-{
-  LWIP_UNUSED_ARG(fd);
-  LWIP_DEBUGF(SIO_DEBUG, ("sio_read_abort() !!!!!...\n"));
-  sio_abort = 1;
-  return;
-}
diff --git a/contrib/ports/win32/sys_arch.c b/contrib/ports/win32/sys_arch.c
deleted file mode 100644
index 84c1bcaf..00000000
--- a/contrib/ports/win32/sys_arch.c
+++ /dev/null
@@ -1,772 +0,0 @@
-/*
- * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Adam Dunkels <adam@sics.se>
- *         Simon Goldschmidt
- *
- */
-
-#include <stdlib.h>
-#include <stdio.h> /* sprintf() for task names */
-
-#ifdef _MSC_VER
-#pragma warning (push, 3)
-#endif
-#include <windows.h>
-#ifdef _MSC_VER
-#pragma warning (pop)
-#endif
-#include <time.h>
-
-#include <lwip/opt.h>
-#include <lwip/arch.h>
-#include <lwip/stats.h>
-#include <lwip/debug.h>
-#include <lwip/sys.h>
-#include <lwip/tcpip.h>
-
-/** Set this to 1 to enable assertion checks that SYS_ARCH_PROTECT() is only
- * called once in a call stack (calling it nested might cause trouble in some
- * implementations, so let's avoid this in core code as long as we can).
- */
-#ifndef LWIP_SYS_ARCH_CHECK_NESTED_PROTECT
-#define LWIP_SYS_ARCH_CHECK_NESTED_PROTECT 1
-#endif
-
-/** Set this to 1 to enable assertion checks that SYS_ARCH_PROTECT() is *not*
- * called before functions potentiolly involving the OS scheduler.
- *
- * This scheme is currently broken only for non-core-locking when waking up
- * threads waiting on a socket via select/poll.
- */
-#ifndef LWIP_SYS_ARCH_CHECK_SCHEDULING_UNPROTECTED
-#define LWIP_SYS_ARCH_CHECK_SCHEDULING_UNPROTECTED LWIP_TCPIP_CORE_LOCKING
-#endif
-
-#define LWIP_WIN32_SYS_ARCH_ENABLE_PROTECT_COUNTER (LWIP_SYS_ARCH_CHECK_NESTED_PROTECT || LWIP_SYS_ARCH_CHECK_SCHEDULING_UNPROTECTED)
-
-/* These functions are used from NO_SYS also, for precise timer triggering */
-static LARGE_INTEGER freq, sys_start_time;
-#define SYS_INITIALIZED() (freq.QuadPart != 0)
-
-static DWORD netconn_sem_tls_index;
-
-static HCRYPTPROV hcrypt;
-
-u32_t
-lwip_port_rand(void)
-{
-  u32_t ret;
-  if (CryptGenRandom(hcrypt, sizeof(ret), (BYTE*)&ret)) {
-    return ret;
-  }
-  LWIP_ASSERT("CryptGenRandom failed", 0);
-  return 0;
-}
-
-static void
-sys_win_rand_init(void)
-{
-  if (!CryptAcquireContext(&hcrypt, NULL, NULL, PROV_RSA_FULL, 0)) {
-    DWORD err = GetLastError();
-    LWIP_PLATFORM_DIAG(("CryptAcquireContext failed with error %d, trying to create NEWKEYSET", (int)err));
-    if(!CryptAcquireContext(&hcrypt, NULL, NULL, PROV_RSA_FULL, CRYPT_NEWKEYSET)) {
-      char errbuf[128];
-      err = GetLastError();
-      snprintf(errbuf, sizeof(errbuf), "CryptAcquireContext failed with error %d", (int)err);
-      LWIP_UNUSED_ARG(err);
-      LWIP_ASSERT(errbuf, 0);
-    }
-  }
-}
-
-static void
-sys_init_timing(void)
-{
-  QueryPerformanceFrequency(&freq);
-  QueryPerformanceCounter(&sys_start_time);
-}
-
-static LONGLONG
-sys_get_ms_longlong(void)
-{
-  LONGLONG ret;
-  LARGE_INTEGER now;
-#if NO_SYS
-  if (!SYS_INITIALIZED()) {
-    sys_init();
-    LWIP_ASSERT("initialization failed", SYS_INITIALIZED());
-  }
-#endif /* NO_SYS */
-  QueryPerformanceCounter(&now);
-  ret = now.QuadPart-sys_start_time.QuadPart;
-  return (u32_t)(((ret)*1000)/freq.QuadPart);
-}
-
-u32_t
-sys_jiffies(void)
-{
-  return (u32_t)sys_get_ms_longlong();
-}
-
-u32_t
-sys_now(void)
-{
-  return (u32_t)sys_get_ms_longlong();
-}
-
-CRITICAL_SECTION critSec;
-#if LWIP_WIN32_SYS_ARCH_ENABLE_PROTECT_COUNTER
-static int protection_depth;
-#endif
-
-static void
-InitSysArchProtect(void)
-{
-  InitializeCriticalSection(&critSec);
-}
-
-sys_prot_t
-sys_arch_protect(void)
-{
-#if NO_SYS
-  if (!SYS_INITIALIZED()) {
-    sys_init();
-    LWIP_ASSERT("initialization failed", SYS_INITIALIZED());
-  }
-#endif
-  EnterCriticalSection(&critSec);
-#if LWIP_SYS_ARCH_CHECK_NESTED_PROTECT
-  LWIP_ASSERT("nested SYS_ARCH_PROTECT", protection_depth == 0);
-#endif
-#if LWIP_WIN32_SYS_ARCH_ENABLE_PROTECT_COUNTER
-  protection_depth++;
-#endif
-  return 0;
-}
-
-void
-sys_arch_unprotect(sys_prot_t pval)
-{
-  LWIP_UNUSED_ARG(pval);
-#if LWIP_SYS_ARCH_CHECK_NESTED_PROTECT
-  LWIP_ASSERT("missing SYS_ARCH_PROTECT", protection_depth == 1);
-#else
-  LWIP_ASSERT("missing SYS_ARCH_PROTECT", protection_depth > 0);
-#endif
-#if LWIP_WIN32_SYS_ARCH_ENABLE_PROTECT_COUNTER
-  protection_depth--;
-#endif
-  LeaveCriticalSection(&critSec);
-}
-
-#if LWIP_SYS_ARCH_CHECK_SCHEDULING_UNPROTECTED
-/** This checks that SYS_ARCH_PROTECT() hasn't been called by protecting
- * and then checking the level
- */
-static void
-sys_arch_check_not_protected(void)
-{
-  sys_arch_protect();
-  LWIP_ASSERT("SYS_ARCH_PROTECT before scheduling", protection_depth == 1);
-  sys_arch_unprotect(0);
-}
-#else
-#define sys_arch_check_not_protected()
-#endif
-
-static void
-msvc_sys_init(void)
-{
-  sys_win_rand_init();
-  sys_init_timing();
-  InitSysArchProtect();
-  netconn_sem_tls_index = TlsAlloc();
-  LWIP_ASSERT("TlsAlloc failed", netconn_sem_tls_index != TLS_OUT_OF_INDEXES);
-}
-
-void
-sys_init(void)
-{
-  msvc_sys_init();
-}
-
-#if !NO_SYS
-
-struct threadlist {
-  lwip_thread_fn function;
-  void *arg;
-  DWORD id;
-  struct threadlist *next;
-};
-
-static struct threadlist *lwip_win32_threads = NULL;
-
-err_t
-sys_sem_new(sys_sem_t *sem, u8_t count)
-{
-  HANDLE new_sem = NULL;
-
-  LWIP_ASSERT("sem != NULL", sem != NULL);
-
-  new_sem = CreateSemaphore(0, count, 100000, 0);
-  LWIP_ASSERT("Error creating semaphore", new_sem != NULL);
-  if(new_sem != NULL) {
-    if (SYS_INITIALIZED()) {
-      SYS_ARCH_LOCKED(SYS_STATS_INC_USED(sem));
-    } else {
-      SYS_STATS_INC_USED(sem);
-    }
-#if LWIP_STATS && SYS_STATS
-    LWIP_ASSERT("sys_sem_new() counter overflow", lwip_stats.sys.sem.used != 0);
-#endif /* LWIP_STATS && SYS_STATS*/
-    sem->sem = new_sem;
-    return ERR_OK;
-  }
-
-  /* failed to allocate memory... */
-  if (SYS_INITIALIZED()) {
-    SYS_ARCH_LOCKED(SYS_STATS_INC(sem.err));
-  } else {
-    SYS_STATS_INC(sem.err);
-  }
-  sem->sem = NULL;
-  return ERR_MEM;
-}
-
-void
-sys_sem_free(sys_sem_t *sem)
-{
-  /* parameter check */
-  LWIP_ASSERT("sem != NULL", sem != NULL);
-  LWIP_ASSERT("sem->sem != NULL", sem->sem != NULL);
-  LWIP_ASSERT("sem->sem != INVALID_HANDLE_VALUE", sem->sem != INVALID_HANDLE_VALUE);
-  CloseHandle(sem->sem);
-
-  SYS_ARCH_LOCKED(SYS_STATS_DEC(sem.used));
-#if LWIP_STATS && SYS_STATS
-  LWIP_ASSERT("sys_sem_free() closed more than created", lwip_stats.sys.sem.used != (u16_t)-1);
-#endif /* LWIP_STATS && SYS_STATS */
-  sem->sem = NULL;
-}
-
-u32_t
-sys_arch_sem_wait(sys_sem_t *sem, u32_t timeout)
-{
-  DWORD ret;
-  LONGLONG starttime, endtime;
-  LWIP_ASSERT("sem != NULL", sem != NULL);
-  LWIP_ASSERT("sem->sem != NULL", sem->sem != NULL);
-  LWIP_ASSERT("sem->sem != INVALID_HANDLE_VALUE", sem->sem != INVALID_HANDLE_VALUE);
-  if (!timeout) {
-    /* wait infinite */
-    starttime = sys_get_ms_longlong();
-    ret = WaitForSingleObject(sem->sem, INFINITE);
-    LWIP_ASSERT("Error waiting for semaphore", ret == WAIT_OBJECT_0);
-    endtime = sys_get_ms_longlong();
-    /* return the time we waited for the sem */
-    return (u32_t)(endtime - starttime);
-  } else {
-    starttime = sys_get_ms_longlong();
-    ret = WaitForSingleObject(sem->sem, timeout);
-    LWIP_ASSERT("Error waiting for semaphore", (ret == WAIT_OBJECT_0) || (ret == WAIT_TIMEOUT));
-    if (ret == WAIT_OBJECT_0) {
-      endtime = sys_get_ms_longlong();
-      /* return the time we waited for the sem */
-      return (u32_t)(endtime - starttime);
-    } else {
-      /* timeout */
-      return SYS_ARCH_TIMEOUT;
-    }
-  }
-}
-
-void
-sys_sem_signal(sys_sem_t *sem)
-{
-  BOOL ret;
-  sys_arch_check_not_protected();
-  LWIP_ASSERT("sem != NULL", sem != NULL);
-  LWIP_ASSERT("sem->sem != NULL", sem->sem != NULL);
-  LWIP_ASSERT("sem->sem != INVALID_HANDLE_VALUE", sem->sem != INVALID_HANDLE_VALUE);
-  ret = ReleaseSemaphore(sem->sem, 1, NULL);
-  LWIP_ASSERT("Error releasing semaphore", ret != 0);
-  LWIP_UNUSED_ARG(ret);
-}
-
-err_t
-sys_mutex_new(sys_mutex_t *mutex)
-{
-  HANDLE new_mut = NULL;
-
-  LWIP_ASSERT("mutex != NULL", mutex != NULL);
-
-  new_mut = CreateMutex(NULL, FALSE, NULL);
-  LWIP_ASSERT("Error creating mutex", new_mut != NULL);
-  if (new_mut != NULL) {
-    SYS_ARCH_LOCKED(SYS_STATS_INC_USED(mutex));
-#if LWIP_STATS && SYS_STATS
-    LWIP_ASSERT("sys_mutex_new() counter overflow", lwip_stats.sys.mutex.used != 0);
-#endif /* LWIP_STATS && SYS_STATS*/
-    mutex->mut = new_mut;
-    return ERR_OK;
-  }
-
-  /* failed to allocate memory... */
-  SYS_ARCH_LOCKED(SYS_STATS_INC(mutex.err));
-  mutex->mut = NULL;
-  return ERR_MEM;
-}
-
-void
-sys_mutex_free(sys_mutex_t *mutex)
-{
-  /* parameter check */
-  LWIP_ASSERT("mutex != NULL", mutex != NULL);
-  LWIP_ASSERT("mutex->mut != NULL", mutex->mut != NULL);
-  LWIP_ASSERT("mutex->mut != INVALID_HANDLE_VALUE", mutex->mut != INVALID_HANDLE_VALUE);
-  CloseHandle(mutex->mut);
-
-  SYS_ARCH_LOCKED(SYS_STATS_DEC(mutex.used));
-#if LWIP_STATS && SYS_STATS
-  LWIP_ASSERT("sys_mutex_free() closed more than created", lwip_stats.sys.mutex.used != (u16_t)-1);
-#endif /* LWIP_STATS && SYS_STATS */
-  mutex->mut = NULL;
-}
-
-void sys_mutex_lock(sys_mutex_t *mutex)
-{
-  DWORD ret;
-  LWIP_ASSERT("mutex != NULL", mutex != NULL);
-  LWIP_ASSERT("mutex->mut != NULL", mutex->mut != NULL);
-  LWIP_ASSERT("mutex->mut != INVALID_HANDLE_VALUE", mutex->mut != INVALID_HANDLE_VALUE);
-  /* wait infinite */
-  ret = WaitForSingleObject(mutex->mut, INFINITE);
-  LWIP_ASSERT("Error waiting for mutex", ret == WAIT_OBJECT_0);
-  LWIP_UNUSED_ARG(ret);
-}
-
-void
-sys_mutex_unlock(sys_mutex_t *mutex)
-{
-  sys_arch_check_not_protected();
-  LWIP_ASSERT("mutex != NULL", mutex != NULL);
-  LWIP_ASSERT("mutex->mut != NULL", mutex->mut != NULL);
-  LWIP_ASSERT("mutex->mut != INVALID_HANDLE_VALUE", mutex->mut != INVALID_HANDLE_VALUE);
-  /* wait infinite */
-  if (!ReleaseMutex(mutex->mut)) {
-    LWIP_ASSERT("Error releasing mutex", 0);
-  }
-}
-
-
-#ifdef _MSC_VER
-const DWORD MS_VC_EXCEPTION=0x406D1388;
-#pragma pack(push,8)
-typedef struct tagTHREADNAME_INFO
-{
-  DWORD dwType; /* Must be 0x1000. */
-  LPCSTR szName; /* Pointer to name (in user addr space). */
-  DWORD dwThreadID; /* Thread ID (-1=caller thread). */
-  DWORD dwFlags; /* Reserved for future use, must be zero. */
-} THREADNAME_INFO;
-#pragma pack(pop)
-
-static void
-SetThreadName(DWORD dwThreadID, const char* threadName)
-{
-  THREADNAME_INFO info;
-  info.dwType = 0x1000;
-  info.szName = threadName;
-  info.dwThreadID = dwThreadID;
-  info.dwFlags = 0;
-
-  __try {
-    RaiseException(MS_VC_EXCEPTION, 0, sizeof(info)/sizeof(ULONG_PTR), (ULONG_PTR*)&info);
-  }
-  __except(EXCEPTION_EXECUTE_HANDLER) {
-  }
-}
-#else /* _MSC_VER */
-static void
-SetThreadName(DWORD dwThreadID, const char* threadName)
-{
-  LWIP_UNUSED_ARG(dwThreadID);
-  LWIP_UNUSED_ARG(threadName);
-}
-#endif /* _MSC_VER */
-
-static void
-sys_thread_function(void* arg)
-{
-  struct threadlist* t = (struct threadlist*)arg;
-#if LWIP_NETCONN_SEM_PER_THREAD
-  sys_arch_netconn_sem_alloc();
-#endif
-  t->function(t->arg);
-#if LWIP_NETCONN_SEM_PER_THREAD
-  sys_arch_netconn_sem_free();
-#endif
-}
-
-sys_thread_t
-sys_thread_new(const char *name, lwip_thread_fn function, void *arg, int stacksize, int prio)
-{
-  struct threadlist *new_thread;
-  HANDLE h;
-  SYS_ARCH_DECL_PROTECT(lev);
-
-  LWIP_UNUSED_ARG(name);
-  LWIP_UNUSED_ARG(stacksize);
-  LWIP_UNUSED_ARG(prio);
-
-  new_thread = (struct threadlist*)malloc(sizeof(struct threadlist));
-  LWIP_ASSERT("new_thread != NULL", new_thread != NULL);
-  if (new_thread != NULL) {
-    new_thread->function = function;
-    new_thread->arg = arg;
-    SYS_ARCH_PROTECT(lev);
-    new_thread->next = lwip_win32_threads;
-    lwip_win32_threads = new_thread;
-
-    h = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)sys_thread_function, new_thread, 0, &(new_thread->id));
-    LWIP_ASSERT("h != 0", h != 0);
-    LWIP_ASSERT("h != -1", h != INVALID_HANDLE_VALUE);
-    LWIP_UNUSED_ARG(h);
-    SetThreadName(new_thread->id, name);
-
-    SYS_ARCH_UNPROTECT(lev);
-    return new_thread->id;
-  }
-  return 0;
-}
-
-#if !NO_SYS
-#if LWIP_TCPIP_CORE_LOCKING
-
-static DWORD lwip_core_lock_holder_thread_id;
-
-void
-sys_lock_tcpip_core(void)
-{
-  sys_mutex_lock(&lock_tcpip_core);
-  lwip_core_lock_holder_thread_id = GetCurrentThreadId();
-}
-
-void
-sys_unlock_tcpip_core(void)
-{
-  lwip_core_lock_holder_thread_id = 0;
-  sys_mutex_unlock(&lock_tcpip_core);
-}
-#endif /* LWIP_TCPIP_CORE_LOCKING */
-
-static DWORD lwip_tcpip_thread_id;
-
-void
-sys_mark_tcpip_thread(void)
-{
-  lwip_tcpip_thread_id = GetCurrentThreadId();
-}
-
-void
-sys_check_core_locking(void)
-{
-  /* Embedded systems should check we are NOT in an interrupt context here */
-
-  if (lwip_tcpip_thread_id != 0) {
-    DWORD current_thread_id = GetCurrentThreadId();
-
-#if LWIP_TCPIP_CORE_LOCKING
-    LWIP_ASSERT("Function called without core lock", current_thread_id == lwip_core_lock_holder_thread_id);
-#else /* LWIP_TCPIP_CORE_LOCKING */
-    LWIP_ASSERT("Function called from wrong thread", current_thread_id == lwip_tcpip_thread_id);
-#endif /* LWIP_TCPIP_CORE_LOCKING */
-    LWIP_UNUSED_ARG(current_thread_id); /* for LWIP_NOASSERT */
-  }
-}
-#endif /* !NO_SYS */
-
-err_t
-sys_mbox_new(sys_mbox_t *mbox, int size)
-{
-  LWIP_ASSERT("mbox != NULL", mbox != NULL);
-  LWIP_UNUSED_ARG(size);
-
-  mbox->sem = CreateSemaphore(0, 0, MAX_QUEUE_ENTRIES, 0);
-  LWIP_ASSERT("Error creating semaphore", mbox->sem != NULL);
-  if (mbox->sem == NULL) {
-    SYS_ARCH_LOCKED(SYS_STATS_INC(mbox.err));
-    return ERR_MEM;
-  }
-  memset(&mbox->q_mem, 0, sizeof(u32_t)*MAX_QUEUE_ENTRIES);
-  mbox->head = 0;
-  mbox->tail = 0;
-  SYS_ARCH_LOCKED(SYS_STATS_INC_USED(mbox));
-#if LWIP_STATS && SYS_STATS
-  LWIP_ASSERT("sys_mbox_new() counter overflow", lwip_stats.sys.mbox.used != 0);
-#endif /* LWIP_STATS && SYS_STATS */
-  return ERR_OK;
-}
-
-void
-sys_mbox_free(sys_mbox_t *mbox)
-{
-  /* parameter check */
-  LWIP_ASSERT("mbox != NULL", mbox != NULL);
-  LWIP_ASSERT("mbox->sem != NULL", mbox->sem != NULL);
-  LWIP_ASSERT("mbox->sem != INVALID_HANDLE_VALUE", mbox->sem != INVALID_HANDLE_VALUE);
-
-  CloseHandle(mbox->sem);
-
-  SYS_STATS_DEC(mbox.used);
-#if LWIP_STATS && SYS_STATS
-  LWIP_ASSERT( "sys_mbox_free() ", lwip_stats.sys.mbox.used != (u16_t)-1);
-#endif /* LWIP_STATS && SYS_STATS */
-  mbox->sem = NULL;
-}
-
-void
-sys_mbox_post(sys_mbox_t *q, void *msg)
-{
-  BOOL ret;
-  SYS_ARCH_DECL_PROTECT(lev);
-  sys_arch_check_not_protected();
-
-  /* parameter check */
-  LWIP_ASSERT("q != SYS_MBOX_NULL", q != SYS_MBOX_NULL);
-  LWIP_ASSERT("q->sem != NULL", q->sem != NULL);
-  LWIP_ASSERT("q->sem != INVALID_HANDLE_VALUE", q->sem != INVALID_HANDLE_VALUE);
-
-  SYS_ARCH_PROTECT(lev);
-  q->q_mem[q->head] = msg;
-  q->head++;
-  if (q->head >= MAX_QUEUE_ENTRIES) {
-    q->head = 0;
-  }
-  LWIP_ASSERT("mbox is full!", q->head != q->tail);
-  ret = ReleaseSemaphore(q->sem, 1, 0);
-  LWIP_ASSERT("Error releasing sem", ret != 0);
-  LWIP_UNUSED_ARG(ret);
-
-  SYS_ARCH_UNPROTECT(lev);
-}
-
-err_t
-sys_mbox_trypost(sys_mbox_t *q, void *msg)
-{
-  u32_t new_head;
-  BOOL ret;
-  SYS_ARCH_DECL_PROTECT(lev);
-  sys_arch_check_not_protected();
-
-  /* parameter check */
-  LWIP_ASSERT("q != SYS_MBOX_NULL", q != SYS_MBOX_NULL);
-  LWIP_ASSERT("q->sem != NULL", q->sem != NULL);
-  LWIP_ASSERT("q->sem != INVALID_HANDLE_VALUE", q->sem != INVALID_HANDLE_VALUE);
-
-  SYS_ARCH_PROTECT(lev);
-
-  new_head = q->head + 1;
-  if (new_head >= MAX_QUEUE_ENTRIES) {
-    new_head = 0;
-  }
-  if (new_head == q->tail) {
-    SYS_ARCH_UNPROTECT(lev);
-    return ERR_MEM;
-  }
-
-  q->q_mem[q->head] = msg;
-  q->head = new_head;
-  LWIP_ASSERT("mbox is full!", q->head != q->tail);
-  ret = ReleaseSemaphore(q->sem, 1, 0);
-  LWIP_ASSERT("Error releasing sem", ret != 0);
-  LWIP_UNUSED_ARG(ret);
-
-  SYS_ARCH_UNPROTECT(lev);
-  return ERR_OK;
-}
-
-err_t
-sys_mbox_trypost_fromisr(sys_mbox_t *q, void *msg)
-{
-  return sys_mbox_trypost(q, msg);
-}
-
-u32_t
-sys_arch_mbox_fetch(sys_mbox_t *q, void **msg, u32_t timeout)
-{
-  DWORD ret;
-  LONGLONG starttime, endtime;
-  SYS_ARCH_DECL_PROTECT(lev);
-
-  /* parameter check */
-  LWIP_ASSERT("q != SYS_MBOX_NULL", q != SYS_MBOX_NULL);
-  LWIP_ASSERT("q->sem != NULL", q->sem != NULL);
-  LWIP_ASSERT("q->sem != INVALID_HANDLE_VALUE", q->sem != INVALID_HANDLE_VALUE);
-
-  if (timeout == 0) {
-    timeout = INFINITE;
-  }
-  starttime = sys_get_ms_longlong();
-  ret = WaitForSingleObject(q->sem, timeout);
-  if (ret == WAIT_OBJECT_0) {
-    SYS_ARCH_PROTECT(lev);
-    if (msg != NULL) {
-      *msg  = q->q_mem[q->tail];
-    }
-
-    q->tail++;
-    if (q->tail >= MAX_QUEUE_ENTRIES) {
-      q->tail = 0;
-    }
-    SYS_ARCH_UNPROTECT(lev);
-    endtime = sys_get_ms_longlong();
-    return (u32_t)(endtime - starttime);
-  } else {
-    LWIP_ASSERT("Error waiting for sem", ret == WAIT_TIMEOUT);
-    if (msg != NULL) {
-      *msg  = NULL;
-    }
-
-    return SYS_ARCH_TIMEOUT;
-  }
-}
-
-u32_t
-sys_arch_mbox_tryfetch(sys_mbox_t *q, void **msg)
-{
-  DWORD ret;
-  SYS_ARCH_DECL_PROTECT(lev);
-
-  /* parameter check */
-  LWIP_ASSERT("q != SYS_MBOX_NULL", q != SYS_MBOX_NULL);
-  LWIP_ASSERT("q->sem != NULL", q->sem != NULL);
-  LWIP_ASSERT("q->sem != INVALID_HANDLE_VALUE", q->sem != INVALID_HANDLE_VALUE);
-
-  ret = WaitForSingleObject(q->sem, 0);
-  if (ret == WAIT_OBJECT_0) {
-    SYS_ARCH_PROTECT(lev);
-    if (msg != NULL) {
-      *msg  = q->q_mem[q->tail];
-    }
-
-    q->tail++;
-    if (q->tail >= MAX_QUEUE_ENTRIES) {
-      q->tail = 0;
-    }
-    SYS_ARCH_UNPROTECT(lev);
-    return 0;
-  } else {
-    LWIP_ASSERT("Error waiting for sem", ret == WAIT_TIMEOUT);
-    if (msg != NULL) {
-      *msg  = NULL;
-    }
-
-    return SYS_MBOX_EMPTY;
-  }
-}
-
-#if LWIP_NETCONN_SEM_PER_THREAD
-sys_sem_t*
-sys_arch_netconn_sem_get(void)
-{
-  LPVOID tls_data = TlsGetValue(netconn_sem_tls_index);
-  return (sys_sem_t*)tls_data;
-}
-
-void
-sys_arch_netconn_sem_alloc(void)
-{
-  sys_sem_t *sem;
-  err_t err;
-  BOOL done;
-
-  sem = (sys_sem_t*)malloc(sizeof(sys_sem_t));
-  LWIP_ASSERT("failed to allocate memory for TLS semaphore", sem != NULL);
-  err = sys_sem_new(sem, 0);
-  LWIP_ASSERT("failed to initialise TLS semaphore", err == ERR_OK);
-  done = TlsSetValue(netconn_sem_tls_index, sem);
-  LWIP_UNUSED_ARG(done);
-  LWIP_ASSERT("failed to initialise TLS semaphore storage", done == TRUE);
-}
-
-void
-sys_arch_netconn_sem_free(void)
-{
-  LPVOID tls_data = TlsGetValue(netconn_sem_tls_index);
-  if (tls_data != NULL) {
-    BOOL done;
-    free(tls_data);
-    done = TlsSetValue(netconn_sem_tls_index, NULL);
-    LWIP_UNUSED_ARG(done);
-    LWIP_ASSERT("failed to de-init TLS semaphore storage", done == TRUE);
-  }
-}
-#endif /* LWIP_NETCONN_SEM_PER_THREAD */
-
-#endif /* !NO_SYS */
-
-/* get keyboard state to terminate the debug app on any kbhit event using win32 API */
-int
-lwip_win32_keypressed(void)
-{
-  INPUT_RECORD rec;
-  DWORD num = 0;
-  HANDLE h = GetStdHandle(STD_INPUT_HANDLE);
-  BOOL ret = PeekConsoleInput(h, &rec, 1, &num);
-  if (ret && num) {
-    ReadConsoleInput(h, &rec, 1, &num);
-    if (rec.EventType == KEY_EVENT) {
-      if (rec.Event.KeyEvent.bKeyDown) {
-        /* not a special key? */
-        if (rec.Event.KeyEvent.uChar.AsciiChar != 0) {
-          return 1;
-        }
-      }
-    }
-  }
-  return 0;
-}
-
-#include <stdarg.h>
-
-/* This is an example implementation for LWIP_PLATFORM_DIAG:
- * format a string and pass it to your output function.
- */
-void
-lwip_win32_platform_diag(const char *format, ...)
-{
-  va_list ap;
-  /* get the varargs */
-  va_start(ap, format);
-  /* print via varargs; to use another output function, you could use
-     vsnprintf here */
-  vprintf(format, ap);
-  va_end(ap);
-}
diff --git a/doc/contrib.txt b/doc/contrib.txt
index 2a44857e..6f0d7bc5 100644
--- a/doc/contrib.txt
+++ b/doc/contrib.txt
@@ -55,4 +55,4 @@ features of Savannah help us not lose users' input.
 
 1. If you have ported lwIP to a platform (an OS, a uC/processor or a combination of these) and
    you think it could benefit others[1] you might want discuss this on the mailing list. You
-   can also ask for Git access to submit and maintain your port in the lwIP/contrib subdir.
+   can also ask for Git access to submit and maintain your port in the contrib Git module.
diff --git a/doc/doxygen/lwip.Doxyfile b/doc/doxygen/lwip.Doxyfile
index 750e0ad4..c2039e59 100644
--- a/doc/doxygen/lwip.Doxyfile
+++ b/doc/doxygen/lwip.Doxyfile
@@ -38,7 +38,7 @@ PROJECT_NAME           = "lwIP"
 # could be handy for archiving the generated documentation or if some version
 # control system is used.
 
-PROJECT_NUMBER         = "2.2.0.dev"
+PROJECT_NUMBER         = "2.1.2"
 
 # Using the PROJECT_BRIEF tag one can provide an optional one line description
 # for a project that appears at the top of each page and should give viewer a
@@ -762,7 +762,7 @@ WARN_NO_PARAMDOC       = NO
 # a warning is encountered.
 # The default value is: NO.
 
-WARN_AS_ERROR          = YES
+WARN_AS_ERROR          = NO
 
 # The WARN_FORMAT tag determines the format of the warning messages that doxygen
 # can produce. The string should contain the $file, $line, and $text tags, which
diff --git a/doc/doxygen/lwip.Doxyfile.cmake.in b/doc/doxygen/lwip.Doxyfile.cmake.in
index 4879d2e6..063c2887 100644
--- a/doc/doxygen/lwip.Doxyfile.cmake.in
+++ b/doc/doxygen/lwip.Doxyfile.cmake.in
@@ -762,7 +762,7 @@ WARN_NO_PARAMDOC       = NO
 # a warning is encountered.
 # The default value is: NO.
 
-WARN_AS_ERROR          = YES
+WARN_AS_ERROR          = NO
 
 # The WARN_FORMAT tag determines the format of the warning messages that doxygen
 # can produce. The string should contain the $file, $line, and $text tags, which
diff --git a/doc/doxygen/main_page.h b/doc/doxygen/main_page.h
index 6fa2c916..89d86f82 100644
--- a/doc/doxygen/main_page.h
+++ b/doc/doxygen/main_page.h
@@ -2,14 +2,14 @@
  * @defgroup lwip lwIP
  *
  * @defgroup infrastructure Infrastructure
- *
+ * 
  * @defgroup api APIs
  * lwIP provides three Application Program's Interfaces (APIs) for programs
  * to use for communication with the TCP/IP code:
  * - low-level "core" / "callback" or @ref callbackstyle_api.
  * - higher-level @ref sequential_api.
  * - BSD-style @ref socket.
- *
+ * 
  * The raw TCP/IP interface allows the application program to integrate
  * better with the TCP/IP code. Program execution is event based by
  * having callback functions being called from within the TCP/IP
@@ -17,23 +17,23 @@
  * thread. The sequential API has a much higher overhead and is not very
  * well suited for small systems since it forces a multithreaded paradigm
  * on the application.
- *
+ * 
  * The raw TCP/IP interface is not only faster in terms of code execution
  * time but is also less memory intensive. The drawback is that program
  * development is somewhat harder and application programs written for
  * the raw TCP/IP interface are more difficult to understand. Still, this
  * is the preferred way of writing applications that should be small in
  * code size and memory usage.
- *
+ * 
  * All APIs can be used simultaneously by different application
  * programs. In fact, the sequential API is implemented as an application
  * program using the raw TCP/IP interface.
- *
+ * 
  * Do not confuse the lwIP raw API with raw Ethernet or IP sockets.
  * The former is a way of interfacing the lwIP network stack (including
  * TCP and UDP), the latter refers to processing raw Ethernet or IP data
  * instead of TCP connections or UDP packets.
- *
+ * 
  * Raw API applications may never block since all packet processing
  * (input and output) as well as timer processing (TCP mainly) is done
  * in a single execution context.
@@ -59,7 +59,7 @@
  * receive. This API is also used by the core stack for interaction between
  * the various protocols. It is the only API available when running lwIP
  * without an operating system.
- *
+ * 
  * @defgroup sequential_api Sequential-style APIs
  * @ingroup api
  * Sequential-style APIs, blocking functions. More overhead, but can be called
@@ -70,7 +70,7 @@
  * paradigm. Since the TCP/IP stack is event based by nature, the TCP/IP
  * code and the application program must reside in different execution
  * contexts (threads).
- *
+ * 
  * @defgroup socket Socket API
  * @ingroup api
  * BSD-style socket API.\n
@@ -83,9 +83,9 @@
  * on other platforms (e.g. unix / windows etc.). However, due to limitations
  * in the specification of this API, there might be incompatibilities
  * that require small modifications of existing programs.
- *
+ * 
  * @defgroup netifs NETIFs
- *
+ * 
  * @defgroup apps Applications
  */
 
@@ -112,7 +112,7 @@
  * * Add sys_mbox_trypost_fromisr() and tcpip_callbackmsg_trycallback_fromisr()
  *   (for FreeRTOS, mainly)
  * * socket API: support poll(), sendmsg() and recvmsg(); fix problems on close
- *
+ * 
  * Detailed Changelog
  * ------------------
  * @verbinclude "CHANGELOG"
@@ -123,11 +123,6 @@
  * @verbinclude "contrib.txt"
  */
 
-/**
- * @page cmake CMake build system
- * @verbinclude "BUILDING"
- */
-
 /**
  * @page pitfalls Common pitfalls
  *
@@ -136,21 +131,21 @@
  *
  * The most common source of lwIP problems is to have multiple execution contexts
  * inside the lwIP code.
- *
- * lwIP can be used in two basic modes: @ref lwip_nosys (no OS/RTOS
+ * 
+ * lwIP can be used in two basic modes: @ref lwip_nosys (no OS/RTOS 
  * running on target system) or @ref lwip_os (there is an OS running
  * on the target system).
- *
+ * 
  * See also: @ref multithreading (especially the part about @ref LWIP_ASSERT_CORE_LOCKED()!)
  *
  * Mainloop Mode
  * -------------
  * In mainloop mode, only @ref callbackstyle_api can be used.
- * The user has two possibilities to ensure there is only one
+ * The user has two possibilities to ensure there is only one 
  * exection context at a time in lwIP:
  *
  * 1) Deliver RX ethernet packets directly in interrupt context to lwIP
- *    by calling netif->input directly in interrupt. This implies all lwIP
+ *    by calling netif->input directly in interrupt. This implies all lwIP 
  *    callback functions are called in IRQ context, which may cause further
  *    problems in application code: IRQ is blocked for a long time, multiple
  *    execution contexts in application code etc. When the application wants
@@ -176,7 +171,7 @@
  * implemented in tcpip_input().​​
  * Again, ensure lwIP is _NEVER_ called from an interrupt, e.g.
  * some SPI IRQ wants to forward data to udp_send() or tcp_write()!
- *
+ * 
  * 1) tcpip_callback() can be used get called back from TCPIP thread,
  *    it is safe to call any @ref callbackstyle_api from there.
  *
@@ -191,7 +186,7 @@
  *
  * DMA-capable ethernet hardware and zero-copy RX
  * ----------------------------------------------
- *
+ * 
  * lwIP changes the content of RECEIVED pbufs in the TCP code path.
  * This implies one or more cacheline(s) of the RX pbuf become dirty
  * and need to be flushed before the memory is handed over to the
@@ -209,15 +204,6 @@
  * Read especially sections "Cache coherency" and "Buffer alignment".
  */
 
-/**
- * @page mem_err Debugging memory pool sizes
- * If you have issues with lwIP and you are using memory pools, check that your pools
- * are correctly sized.\n
- * To debug pool sizes, \#define LWIP_STATS and MEMP_STATS to 1. Check the global variable
- * lwip_stats.memp[] using a debugger. If the "err" member of a pool is > 0, the pool
- * may be too small for your application and you need to increase its size.
- */
-
 /**
  * @page bugs Reporting bugs
  * Please report bugs in the lwIP bug tracker at savannah.\n
@@ -239,7 +225,7 @@
  * *not* *from* *interrupt* *context*. You can allocate a @ref pbuf in interrupt
  * context and put them into a queue which is processed from mainloop.\n
  * Call sys_check_timeouts() periodically in the mainloop.\n
- * Porting: implement all functions in @ref sys_time, @ref sys_prot and
+ * Porting: implement all functions in @ref sys_time, @ref sys_prot and 
  * @ref compiler_abstraction.\n
  * You can only use @ref callbackstyle_api in this mode.\n
  * Sample code:\n
@@ -279,12 +265,12 @@ Call these functions in the order of appearance:
 
   The init function pointer must point to a initialization function for
   your Ethernet netif interface. The following code illustrates its use.
-
+  
 @code{.c}
   err_t netif_if_init(struct netif *netif)
   {
     u8_t i;
-
+    
     for (i = 0; i < ETHARP_HWADDR_LEN; i++) {
       netif->hwaddr[i] = some_eth_addr[i];
     }
@@ -292,11 +278,11 @@ Call these functions in the order of appearance:
     return ERR_OK;
   }
 @endcode
-
+  
   For Ethernet drivers, the input function pointer must point to the lwIP
   function ethernet_input() declared in "netif/etharp.h". Other drivers
   must use ip_input() declared in "lwip/ip.h".
-
+  
 - netif_set_default(struct netif *netif)
   Registers the default network interface.
 
@@ -331,7 +317,7 @@ Call these functions in the order of appearance:
  * from pbuf- and memory management functions). Application threads using
  * the sequential- or socket API communicate with this main thread through
  * message passing.
- *
+ * 
  * As such, the list of functions that may be called from
  * other threads or an ISR is very limited! Only functions
  * from these API header files are thread-safe:
@@ -342,43 +328,43 @@ Call these functions in the order of appearance:
  * - pppapi.h
  * - sockets.h
  * - sys.h
- *
+ * 
  * Additionaly, memory (de-)allocation functions may be
  * called from multiple threads (not ISR!) with NO_SYS=0
  * since they are protected by @ref SYS_LIGHTWEIGHT_PROT and/or
  * semaphores.
- *
+ * 
  * Netconn or Socket API functions are thread safe against the
  * core thread but they are not reentrant at the control block
  * granularity level. That is, a UDP or TCP control block must
  * not be shared among multiple threads without proper locking.
- *
+ * 
  * If @ref SYS_LIGHTWEIGHT_PROT is set to 1 and
  * @ref LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT is set to 1,
  * pbuf_free() may also be called from another thread or
  * an ISR (since only then, mem_free - for PBUF_RAM - may
  * be called from an ISR: otherwise, the HEAP is only
  * protected by semaphores).
- *
+ * 
  * How to get threading done right
  * -------------------------------
- *
+ * 
  * It is strongly recommended to implement the LWIP_ASSERT_CORE_LOCKED()
  * macro in an application that uses multithreading. lwIP code has
  * several places where a check for a correct thread context is
  * implemented which greatly helps the user to get threading done right.
- * See the example sys_arch.c files in unix and Win32 port
- * in the lwIP/contrib subdirectory.
- *
- * In short: Copy the functions sys_mark_tcpip_thread() and
+ * See the example sys_arch.c files in unix and Win32 port 
+ * in the contrib repository.
+ * 
+ * In short: Copy the functions sys_mark_tcpip_thread() and 
  * sys_check_core_locking() to your port and modify them to work with your OS.
  * Then let @ref LWIP_ASSERT_CORE_LOCKED() and @ref LWIP_MARK_TCPIP_THREAD()
  * point to these functions.
- *
+ * 
  * If you use @ref LWIP_TCPIP_CORE_LOCKING, you also need to copy and adapt
  * the functions sys_lock_tcpip_core() and sys_unlock_tcpip_core().
- * Let @ref LOCK_TCPIP_CORE() and @ref UNLOCK_TCPIP_CORE() point
- * to these functions.
+ * Let @ref LOCK_TCPIP_CORE() and @ref UNLOCK_TCPIP_CORE() point 
+ * to these functions. 
  */
 
 /**
diff --git a/doc/mdns.txt b/doc/mdns.txt
index 5e5005fc..0c28970d 100644
--- a/doc/mdns.txt
+++ b/doc/mdns.txt
@@ -45,7 +45,7 @@ This opens UDP sockets on port 5353 for IPv4 and IPv6.
 
 
 To start responding on a netif, run
-  mdns_resp_add_netif(struct netif *netif, const char *hostname)
+  mdns_resp_add_netif(struct netif *netif, char *hostname, u32_t dns_ttl)
 
 The hostname will be copied. If this returns successfully, the netif will join
 the multicast groups and any MDNS/legacy DNS requests sent unicast or multicast
@@ -53,6 +53,7 @@ to port 5353 will be handled:
 - <hostname>.local type A, AAAA or ANY returns relevant IP addresses
 - Reverse lookups (PTR in-addr.arpa, ip6.arpa) of netif addresses
   returns <hostname>.local
+Answers will use the supplied TTL (in seconds)
 MDNS allows UTF-8 names, but it is recommended to stay within ASCII,
 since the default case-insensitive comparison assumes this.
 
@@ -70,8 +71,8 @@ Adding services:
 ================
 
 The netif first needs to be registered. Then run
-  mdns_resp_add_service(struct netif *netif, const char *name, const char *service,
-      enum mdns_sd_proto proto, u16_t port,
+  mdns_resp_add_service(struct netif *netif, char *name, char *service,
+      u16_t proto, u16_t port, u32_t dns_ttl,
       service_get_txt_fn_t txt_fn, void *txt_userdata);
 
 The name and service pointers will be copied. Name refers to the name of the
@@ -99,7 +100,7 @@ If this call returns successfully, the following queries will be answered:
 If your device runs a webserver on port 80, an example call might be:
 
   mdns_resp_add_service(netif, "myweb", "_http"
-      DNSSD_PROTO_TCP, 80, srv_txt, NULL);
+      DNSSD_PROTO_TCP, 80, 3600, srv_txt, NULL);
 
 which will publish myweb._http._tcp.local for any hosts looking for web servers,
 and point them to <hostname>.local:80
@@ -108,4 +109,4 @@ Relevant information will be sent as additional records to reduce number of
 requests required from a client.
 
 To remove a service from a netif, run
-  mdns_resp_del_service(struct netif *netif, s8_t slot)
+  mdns_resp_del_service(struct netif *netif, s8_t slot)
\ No newline at end of file
diff --git a/doc/savannah.txt b/doc/savannah.txt
index dd537ffb..a98418d9 100644
--- a/doc/savannah.txt
+++ b/doc/savannah.txt
@@ -107,8 +107,9 @@ Now, sign the archives with a detached GPG binary signature as follows:
  gpg -b lwip-1.4.1.tar.bz2
  gpg -b lwip-1.4.1.zip
 
-Upload these files using scp:
- scp lwip-1.4.1.* <username>@dl.sv.nongnu.org:/releases/lwip/
+Upload these files using anonymous FTP:
+ ncftp ftp://savannah.gnu.org/incoming/savannah/lwip
+ ncftp> mput *1.4.1.*
 
 Additionally, you may post a news item on Savannah, like this:
 
diff --git a/src/Filelists.cmake b/src/Filelists.cmake
index 6003c6fc..c7656287 100644
--- a/src/Filelists.cmake
+++ b/src/Filelists.cmake
@@ -5,20 +5,16 @@
 #
 # This file is NOT designed (on purpose) to be used as cmake
 # subdir via add_subdirectory()
-# The intention is to provide greater flexibility to users to
+# The intention is to provide greater flexibility to users to 
 # create their own targets using the *_SRCS variables.
 
-if(NOT ${CMAKE_VERSION} VERSION_LESS "3.10.0")
-    include_guard(GLOBAL)
-endif()
-
 set(LWIP_VERSION_MAJOR    "2")
-set(LWIP_VERSION_MINOR    "2")
-set(LWIP_VERSION_REVISION "0")
+set(LWIP_VERSION_MINOR    "1")
+set(LWIP_VERSION_REVISION "2")
 # LWIP_VERSION_RC is set to LWIP_RC_RELEASE for official releases
 # LWIP_VERSION_RC is set to LWIP_RC_DEVELOPMENT for Git versions
 # Numbers 1..31 are reserved for release candidates
-set(LWIP_VERSION_RC       "LWIP_RC_DEVELOPMENT")
+set(LWIP_VERSION_RC       "LWIP_RC_RELEASE")
 
 if ("${LWIP_VERSION_RC}" STREQUAL "LWIP_RC_RELEASE")
     set(LWIP_VERSION_STRING
@@ -28,11 +24,11 @@ elseif ("${LWIP_VERSION_RC}" STREQUAL "LWIP_RC_DEVELOPMENT")
     set(LWIP_VERSION_STRING
         "${LWIP_VERSION_MAJOR}.${LWIP_VERSION_MINOR}.${LWIP_VERSION_REVISION}.dev"
     )
-else()
+else ("${LWIP_VERSION_RC}" STREQUAL "LWIP_RC_RELEASE")
     set(LWIP_VERSION_STRING
         "${LWIP_VERSION_MAJOR}.${LWIP_VERSION_MINOR}.${LWIP_VERSION_REVISION}.rc${LWIP_VERSION_RC}"
     )
-endif()
+endif ("${LWIP_VERSION_RC}" STREQUAL "LWIP_RC_RELEASE")
 
 # The minimum set of files needed for lwIP.
 set(lwipcore_SRCS
@@ -58,7 +54,6 @@ set(lwipcore_SRCS
     ${LWIP_DIR}/src/core/udp.c
 )
 set(lwipcore4_SRCS
-    ${LWIP_DIR}/src/core/ipv4/acd.c
     ${LWIP_DIR}/src/core/ipv4/autoip.c
     ${LWIP_DIR}/src/core/ipv4/dhcp.c
     ${LWIP_DIR}/src/core/ipv4/etharp.c
@@ -199,8 +194,6 @@ set(lwipsntp_SRCS
 # MDNS responder
 set(lwipmdns_SRCS
     ${LWIP_DIR}/src/apps/mdns/mdns.c
-    ${LWIP_DIR}/src/apps/mdns/mdns_out.c
-    ${LWIP_DIR}/src/apps/mdns/mdns_domain.c
 )
 
 # NetBIOS name server
@@ -210,7 +203,7 @@ set(lwipnetbios_SRCS
 
 # TFTP server files
 set(lwiptftp_SRCS
-    ${LWIP_DIR}/src/apps/tftp/tftp.c
+    ${LWIP_DIR}/src/apps/tftp/tftp_server.c
 )
 
 # MQTT client files
@@ -247,6 +240,7 @@ set(lwipallapps_SRCS
     ${lwipnetbios_SRCS}
     ${lwiptftp_SRCS}
     ${lwipmqtt_SRCS}
+    ${lwipmbedtls_SRCS}
 )
 
 # Generate lwip/init.h (version info)
@@ -261,7 +255,7 @@ configure_file(${DOXYGEN_IN} ${DOXYGEN_OUT})
 
 find_package(Doxygen)
 if (DOXYGEN_FOUND)
-    message(STATUS "Doxygen build started")
+    message("Doxygen build started")
 
     add_custom_target(lwipdocs
         COMMAND ${CMAKE_COMMAND} -E remove_directory ${DOXYGEN_DIR}/${DOXYGEN_OUTPUT_DIR}/html
@@ -270,7 +264,7 @@ if (DOXYGEN_FOUND)
         COMMENT "Generating API documentation with Doxygen"
         VERBATIM)
 else (DOXYGEN_FOUND)
-    message(STATUS "Doxygen needs to be installed to generate the doxygen documentation")
+    message("Doxygen needs to be installed to generate the doxygen documentation")
 endif (DOXYGEN_FOUND)
 
 # lwIP libraries
@@ -283,8 +277,3 @@ add_library(lwipallapps EXCLUDE_FROM_ALL ${lwipallapps_SRCS})
 target_compile_options(lwipallapps PRIVATE ${LWIP_COMPILER_FLAGS})
 target_compile_definitions(lwipallapps PRIVATE ${LWIP_DEFINITIONS}  ${LWIP_MBEDTLS_DEFINITIONS})
 target_include_directories(lwipallapps PRIVATE ${LWIP_INCLUDE_DIRS} ${LWIP_MBEDTLS_INCLUDE_DIRS})
-
-add_library(lwipmbedtls EXCLUDE_FROM_ALL ${lwipmbedtls_SRCS})
-target_compile_options(lwipmbedtls PRIVATE ${LWIP_COMPILER_FLAGS})
-target_compile_definitions(lwipmbedtls PRIVATE ${LWIP_DEFINITIONS}  ${LWIP_MBEDTLS_DEFINITIONS})
-target_include_directories(lwipmbedtls PRIVATE ${LWIP_INCLUDE_DIRS} ${LWIP_MBEDTLS_INCLUDE_DIRS})
diff --git a/src/Filelists.mk b/src/Filelists.mk
index 7e076f34..828b9f2a 100644
--- a/src/Filelists.mk
+++ b/src/Filelists.mk
@@ -1,8 +1,8 @@
 #
 # Copyright (c) 2001, 2002 Swedish Institute of Computer Science.
-# All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without modification,
+# All rights reserved. 
+# 
+# Redistribution and use in source and binary forms, with or without modification, 
 # are permitted provided that the following conditions are met:
 #
 # 1. Redistributions of source code must retain the above copyright notice,
@@ -11,21 +11,21 @@
 #    this list of conditions and the following disclaimer in the documentation
 #    and/or other materials provided with the distribution.
 # 3. The name of the author may not be used to endorse or promote products
-#    derived from this software without specific prior written permission.
+#    derived from this software without specific prior written permission. 
 #
-# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
-# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
-# SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
-# OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
-# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
+# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
+# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
+# SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
+# OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
+# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
 # OF SUCH DAMAGE.
 #
 # This file is part of the lwIP TCP/IP stack.
-#
+# 
 # Author: Adam Dunkels <adam@sics.se>
 #
 
@@ -51,8 +51,7 @@ COREFILES=$(LWIPDIR)/core/init.c \
 	$(LWIPDIR)/core/timeouts.c \
 	$(LWIPDIR)/core/udp.c
 
-CORE4FILES=$(LWIPDIR)/core/ipv4/acd.c \
-	$(LWIPDIR)/core/ipv4/autoip.c \
+CORE4FILES=$(LWIPDIR)/core/ipv4/autoip.c \
 	$(LWIPDIR)/core/ipv4/dhcp.c \
 	$(LWIPDIR)/core/ipv4/etharp.c \
 	$(LWIPDIR)/core/ipv4/icmp.c \
@@ -177,15 +176,13 @@ SMTPFILES=$(LWIPDIR)/apps/smtp/smtp.c
 SNTPFILES=$(LWIPDIR)/apps/sntp/sntp.c
 
 # MDNSFILES: MDNS responder
-MDNSFILES=$(LWIPDIR)/apps/mdns/mdns.c \
-	$(LWIPDIR)/apps/mdns/mdns_out.c \
-	$(LWIPDIR)/apps/mdns/mdns_domain.c
+MDNSFILES=$(LWIPDIR)/apps/mdns/mdns.c
 
 # NETBIOSNSFILES: NetBIOS name server
 NETBIOSNSFILES=$(LWIPDIR)/apps/netbiosns/netbiosns.c
 
-# TFTPFILES: TFTP client/server files
-TFTPFILES=$(LWIPDIR)/apps/tftp/tftp.c
+# TFTPFILES: TFTP server files
+TFTPFILES=$(LWIPDIR)/apps/tftp/tftp_server.c
 
 # MQTTFILES: MQTT client files
 MQTTFILES=$(LWIPDIR)/apps/mqtt/mqtt.c
diff --git a/src/api/api_msg.c b/src/api/api_msg.c
index 3f08e038..39531024 100644
--- a/src/api/api_msg.c
+++ b/src/api/api_msg.c
@@ -716,9 +716,6 @@ netconn_alloc(enum netconn_type t, netconn_callback callback)
   conn->pending_err = ERR_OK;
   conn->type = t;
   conn->pcb.tcp = NULL;
-#if LWIP_NETCONN_FULLDUPLEX
-  conn->mbox_threads_waiting = 0;
-#endif
 
   /* If all sizes are the same, every compiler should optimize this switch to nothing */
   switch (NETCONNTYPE_GROUP(t)) {
diff --git a/src/api/sockets.c b/src/api/sockets.c
index 05951ffd..cb7df914 100644
--- a/src/api/sockets.c
+++ b/src/api/sockets.c
@@ -688,6 +688,7 @@ lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
     err = netconn_peer(newconn, &naddr, &port);
     if (err != ERR_OK) {
       LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d): netconn_peer failed, err=%d\n", s, err));
+      netconn_delete(newconn);
       free_socket(nsock, 1);
       sock_set_errno(sock, err_to_errno(err));
       done_socket(sock);
@@ -2821,7 +2822,7 @@ lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
          LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).optlen);
 #endif /* LWIP_MPU_COMPATIBLE */
 
-  /* maybe lwip_getsockopt_impl has changed err */
+  /* maybe lwip_getsockopt_internal has changed err */
   err = LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).err;
   LWIP_SETGETSOCKOPT_DATA_VAR_FREE(data);
 #endif /* LWIP_TCPIP_CORE_LOCKING */
@@ -3262,7 +3263,7 @@ lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t opt
   }
   sys_arch_sem_wait((sys_sem_t *)(LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).completed_sem), 0);
 
-  /* maybe lwip_setsockopt_impl has changed err */
+  /* maybe lwip_getsockopt_internal has changed err */
   err = LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).err;
   LWIP_SETGETSOCKOPT_DATA_VAR_FREE(data);
 #endif  /* LWIP_TCPIP_CORE_LOCKING */
diff --git a/src/api/tcpip.c b/src/api/tcpip.c
index b0382e83..743553a5 100644
--- a/src/api/tcpip.c
+++ b/src/api/tcpip.c
@@ -519,7 +519,7 @@ tcpip_api_call(tcpip_api_call_fn fn, struct tcpip_api_call_data *call)
  * e.g. the message is allocated once and posted several times from an IRQ
  * using tcpip_callbackmsg_trycallback().
  * Example usage: Trigger execution of an ethernet IRQ DPC routine in lwIP thread context.
- *
+ * 
  * @param function the function to call
  * @param ctx parameter passed to function
  * @return a struct pointer to pass to tcpip_callbackmsg_trycallback().
diff --git a/src/apps/altcp_tls/altcp_tls_mbedtls.c b/src/apps/altcp_tls/altcp_tls_mbedtls.c
index f3a07e30..d642decb 100644
--- a/src/apps/altcp_tls/altcp_tls_mbedtls.c
+++ b/src/apps/altcp_tls/altcp_tls_mbedtls.c
@@ -40,8 +40,10 @@
  *   track of the ratio of application data and TLS overhead would be too much.
  *
  * Mandatory security-related configuration:
- * - ensure to add at least one strong entropy source to your mbedtls port (implement
- *   mbedtls_platform_entropy_poll or mbedtls_hardware_poll providing strong entropy)
+ * - define ALTCP_MBEDTLS_RNG_FN to mbedtls_entropy_func to use the standard mbedTLS
+ *   entropy and ensure to add at least one strong entropy source to your mbedtls port
+ *   (implement mbedtls_platform_entropy_poll or mbedtls_hardware_poll providing strong
+ *   entropy)
  * - define ALTCP_MBEDTLS_ENTROPY_PTR and ALTCP_MBEDTLS_ENTROPY_LEN to something providing
  *   GOOD custom entropy
  *
@@ -76,7 +78,6 @@
 #include "mbedtls/platform.h"
 #include "mbedtls/memory_buffer_alloc.h"
 #include "mbedtls/ssl_cache.h"
-#include "mbedtls/ssl_ticket.h"
 
 #include "mbedtls/ssl_internal.h" /* to call mbedtls_flush_output after ERR_MEM */
 
@@ -96,29 +97,16 @@ extern const struct altcp_functions altcp_mbedtls_functions;
 /** Our global mbedTLS configuration (server-specific, not connection-specific) */
 struct altcp_tls_config {
   mbedtls_ssl_config conf;
+  mbedtls_entropy_context entropy;
+  mbedtls_ctr_drbg_context ctr_drbg;
   mbedtls_x509_crt *cert;
   mbedtls_pk_context *pkey;
-  u8_t cert_count;
-  u8_t cert_max;
-  u8_t pkey_count;
-  u8_t pkey_max;
   mbedtls_x509_crt *ca;
-#if defined(MBEDTLS_SSL_CACHE_C) && ALTCP_MBEDTLS_USE_SESSION_CACHE
+#if defined(MBEDTLS_SSL_CACHE_C) && ALTCP_MBEDTLS_SESSION_CACHE_TIMEOUT_SECONDS
   /** Inter-connection cache for fast connection startup */
   struct mbedtls_ssl_cache_context cache;
 #endif
-#if defined(MBEDTLS_SSL_SESSION_TICKETS) && ALTCP_MBEDTLS_USE_SESSION_TICKETS
-  mbedtls_ssl_ticket_context ticket_ctx;
-#endif
-};
-
-/** Entropy and random generator are shared by all mbedTLS configuration */
-struct altcp_tls_entropy_rng {
-  mbedtls_entropy_context entropy;
-  mbedtls_ctr_drbg_context ctr_drbg;
-  int ref;
 };
-static struct altcp_tls_entropy_rng *altcp_tls_entropy_rng;
 
 static err_t altcp_mbedtls_lower_recv(void *arg, struct altcp_pcb *inner_conn, struct pbuf *p, err_t err);
 static err_t altcp_mbedtls_setup(void *conf, struct altcp_pcb *conn, struct altcp_pcb *inner_conn);
@@ -461,7 +449,6 @@ altcp_mbedtls_bio_recv(void *ctx, unsigned char *buf, size_t len)
     return MBEDTLS_ERR_NET_INVALID_CONTEXT;
   }
   state = (altcp_mbedtls_state_t *)conn->state;
-  LWIP_ASSERT("state != NULL", state != NULL);
   p = state->rx;
 
   /* @todo: return MBEDTLS_ERR_NET_CONN_RESET/MBEDTLS_ERR_NET_RECV_FAILED? */
@@ -649,26 +636,41 @@ altcp_tls_context(struct altcp_pcb *conn)
   return NULL;
 }
 
-#if ALTCP_MBEDTLS_LIB_DEBUG != LWIP_DBG_OFF
+#if ALTCP_MBEDTLS_DEBUG != LWIP_DBG_OFF
 static void
 altcp_mbedtls_debug(void *ctx, int level, const char *file, int line, const char *str)
 {
   LWIP_UNUSED_ARG(ctx);
+  LWIP_UNUSED_ARG(level);
   LWIP_UNUSED_ARG(file);
   LWIP_UNUSED_ARG(line);
   LWIP_UNUSED_ARG(str);
 
-  if (level >= ALTCP_MBEDTLS_LIB_DEBUG_LEVEL_MIN) {
-    LWIP_DEBUGF(ALTCP_MBEDTLS_LIB_DEBUG, ("%s:%04d: %s", file, line, str));
-  }
+  LWIP_DEBUGF(ALTCP_MBEDTLS_DEBUG, ("%s:%04d: %s", file, line, str));
 }
 #endif
 
+#ifndef ALTCP_MBEDTLS_RNG_FN
+/** ATTENTION: It is *really* important to *NOT* use this dummy RNG in production code!!!! */
+static int
+dummy_rng(void *ctx, unsigned char *buffer, size_t len)
+{
+  static size_t ctr;
+  size_t i;
+  LWIP_UNUSED_ARG(ctx);
+  for (i = 0; i < len; i++) {
+    buffer[i] = (unsigned char)++ctr;
+  }
+  return 0;
+}
+#define ALTCP_MBEDTLS_RNG_FN dummy_rng
+#endif /* ALTCP_MBEDTLS_RNG_FN */
+
 /** Create new TLS configuration
  * ATTENTION: Server certificate and private key have to be added outside this function!
  */
 static struct altcp_tls_config *
-altcp_tls_create_config(int is_server, u8_t cert_count, u8_t pkey_count, int have_ca)
+altcp_tls_create_config(int is_server, int have_cert, int have_pkey, int have_ca)
 {
   size_t sz;
   int ret;
@@ -677,68 +679,49 @@ altcp_tls_create_config(int is_server, u8_t cert_count, u8_t pkey_count, int hav
 
   if (TCP_WND < MBEDTLS_SSL_MAX_CONTENT_LEN) {
     LWIP_DEBUGF(ALTCP_MBEDTLS_DEBUG|LWIP_DBG_LEVEL_SERIOUS,
-      ("altcp_tls: TCP_WND is smaller than the RX decrypion buffer, connection RX might stall!\n"));
+      ("altcp_tls: TCP_WND is smaller than the RX decryption buffer, connection RX might stall!\n"));
   }
 
   altcp_mbedtls_mem_init();
 
   sz = sizeof(struct altcp_tls_config);
-  if (cert_count > 0) {
-    sz += (cert_count * sizeof(mbedtls_x509_crt));
+  if (have_cert) {
+    sz += sizeof(mbedtls_x509_crt);
   }
   if (have_ca) {
     sz += sizeof(mbedtls_x509_crt);
   }
-  if (pkey_count > 0) {
-    sz += (pkey_count * sizeof(mbedtls_pk_context));
+  if (have_pkey) {
+    sz += sizeof(mbedtls_pk_context);
   }
 
   conf = (struct altcp_tls_config *)altcp_mbedtls_alloc_config(sz);
   if (conf == NULL) {
     return NULL;
   }
-  conf->cert_max = cert_count;
   mem = (mbedtls_x509_crt *)(conf + 1);
-  if (cert_count > 0) {
+  if (have_cert) {
     conf->cert = mem;
-    mem += cert_count;
+    mem++;
   }
   if (have_ca) {
     conf->ca = mem;
     mem++;
   }
-  conf->pkey_max = pkey_count;
-  if (pkey_count > 0) {
+  if (have_pkey) {
     conf->pkey = (mbedtls_pk_context *)mem;
   }
 
   mbedtls_ssl_config_init(&conf->conf);
+  mbedtls_entropy_init(&conf->entropy);
+  mbedtls_ctr_drbg_init(&conf->ctr_drbg);
 
-  if (!altcp_tls_entropy_rng) {
-    altcp_tls_entropy_rng = (struct altcp_tls_entropy_rng *)altcp_mbedtls_alloc_config(sizeof(struct altcp_tls_entropy_rng));
-    if (altcp_tls_entropy_rng) {
-      altcp_tls_entropy_rng->ref = 1;
-      mbedtls_entropy_init(&altcp_tls_entropy_rng->entropy);
-      mbedtls_ctr_drbg_init(&altcp_tls_entropy_rng->ctr_drbg);
-      /* Seed the RNG, only once */
-      ret = mbedtls_ctr_drbg_seed(&altcp_tls_entropy_rng->ctr_drbg,
-                                  mbedtls_entropy_func, &altcp_tls_entropy_rng->entropy,
-                                  ALTCP_MBEDTLS_ENTROPY_PTR, ALTCP_MBEDTLS_ENTROPY_LEN);
-      if (ret != 0) {
-        LWIP_DEBUGF(ALTCP_MBEDTLS_DEBUG, ("mbedtls_ctr_drbg_seed failed: %d\n", ret));
-        mbedtls_ctr_drbg_free(&altcp_tls_entropy_rng->ctr_drbg);
-        mbedtls_entropy_free(&altcp_tls_entropy_rng->entropy);
-        altcp_mbedtls_free_config(altcp_tls_entropy_rng);
-        altcp_tls_entropy_rng = NULL;
-        altcp_mbedtls_free_config(conf);
-        return NULL;
-      }
-    } else {
-      altcp_mbedtls_free_config(conf);
-      return NULL;
-    }
-  } else {
-    altcp_tls_entropy_rng->ref++;
+  /* Seed the RNG */
+  ret = mbedtls_ctr_drbg_seed(&conf->ctr_drbg, ALTCP_MBEDTLS_RNG_FN, &conf->entropy, ALTCP_MBEDTLS_ENTROPY_PTR, ALTCP_MBEDTLS_ENTROPY_LEN);
+  if (ret != 0) {
+    LWIP_DEBUGF(ALTCP_MBEDTLS_DEBUG, ("mbedtls_ctr_drbg_seed failed: %d\n", ret));
+    altcp_mbedtls_free_config(conf);
+    return NULL;
   }
 
   /* Setup ssl context (@todo: what's different for a client here? -> might better be done on listen/connect) */
@@ -746,125 +729,72 @@ altcp_tls_create_config(int is_server, u8_t cert_count, u8_t pkey_count, int hav
                                     MBEDTLS_SSL_TRANSPORT_STREAM, MBEDTLS_SSL_PRESET_DEFAULT);
   if (ret != 0) {
     LWIP_DEBUGF(ALTCP_MBEDTLS_DEBUG, ("mbedtls_ssl_config_defaults failed: %d\n", ret));
-    if (altcp_tls_entropy_rng->ref == 1) {
-      mbedtls_ctr_drbg_free(&altcp_tls_entropy_rng->ctr_drbg);
-      mbedtls_entropy_free(&altcp_tls_entropy_rng->entropy);
-      altcp_mbedtls_free_config(altcp_tls_entropy_rng);
-      altcp_tls_entropy_rng = NULL;
-    }
     altcp_mbedtls_free_config(conf);
     return NULL;
   }
   mbedtls_ssl_conf_authmode(&conf->conf, MBEDTLS_SSL_VERIFY_OPTIONAL);
 
-  mbedtls_ssl_conf_rng(&conf->conf, mbedtls_ctr_drbg_random, &altcp_tls_entropy_rng->ctr_drbg);
-#if ALTCP_MBEDTLS_LIB_DEBUG != LWIP_DBG_OFF
+  mbedtls_ssl_conf_rng(&conf->conf, mbedtls_ctr_drbg_random, &conf->ctr_drbg);
+#if ALTCP_MBEDTLS_DEBUG != LWIP_DBG_OFF
   mbedtls_ssl_conf_dbg(&conf->conf, altcp_mbedtls_debug, stdout);
 #endif
-#if defined(MBEDTLS_SSL_CACHE_C) && ALTCP_MBEDTLS_USE_SESSION_CACHE
+#if defined(MBEDTLS_SSL_CACHE_C) && ALTCP_MBEDTLS_SESSION_CACHE_TIMEOUT_SECONDS
   mbedtls_ssl_conf_session_cache(&conf->conf, &conf->cache, mbedtls_ssl_cache_get, mbedtls_ssl_cache_set);
-  mbedtls_ssl_cache_set_timeout(&conf->cache, ALTCP_MBEDTLS_SESSION_CACHE_TIMEOUT_SECONDS);
-  mbedtls_ssl_cache_set_max_entries(&conf->cache, ALTCP_MBEDTLS_SESSION_CACHE_SIZE);
-#endif
-
-#if defined(MBEDTLS_SSL_SESSION_TICKETS) && ALTCP_MBEDTLS_USE_SESSION_TICKETS
-  mbedtls_ssl_ticket_init(&conf->ticket_ctx);
-
-  ret = mbedtls_ssl_ticket_setup(&conf->ticket_ctx, mbedtls_ctr_drbg_random, &altcp_tls_entropy_rng->ctr_drbg,
-    ALTCP_MBEDTLS_SESSION_TICKET_CIPHER, ALTCP_MBEDTLS_SESSION_TICKET_TIMEOUT_SECONDS);
-  if (ret) {
-    LWIP_DEBUGF(ALTCP_MBEDTLS_DEBUG, ("mbedtls_ssl_ticket_setup failed: %d\n", ret));
-    altcp_mbedtls_free_config(conf);
-    return NULL;
-  }
-
-  mbedtls_ssl_conf_session_tickets_cb(&conf->conf, mbedtls_ssl_ticket_write, mbedtls_ssl_ticket_parse,
-    &conf->ticket_ctx);
+  mbedtls_ssl_cache_set_timeout(&conf->cache, 30);
+  mbedtls_ssl_cache_set_max_entries(&conf->cache, 30);
 #endif
 
   return conf;
 }
 
-struct altcp_tls_config *altcp_tls_create_config_server(u8_t cert_count)
-{
-  struct altcp_tls_config *conf = altcp_tls_create_config(1, cert_count, cert_count, 0);
-  if (conf == NULL) {
-    return NULL;
-  }
-
-  mbedtls_ssl_conf_ca_chain(&conf->conf, NULL, NULL);
-  return conf;
-}
-
-err_t altcp_tls_config_server_add_privkey_cert(struct altcp_tls_config *config,
-      const u8_t *privkey, size_t privkey_len,
-      const u8_t *privkey_pass, size_t privkey_pass_len,
-      const u8_t *cert, size_t cert_len)
+/** Create new TLS configuration
+ * This is a suboptimal version that gets the encrypted private key and its password,
+ * as well as the server certificate.
+ */
+struct altcp_tls_config *
+altcp_tls_create_config_server_privkey_cert(const u8_t *privkey, size_t privkey_len,
+    const u8_t *privkey_pass, size_t privkey_pass_len,
+    const u8_t *cert, size_t cert_len)
 {
   int ret;
   mbedtls_x509_crt *srvcert;
   mbedtls_pk_context *pkey;
-
-  if (config->cert_count >= config->cert_max) {
-    return ERR_MEM;
-  }
-  if (config->pkey_count >= config->pkey_max) {
-    return ERR_MEM;
+  struct altcp_tls_config *conf = altcp_tls_create_config(1, 1, 1, 0);
+  if (conf == NULL) {
+    return NULL;
   }
 
-  srvcert = config->cert + config->cert_count;
+  srvcert = conf->cert;
   mbedtls_x509_crt_init(srvcert);
 
-  pkey = config->pkey + config->pkey_count;
+  pkey = conf->pkey;
   mbedtls_pk_init(pkey);
 
   /* Load the certificates and private key */
   ret = mbedtls_x509_crt_parse(srvcert, cert, cert_len);
   if (ret != 0) {
     LWIP_DEBUGF(ALTCP_MBEDTLS_DEBUG, ("mbedtls_x509_crt_parse failed: %d\n", ret));
-    return ERR_VAL;
+    altcp_mbedtls_free_config(conf);
+    return NULL;
   }
 
   ret = mbedtls_pk_parse_key(pkey, (const unsigned char *) privkey, privkey_len, privkey_pass, privkey_pass_len);
   if (ret != 0) {
     LWIP_DEBUGF(ALTCP_MBEDTLS_DEBUG, ("mbedtls_pk_parse_public_key failed: %d\n", ret));
     mbedtls_x509_crt_free(srvcert);
-    return ERR_VAL;
+    altcp_mbedtls_free_config(conf);
+    return NULL;
   }
 
-  ret = mbedtls_ssl_conf_own_cert(&config->conf, srvcert, pkey);
+  mbedtls_ssl_conf_ca_chain(&conf->conf, srvcert->next, NULL);
+  ret = mbedtls_ssl_conf_own_cert(&conf->conf, srvcert, pkey);
   if (ret != 0) {
     LWIP_DEBUGF(ALTCP_MBEDTLS_DEBUG, ("mbedtls_ssl_conf_own_cert failed: %d\n", ret));
     mbedtls_x509_crt_free(srvcert);
     mbedtls_pk_free(pkey);
-    return ERR_VAL;
-  }
-
-  config->cert_count++;
-  config->pkey_count++;
-  return ERR_OK;
-}
-
-/** Create new TLS configuration
- * This is a suboptimal version that gets the encrypted private key and its password,
- * as well as the server certificate.
- */
-struct altcp_tls_config *
-altcp_tls_create_config_server_privkey_cert(const u8_t *privkey, size_t privkey_len,
-    const u8_t *privkey_pass, size_t privkey_pass_len,
-    const u8_t *cert, size_t cert_len)
-{
-  struct altcp_tls_config *conf = altcp_tls_create_config_server(1);
-  if (conf == NULL) {
-    return NULL;
-  }
-
-  if (altcp_tls_config_server_add_privkey_cert(conf, privkey, privkey_len,
-    privkey_pass, privkey_pass_len, cert, cert_len) != ERR_OK) {
     altcp_mbedtls_free_config(conf);
     return NULL;
   }
-
   return conf;
 }
 
@@ -872,7 +802,7 @@ static struct altcp_tls_config *
 altcp_tls_create_config_client_common(const u8_t *ca, size_t ca_len, int is_2wayauth)
 {
   int ret;
-  struct altcp_tls_config *conf = altcp_tls_create_config(0, (is_2wayauth) ? 1 : 0, (is_2wayauth) ? 1 : 0, ca != NULL);
+  struct altcp_tls_config *conf = altcp_tls_create_config(0, is_2wayauth, is_2wayauth, ca != NULL);
   if (conf == NULL) {
     return NULL;
   }
@@ -956,21 +886,8 @@ altcp_tls_free_config(struct altcp_tls_config *conf)
   }
   if (conf->ca) {
     mbedtls_x509_crt_free(conf->ca);
-  }
+  }  
   altcp_mbedtls_free_config(conf);
-  if (altcp_tls_entropy_rng && altcp_tls_entropy_rng->ref)
-      altcp_tls_entropy_rng->ref--;
-}
-
-void
-altcp_tls_free_entropy(void)
-{
-  if (altcp_tls_entropy_rng && altcp_tls_entropy_rng->ref == 0) {
-    mbedtls_ctr_drbg_free(&altcp_tls_entropy_rng->ctr_drbg);
-    mbedtls_entropy_free(&altcp_tls_entropy_rng->entropy);
-    altcp_mbedtls_free_config(altcp_tls_entropy_rng);
-    altcp_tls_entropy_rng = NULL;
-  }
 }
 
 /* "virtual" functions */
@@ -1027,11 +944,6 @@ altcp_mbedtls_listen(struct altcp_pcb *conn, u8_t backlog, err_t *err)
   }
   lpcb = altcp_listen_with_backlog_and_err(conn->inner_conn, backlog, err);
   if (lpcb != NULL) {
-    altcp_mbedtls_state_t *state = (altcp_mbedtls_state_t *)conn->state;
-    /* Free members of the ssl context (not used on listening pcb). This
-       includes freeing input/output buffers, so saves ~32KByte by default */
-    mbedtls_ssl_free(&state->ssl_context);
-
     conn->inner_conn = lpcb;
     altcp_accept(lpcb, altcp_mbedtls_lower_accept);
     return conn;
@@ -1257,10 +1169,6 @@ const struct altcp_functions altcp_mbedtls_functions = {
   altcp_default_get_tcp_addrinfo,
   altcp_default_get_ip,
   altcp_default_get_port
-#if LWIP_TCP_KEEPALIVE
-  , altcp_default_keepalive_disable
-  , altcp_default_keepalive_enable
-#endif
 #ifdef LWIP_DEBUG
   , altcp_default_dbg_get_tcp_state
 #endif
diff --git a/src/apps/http/fsdata.c b/src/apps/http/fsdata.c
index 50bc87ac..ab9da7e1 100644
--- a/src/apps/http/fsdata.c
+++ b/src/apps/http/fsdata.c
@@ -334,3 +334,4 @@ FS_FILE_FLAGS_HEADER_INCLUDED | FS_FILE_FLAGS_HEADER_PERSISTENT,
 
 #define FS_ROOT file__index_html
 #define FS_NUMFILES 3
+
diff --git a/src/apps/http/http_client.c b/src/apps/http/http_client.c
index 6fbb6915..82da60d7 100644
--- a/src/apps/http/http_client.c
+++ b/src/apps/http/http_client.c
@@ -615,7 +615,7 @@ httpc_init_connection_addr(httpc_state_t **connection, const httpc_connection_t
 }
 
 /**
- * @ingroup httpc
+ * @ingroup httpc 
  * HTTP client API: get a file by passing server IP address
  *
  * @param server_addr IP address of the server to connect
@@ -660,7 +660,7 @@ httpc_get_file(const ip_addr_t* server_addr, u16_t port, const char* uri, const
 }
 
 /**
- * @ingroup httpc
+ * @ingroup httpc 
  * HTTP client API: get a file by passing server name as string (DNS name or IP address string)
  *
  * @param server_name server name as string (DNS name or IP address string)
@@ -802,7 +802,7 @@ httpc_fs_tcp_recv(void *arg, struct altcp_pcb *pcb, struct pbuf *p, err_t err)
 }
 
 /**
- * @ingroup httpc
+ * @ingroup httpc 
  * HTTP client API: get a file to disk by passing server IP address
  *
  * @param server_addr IP address of the server to connect
@@ -854,7 +854,7 @@ httpc_get_file_to_disk(const ip_addr_t* server_addr, u16_t port, const char* uri
 }
 
 /**
- * @ingroup httpc
+ * @ingroup httpc 
  * HTTP client API: get a file to disk by passing server name as string (DNS name or IP address string)
  *
  * @param server_name server name as string (DNS name or IP address string)
diff --git a/src/apps/http/httpd.c b/src/apps/http/httpd.c
index 6e53b484..ccc9ba72 100644
--- a/src/apps/http/httpd.c
+++ b/src/apps/http/httpd.c
@@ -233,7 +233,7 @@ struct http_ssi_state {
 
 struct http_ssi_tag_description {
   const char *lead_in;
-  const char *lead_out;
+  const char *lead_out; 
 };
 
 #endif /* LWIP_HTTPD_SSI */
diff --git a/src/apps/http/httpd_structs.h b/src/apps/http/httpd_structs.h
index aa5bce2f..56b97a32 100644
--- a/src/apps/http/httpd_structs.h
+++ b/src/apps/http/httpd_structs.h
@@ -113,11 +113,11 @@ static const tHTTPHeader g_psHTTPHeaders[] = {
 
 #endif /* LWIP_HTTPD_DYNAMIC_HEADERS */
 
-#if LWIP_HTTPD_SSI && LWIP_HTTPD_SSI_BY_FILE_EXTENSION
+#if LWIP_HTTPD_SSI
 static const char *const g_pcSSIExtensions[] = {
-  LWIP_HTTPD_SSI_EXTENSIONS
+  ".shtml", ".shtm", ".ssi", ".xml", ".json"
 };
 #define NUM_SHTML_EXTENSIONS LWIP_ARRAYSIZE(g_pcSSIExtensions)
-#endif /* LWIP_HTTPD_SSI && LWIP_HTTPD_SSI_BY_FILE_EXTENSION */
+#endif /* LWIP_HTTPD_SSI */
 
 #endif /* LWIP_HTTPD_STRUCTS_H */
diff --git a/src/apps/http/makefsdata/makefsdata.c b/src/apps/http/makefsdata/makefsdata.c
index b9265704..695e94f5 100644
--- a/src/apps/http/makefsdata/makefsdata.c
+++ b/src/apps/http/makefsdata/makefsdata.c
@@ -63,14 +63,12 @@ int deflate_level = 10; /* default compression level, can be changed via command
 #ifdef WIN32
 
 #define GETCWD(path, len)             GetCurrentDirectoryA(len, path)
-#define GETCWD_SUCCEEDED(ret)         (ret != 0)
 #define CHDIR(path)                   SetCurrentDirectoryA(path)
 #define CHDIR_SUCCEEDED(ret)          (ret == TRUE)
 
 #elif __linux__
 
 #define GETCWD(path, len)             getcwd(path, len)
-#define GETCWD_SUCCEEDED(ret)         (ret != NULL)
 #define CHDIR(path)                   chdir(path)
 #define CHDIR_SUCCEEDED(ret)          (ret == 0)
 
@@ -83,10 +81,6 @@ int deflate_level = 10; /* default compression level, can be changed via command
 #define NEWLINE     "\r\n"
 #define NEWLINE_LEN 2
 
-/* Define this here since we don't include any external C files and ports might override it */
-#define LWIP_PLATFORM_ASSERT(x) do {printf("Assertion \"%s\" failed at line %d in %s\n", \
-                                     x, __LINE__, __FILE__); fflush(NULL); abort();} while(0)
-
 /* define this to get the header variables we use to build HTTP headers */
 #define LWIP_HTTPD_DYNAMIC_HEADERS 1
 #define LWIP_HTTPD_SSI             1
@@ -134,7 +128,7 @@ static int file_can_be_compressed(const char* filename);
 /* 5 bytes per char + 3 bytes per line */
 static char file_buffer_c[COPY_BUFSIZE * 5 + ((COPY_BUFSIZE / HEX_BYTES_PER_LINE) * 3)];
 
-char curSubdir[MAX_PATH_LEN-3];
+char curSubdir[MAX_PATH_LEN];
 char lastFileVar[MAX_PATH_LEN];
 char hdr_buf[4096];
 
@@ -278,10 +272,7 @@ int main(int argc, char *argv[])
     exit(-1);
   }
 
-  if(!GETCWD_SUCCEEDED(GETCWD(appPath, MAX_PATH_LEN))) {
-    printf("Unable to get current dir." NEWLINE);
-    exit(-1);
-  }
+  GETCWD(appPath, MAX_PATH_LEN);
   /* if command line param or subdir named 'fs' not found spout usage verbiage */
   if (!CHDIR_SUCCEEDED(CHDIR(path))) {
     /* if no subdir named 'fs' (or the one which was given) exists, spout usage verbiage */
@@ -289,10 +280,7 @@ int main(int argc, char *argv[])
     print_usage();
     exit(-1);
   }
-  if(!CHDIR_SUCCEEDED(CHDIR(appPath))) {
-    printf("Invalid path: \"%s\"." NEWLINE, appPath);
-    exit(-1);
-  }
+  CHDIR(appPath);
 
   printf("HTTP %sheader will %s statically included." NEWLINE,
          (includeHttpHeader ? (useHttp11 ? "1.1 " : "1.0 ") : ""),
@@ -318,10 +306,7 @@ int main(int argc, char *argv[])
     exit(-1);
   }
 
-  if(!CHDIR_SUCCEEDED(CHDIR(path))) {
-    printf("Invalid path: \"%s\"." NEWLINE, path);
-    exit(-1);
-  }
+  CHDIR(path);
 
   fprintf(data_file, "#include \"lwip/apps/fs.h\"" NEWLINE);
   fprintf(data_file, "#include \"lwip/def.h\"" NEWLINE NEWLINE NEWLINE);
@@ -355,11 +340,7 @@ int main(int argc, char *argv[])
   fclose(data_file);
   fclose(struct_file);
 
-  if(!CHDIR_SUCCEEDED(CHDIR(appPath))) {
-    printf("Invalid path: \"%s\"." NEWLINE, appPath);
-    exit(-1);
-  }
-
+  CHDIR(appPath);
   /* append struct_file to data_file */
   printf(NEWLINE "Creating target file..." NEWLINE NEWLINE);
   concat_files("fsdata.tmp", "fshdr.tmp", targetfile);
@@ -488,19 +469,13 @@ int process_sub(FILE *data_file, FILE *struct_file)
             continue;
           }
           if (freelen > 0) {
-            if(!CHDIR_SUCCEEDED(CHDIR(currName))) {
-              printf("Invalid path: \"%s\"." NEWLINE, currName);
-              exit(-1);
-            }
+            CHDIR(currName);
             strncat(curSubdir, "/", freelen);
             strncat(curSubdir, currName, freelen - 1);
             curSubdir[sizeof(curSubdir) - 1] = 0;
             printf("processing subdirectory %s/..." NEWLINE, curSubdir);
             filesProcessed += process_sub(data_file, struct_file);
-            if(!CHDIR_SUCCEEDED(CHDIR(".."))) {
-              printf("Unable to get back to parent dir of: \"%s\"." NEWLINE, currName);
-              exit(-1);
-            }
+            CHDIR("..");
             curSubdir[sublen] = 0;
           } else {
             printf("WARNING: cannot process sub due to path length restrictions: \"%s/%s\"\n", curSubdir, currName);
@@ -878,7 +853,6 @@ static int is_ssi_file(const char *filename)
       }
       curSubdir[sublen] = 0;
       return ret;
-#if LWIP_HTTPD_SSI_BY_FILE_EXTENSION
     } else {
       /* check file extension */
       size_t loop;
@@ -887,7 +861,6 @@ static int is_ssi_file(const char *filename)
           return 1;
         }
       }
-#endif /* LWIP_HTTPD_SSI_BY_FILE_EXTENSION */
     }
   }
   return 0;
@@ -947,9 +920,9 @@ int process_file(FILE *data_file, FILE *struct_file, const char *filename)
   int flags_printed;
 
   /* create qualified name (@todo: prepend slash or not?) */
-  snprintf(qualifiedName, sizeof(qualifiedName), "%s/%s", curSubdir, filename);
+  sprintf(qualifiedName, "%s/%s", curSubdir, filename);
   /* create C variable name */
-  strncpy(varname, qualifiedName, sizeof(varname));
+  strcpy(varname, qualifiedName);
   /* convert slashes & dots to underscores */
   fix_filename_for_c(varname, MAX_PATH_LEN);
   register_filename(varname);
diff --git a/src/apps/mdns/mdns.c b/src/apps/mdns/mdns.c
index 5130bf32..aad27288 100644
--- a/src/apps/mdns/mdns.c
+++ b/src/apps/mdns/mdns.c
@@ -13,10 +13,12 @@
  * Things left to implement:
  * -------------------------
  *
+ * - Tiebreaking for simultaneous probing
  * - Sending goodbye messages (zero ttl) - shutdown, DHCP lease about to expire, DHCP turned off...
- * - Sending negative responses NSEC
+ * - Checking that source address of unicast requests are on the same network
+ * - Limiting multicast responses to 1 per second per resource record
  * - Fragmenting replies if required
- * - Handling multi-packet known answers (TC bit)
+ * - Handling multi-packet known answers
  * - Individual known answer detection for all local IPv6 addresses
  * - Dynamic size of outgoing packet
  */
@@ -50,14 +52,11 @@
  * This file is part of the lwIP TCP/IP stack.
  *
  * Author: Erik Ekman <erik@kryo.se>
- * Author: Jasper Verschueren <jasper.verschueren@apart-audio.com>
  *
  */
 
 #include "lwip/apps/mdns.h"
 #include "lwip/apps/mdns_priv.h"
-#include "lwip/apps/mdns_domain.h"
-#include "lwip/apps/mdns_out.h"
 #include "lwip/netif.h"
 #include "lwip/udp.h"
 #include "lwip/ip_addr.h"
@@ -65,10 +64,8 @@
 #include "lwip/prot/dns.h"
 #include "lwip/prot/iana.h"
 #include "lwip/timeouts.h"
-#include "lwip/sys.h"
 
-#include <string.h> /* memset */
-#include <stdio.h>  /* snprintf */
+#include <string.h>
 
 #if LWIP_MDNS_RESPONDER
 
@@ -81,9 +78,6 @@
 #if (!LWIP_UDP)
 #error "If you want to use MDNS, you have to define LWIP_UDP=1 in your lwipopts.h"
 #endif
-#ifndef LWIP_RAND
-#error "If you want to use MDNS, you have to define LWIP_RAND=(random function) in your lwipopts.h"
-#endif
 
 #if LWIP_IPV4
 #include "lwip/igmp.h"
@@ -97,11 +91,14 @@ static const ip_addr_t v4group = DNS_MQUERY_IPV4_GROUP_INIT;
 static const ip_addr_t v6group = DNS_MQUERY_IPV6_GROUP_INIT;
 #endif
 
-#define MDNS_IP_TTL  255
+#define MDNS_TTL  255
 
-#if LWIP_MDNS_SEARCH
-static struct mdns_request mdns_requests[MDNS_MAX_REQUESTS];
-#endif
+/* Stored offsets to beginning of domain names
+ * Used for compression.
+ */
+#define NUM_DOMAIN_OFFSETS 10
+#define DOMAIN_JUMP_SIZE 2
+#define DOMAIN_JUMP 0xc000
 
 static u8_t mdns_netif_client_id;
 static struct udp_pcb *mdns_pcb;
@@ -112,13 +109,36 @@ static mdns_name_result_cb_t mdns_name_result_cb;
 
 #define NETIF_TO_HOST(netif) (struct mdns_host*)(netif_get_client_data(netif, mdns_netif_client_id))
 
-/** Delayed response defines */
-#define MDNS_RESPONSE_DELAY_MAX   120
-#define MDNS_RESPONSE_DELAY_MIN    20
-#define MDNS_RESPONSE_DELAY (LWIP_RAND() %(MDNS_RESPONSE_DELAY_MAX - \
-                             MDNS_RESPONSE_DELAY_MIN) + MDNS_RESPONSE_DELAY_MIN)
+#define TOPDOMAIN_LOCAL "local"
+
+#define REVERSE_PTR_TOPDOMAIN "arpa"
+#define REVERSE_PTR_V4_DOMAIN "in-addr"
+#define REVERSE_PTR_V6_DOMAIN "ip6"
+
+#define SRV_PRIORITY 0
+#define SRV_WEIGHT   0
+
+/* Payload size allocated for each outgoing UDP packet */
+#define OUTPACKET_SIZE 500
+
+/* Lookup from hostname -> IPv4 */
+#define REPLY_HOST_A            0x01
+/* Lookup from IPv4/v6 -> hostname */
+#define REPLY_HOST_PTR_V4       0x02
+/* Lookup from hostname -> IPv6 */
+#define REPLY_HOST_AAAA         0x04
+/* Lookup from hostname -> IPv6 */
+#define REPLY_HOST_PTR_V6       0x08
+
+/* Lookup for service types */
+#define REPLY_SERVICE_TYPE_PTR  0x10
+/* Lookup for instances of service */
+#define REPLY_SERVICE_NAME_PTR  0x20
+/* Lookup for location of service instance */
+#define REPLY_SERVICE_SRV       0x40
+/* Lookup for text info on service instance */
+#define REPLY_SERVICE_TXT       0x80
 
-/** Probing & announcing defines */
 #define MDNS_PROBE_DELAY_MS       250
 #define MDNS_PROBE_COUNT          3
 #ifdef LWIP_RAND
@@ -128,19 +148,48 @@ static mdns_name_result_cb_t mdns_name_result_cb;
 #define MDNS_INITIAL_PROBE_DELAY_MS MDNS_PROBE_DELAY_MS
 #endif
 
-#define MDNS_PROBE_TIEBREAK_CONFLICT_DELAY_MS    1000
-#define MDNS_PROBE_TIEBREAK_MAX_ANSWERS          5
+#define MDNS_PROBING_NOT_STARTED  0
+#define MDNS_PROBING_ONGOING      1
+#define MDNS_PROBING_COMPLETE     2
 
-#define MDNS_LEXICOGRAPHICAL_EQUAL    0
-#define MDNS_LEXICOGRAPHICAL_EARLIER  1
-#define MDNS_LEXICOGRAPHICAL_LATER    2
+static const char *dnssd_protos[] = {
+  "_udp", /* DNSSD_PROTO_UDP */
+  "_tcp", /* DNSSD_PROTO_TCP */
+};
 
-/* Delay between successive announcements (RFC6762 section 8.3)
- * -> increase by a factor 2 with every response sent.
- */
-#define MDNS_ANNOUNCE_DELAY_MS    1000
-/* Minimum 2 announces, may send up to 8 (RFC6762 section 8.3) */
-#define MDNS_ANNOUNCE_COUNT       2
+/** Description of a service */
+struct mdns_service {
+  /** TXT record to answer with */
+  struct mdns_domain txtdata;
+  /** Name of service, like 'myweb' */
+  char name[MDNS_LABEL_MAXLEN + 1];
+  /** Type of service, like '_http' */
+  char service[MDNS_LABEL_MAXLEN + 1];
+  /** Callback function and userdata
+   * to update txtdata buffer */
+  service_get_txt_fn_t txt_fn;
+  void *txt_userdata;
+  /** TTL in seconds of SRV/TXT replies */
+  u32_t dns_ttl;
+  /** Protocol, TCP or UDP */
+  u16_t proto;
+  /** Port of the service */
+  u16_t port;
+};
+
+/** Description of a host/netif */
+struct mdns_host {
+  /** Hostname */
+  char name[MDNS_LABEL_MAXLEN + 1];
+  /** Pointer to services */
+  struct mdns_service *services[MDNS_MAX_SERVICES];
+  /** TTL in seconds of A/AAAA/PTR replies */
+  u32_t dns_ttl;
+  /** Number of probes sent for the current name */
+  u8_t probes_sent;
+  /** State in probing sequence */
+  u8_t probing_state;
+};
 
 /** Information about received packet */
 struct mdns_packet {
@@ -149,6 +198,8 @@ struct mdns_packet {
   u16_t source_port;
   /** If packet was received unicast */
   u16_t recv_unicast;
+  /** Netif that received the packet */
+  struct netif *netif;
   /** Packet data */
   struct pbuf *pbuf;
   /** Current parsing offset in packet */
@@ -160,18 +211,59 @@ struct mdns_packet {
   u16_t questions;
   /** Number of unparsed questions */
   u16_t questions_left;
-  /** Number of answers in packet */
+  /** Number of answers in packet,
+   *  (sum of normal, authoritative and additional answers)
+   *  read from packet header */
   u16_t answers;
   /** Number of unparsed answers */
   u16_t answers_left;
-  /** Number of authoritative answers in packet */
+};
+
+/** Information about outgoing packet */
+struct mdns_outpacket {
+  /** Netif to send the packet on */
+  struct netif *netif;
+  /** Packet data */
+  struct pbuf *pbuf;
+  /** Current write offset in packet */
+  u16_t write_offset;
+  /** Identifier. Used in legacy queries */
+  u16_t tx_id;
+  /** Destination IP/port if sent unicast */
+  ip_addr_t dest_addr;
+  u16_t dest_port;
+  /** Number of questions written */
+  u16_t questions;
+  /** Number of normal answers written */
+  u16_t answers;
+  /** Number of authoritative answers written */
   u16_t authoritative;
-  /** Number of unparsed authoritative answers */
-  u16_t authoritative_left;
-  /** Number of additional answers in packet */
+  /** Number of additional answers written */
   u16_t additional;
-  /** Number of unparsed additional answers */
-  u16_t additional_left;
+  /** Offsets for written domain names in packet.
+   *  Used for compression */
+  u16_t domain_offsets[NUM_DOMAIN_OFFSETS];
+  /** If all answers in packet should set cache_flush bit */
+  u8_t cache_flush;
+  /** If reply should be sent unicast */
+  u8_t unicast_reply;
+  /** If legacy query. (tx_id needed, and write
+   *  question again in reply before answer) */
+  u8_t legacy_query;
+  /* Reply bitmask for host information */
+  u8_t host_replies;
+  /* Bitmask for which reverse IPv6 hosts to answer */
+  u8_t host_reverse_v6_replies;
+  /* Reply bitmask per service */
+  u8_t serv_replies[MDNS_MAX_SERVICES];
+};
+
+/** Domain, type and class.
+ *  Shared between questions and answers */
+struct mdns_rr_info {
+  struct mdns_domain domain;
+  u16_t type;
+  u16_t klass;
 };
 
 struct mdns_question {
@@ -180,41 +272,389 @@ struct mdns_question {
   u16_t unicast;
 };
 
-struct mdns_answer_list {
-  u16_t offset[MDNS_PROBE_TIEBREAK_MAX_ANSWERS];
-  u16_t size;
+struct mdns_answer {
+  struct mdns_rr_info info;
+  /** cache flush command bit */
+  u16_t cache_flush;
+  /* Validity time in seconds */
+  u32_t ttl;
+  /** Length of variable answer */
+  u16_t rd_length;
+  /** Offset of start of variable answer in packet */
+  u16_t rd_offset;
 };
 
-static err_t mdns_parse_pkt_questions(struct netif *netif,
-                                      struct mdns_packet *pkt,
-                                      struct mdns_outmsg *reply);
-static void mdns_define_probe_rrs_to_send(struct netif *netif,
-                                          struct mdns_outmsg *outmsg);
-static void mdns_probe_and_announce(void* arg);
+static err_t mdns_send_outpacket(struct mdns_outpacket *outpkt, u8_t flags);
+static void mdns_probe(void* arg);
+
+static err_t
+mdns_domain_add_label_base(struct mdns_domain *domain, u8_t len)
+{
+  if (len > MDNS_LABEL_MAXLEN) {
+    return ERR_VAL;
+  }
+  if (len > 0 && (1 + len + domain->length >= MDNS_DOMAIN_MAXLEN)) {
+    return ERR_VAL;
+  }
+  /* Allow only zero marker on last byte */
+  if (len == 0 && (1 + domain->length > MDNS_DOMAIN_MAXLEN)) {
+    return ERR_VAL;
+  }
+  domain->name[domain->length] = len;
+  domain->length++;
+  return ERR_OK;
+}
+
+/**
+ * Add a label part to a domain
+ * @param domain The domain to add a label to
+ * @param label The label to add, like &lt;hostname&gt;, 'local', 'com' or ''
+ * @param len The length of the label
+ * @return ERR_OK on success, an err_t otherwise if label too long
+ */
+err_t
+mdns_domain_add_label(struct mdns_domain *domain, const char *label, u8_t len)
+{
+  err_t err = mdns_domain_add_label_base(domain, len);
+  if (err != ERR_OK) {
+    return err;
+  }
+  if (len) {
+    MEMCPY(&domain->name[domain->length], label, len);
+    domain->length += len;
+  }
+  return ERR_OK;
+}
 
 /**
- *  Construction to make mdns struct accessible from mdns_out.c
- *  TODO:
- *  can we add the mdns struct to the netif like we do for dhcp, autoip,...?
- *  Then this is not needed any more.
- *
- *  @param netif  The network interface
- *  @return       mdns struct
+ * Add a label part to a domain (@see mdns_domain_add_label but copy directly from pbuf)
  */
-struct mdns_host*
-netif_mdns_data(struct netif *netif) {
-  return NETIF_TO_HOST(netif);
+static err_t
+mdns_domain_add_label_pbuf(struct mdns_domain *domain, const struct pbuf *p, u16_t offset, u8_t len)
+{
+  err_t err = mdns_domain_add_label_base(domain, len);
+  if (err != ERR_OK) {
+    return err;
+  }
+  if (len) {
+    if (pbuf_copy_partial(p, &domain->name[domain->length], len, offset) != len) {
+      /* take back the ++ done before */
+      domain->length--;
+      return ERR_ARG;
+    }
+    domain->length += len;
+  }
+  return ERR_OK;
 }
 
 /**
- *  Construction to access the mdns udp pcb.
- *
- *  @return   udp_pcb struct of mdns
+ * Internal readname function with max 6 levels of recursion following jumps
+ * while decompressing name
+ */
+static u16_t
+mdns_readname_loop(struct pbuf *p, u16_t offset, struct mdns_domain *domain, unsigned depth)
+{
+  u8_t c;
+
+  do {
+    if (depth > 5) {
+      /* Too many jumps */
+      return MDNS_READNAME_ERROR;
+    }
+
+    c = pbuf_get_at(p, offset);
+    offset++;
+
+    /* is this a compressed label? */
+    if ((c & 0xc0) == 0xc0) {
+      u16_t jumpaddr;
+      if (offset >= p->tot_len) {
+        /* Make sure both jump bytes fit in the packet */
+        return MDNS_READNAME_ERROR;
+      }
+      jumpaddr = (((c & 0x3f) << 8) | (pbuf_get_at(p, offset) & 0xff));
+      offset++;
+      if (jumpaddr >= SIZEOF_DNS_HDR && jumpaddr < p->tot_len) {
+        u16_t res;
+        /* Recursive call, maximum depth will be checked */
+        res = mdns_readname_loop(p, jumpaddr, domain, depth + 1);
+        /* Dont return offset since new bytes were not read (jumped to somewhere in packet) */
+        if (res == MDNS_READNAME_ERROR) {
+          return res;
+        }
+      } else {
+        return MDNS_READNAME_ERROR;
+      }
+      break;
+    }
+
+    /* normal label */
+    if (c <= MDNS_LABEL_MAXLEN) {
+      err_t res;
+
+      if (c + domain->length >= MDNS_DOMAIN_MAXLEN) {
+        return MDNS_READNAME_ERROR;
+      }
+      res = mdns_domain_add_label_pbuf(domain, p, offset, c);
+      if (res != ERR_OK) {
+        return MDNS_READNAME_ERROR;
+      }
+      offset += c;
+    } else {
+      /* bad length byte */
+      return MDNS_READNAME_ERROR;
+    }
+  } while (c != 0);
+
+  return offset;
+}
+
+/**
+ * Read possibly compressed domain name from packet buffer
+ * @param p The packet
+ * @param offset start position of domain name in packet
+ * @param domain The domain name destination
+ * @return The new offset after the domain, or MDNS_READNAME_ERROR
+ *         if reading failed
+ */
+u16_t
+mdns_readname(struct pbuf *p, u16_t offset, struct mdns_domain *domain)
+{
+  memset(domain, 0, sizeof(struct mdns_domain));
+  return mdns_readname_loop(p, offset, domain, 0);
+}
+
+/**
+ * Print domain name to debug output
+ * @param domain The domain name
+ */
+static void
+mdns_domain_debug_print(struct mdns_domain *domain)
+{
+  u8_t *src = domain->name;
+  u8_t i;
+
+  while (*src) {
+    u8_t label_len = *src;
+    src++;
+    for (i = 0; i < label_len; i++) {
+      LWIP_DEBUGF(MDNS_DEBUG, ("%c", src[i]));
+    }
+    src += label_len;
+    LWIP_DEBUGF(MDNS_DEBUG, ("."));
+  }
+}
+
+/**
+ * Return 1 if contents of domains match (case-insensitive)
+ * @param a Domain name to compare 1
+ * @param b Domain name to compare 2
+ * @return 1 if domains are equal ignoring case, 0 otherwise
+ */
+int
+mdns_domain_eq(struct mdns_domain *a, struct mdns_domain *b)
+{
+  u8_t *ptra, *ptrb;
+  u8_t len;
+  int res;
+
+  if (a->length != b->length) {
+    return 0;
+  }
+
+  ptra = a->name;
+  ptrb = b->name;
+  while (*ptra && *ptrb && ptra < &a->name[a->length]) {
+    if (*ptra != *ptrb) {
+      return 0;
+    }
+    len = *ptra;
+    ptra++;
+    ptrb++;
+    res = lwip_strnicmp((char *) ptra, (char *) ptrb, len);
+    if (res != 0) {
+      return 0;
+    }
+    ptra += len;
+    ptrb += len;
+  }
+  if (*ptra != *ptrb && ptra < &a->name[a->length]) {
+    return 0;
+  }
+  return 1;
+}
+
+/**
+ * Call user supplied function to setup TXT data
+ * @param service The service to build TXT record for
+ */
+static void
+mdns_prepare_txtdata(struct mdns_service *service)
+{
+  memset(&service->txtdata, 0, sizeof(struct mdns_domain));
+  if (service->txt_fn) {
+    service->txt_fn(service, service->txt_userdata);
+  }
+}
+
+#if LWIP_IPV4
+/**
+ * Build domain for reverse lookup of IPv4 address
+ * like 12.0.168.192.in-addr.arpa. for 192.168.0.12
+ * @param domain Where to write the domain name
+ * @param addr Pointer to an IPv4 address to encode
+ * @return ERR_OK if domain was written, an err_t otherwise
+ */
+static err_t
+mdns_build_reverse_v4_domain(struct mdns_domain *domain, const ip4_addr_t *addr)
+{
+  int i;
+  err_t res;
+  const u8_t *ptr;
+
+  LWIP_UNUSED_ARG(res);
+  if (!domain || !addr) {
+    return ERR_ARG;
+  }
+  memset(domain, 0, sizeof(struct mdns_domain));
+  ptr = (const u8_t *) addr;
+  for (i = sizeof(ip4_addr_t) - 1; i >= 0; i--) {
+    char buf[4];
+    u8_t val = ptr[i];
+
+    lwip_itoa(buf, sizeof(buf), val);
+    res = mdns_domain_add_label(domain, buf, (u8_t)strlen(buf));
+    LWIP_ERROR("mdns_build_reverse_v4_domain: Failed to add label", (res == ERR_OK), return res);
+  }
+  res = mdns_domain_add_label(domain, REVERSE_PTR_V4_DOMAIN, (u8_t)(sizeof(REVERSE_PTR_V4_DOMAIN) - 1));
+  LWIP_ERROR("mdns_build_reverse_v4_domain: Failed to add label", (res == ERR_OK), return res);
+  res = mdns_domain_add_label(domain, REVERSE_PTR_TOPDOMAIN, (u8_t)(sizeof(REVERSE_PTR_TOPDOMAIN) - 1));
+  LWIP_ERROR("mdns_build_reverse_v4_domain: Failed to add label", (res == ERR_OK), return res);
+  res = mdns_domain_add_label(domain, NULL, 0);
+  LWIP_ERROR("mdns_build_reverse_v4_domain: Failed to add label", (res == ERR_OK), return res);
+
+  return ERR_OK;
+}
+#endif
+
+#if LWIP_IPV6
+/**
+ * Build domain for reverse lookup of IP address
+ * like b.a.9.8.7.6.5.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.b.d.0.1.0.0.2.ip6.arpa. for 2001:db8::567:89ab
+ * @param domain Where to write the domain name
+ * @param addr Pointer to an IPv6 address to encode
+ * @return ERR_OK if domain was written, an err_t otherwise
+ */
+static err_t
+mdns_build_reverse_v6_domain(struct mdns_domain *domain, const ip6_addr_t *addr)
+{
+  int i;
+  err_t res;
+  const u8_t *ptr;
+  LWIP_UNUSED_ARG(res);
+  if (!domain || !addr) {
+    return ERR_ARG;
+  }
+  memset(domain, 0, sizeof(struct mdns_domain));
+  ptr = (const u8_t *) addr;
+  for (i = sizeof(ip6_addr_p_t) - 1; i >= 0; i--) {
+    char buf;
+    u8_t byte = ptr[i];
+    int j;
+    for (j = 0; j < 2; j++) {
+      if ((byte & 0x0F) < 0xA) {
+        buf = '0' + (byte & 0x0F);
+      } else {
+        buf = 'a' + (byte & 0x0F) - 0xA;
+      }
+      res = mdns_domain_add_label(domain, &buf, sizeof(buf));
+      LWIP_ERROR("mdns_build_reverse_v6_domain: Failed to add label", (res == ERR_OK), return res);
+      byte >>= 4;
+    }
+  }
+  res = mdns_domain_add_label(domain, REVERSE_PTR_V6_DOMAIN, (u8_t)(sizeof(REVERSE_PTR_V6_DOMAIN) - 1));
+  LWIP_ERROR("mdns_build_reverse_v6_domain: Failed to add label", (res == ERR_OK), return res);
+  res = mdns_domain_add_label(domain, REVERSE_PTR_TOPDOMAIN, (u8_t)(sizeof(REVERSE_PTR_TOPDOMAIN) - 1));
+  LWIP_ERROR("mdns_build_reverse_v6_domain: Failed to add label", (res == ERR_OK), return res);
+  res = mdns_domain_add_label(domain, NULL, 0);
+  LWIP_ERROR("mdns_build_reverse_v6_domain: Failed to add label", (res == ERR_OK), return res);
+
+  return ERR_OK;
+}
+#endif
+
+/* Add .local. to domain */
+static err_t
+mdns_add_dotlocal(struct mdns_domain *domain)
+{
+  err_t res = mdns_domain_add_label(domain, TOPDOMAIN_LOCAL, (u8_t)(sizeof(TOPDOMAIN_LOCAL) - 1));
+  LWIP_UNUSED_ARG(res);
+  LWIP_ERROR("mdns_add_dotlocal: Failed to add label", (res == ERR_OK), return res);
+  return mdns_domain_add_label(domain, NULL, 0);
+}
+
+/**
+ * Build the <hostname>.local. domain name
+ * @param domain Where to write the domain name
+ * @param mdns TMDNS netif descriptor.
+ * @return ERR_OK if domain <hostname>.local. was written, an err_t otherwise
+ */
+static err_t
+mdns_build_host_domain(struct mdns_domain *domain, struct mdns_host *mdns)
+{
+  err_t res;
+  LWIP_UNUSED_ARG(res);
+  memset(domain, 0, sizeof(struct mdns_domain));
+  LWIP_ERROR("mdns_build_host_domain: mdns != NULL", (mdns != NULL), return ERR_VAL);
+  res = mdns_domain_add_label(domain, mdns->name, (u8_t)strlen(mdns->name));
+  LWIP_ERROR("mdns_build_host_domain: Failed to add label", (res == ERR_OK), return res);
+  return mdns_add_dotlocal(domain);
+}
+
+/**
+ * Build the lookup-all-services special DNS-SD domain name
+ * @param domain Where to write the domain name
+ * @return ERR_OK if domain _services._dns-sd._udp.local. was written, an err_t otherwise
+ */
+static err_t
+mdns_build_dnssd_domain(struct mdns_domain *domain)
+{
+  err_t res;
+  LWIP_UNUSED_ARG(res);
+  memset(domain, 0, sizeof(struct mdns_domain));
+  res = mdns_domain_add_label(domain, "_services", (u8_t)(sizeof("_services") - 1));
+  LWIP_ERROR("mdns_build_dnssd_domain: Failed to add label", (res == ERR_OK), return res);
+  res = mdns_domain_add_label(domain, "_dns-sd", (u8_t)(sizeof("_dns-sd") - 1));
+  LWIP_ERROR("mdns_build_dnssd_domain: Failed to add label", (res == ERR_OK), return res);
+  res = mdns_domain_add_label(domain, dnssd_protos[DNSSD_PROTO_UDP], (u8_t)strlen(dnssd_protos[DNSSD_PROTO_UDP]));
+  LWIP_ERROR("mdns_build_dnssd_domain: Failed to add label", (res == ERR_OK), return res);
+  return mdns_add_dotlocal(domain);
+}
+
+/**
+ * Build domain name for a service
+ * @param domain Where to write the domain name
+ * @param service The service struct, containing service name, type and protocol
+ * @param include_name Whether to include the service name in the domain
+ * @return ERR_OK if domain was written. If service name is included,
+ *         <name>.<type>.<proto>.local. will be written, otherwise <type>.<proto>.local.
+ *         An err_t is returned on error.
  */
-struct udp_pcb*
-get_mdns_pcb(void)
+static err_t
+mdns_build_service_domain(struct mdns_domain *domain, struct mdns_service *service, int include_name)
 {
-  return mdns_pcb;
+  err_t res;
+  LWIP_UNUSED_ARG(res);
+  memset(domain, 0, sizeof(struct mdns_domain));
+  if (include_name) {
+    res = mdns_domain_add_label(domain, service->name, (u8_t)strlen(service->name));
+    LWIP_ERROR("mdns_build_service_domain: Failed to add label", (res == ERR_OK), return res);
+  }
+  res = mdns_domain_add_label(domain, service->service, (u8_t)strlen(service->service));
+  LWIP_ERROR("mdns_build_service_domain: Failed to add label", (res == ERR_OK), return res);
+  res = mdns_domain_add_label(domain, dnssd_protos[service->proto], (u8_t)strlen(dnssd_protos[service->proto]));
+  LWIP_ERROR("mdns_build_service_domain: Failed to add label", (res == ERR_OK), return res);
+  return mdns_add_dotlocal(domain);
 }
 
 /**
@@ -332,98 +772,324 @@ check_service(struct mdns_service *service, struct mdns_rr_info *rr)
   return replies;
 }
 
-#if LWIP_MDNS_SEARCH
 /**
- * Check if question belong to a specified request
- * @param request A ongoing MDNS request
- * @param rr Domain/type/class from an answer
- * @return Bitmask of which matching replies
+ * Return bytes needed to write before jump for best result of compressing supplied domain
+ * against domain in outpacket starting at specified offset.
+ * If a match is found, offset is updated to where to jump to
+ * @param pbuf Pointer to pbuf with the partially constructed DNS packet
+ * @param offset Start position of a domain written earlier. If this location is suitable
+ *               for compression, the pointer is updated to where in the domain to jump to.
+ * @param domain The domain to write
+ * @return Number of bytes to write of the new domain before writing a jump to the offset.
+ *         If compression can not be done against this previous domain name, the full new
+ *         domain length is returned.
  */
-static int
-check_request(struct mdns_request *request, struct mdns_rr_info *rr)
+u16_t
+mdns_compress_domain(struct pbuf *pbuf, u16_t *offset, struct mdns_domain *domain)
 {
-  err_t res;
-  int replies = 0;
-  struct mdns_domain mydomain;
-
-  if (rr->klass != DNS_RRCLASS_IN && rr->klass != DNS_RRCLASS_ANY) {
-    /* Invalid class */
-    return 0;
+  struct mdns_domain target;
+  u16_t target_end;
+  u8_t target_len;
+  u8_t writelen = 0;
+  u8_t *ptr;
+  if (pbuf == NULL) {
+    return domain->length;
+  }
+  target_end = mdns_readname(pbuf, *offset, &target);
+  if (target_end == MDNS_READNAME_ERROR) {
+    return domain->length;
+  }
+  target_len = (u8_t)(target_end - *offset);
+  ptr = domain->name;
+  while (writelen < domain->length) {
+    u8_t domainlen = (u8_t)(domain->length - writelen);
+    u8_t labellen;
+    if (domainlen <= target.length && domainlen > DOMAIN_JUMP_SIZE) {
+      /* Compare domains if target is long enough, and we have enough left of the domain */
+      u8_t targetpos = (u8_t)(target.length - domainlen);
+      if ((targetpos + DOMAIN_JUMP_SIZE) >= target_len) {
+        /* We are checking at or beyond a jump in the original, stop looking */
+        break;
+      }
+      if (target.length >= domainlen &&
+          memcmp(&domain->name[writelen], &target.name[targetpos], domainlen) == 0) {
+        *offset += targetpos;
+        return writelen;
+      }
+    }
+    /* Skip to next label in domain */
+    labellen = *ptr;
+    writelen += 1 + labellen;
+    ptr += 1 + labellen;
   }
+  /* Nothing found */
+  return domain->length;
+}
 
-  res = mdns_build_request_domain(&mydomain, request, 0);
-  if (res == ERR_OK && mdns_domain_eq(&rr->domain, &mydomain) &&
-      (rr->type == DNS_RRTYPE_PTR || rr->type == DNS_RRTYPE_ANY)) {
-    /* Request for the instance of my service */
-    replies |= REPLY_SERVICE_TYPE_PTR;
+/**
+ * Write domain to outpacket. Compression will be attempted,
+ * unless domain->skip_compression is set.
+ * @param outpkt The outpacket to write to
+ * @param domain The domain name to write
+ * @return ERR_OK on success, an err_t otherwise
+ */
+static err_t
+mdns_write_domain(struct mdns_outpacket *outpkt, struct mdns_domain *domain)
+{
+  int i;
+  err_t res;
+  u16_t writelen = domain->length;
+  u16_t jump_offset = 0;
+  u16_t jump;
+
+  if (!domain->skip_compression) {
+    for (i = 0; i < NUM_DOMAIN_OFFSETS; i++) {
+      u16_t offset = outpkt->domain_offsets[i];
+      if (offset) {
+        u16_t len = mdns_compress_domain(outpkt->pbuf, &offset, domain);
+        if (len < writelen) {
+          writelen = len;
+          jump_offset = offset;
+        }
+      }
+    }
   }
-  res = mdns_build_request_domain(&mydomain, request, 1);
-  if (res == ERR_OK && mdns_domain_eq(&rr->domain, &mydomain)) {
-    /* Request for info about my service */
-    if (rr->type == DNS_RRTYPE_SRV || rr->type == DNS_RRTYPE_ANY) {
-      replies |= REPLY_SERVICE_SRV;
+
+  if (writelen) {
+    /* Write uncompressed part of name */
+    res = pbuf_take_at(outpkt->pbuf, domain->name, writelen, outpkt->write_offset);
+    if (res != ERR_OK) {
+      return res;
     }
-    if (rr->type == DNS_RRTYPE_TXT || rr->type == DNS_RRTYPE_ANY) {
-      replies |= REPLY_SERVICE_TXT;
+
+    /* Store offset of this new domain */
+    for (i = 0; i < NUM_DOMAIN_OFFSETS; i++) {
+      if (outpkt->domain_offsets[i] == 0) {
+        outpkt->domain_offsets[i] = outpkt->write_offset;
+        break;
+      }
     }
+
+    outpkt->write_offset += writelen;
   }
-  return replies;
+  if (jump_offset) {
+    /* Write jump */
+    jump = lwip_htons(DOMAIN_JUMP | jump_offset);
+    res = pbuf_take_at(outpkt->pbuf, &jump, DOMAIN_JUMP_SIZE, outpkt->write_offset);
+    if (res != ERR_OK) {
+      return res;
+    }
+    outpkt->write_offset += DOMAIN_JUMP_SIZE;
+  }
+  return ERR_OK;
 }
-#endif
 
 /**
- * Helper function for mdns_read_question/mdns_read_answer
- * Reads a domain, type and class from the packet
- * @param pkt The MDNS packet to read from. The parse_offset field will be
- *            incremented to point to the next unparsed byte.
- * @param info The struct to fill with domain, type and class
+ * Write a question to an outpacket
+ * A question contains domain, type and class. Since an answer also starts with these fields this function is also
+ * called from mdns_add_answer().
+ * @param outpkt The outpacket to write to
+ * @param domain The domain name the answer is for
+ * @param type The DNS type of the answer (like 'AAAA', 'SRV')
+ * @param klass The DNS type of the answer (like 'IN')
+ * @param unicast If highest bit in class should be set, to instruct the responder to
+ *                reply with a unicast packet
  * @return ERR_OK on success, an err_t otherwise
  */
 static err_t
-mdns_read_rr_info(struct mdns_packet *pkt, struct mdns_rr_info *info)
+mdns_add_question(struct mdns_outpacket *outpkt, struct mdns_domain *domain, u16_t type, u16_t klass, u16_t unicast)
 {
-  u16_t field16, copied;
-  pkt->parse_offset = mdns_readname(pkt->pbuf, pkt->parse_offset, &info->domain);
-  if (pkt->parse_offset == MDNS_READNAME_ERROR) {
-    return ERR_VAL;
+  u16_t question_len;
+  u16_t field16;
+  err_t res;
+
+  if (!outpkt->pbuf) {
+    /* If no pbuf is active, allocate one */
+    outpkt->pbuf = pbuf_alloc(PBUF_TRANSPORT, OUTPACKET_SIZE, PBUF_RAM);
+    if (!outpkt->pbuf) {
+      return ERR_MEM;
+    }
+    outpkt->write_offset = SIZEOF_DNS_HDR;
   }
 
-  copied = pbuf_copy_partial(pkt->pbuf, &field16, sizeof(field16), pkt->parse_offset);
-  if (copied != sizeof(field16)) {
-    return ERR_VAL;
+  /* Worst case calculation. Domain string might be compressed */
+  question_len = domain->length + sizeof(type) + sizeof(klass);
+  if (outpkt->write_offset + question_len > outpkt->pbuf->tot_len) {
+    /* No space */
+    return ERR_MEM;
   }
-  pkt->parse_offset += copied;
-  info->type = lwip_ntohs(field16);
 
-  copied = pbuf_copy_partial(pkt->pbuf, &field16, sizeof(field16), pkt->parse_offset);
-  if (copied != sizeof(field16)) {
-    return ERR_VAL;
+  /* Write name */
+  res = mdns_write_domain(outpkt, domain);
+  if (res != ERR_OK) {
+    return res;
   }
-  pkt->parse_offset += copied;
-  info->klass = lwip_ntohs(field16);
+
+  /* Write type */
+  field16 = lwip_htons(type);
+  res = pbuf_take_at(outpkt->pbuf, &field16, sizeof(field16), outpkt->write_offset);
+  if (res != ERR_OK) {
+    return res;
+  }
+  outpkt->write_offset += sizeof(field16);
+
+  /* Write class */
+  if (unicast) {
+    klass |= 0x8000;
+  }
+  field16 = lwip_htons(klass);
+  res = pbuf_take_at(outpkt->pbuf, &field16, sizeof(field16), outpkt->write_offset);
+  if (res != ERR_OK) {
+    return res;
+  }
+  outpkt->write_offset += sizeof(field16);
 
   return ERR_OK;
 }
 
 /**
- * Read a question from the packet.
- * All questions have to be read before the answers.
- * @param pkt The MDNS packet to read from. The questions_left field will be decremented
- *            and the parse_offset will be updated.
- * @param question The struct to fill with question data
+ * Write answer to reply packet.
+ * buf or answer_domain can be null. The rd_length written will be buf_length +
+ * size of (compressed) domain. Most uses will need either buf or answer_domain,
+ * special case is SRV that starts with 3 u16 and then a domain name.
+ * @param reply The outpacket to write to
+ * @param domain The domain name the answer is for
+ * @param type The DNS type of the answer (like 'AAAA', 'SRV')
+ * @param klass The DNS type of the answer (like 'IN')
+ * @param cache_flush If highest bit in class should be set, to instruct receiver that
+ *                    this reply replaces any earlier answer for this domain/type/class
+ * @param ttl Validity time in seconds to send out for IP address data in DNS replies
+ * @param buf Pointer to buffer of answer data
+ * @param buf_length Length of variable data
+ * @param answer_domain A domain to write after any buffer data as answer
  * @return ERR_OK on success, an err_t otherwise
  */
 static err_t
-mdns_read_question(struct mdns_packet *pkt, struct mdns_question *question)
+mdns_add_answer(struct mdns_outpacket *reply, struct mdns_domain *domain, u16_t type, u16_t klass, u16_t cache_flush,
+                u32_t ttl, const u8_t *buf, size_t buf_length, struct mdns_domain *answer_domain)
 {
-  /* Safety check */
-  if (pkt->pbuf->tot_len < pkt->parse_offset) {
-    return ERR_VAL;
+  u16_t answer_len;
+  u16_t field16;
+  u16_t rdlen_offset;
+  u16_t answer_offset;
+  u32_t field32;
+  err_t res;
+
+  if (!reply->pbuf) {
+    /* If no pbuf is active, allocate one */
+    reply->pbuf = pbuf_alloc(PBUF_TRANSPORT, OUTPACKET_SIZE, PBUF_RAM);
+    if (!reply->pbuf) {
+      return ERR_MEM;
+    }
+    reply->write_offset = SIZEOF_DNS_HDR;
   }
 
-  if (pkt->questions_left) {
-    err_t res;
-    pkt->questions_left--;
+  /* Worst case calculation. Domain strings might be compressed */
+  answer_len = domain->length + sizeof(type) + sizeof(klass) + sizeof(ttl) + sizeof(field16)/*rd_length*/;
+  if (buf) {
+    answer_len += (u16_t)buf_length;
+  }
+  if (answer_domain) {
+    answer_len += answer_domain->length;
+  }
+  if (reply->write_offset + answer_len > reply->pbuf->tot_len) {
+    /* No space */
+    return ERR_MEM;
+  }
+
+  /* Answer starts with same data as question, then more fields */
+  mdns_add_question(reply, domain, type, klass, cache_flush);
+
+  /* Write TTL */
+  field32 = lwip_htonl(ttl);
+  res = pbuf_take_at(reply->pbuf, &field32, sizeof(field32), reply->write_offset);
+  if (res != ERR_OK) {
+    return res;
+  }
+  reply->write_offset += sizeof(field32);
+
+  /* Store offsets and skip forward to the data */
+  rdlen_offset = reply->write_offset;
+  reply->write_offset += sizeof(field16);
+  answer_offset = reply->write_offset;
+
+  if (buf) {
+    /* Write static data */
+    res = pbuf_take_at(reply->pbuf, buf, (u16_t)buf_length, reply->write_offset);
+    if (res != ERR_OK) {
+      return res;
+    }
+    reply->write_offset += (u16_t)buf_length;
+  }
+
+  if (answer_domain) {
+    /* Write name answer (compressed if possible) */
+    res = mdns_write_domain(reply, answer_domain);
+    if (res != ERR_OK) {
+      return res;
+    }
+  }
+
+  /* Write rd_length after when we know the answer size */
+  field16 = lwip_htons(reply->write_offset - answer_offset);
+  res = pbuf_take_at(reply->pbuf, &field16, sizeof(field16), rdlen_offset);
+
+  return res;
+}
+
+/**
+ * Helper function for mdns_read_question/mdns_read_answer
+ * Reads a domain, type and class from the packet
+ * @param pkt The MDNS packet to read from. The parse_offset field will be
+ *            incremented to point to the next unparsed byte.
+ * @param info The struct to fill with domain, type and class
+ * @return ERR_OK on success, an err_t otherwise
+ */
+static err_t
+mdns_read_rr_info(struct mdns_packet *pkt, struct mdns_rr_info *info)
+{
+  u16_t field16, copied;
+  pkt->parse_offset = mdns_readname(pkt->pbuf, pkt->parse_offset, &info->domain);
+  if (pkt->parse_offset == MDNS_READNAME_ERROR) {
+    return ERR_VAL;
+  }
+
+  copied = pbuf_copy_partial(pkt->pbuf, &field16, sizeof(field16), pkt->parse_offset);
+  if (copied != sizeof(field16)) {
+    return ERR_VAL;
+  }
+  pkt->parse_offset += copied;
+  info->type = lwip_ntohs(field16);
+
+  copied = pbuf_copy_partial(pkt->pbuf, &field16, sizeof(field16), pkt->parse_offset);
+  if (copied != sizeof(field16)) {
+    return ERR_VAL;
+  }
+  pkt->parse_offset += copied;
+  info->klass = lwip_ntohs(field16);
+
+  return ERR_OK;
+}
+
+/**
+ * Read a question from the packet.
+ * All questions have to be read before the answers.
+ * @param pkt The MDNS packet to read from. The questions_left field will be decremented
+ *            and the parse_offset will be updated.
+ * @param question The struct to fill with question data
+ * @return ERR_OK on success, an err_t otherwise
+ */
+static err_t
+mdns_read_question(struct mdns_packet *pkt, struct mdns_question *question)
+{
+  /* Safety check */
+  if (pkt->pbuf->tot_len < pkt->parse_offset) {
+    return ERR_VAL;
+  }
+
+  if (pkt->questions_left) {
+    err_t res;
+    pkt->questions_left--;
 
     memset(question, 0, sizeof(struct mdns_question));
     res = mdns_read_rr_info(pkt, &question->info);
@@ -443,14 +1109,13 @@ mdns_read_question(struct mdns_packet *pkt, struct mdns_question *question)
 /**
  * Read an answer from the packet
  * The variable length reply is not copied, its pbuf offset and length is stored instead.
- * @param pkt The MDNS packet to read. The num_left field will be decremented and
+ * @param pkt The MDNS packet to read. The answers_left field will be decremented and
  *            the parse_offset will be updated.
- * @param answer    The struct to fill with answer data
- * @param num_left  number of answers left -> answers, authoritative or additional
+ * @param answer The struct to fill with answer data
  * @return ERR_OK on success, an err_t otherwise
  */
 static err_t
-mdns_read_answer(struct mdns_packet *pkt, struct mdns_answer *answer, u16_t *num_left)
+mdns_read_answer(struct mdns_packet *pkt, struct mdns_answer *answer)
 {
   /* Read questions first */
   if (pkt->questions_left) {
@@ -462,11 +1127,11 @@ mdns_read_answer(struct mdns_packet *pkt, struct mdns_answer *answer, u16_t *num
     return ERR_VAL;
   }
 
-  if (*num_left) {
+  if (pkt->answers_left) {
     u16_t copied, field16;
     u32_t ttl;
     err_t res;
-    (*num_left)--;
+    pkt->answers_left--;
 
     memset(answer, 0, sizeof(struct mdns_answer));
     res = mdns_read_rr_info(pkt, &answer->info);
@@ -500,567 +1165,416 @@ mdns_read_answer(struct mdns_packet *pkt, struct mdns_answer *answer, u16_t *num
   return ERR_VAL;
 }
 
-/**
- * Send unsolicited answer containing all our known data
- * @param netif The network interface to send on
- * @param destination The target address to send to (usually multicast address)
- */
-static void
-mdns_announce(struct netif *netif, const ip_addr_t *destination)
+#if LWIP_IPV4
+/** Write an IPv4 address (A) RR to outpacket */
+static err_t
+mdns_add_a_answer(struct mdns_outpacket *reply, u16_t cache_flush, struct netif *netif)
 {
-  struct mdns_outmsg announce;
-  int i;
-  struct mdns_host *mdns = NETIF_TO_HOST(netif);
+  struct mdns_domain host;
+  mdns_build_host_domain(&host, NETIF_TO_HOST(netif));
+  LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Responding with A record\n"));
+  return mdns_add_answer(reply, &host, DNS_RRTYPE_A, DNS_RRCLASS_IN, cache_flush, (NETIF_TO_HOST(netif))->dns_ttl, (const u8_t *) netif_ip4_addr(netif), sizeof(ip4_addr_t), NULL);
+}
 
-  memset(&announce, 0, sizeof(announce));
-  announce.cache_flush = 1;
-#if LWIP_IPV4
-  if (!ip4_addr_isany_val(*netif_ip4_addr(netif))) {
-    announce.host_replies = REPLY_HOST_A | REPLY_HOST_PTR_V4;
-  }
-#endif
-#if LWIP_IPV6
-  for (i = 0; i < LWIP_IPV6_NUM_ADDRESSES; i++) {
-    if (ip6_addr_isvalid(netif_ip6_addr_state(netif, i))) {
-      announce.host_replies |= REPLY_HOST_AAAA | REPLY_HOST_PTR_V6;
-      announce.host_reverse_v6_replies |= (1 << i);
-    }
-  }
+/** Write a 4.3.2.1.in-addr.arpa -> hostname.local PTR RR to outpacket */
+static err_t
+mdns_add_hostv4_ptr_answer(struct mdns_outpacket *reply, u16_t cache_flush, struct netif *netif)
+{
+  struct mdns_domain host, revhost;
+  mdns_build_host_domain(&host, NETIF_TO_HOST(netif));
+  mdns_build_reverse_v4_domain(&revhost, netif_ip4_addr(netif));
+  LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Responding with v4 PTR record\n"));
+  return mdns_add_answer(reply, &revhost, DNS_RRTYPE_PTR, DNS_RRCLASS_IN, cache_flush, (NETIF_TO_HOST(netif))->dns_ttl, NULL, 0, &host);
+}
 #endif
 
-  for (i = 0; i < MDNS_MAX_SERVICES; i++) {
-    struct mdns_service *serv = mdns->services[i];
-    if (serv) {
-      announce.serv_replies[i] = REPLY_SERVICE_TYPE_PTR | REPLY_SERVICE_NAME_PTR |
-                                 REPLY_SERVICE_SRV | REPLY_SERVICE_TXT;
-    }
-  }
-
-  announce.dest_port = LWIP_IANA_PORT_MDNS;
-  SMEMCPY(&announce.dest_addr, destination, sizeof(announce.dest_addr));
-  announce.flags = DNS_FLAG1_RESPONSE | DNS_FLAG1_AUTHORATIVE;
-  mdns_send_outpacket(&announce, netif);
+#if LWIP_IPV6
+/** Write an IPv6 address (AAAA) RR to outpacket */
+static err_t
+mdns_add_aaaa_answer(struct mdns_outpacket *reply, u16_t cache_flush, struct netif *netif, int addrindex)
+{
+  struct mdns_domain host;
+  mdns_build_host_domain(&host, NETIF_TO_HOST(netif));
+  LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Responding with AAAA record\n"));
+  return mdns_add_answer(reply, &host, DNS_RRTYPE_AAAA, DNS_RRCLASS_IN, cache_flush, (NETIF_TO_HOST(netif))->dns_ttl, (const u8_t *) netif_ip6_addr(netif, addrindex), sizeof(ip6_addr_p_t), NULL);
 }
 
-/**
- * Perform lexicographical comparison to define the lexicographical order of the
- * records.
- *
- * @param pkt_a   first packet (needed for rr data)
- * @param pkt_b   second packet (needed for rr data)
- * @param ans_a   first rr
- * @param ans_b   second rr
- * @param result  pointer to save result in ->  MDNS_LEXICOGRAPHICAL_EQUAL,
- *                MDNS_LEXICOGRAPHICAL_LATER or MDNS_LEXICOGRAPHICAL_EARLIER.
- * @return err_t  ERR_OK if result is good, ERR_VAL if domain decompression failed.
- */
+/** Write a x.y.z.ip6.arpa -> hostname.local PTR RR to outpacket */
 static err_t
-mdns_lexicographical_comparison(struct mdns_packet *pkt_a, struct mdns_packet *pkt_b,
-                                struct mdns_answer *ans_a, struct mdns_answer *ans_b,
-                                u8_t *result)
+mdns_add_hostv6_ptr_answer(struct mdns_outpacket *reply, u16_t cache_flush, struct netif *netif, int addrindex)
 {
-  int len, i;
-  u8_t a_rd, b_rd;
-  u16_t res;
-  struct mdns_domain domain_a, domain_b;
-
-  /* Compare classes */
-  if (ans_a->info.klass != ans_b->info.klass) {
-    if (ans_a->info.klass > ans_b->info.klass) {
-      *result = MDNS_LEXICOGRAPHICAL_LATER;
-      return ERR_OK;
-    }
-    else {
-      *result = MDNS_LEXICOGRAPHICAL_EARLIER;
-      return ERR_OK;
-    }
-  }
-  /* Compare types */
-  if (ans_a->info.type != ans_b->info.type) {
-    if (ans_a->info.type > ans_b->info.type) {
-      *result = MDNS_LEXICOGRAPHICAL_LATER;
-      return ERR_OK;
-    }
-    else {
-      *result = MDNS_LEXICOGRAPHICAL_EARLIER;
-      return ERR_OK;
-    }
-  }
-
-  /* Compare rr data section
-   * Name compression:
-   * We have 4 different RR types in our authoritative section (if IPv4 and IPv6 is enabled): A,
-   * AAAA, SRV and TXT. Only one of the 4 can be subject to name compression in the rdata, the SRV
-   * record. As stated in the RFC6762 section 8.2: the names must be uncompressed before comparison.
-   * We only need to take the SRV record into account. It's the only one that in a comparison with
-   * compressed data could lead to rdata comparison. Others will already stop after the type
-   * comparison. So if we get passed the class and type comparison we need to check if the
-   * comparison contains an SRV record. If so, we need a different comparison method.
-   */
-
-  /* The answers do not contain an SRV record */
-  if (ans_a->info.type != DNS_RRTYPE_SRV && ans_b->info.type != DNS_RRTYPE_SRV) {
-    len = LWIP_MIN(ans_a->rd_length, ans_b->rd_length);
-    for (i = 0; i < len; i++) {
-      a_rd = pbuf_get_at(pkt_a->pbuf, (u16_t)(ans_a->rd_offset + i));
-      b_rd = pbuf_get_at(pkt_b->pbuf, (u16_t)(ans_b->rd_offset + i));
-      if (a_rd != b_rd) {
-        if (a_rd > b_rd) {
-          *result = MDNS_LEXICOGRAPHICAL_LATER;
-          return ERR_OK;
-        }
-        else {
-          *result = MDNS_LEXICOGRAPHICAL_EARLIER;
-          return ERR_OK;
-        }
-      }
-    }
-    /* If the overlapping data is the same, compare the length */
-    if (ans_a->rd_length != ans_b->rd_length) {
-      if (ans_a->rd_length > ans_b->rd_length) {
-        *result = MDNS_LEXICOGRAPHICAL_LATER;
-        return ERR_OK;
-      }
-      else {
-        *result = MDNS_LEXICOGRAPHICAL_EARLIER;
-        return ERR_OK;
-      }
-    }
-  }
-  /* Because the types are guaranteed equal here, we know they are both SRV RRs */
-  else {
-    /* We will first compare the priority, weight and port */
-    for (i = 0; i < 6; i++) {
-      a_rd = pbuf_get_at(pkt_a->pbuf, (u16_t)(ans_a->rd_offset + i));
-      b_rd = pbuf_get_at(pkt_b->pbuf, (u16_t)(ans_b->rd_offset + i));
-      if (a_rd != b_rd) {
-        if (a_rd > b_rd) {
-          *result = MDNS_LEXICOGRAPHICAL_LATER;
-          return ERR_OK;
-        }
-        else {
-          *result = MDNS_LEXICOGRAPHICAL_EARLIER;
-          return ERR_OK;
-        }
-      }
-    }
-    /* Decompress names if compressed and save in domain_a or domain_b */
-    res = mdns_readname(pkt_a->pbuf, ans_a->rd_offset + 6, &domain_a);
-    if (res == MDNS_READNAME_ERROR) {
-      return ERR_VAL;
-    }
-    res = mdns_readname(pkt_b->pbuf, ans_b->rd_offset + 6, &domain_b);
-    if (res == MDNS_READNAME_ERROR) {
-      return ERR_VAL;
-    }
-    LWIP_DEBUGF(MDNS_DEBUG, ("mDNS: domain a: len = %d, name = ", domain_a.name[0]));
-    mdns_domain_debug_print(&domain_a);
-    LWIP_DEBUGF(MDNS_DEBUG, ("mDNS: domain b: len = %d, name = ", domain_b.name[0]));
-    mdns_domain_debug_print(&domain_b);
-    /* Compare names pairwise */
-    len = LWIP_MIN(domain_a.length, domain_b.length);
-    for (i = 0; i < len; i++) {
-      if (domain_a.name[i] != domain_b.name[i]) {
-        if (domain_a.name[i] > domain_b.name[i]) {
-          *result = MDNS_LEXICOGRAPHICAL_LATER;
-          return ERR_OK;
-        }
-        else {
-          *result = MDNS_LEXICOGRAPHICAL_EARLIER;
-          return ERR_OK;
-        }
-      }
-    }
-    /* If the overlapping data is the same, compare the length */
-    if (domain_a.length != domain_b.length) {
-      if (domain_a.length > domain_b.length) {
-        *result = MDNS_LEXICOGRAPHICAL_LATER;
-        return ERR_OK;
-      }
-      else {
-        *result = MDNS_LEXICOGRAPHICAL_EARLIER;
-        return ERR_OK;
-      }
-    }
-  }
-  /* They are exactly the same */
-  *result = MDNS_LEXICOGRAPHICAL_EQUAL;
-  return ERR_OK;
+  struct mdns_domain host, revhost;
+  mdns_build_host_domain(&host, NETIF_TO_HOST(netif));
+  mdns_build_reverse_v6_domain(&revhost, netif_ip6_addr(netif, addrindex));
+  LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Responding with v6 PTR record\n"));
+  return mdns_add_answer(reply, &revhost, DNS_RRTYPE_PTR, DNS_RRCLASS_IN, cache_flush, (NETIF_TO_HOST(netif))->dns_ttl, NULL, 0, &host);
 }
+#endif
 
-/**
- * Clear authoritative answer list
- *
- * @param a_list  answer list to clear
- */
-static void
-mdns_init_answer_list(struct mdns_answer_list *a_list)
+/** Write an all-services -> servicetype PTR RR to outpacket */
+static err_t
+mdns_add_servicetype_ptr_answer(struct mdns_outpacket *reply, struct mdns_service *service)
 {
-  int i;
-  a_list->size = 0;
-  for(i = 0; i < MDNS_PROBE_TIEBREAK_MAX_ANSWERS; i++) {
-    a_list->offset[i] = 0;
-  }
+  struct mdns_domain service_type, service_dnssd;
+  mdns_build_service_domain(&service_type, service, 0);
+  mdns_build_dnssd_domain(&service_dnssd);
+  LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Responding with service type PTR record\n"));
+  return mdns_add_answer(reply, &service_dnssd, DNS_RRTYPE_PTR, DNS_RRCLASS_IN, 0, service->dns_ttl, NULL, 0, &service_type);
 }
 
-/**
- * Pushes the offset of the answer on a lexicographically later sorted list.
- * We use a simple insertion sort because most of the time we are only sorting
- * two items. The answers are sorted from the smallest to the largest.
- *
- * @param a_list      Answer list to which to add the answer
- * @param pkt         Packet where answer originated
- * @param new_offset  Offset of the new answer in the packet
- * @param new_answer  The new answer
- * @return err_t ERR_MEM if list is full
- */
+/** Write a servicetype -> servicename PTR RR to outpacket */
 static err_t
-mdns_push_answer_to_sorted_list(struct mdns_answer_list *a_list,
-                                struct mdns_packet *pkt,
-                                u16_t new_offset,
-                                struct mdns_answer *new_answer)
+mdns_add_servicename_ptr_answer(struct mdns_outpacket *reply, struct mdns_service *service)
 {
-  int i;
-  struct mdns_answer a;
-  int pos = a_list->size;
-  err_t res = ERR_OK;
-  u8_t result;
-  u16_t num_left = pkt->authoritative;
-  u16_t parse_offset = pkt->parse_offset;
-
-  /* Check size */
-  if ((a_list->size + 1) >= MDNS_PROBE_TIEBREAK_MAX_ANSWERS) {
-    return ERR_MEM;
-  }
-  /* Search location and open a location */
-  for (i = 0; i < a_list->size; i++) {
-    /* Read answers already in the list from pkt */
-    pkt->parse_offset = a_list->offset[i];
-    res = mdns_read_answer(pkt, &a, &num_left);
-    if (res != ERR_OK) {
-      LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Failed to parse answer, skipping probe packet\n"));
-      return res;
-    }
-    /* Compare them with the new answer to find it's place */
-    res = mdns_lexicographical_comparison(pkt, pkt, &a, new_answer, &result);
-    if (res != ERR_OK) {
-      LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Failed to compare answers, skipping probe packet\n"));
-      return res;
-    }
-    if (result == MDNS_LEXICOGRAPHICAL_LATER) {
-      int j;
-      pos = i;
-      for (j = (a_list->size + 1); j>i; j--) {
-        a_list->offset[j] = a_list->offset[j-1];
-      }
-      break;
-    }
-  }
-  /* Insert new value */
-  a_list->offset[pos] = new_offset;
-  a_list->size++;
-  /* Reset parse offset for further evaluation */
-  pkt->parse_offset = parse_offset;
-  return res;
+  struct mdns_domain service_type, service_instance;
+  mdns_build_service_domain(&service_type, service, 0);
+  mdns_build_service_domain(&service_instance, service, 1);
+  LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Responding with service name PTR record\n"));
+  return mdns_add_answer(reply, &service_type, DNS_RRTYPE_PTR, DNS_RRCLASS_IN, 0, service->dns_ttl, NULL, 0, &service_instance);
 }
 
-/**
- * Check if the given answer answers the give question
- *
- * @param q     query to find answer for
- * @param a     answer to given query
- * @return      1 it a answers q, 0 if not
- */
-static u8_t
-mdns_is_answer_to_question(struct mdns_question *q, struct mdns_answer *a)
+/** Write a SRV RR to outpacket */
+static err_t
+mdns_add_srv_answer(struct mdns_outpacket *reply, u16_t cache_flush, struct mdns_host *mdns, struct mdns_service *service)
 {
-  if (q->info.type == DNS_RRTYPE_ANY || q->info.type == a->info.type) {
-    /* The types match or question type is any */
-    if (mdns_domain_eq(&q->info.domain, &a->info.domain)) {
-      return 1;
-    }
-  }
-  return 0;
+  struct mdns_domain service_instance, srvhost;
+  u16_t srvdata[3];
+  mdns_build_service_domain(&service_instance, service, 1);
+  mdns_build_host_domain(&srvhost, mdns);
+  if (reply->legacy_query) {
+    /* RFC 6762 section 18.14:
+     * In legacy unicast responses generated to answer legacy queries,
+     * name compression MUST NOT be performed on SRV records.
+     */
+    srvhost.skip_compression = 1;
+  }
+  srvdata[0] = lwip_htons(SRV_PRIORITY);
+  srvdata[1] = lwip_htons(SRV_WEIGHT);
+  srvdata[2] = lwip_htons(service->port);
+  LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Responding with SRV record\n"));
+  return mdns_add_answer(reply, &service_instance, DNS_RRTYPE_SRV, DNS_RRCLASS_IN, cache_flush, service->dns_ttl,
+                         (const u8_t *) &srvdata, sizeof(srvdata), &srvhost);
 }
 
-/**
- * Converts the output packet to the input packet format for probe tiebreaking
- *
- * @param inpkt   destination packet for conversion
- * @param outpkt  source packet for conversion
- */
-static void
-mdns_convert_out_to_in_pkt(struct mdns_packet *inpkt, struct mdns_outpacket *outpkt)
+/** Write a TXT RR to outpacket */
+static err_t
+mdns_add_txt_answer(struct mdns_outpacket *reply, u16_t cache_flush, struct mdns_service *service)
 {
-  inpkt->pbuf = outpkt->pbuf;
-  inpkt->parse_offset = SIZEOF_DNS_HDR;
-
-  inpkt->questions = inpkt->questions_left = outpkt->questions;
-  inpkt->answers = inpkt->answers_left = outpkt->answers;
-  inpkt->authoritative = inpkt->authoritative_left = outpkt->authoritative;
-  inpkt->additional = inpkt->additional_left = outpkt->additional;
+  struct mdns_domain service_instance;
+  mdns_build_service_domain(&service_instance, service, 1);
+  mdns_prepare_txtdata(service);
+  LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Responding with TXT record\n"));
+  return mdns_add_answer(reply, &service_instance, DNS_RRTYPE_TXT, DNS_RRCLASS_IN, cache_flush, service->dns_ttl,
+                         (u8_t *) &service->txtdata.name, service->txtdata.length, NULL);
 }
 
 /**
- * Debug print to print the answer part that is lexicographically compared
- *
- * @param pkt Packet where answer originated
- * @param a   The answer to print
+ * Setup outpacket as a reply to the incoming packet
  */
 static void
-mdns_debug_print_answer(struct mdns_packet *pkt, struct mdns_answer *a)
+mdns_init_outpacket(struct mdns_outpacket *out, struct mdns_packet *in)
 {
-#ifdef LWIP_DEBUG
-  /* Arbitratry chose for 200 -> don't want to see more then that. It's only
-   * for debug so not that important. */
-  char string[200];
-  int i;
-  int pos;
+  memset(out, 0, sizeof(struct mdns_outpacket));
+  out->cache_flush = 1;
+  out->netif = in->netif;
+
+  /* Copy source IP/port to use when responding unicast, or to choose
+   * which pcb to use for multicast (IPv4/IPv6)
+   */
+  SMEMCPY(&out->dest_addr, &in->source_addr, sizeof(ip_addr_t));
+  out->dest_port = in->source_port;
+
+  if (in->source_port != LWIP_IANA_PORT_MDNS) {
+    out->unicast_reply = 1;
+    out->cache_flush = 0;
+    if (in->questions == 1) {
+      out->legacy_query = 1;
+      out->tx_id = in->tx_id;
+    }
+  }
 
-  pos = snprintf(string, sizeof(string), "Type = %2d, class = %1d, rdata = ", a->info.type, a->info.klass);
-  for (i = 0; ((i < a->rd_length) && ((pos + 4*i) < 195)) ; i++) {
-    snprintf(&string[pos + 4*i], 5, "%3d ", (u8_t)pbuf_get_at(pkt->pbuf, (u16_t)(a->rd_offset + i)));
+  if (in->recv_unicast) {
+    out->unicast_reply = 1;
   }
-  LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: %s\n", string));
-#else
-  LWIP_UNUSED_ARG(pkt);
-  LWIP_UNUSED_ARG(a);
-#endif
 }
 
 /**
- * Perform probe tiebreaking according to RFC6762 section 8.2
+ * Send chosen answers as a reply
  *
- * @param netif network interface of incoming packet
- * @param pkt   incoming packet
+ * Add all selected answers (first write will allocate pbuf)
+ * Add additional answers based on the selected answers
+ * Send the packet
  */
-static void
-mdns_handle_probe_tiebreaking(struct netif *netif, struct mdns_packet *pkt)
+static err_t
+mdns_send_outpacket(struct mdns_outpacket *outpkt, u8_t flags)
 {
-  struct mdns_host *mdns = NETIF_TO_HOST(netif);
-  struct mdns_question pkt_q, my_q, q_dummy;
-  struct mdns_answer pkt_a, my_a;
-  struct mdns_outmsg myprobe_msg;
-  struct mdns_outpacket myprobe_outpkt;
-  struct mdns_packet myprobe_inpkt;
-  struct mdns_answer_list pkt_a_list, my_a_list;
-  u16_t save_parse_offset;
-  u16_t pkt_parse_offset, myprobe_parse_offset, myprobe_questions_left;
-  err_t res;
-  u8_t match, result;
-  int min, i;
+  struct mdns_service *service;
+  err_t res = ERR_ARG;
+  int i;
+  struct mdns_host *mdns = NETIF_TO_HOST(outpkt->netif);
+  u16_t answers = 0;
 
-  /* Generate probe packet to perform comparison.
-   * This is a lot of calculation at this stage without any pre calculation
-   * needed. It should be evaluated if this is the best approach.
-   */
-  mdns_define_probe_rrs_to_send(netif, &myprobe_msg);
-  memset(&myprobe_outpkt, 0, sizeof(myprobe_outpkt));
-  memset(&myprobe_inpkt, 0, sizeof(myprobe_inpkt));
-  res = mdns_create_outpacket(netif, &myprobe_msg, &myprobe_outpkt);
-  if (res != ERR_OK) {
-    goto cleanup;
+  /* Write answers to host questions */
+#if LWIP_IPV4
+  if (outpkt->host_replies & REPLY_HOST_A) {
+    res = mdns_add_a_answer(outpkt, outpkt->cache_flush, outpkt->netif);
+    if (res != ERR_OK) {
+      goto cleanup;
+    }
+    answers++;
   }
-  mdns_convert_out_to_in_pkt(&myprobe_inpkt, &myprobe_outpkt);
-
-  /* Loop over all our probes to search for matches */
-  while (myprobe_inpkt.questions_left) {
-    /* Read one of our probe questions to check if pkt contains same question */
-    res = mdns_read_question(&myprobe_inpkt, &my_q);
+  if (outpkt->host_replies & REPLY_HOST_PTR_V4) {
+    res = mdns_add_hostv4_ptr_answer(outpkt, outpkt->cache_flush, outpkt->netif);
     if (res != ERR_OK) {
-      LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Failed to parse question, skipping probe packet\n"));
       goto cleanup;
     }
-    /* Remember parse offsets so we can restart the search for the next question */
-    pkt_parse_offset = pkt->parse_offset;
-    myprobe_parse_offset = myprobe_inpkt.parse_offset;
-    /* Remember questions left of our probe packet */
-    myprobe_questions_left = myprobe_inpkt.questions_left;
-    /* Reset match flag */
-    match = 0;
-    /* Search for a matching probe in the incomming packet */
-    while (pkt->questions_left) {
-      /* Read probe questions one by one */
-      res = mdns_read_question(pkt, &pkt_q);
+    answers++;
+  }
+#endif
+#if LWIP_IPV6
+  if (outpkt->host_replies & REPLY_HOST_AAAA) {
+    int addrindex;
+    for (addrindex = 0; addrindex < LWIP_IPV6_NUM_ADDRESSES; addrindex++) {
+      if (ip6_addr_isvalid(netif_ip6_addr_state(outpkt->netif, addrindex))) {
+        res = mdns_add_aaaa_answer(outpkt, outpkt->cache_flush, outpkt->netif, addrindex);
+        if (res != ERR_OK) {
+          goto cleanup;
+        }
+        answers++;
+      }
+    }
+  }
+  if (outpkt->host_replies & REPLY_HOST_PTR_V6) {
+    u8_t rev_addrs = outpkt->host_reverse_v6_replies;
+    int addrindex = 0;
+    while (rev_addrs) {
+      if (rev_addrs & 1) {
+        res = mdns_add_hostv6_ptr_answer(outpkt, outpkt->cache_flush, outpkt->netif, addrindex);
+        if (res != ERR_OK) {
+          goto cleanup;
+        }
+        answers++;
+      }
+      addrindex++;
+      rev_addrs >>= 1;
+    }
+  }
+#endif
+
+  /* Write answers to service questions */
+  for (i = 0; i < MDNS_MAX_SERVICES; i++) {
+    service = mdns->services[i];
+    if (!service) {
+      continue;
+    }
+
+    if (outpkt->serv_replies[i] & REPLY_SERVICE_TYPE_PTR) {
+      res = mdns_add_servicetype_ptr_answer(outpkt, service);
       if (res != ERR_OK) {
-        LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Failed to parse question, skipping probe packet\n"));
         goto cleanup;
       }
-      /* Stop evaluating if the class is not supported */
-      if (pkt_q.info.klass != DNS_RRCLASS_IN && pkt_q.info.klass != DNS_RRCLASS_ANY) {
-        LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: question class not supported, skipping probe packet\n"));
+      answers++;
+    }
+
+    if (outpkt->serv_replies[i] & REPLY_SERVICE_NAME_PTR) {
+      res = mdns_add_servicename_ptr_answer(outpkt, service);
+      if (res != ERR_OK) {
         goto cleanup;
       }
-      /* We probe for type any, so we do not have to compare types */
-      /* Compare if we are probing for the same domain */
-      if (mdns_domain_eq(&pkt_q.info.domain, &my_q.info.domain)) {
-        LWIP_DEBUGF(MDNS_DEBUG, ("mDNS: We are probing for the same rr\n"));
-        match = 1;
-        break;
+      answers++;
+    }
+
+    if (outpkt->serv_replies[i] & REPLY_SERVICE_SRV) {
+      res = mdns_add_srv_answer(outpkt, outpkt->cache_flush, mdns, service);
+      if (res != ERR_OK) {
+        goto cleanup;
       }
+      answers++;
     }
-    /* When matched start evaluating the authoritative section */
-    if (match) {
-      /* Ignore all following questions to be able to get to the authoritative answers */
-      while (pkt->questions_left) {
-        res = mdns_read_question(pkt, &q_dummy);
+
+    if (outpkt->serv_replies[i] & REPLY_SERVICE_TXT) {
+      res = mdns_add_txt_answer(outpkt, outpkt->cache_flush, service);
+      if (res != ERR_OK) {
+        goto cleanup;
+      }
+      answers++;
+    }
+  }
+
+  /* if this is a response, the data above is anwers, else this is a probe and the answers above goes into auth section */
+  if (flags & DNS_FLAG1_RESPONSE) {
+    outpkt->answers += answers;
+  } else {
+    outpkt->authoritative += answers;
+  }
+
+  /* All answers written, add additional RRs */
+  for (i = 0; i < MDNS_MAX_SERVICES; i++) {
+    service = mdns->services[i];
+    if (!service) {
+      continue;
+    }
+
+    if (outpkt->serv_replies[i] & REPLY_SERVICE_NAME_PTR) {
+      /* Our service instance requested, include SRV & TXT
+       * if they are already not requested. */
+      if (!(outpkt->serv_replies[i] & REPLY_SERVICE_SRV)) {
+        res = mdns_add_srv_answer(outpkt, outpkt->cache_flush, mdns, service);
         if (res != ERR_OK) {
-          LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Failed to parse question, skipping probe packet\n"));
           goto cleanup;
         }
+        outpkt->additional++;
       }
-      while (myprobe_inpkt.questions_left) {
-        res = mdns_read_question(&myprobe_inpkt, &q_dummy);
+
+      if (!(outpkt->serv_replies[i] & REPLY_SERVICE_TXT)) {
+        res = mdns_add_txt_answer(outpkt, outpkt->cache_flush, service);
         if (res != ERR_OK) {
-          LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Failed to parse question, skipping probe packet\n"));
           goto cleanup;
         }
+        outpkt->additional++;
       }
+    }
 
-      /* Extract and sort our authoritative answers that answer our question */
-      mdns_init_answer_list(&my_a_list);
-      while(myprobe_inpkt.authoritative_left) {
-        save_parse_offset = myprobe_inpkt.parse_offset;
-        res = mdns_read_answer(&myprobe_inpkt, &my_a, &myprobe_inpkt.authoritative_left);
-        if (res != ERR_OK) {
-          LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Failed to parse answer, skipping probe packet\n"));
-          goto cleanup;
-        }
-        if (mdns_is_answer_to_question(&my_q, &my_a)) {
-          /* Add to list */
-          res = mdns_push_answer_to_sorted_list(&my_a_list, &myprobe_inpkt, save_parse_offset, &my_a);
-          if (res != ERR_OK) {
-            LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Failed to add answer, skipping probe packet\n"));
-            goto cleanup;
+    /* If service instance, SRV, record or an IP address is requested,
+     * supply all addresses for the host
+     */
+    if ((outpkt->serv_replies[i] & (REPLY_SERVICE_NAME_PTR | REPLY_SERVICE_SRV)) ||
+        (outpkt->host_replies & (REPLY_HOST_A | REPLY_HOST_AAAA))) {
+#if LWIP_IPV6
+      if (!(outpkt->host_replies & REPLY_HOST_AAAA)) {
+        int addrindex;
+        for (addrindex = 0; addrindex < LWIP_IPV6_NUM_ADDRESSES; addrindex++) {
+          if (ip6_addr_isvalid(netif_ip6_addr_state(outpkt->netif, addrindex))) {
+            res = mdns_add_aaaa_answer(outpkt, outpkt->cache_flush, outpkt->netif, addrindex);
+            if (res != ERR_OK) {
+              goto cleanup;
+            }
+            outpkt->additional++;
           }
         }
       }
-      /* Extract and sort the packets authoritative answers that answer the
-         question */
-      mdns_init_answer_list(&pkt_a_list);
-      while(pkt->authoritative_left) {
-        save_parse_offset = pkt->parse_offset;
-        res = mdns_read_answer(pkt, &pkt_a, &pkt->authoritative_left);
+#endif
+#if LWIP_IPV4
+      if (!(outpkt->host_replies & REPLY_HOST_A) &&
+          !ip4_addr_isany_val(*netif_ip4_addr(outpkt->netif))) {
+        res = mdns_add_a_answer(outpkt, outpkt->cache_flush, outpkt->netif);
         if (res != ERR_OK) {
-          LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Failed to parse answer, skipping probe packet\n"));
           goto cleanup;
         }
-        if (mdns_is_answer_to_question(&my_q, &pkt_a)) {
-          /* Add to list */
-          res = mdns_push_answer_to_sorted_list(&pkt_a_list, pkt, save_parse_offset, &pkt_a);
-          if (res != ERR_OK) {
-            LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Failed to add answer, skipping probe packet\n"));
-            goto cleanup;
-          }
-        }
+        outpkt->additional++;
       }
+#endif
+    }
+  }
 
-      /* Reinitiate authoritative left */
-      myprobe_inpkt.authoritative_left = myprobe_inpkt.authoritative;
-      pkt->authoritative_left = pkt->authoritative;
+  if (outpkt->pbuf) {
+    const ip_addr_t *mcast_destaddr;
+    struct dns_hdr hdr;
 
-      /* Compare pairwise.
-       *  - lexicographically later? -> we win, ignore the packet.
-       *  - lexicographically earlier? -> we loose, wait one second and retry.
-       *  - lexicographically equal? -> no conflict, check other probes.
-       */
-      min = LWIP_MIN(my_a_list.size, pkt_a_list.size);
-      for (i = 0; i < min; i++) {
-        /* Get answer of our own list */
-        myprobe_inpkt.parse_offset = my_a_list.offset[i];
-        res = mdns_read_answer(&myprobe_inpkt, &my_a, &myprobe_inpkt.authoritative_left);
-        if (res != ERR_OK) {
-          LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Failed to parse answer, skipping probe packet\n"));
-          goto cleanup;
-        }
-        /* Get answer of the packets list  */
-        pkt->parse_offset = pkt_a_list.offset[i];
-        res = mdns_read_answer(pkt, &pkt_a, &pkt->authoritative_left);
-        if (res != ERR_OK) {
-          LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Failed to parse answer, skipping probe packet\n"));
-          goto cleanup;
-        }
-        /* Print both answers for debugging */
-        mdns_debug_print_answer(pkt, &pkt_a);
-        mdns_debug_print_answer(&myprobe_inpkt, &my_a);
-        /* Define the winner */
-        res = mdns_lexicographical_comparison(&myprobe_inpkt, pkt, &my_a, &pkt_a, &result);
-        if (res != ERR_OK) {
-          LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Failed to compare answers, skipping probe packet\n"));
-          goto cleanup;
-        }
-        if (result == MDNS_LEXICOGRAPHICAL_LATER) {
-          LWIP_DEBUGF(MDNS_DEBUG, ("mDNS: we win, we are lexicographically later\n"));
-          goto cleanup;
-        }
-        else if (result == MDNS_LEXICOGRAPHICAL_EARLIER) {
-          LWIP_DEBUGF(MDNS_DEBUG, ("mDNS: we loose, we are lexicographically earlier. 1s timeout started\n"));
-          sys_untimeout(mdns_probe_and_announce, netif);
-          mdns->state = MDNS_STATE_PROBE_WAIT;
-          mdns->sent_num = 0;
-          sys_timeout(MDNS_PROBE_TIEBREAK_CONFLICT_DELAY_MS, mdns_probe_and_announce, netif);
-          goto cleanup;
-        }
-        else {
-          LWIP_DEBUGF(MDNS_DEBUG, ("mDNS: lexicographically equal, so no conclusion\n"));
-        }
-      }
-      /* All compared RR were equal, otherwise we would not be here
-       * -> check if one of both have more answers to the question */
-      if (my_a_list.size != pkt_a_list.size) {
-        if (my_a_list.size > pkt_a_list.size) {
-          LWIP_DEBUGF(MDNS_DEBUG, ("mDNS: we win, we have more records answering the probe\n"));
-          goto cleanup;
-        }
-        else {
-          LWIP_DEBUGF(MDNS_DEBUG, ("mDNS: we loose, we have less records. 1s timeout started\n"));
-          sys_untimeout(mdns_probe_and_announce, netif);
-          mdns->state = MDNS_STATE_PROBE_WAIT;
-          mdns->sent_num = 0;
-          sys_timeout(MDNS_PROBE_TIEBREAK_CONFLICT_DELAY_MS, mdns_probe_and_announce, netif);
-          goto cleanup;
-        }
-      }
-      else {
-        /* There is no conflict on this probe, both devices have the same data
-         * in the authoritative section. We should still check the other probes
-         * for conflicts. */
-        LWIP_DEBUGF(MDNS_DEBUG, ("mDNS: no conflict, all records answering the probe are equal\n"));
-      }
+    /* Write header */
+    memset(&hdr, 0, sizeof(hdr));
+    hdr.flags1 = flags;
+    hdr.numquestions = lwip_htons(outpkt->questions);
+    hdr.numanswers = lwip_htons(outpkt->answers);
+    hdr.numauthrr = lwip_htons(outpkt->authoritative);
+    hdr.numextrarr = lwip_htons(outpkt->additional);
+    hdr.id = lwip_htons(outpkt->tx_id);
+    pbuf_take(outpkt->pbuf, &hdr, sizeof(hdr));
+
+    /* Shrink packet */
+    pbuf_realloc(outpkt->pbuf, outpkt->write_offset);
+
+    if (IP_IS_V6_VAL(outpkt->dest_addr)) {
+#if LWIP_IPV6
+      mcast_destaddr = &v6group;
+#endif
+    } else {
+#if LWIP_IPV4
+      mcast_destaddr = &v4group;
+#endif
+    }
+    /* Send created packet */
+    LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Sending packet, len=%d, unicast=%d\n", outpkt->write_offset, outpkt->unicast_reply));
+    if (outpkt->unicast_reply) {
+      res = udp_sendto_if(mdns_pcb, outpkt->pbuf, &outpkt->dest_addr, outpkt->dest_port, outpkt->netif);
+    } else {
+      res = udp_sendto_if(mdns_pcb, outpkt->pbuf, mcast_destaddr, LWIP_IANA_PORT_MDNS, outpkt->netif);
     }
-    /* Evaluate other probes if any. */
-    /* Reinitiate parse offsets */
-    pkt->parse_offset = pkt_parse_offset;
-    myprobe_inpkt.parse_offset = myprobe_parse_offset;
-    /* Reinitiate questions_left and authoritative_left */
-    pkt->questions_left = pkt->questions;
-    pkt->authoritative_left = pkt->authoritative;
-    myprobe_inpkt.questions_left = myprobe_questions_left;
-    myprobe_inpkt.authoritative_left = myprobe_inpkt.authoritative;
   }
 
 cleanup:
-  if (myprobe_inpkt.pbuf != NULL) {
-    pbuf_free(myprobe_inpkt.pbuf);
+  if (outpkt->pbuf) {
+    pbuf_free(outpkt->pbuf);
+    outpkt->pbuf = NULL;
   }
+  return res;
 }
 
 /**
- * Check the incomming packet and parse all questions
- *
- * @param netif network interface of incoming packet
- * @param pkt   incoming packet
- * @param reply outgoing message
- * @return err_t
+ * Send unsolicited answer containing all our known data
+ * @param netif The network interface to send on
+ * @param destination The target address to send to (usually multicast address)
  */
-static err_t
-mdns_parse_pkt_questions(struct netif *netif, struct mdns_packet *pkt,
-                         struct mdns_outmsg *reply)
+static void
+mdns_announce(struct netif *netif, const ip_addr_t *destination)
 {
+  struct mdns_outpacket announce;
+  int i;
   struct mdns_host *mdns = NETIF_TO_HOST(netif);
+
+  memset(&announce, 0, sizeof(announce));
+  announce.netif = netif;
+  announce.cache_flush = 1;
+#if LWIP_IPV4
+  if (!ip4_addr_isany_val(*netif_ip4_addr(netif))) {
+    announce.host_replies = REPLY_HOST_A | REPLY_HOST_PTR_V4;
+  }
+#endif
+#if LWIP_IPV6
+  for (i = 0; i < LWIP_IPV6_NUM_ADDRESSES; i++) {
+    if (ip6_addr_isvalid(netif_ip6_addr_state(netif, i))) {
+      announce.host_replies |= REPLY_HOST_AAAA | REPLY_HOST_PTR_V6;
+      announce.host_reverse_v6_replies |= (1 << i);
+    }
+  }
+#endif
+
+  for (i = 0; i < MDNS_MAX_SERVICES; i++) {
+    struct mdns_service *serv = mdns->services[i];
+    if (serv) {
+      announce.serv_replies[i] = REPLY_SERVICE_TYPE_PTR | REPLY_SERVICE_NAME_PTR |
+                                 REPLY_SERVICE_SRV | REPLY_SERVICE_TXT;
+    }
+  }
+
+  announce.dest_port = LWIP_IANA_PORT_MDNS;
+  SMEMCPY(&announce.dest_addr, destination, sizeof(announce.dest_addr));
+  mdns_send_outpacket(&announce, DNS_FLAG1_RESPONSE | DNS_FLAG1_AUTHORATIVE);
+}
+
+/**
+ * Handle question MDNS packet
+ * 1. Parse all questions and set bits what answers to send
+ * 2. Clear pending answers if known answers are supplied
+ * 3. Put chosen answers in new packet and send as reply
+ */
+static void
+mdns_handle_question(struct mdns_packet *pkt)
+{
   struct mdns_service *service;
+  struct mdns_outpacket reply;
+  int replies = 0;
   int i;
   err_t res;
+  struct mdns_host *mdns = NETIF_TO_HOST(pkt->netif);
+
+  if (mdns->probing_state != MDNS_PROBING_COMPLETE) {
+    /* Don't answer questions until we've verified our domains via probing */
+    /* @todo we should check incoming questions during probing for tiebreaking */
+    return;
+  }
+
+  mdns_init_outpacket(&reply, pkt);
 
   while (pkt->questions_left) {
     struct mdns_question q;
@@ -1068,7 +1582,7 @@ mdns_parse_pkt_questions(struct netif *netif, struct mdns_packet *pkt,
     res = mdns_read_question(pkt, &q);
     if (res != ERR_OK) {
       LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Failed to parse question, skipping query packet\n"));
-      return res;
+      return;
     }
 
     LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Query for domain "));
@@ -1076,51 +1590,42 @@ mdns_parse_pkt_questions(struct netif *netif, struct mdns_packet *pkt,
     LWIP_DEBUGF(MDNS_DEBUG, (" type %d class %d\n", q.info.type, q.info.klass));
 
     if (q.unicast) {
-      /* Reply unicast if it is requested in the question */
-      reply->unicast_reply_requested = 1;
+      /* Reply unicast if any question is unicast */
+      reply.unicast_reply = 1;
     }
 
-    reply->host_replies |= check_host(netif, &q.info, &reply->host_reverse_v6_replies);
+    reply.host_replies |= check_host(pkt->netif, &q.info, &reply.host_reverse_v6_replies);
+    replies |= reply.host_replies;
 
     for (i = 0; i < MDNS_MAX_SERVICES; i++) {
       service = mdns->services[i];
       if (!service) {
         continue;
       }
-      reply->serv_replies[i] |= check_service(service, &q.info);
+      reply.serv_replies[i] |= check_service(service, &q.info);
+      replies |= reply.serv_replies[i];
     }
-  }
-
-  return ERR_OK;
-}
 
-/**
- * Check the incomming packet and parse all (known) answers
- *
- * @param netif network interface of incoming packet
- * @param pkt   incoming packet
- * @param reply outgoing message
- * @return err_t
- */
-static err_t
-mdns_parse_pkt_known_answers(struct netif *netif, struct mdns_packet *pkt,
-                             struct mdns_outmsg *reply)
-{
-  struct mdns_host *mdns = NETIF_TO_HOST(netif);
-  struct mdns_service *service;
-  int i;
-  err_t res;
+    if (replies && reply.legacy_query) {
+      /* Add question to reply packet (legacy packet only has 1 question) */
+      res = mdns_add_question(&reply, &q.info.domain, q.info.type, q.info.klass, 0);
+      reply.questions = 1;
+      if (res != ERR_OK) {
+        goto cleanup;
+      }
+    }
+  }
 
+  /* Handle known answers */
   while (pkt->answers_left) {
     struct mdns_answer ans;
     u8_t rev_v6;
     int match;
-    u32_t rr_ttl = MDNS_TTL_120;
 
-    res = mdns_read_answer(pkt, &ans, &pkt->answers_left);
+    res = mdns_read_answer(pkt, &ans);
     if (res != ERR_OK) {
       LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Failed to parse answer, skipping query packet\n"));
-      return res;
+      goto cleanup;
     }
 
     LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Known answer for domain "));
@@ -1134,8 +1639,8 @@ mdns_parse_pkt_known_answers(struct netif *netif, struct mdns_packet *pkt,
     }
 
     rev_v6 = 0;
-    match = reply->host_replies & check_host(netif, &ans.info, &rev_v6);
-    if (match && (ans.ttl > (rr_ttl / 2))) {
+    match = reply.host_replies & check_host(pkt->netif, &ans.info, &rev_v6);
+    if (match && (ans.ttl > (mdns->dns_ttl / 2))) {
       /* The RR in the known answer matches an RR we are planning to send,
        * and the TTL is less than half gone.
        * If the payload matches we should not send that answer.
@@ -1150,15 +1655,15 @@ mdns_parse_pkt_known_answers(struct netif *netif, struct mdns_packet *pkt,
 #if LWIP_IPV4
           if (match & REPLY_HOST_PTR_V4) {
             LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Skipping known answer: v4 PTR\n"));
-            reply->host_replies &= ~REPLY_HOST_PTR_V4;
+            reply.host_replies &= ~REPLY_HOST_PTR_V4;
           }
 #endif
 #if LWIP_IPV6
           if (match & REPLY_HOST_PTR_V6) {
             LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Skipping known answer: v6 PTR\n"));
-            reply->host_reverse_v6_replies &= ~rev_v6;
-            if (reply->host_reverse_v6_replies == 0) {
-              reply->host_replies &= ~REPLY_HOST_PTR_V6;
+            reply.host_reverse_v6_replies &= ~rev_v6;
+            if (reply.host_reverse_v6_replies == 0) {
+              reply.host_replies &= ~REPLY_HOST_PTR_V6;
             }
           }
 #endif
@@ -1166,615 +1671,136 @@ mdns_parse_pkt_known_answers(struct netif *netif, struct mdns_packet *pkt,
       } else if (match & REPLY_HOST_A) {
 #if LWIP_IPV4
         if (ans.rd_length == sizeof(ip4_addr_t) &&
-            pbuf_memcmp(pkt->pbuf, ans.rd_offset, netif_ip4_addr(netif), ans.rd_length) == 0) {
-          LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Skipping known answer: A\n"));
-          reply->host_replies &= ~REPLY_HOST_A;
-        }
-#endif
-      } else if (match & REPLY_HOST_AAAA) {
-#if LWIP_IPV6
-        if (ans.rd_length == sizeof(ip6_addr_p_t) &&
-            /* TODO this clears all AAAA responses if first addr is set as known */
-            pbuf_memcmp(pkt->pbuf, ans.rd_offset, netif_ip6_addr(netif, 0), ans.rd_length) == 0) {
-          LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Skipping known answer: AAAA\n"));
-          reply->host_replies &= ~REPLY_HOST_AAAA;
-        }
-#endif
-      }
-    }
-
-    for (i = 0; i < MDNS_MAX_SERVICES; i++) {
-      service = mdns->services[i];
-      if (!service) {
-        continue;
-      }
-      match = reply->serv_replies[i] & check_service(service, &ans.info);
-      if (match & REPLY_SERVICE_TYPE_PTR) {
-        rr_ttl = MDNS_TTL_4500;
-      }
-      if (match && (ans.ttl > (rr_ttl / 2))) {
-        /* The RR in the known answer matches an RR we are planning to send,
-         * and the TTL is less than half gone.
-         * If the payload matches we should not send that answer.
-         */
-        if (ans.info.type == DNS_RRTYPE_PTR) {
-          /* Read domain and compare */
-          struct mdns_domain known_ans, my_ans;
-          u16_t len;
-          len = mdns_readname(pkt->pbuf, ans.rd_offset, &known_ans);
-          if (len != MDNS_READNAME_ERROR) {
-            if (match & REPLY_SERVICE_TYPE_PTR) {
-              res = mdns_build_service_domain(&my_ans, service, 0);
-              if (res == ERR_OK && mdns_domain_eq(&known_ans, &my_ans)) {
-                LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Skipping known answer: service type PTR\n"));
-                reply->serv_replies[i] &= ~REPLY_SERVICE_TYPE_PTR;
-              }
-            }
-            if (match & REPLY_SERVICE_NAME_PTR) {
-              res = mdns_build_service_domain(&my_ans, service, 1);
-              if (res == ERR_OK && mdns_domain_eq(&known_ans, &my_ans)) {
-                LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Skipping known answer: service name PTR\n"));
-                reply->serv_replies[i] &= ~REPLY_SERVICE_NAME_PTR;
-              }
-            }
-          }
-        } else if (match & REPLY_SERVICE_SRV) {
-          /* Read and compare to my SRV record */
-          u16_t field16, len, read_pos;
-          struct mdns_domain known_ans, my_ans;
-          read_pos = ans.rd_offset;
-          do {
-            /* Check priority field */
-            len = pbuf_copy_partial(pkt->pbuf, &field16, sizeof(field16), read_pos);
-            if (len != sizeof(field16) || lwip_ntohs(field16) != SRV_PRIORITY) {
-              break;
-            }
-            read_pos += len;
-            /* Check weight field */
-            len = pbuf_copy_partial(pkt->pbuf, &field16, sizeof(field16), read_pos);
-            if (len != sizeof(field16) || lwip_ntohs(field16) != SRV_WEIGHT) {
-              break;
-            }
-            read_pos += len;
-            /* Check port field */
-            len = pbuf_copy_partial(pkt->pbuf, &field16, sizeof(field16), read_pos);
-            if (len != sizeof(field16) || lwip_ntohs(field16) != service->port) {
-              break;
-            }
-            read_pos += len;
-            /* Check host field */
-            len = mdns_readname(pkt->pbuf, read_pos, &known_ans);
-            mdns_build_host_domain(&my_ans, mdns);
-            if (len == MDNS_READNAME_ERROR || !mdns_domain_eq(&known_ans, &my_ans)) {
-              break;
-            }
-            LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Skipping known answer: SRV\n"));
-            reply->serv_replies[i] &= ~REPLY_SERVICE_SRV;
-          } while (0);
-        } else if (match & REPLY_SERVICE_TXT) {
-          mdns_prepare_txtdata(service);
-          if (service->txtdata.length == ans.rd_length &&
-              pbuf_memcmp(pkt->pbuf, ans.rd_offset, service->txtdata.name, ans.rd_length) == 0) {
-            LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Skipping known answer: TXT\n"));
-            reply->serv_replies[i] &= ~REPLY_SERVICE_TXT;
-          }
-        }
-      }
-    }
-  }
-
-  return ERR_OK;
-}
-
-/**
- * Check the incomming packet and parse all authoritative answers to see if the
- * query is a probe query.
- *
- * @param netif network interface of incoming packet
- * @param pkt   incoming packet
- * @param reply outgoing message
- * @return err_t
- */
-static err_t
-mdns_parse_pkt_authoritative_answers(struct netif *netif, struct mdns_packet *pkt,
-                                     struct mdns_outmsg *reply)
-{
-  struct mdns_host *mdns = NETIF_TO_HOST(netif);
-  struct mdns_service *service;
-  int i;
-  err_t res;
-
-  while (pkt->authoritative_left) {
-    struct mdns_answer ans;
-    u8_t rev_v6;
-    int match;
-
-    res = mdns_read_answer(pkt, &ans, &pkt->authoritative_left);
-    if (res != ERR_OK) {
-      LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Failed to parse answer, skipping query packet\n"));
-      return res;
-    }
-
-    LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Authoritative answer for domain "));
-    mdns_domain_debug_print(&ans.info.domain);
-    LWIP_DEBUGF(MDNS_DEBUG, (" type %d class %d\n", ans.info.type, ans.info.klass));
-
-
-    if (ans.info.type == DNS_RRTYPE_ANY || ans.info.klass == DNS_RRCLASS_ANY) {
-      /* Skip known answers for ANY type & class */
-      continue;
-    }
-
-    rev_v6 = 0;
-    match = reply->host_replies & check_host(netif, &ans.info, &rev_v6);
-    if (match) {
-      reply->probe_query_recv = 1;
-      LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Probe for own host info received\r\n"));
-    }
-
-    for (i = 0; i < MDNS_MAX_SERVICES; i++) {
-      service = mdns->services[i];
-      if (!service) {
-        continue;
-      }
-      match = reply->serv_replies[i] & check_service(service, &ans.info);
-
-      if (match) {
-        reply->probe_query_recv = 1;
-        LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Probe for own service info received\r\n"));
-      }
-    }
-  }
-
-  return ERR_OK;
-}
-
-/**
- * Add / copy message to delaying message buffer.
- *
- * @param dest destination msg struct
- * @param src  source msg struct
- */
-static void
-mdns_add_msg_to_delayed(struct mdns_outmsg *dest, struct mdns_outmsg *src)
-{
-  int i;
-
-  dest->host_questions |= src->host_questions;
-  dest->host_replies |= src->host_replies;
-  dest->host_reverse_v6_replies |= src->host_reverse_v6_replies;
-  for (i = 0; i < MDNS_MAX_SERVICES; i++) {
-    dest->serv_questions[i] |= src->serv_questions[i];
-    dest->serv_replies[i] |= src->serv_replies[i];
-  }
-
-  dest->flags = src->flags;
-  dest->cache_flush = src->cache_flush;
-  dest->tx_id = src->tx_id;
-  dest->legacy_query = src->legacy_query;
-}
-
-/**
- * Handle question MDNS packet
- * - Perform probe tiebreaking when in probing state
- * - Parse all questions and set bits what answers to send
- * - Clear pending answers if known answers are supplied
- * - Define which type of answer is requested
- * - Send out packet or put it on hold until after random time
- *
- * @param pkt   incoming packet
- * @param netif network interface of incoming packet
- */
-static void
-mdns_handle_question(struct mdns_packet *pkt, struct netif *netif)
-{
-  struct mdns_host *mdns = NETIF_TO_HOST(netif);
-  struct mdns_outmsg reply;
-  u8_t rrs_to_send;
-  u8_t shared_answer = 0;
-  u8_t delay_response = 1;
-  u8_t send_unicast = 0;
-  u8_t listen_to_QU_bit = 0;
-  int i;
-  err_t res;
-
-  if ((mdns->state == MDNS_STATE_PROBING) ||
-      (mdns->state == MDNS_STATE_ANNOUNCE_WAIT)) {
-    /* Probe Tiebreaking */
-    /* Check if packet is a probe message */
-    if ((pkt->questions > 0) && (pkt->answers == 0) &&
-        (pkt->authoritative > 0) && (pkt->additional == 0)) {
-      /* This should be a probe message -> call probe handler */
-      mdns_handle_probe_tiebreaking(netif, pkt);
-    }
-  }
-
-  if ((mdns->state != MDNS_STATE_COMPLETE) &&
-      (mdns->state != MDNS_STATE_ANNOUNCING)) {
-    /* Don't answer questions until we've verified our domains via probing */
-    /* @todo we should check incoming questions during probing for tiebreaking */
-    return;
-  }
-
-  memset(&reply, 0, sizeof(struct mdns_outmsg));
-
-  /* Parse question */
-  res = mdns_parse_pkt_questions(netif, pkt, &reply);
-  if (res != ERR_OK) {
-    return;
-  }
-  /* Parse answers -> count as known answers because it's a question */
-  res = mdns_parse_pkt_known_answers(netif, pkt, &reply);
-  if (res != ERR_OK) {
-    return;
-  }
-  /* Parse authoritative answers -> probing */
-  /* If it's a probe query, we need to directly answer via unicast. */
-  res = mdns_parse_pkt_authoritative_answers(netif, pkt, &reply);
-  if (res != ERR_OK) {
-    return;
-  }
-  /* Ignore additional answers -> do not have any need for them at the moment */
-  if(pkt->additional) {
-    LWIP_DEBUGF(MDNS_DEBUG,
-      ("MDNS: Query contains additional answers -> they are discarded \r\n"));
-  }
-
-  /* Any replies on question? */
-  rrs_to_send = reply.host_replies | reply.host_questions;
-  for (i = 0; i < MDNS_MAX_SERVICES; i++) {
-    rrs_to_send |= reply.serv_replies[i] | reply.serv_questions[i];
-  }
-
-  if (!rrs_to_send) {
-    /* This case is most common */
-    LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Nothing to answer\r\n"));
-    return;
-  }
-
-  reply.flags =  DNS_FLAG1_RESPONSE | DNS_FLAG1_AUTHORATIVE;
-
-  /* Detect if it's a legacy querier asking the question
-   * How to detect legacy DNS query? (RFC6762 section 6.7)
-   *  - source port != 5353
-   *  - a legacy query can only contain 1 question
-   */
-  if (pkt->source_port != LWIP_IANA_PORT_MDNS) {
-    if (pkt->questions == 1) {
-      LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: request from legacy querier\r\n"));
-      reply.legacy_query = 1;
-      reply.tx_id = pkt->tx_id;
-      reply.cache_flush = 0;
-    }
-    else {
-      LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: ignore query if (src UDP port != 5353) && (!= legacy query)\r\n"));
-      return;
-    }
-  }
-  else {
-    reply.cache_flush = 1;
-  }
-
-  /* Delaying response. (RFC6762 section 6)
-   * Always delay the response, unicast or multicast, except when:
-   *  - Answering to a single question with a unique answer (not a probe).
-   *  - Answering to a probe query via unicast.
-   *  - Answering to a probe query via multicast if not multicasted within 250ms.
-   *
-   * unique answer? -> not if it includes service type or name ptr's
-   */
-  for (i = 0; i < MDNS_MAX_SERVICES; i++) {
-    shared_answer |= (reply.serv_replies[i] &
-                      (REPLY_SERVICE_TYPE_PTR | REPLY_SERVICE_NAME_PTR));
-  }
-  if (   ((pkt->questions == 1) && (!shared_answer) && !reply.probe_query_recv)
-      || (reply.probe_query_recv && reply.unicast_reply_requested)) {
-    delay_response = 0;
-  }
-#if LWIP_IPV6
-  if (IP_IS_V6_VAL(pkt->source_addr) && reply.probe_query_recv
-      && !reply.unicast_reply_requested && !mdns->ipv6.multicast_probe_timeout) {
-    delay_response = 0;
-  }
-#endif
-#if LWIP_IPV4
-  if (IP_IS_V4_VAL(pkt->source_addr) && reply.probe_query_recv
-      && !reply.unicast_reply_requested && !mdns->ipv4.multicast_probe_timeout) {
-    delay_response = 0;
-  }
-#endif
-  LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: response %s delayed\r\n", (delay_response ? "randomly" : "not")));
-
-  /* Unicast / multicast response:
-   * Answering to (m)DNS querier via unicast response.
-   * When:
-   *  a) Unicast reply requested && recently multicasted 1/4ttl (RFC6762 section 5.4)
-   *  b) Direct unicast query to port 5353 (RFC6762 section 5.5)
-   *  c) Reply to Legacy DNS querier (RFC6762 section 6.7)
-   *  d) A probe message is received requesting unicast (RFC6762 section 6)
-   */
-
-#if LWIP_IPV6
-  if ((IP_IS_V6_VAL(pkt->source_addr) && mdns->ipv6.multicast_timeout_25TTL)) {
-    listen_to_QU_bit = 1;
-  }
-#endif
-#if LWIP_IPV4
-  if ((IP_IS_V4_VAL(pkt->source_addr) && mdns->ipv4.multicast_timeout_25TTL)) {
-    listen_to_QU_bit = 1;
-  }
-#endif
-  if (   (reply.unicast_reply_requested && listen_to_QU_bit)
-      || pkt->recv_unicast
-      || reply.legacy_query
-      || (reply.probe_query_recv && reply.unicast_reply_requested)) {
-    send_unicast = 1;
-  }
-  LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: send response via %s\r\n", (send_unicast ? "unicast" : "multicast")));
-
-  /* Send out or put on waiting list */
-  if (delay_response) {
-    if (send_unicast) {
-#if LWIP_IPV6
-      /* Add answers to IPv6 waiting list if:
-       *  - it's a IPv6 incoming packet
-       *  - no message is in it yet
-       */
-      if (IP_IS_V6_VAL(pkt->source_addr) && !mdns->ipv6.unicast_msg_in_use) {
-        LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: add answers to unicast IPv6 waiting list\r\n"));
-        SMEMCPY(&mdns->ipv6.delayed_msg_unicast.dest_addr, &pkt->source_addr, sizeof(ip_addr_t));
-        mdns->ipv6.delayed_msg_unicast.dest_port = pkt->source_port;
-
-        mdns_add_msg_to_delayed(&mdns->ipv6.delayed_msg_unicast, &reply);
-
-        mdns_set_timeout(netif, MDNS_RESPONSE_DELAY, mdns_send_unicast_msg_delayed_ipv6,
-                         &mdns->ipv6.unicast_msg_in_use);
-      }
-#endif
-#if LWIP_IPV4
-      /* Add answers to IPv4 waiting list if:
-       *  - it's a IPv4 incoming packet
-       *  - no message is in it yet
-       */
-      if (IP_IS_V4_VAL(pkt->source_addr) && !mdns->ipv4.unicast_msg_in_use) {
-        LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: add answers to unicast IPv4 waiting list\r\n"));
-        SMEMCPY(&mdns->ipv4.delayed_msg_unicast.dest_addr, &pkt->source_addr, sizeof(ip_addr_t));
-        mdns->ipv4.delayed_msg_unicast.dest_port = pkt->source_port;
-
-        mdns_add_msg_to_delayed(&mdns->ipv4.delayed_msg_unicast, &reply);
-
-        mdns_set_timeout(netif, MDNS_RESPONSE_DELAY, mdns_send_unicast_msg_delayed_ipv4,
-                         &mdns->ipv4.unicast_msg_in_use);
-      }
-#endif
-    }
-    else {
-#if LWIP_IPV6
-      /* Add answers to IPv6 waiting list if:
-       *  - it's a IPv6 incoming packet
-       *  - the 1 second timeout is passed (RFC6762 section 6)
-       *  - and it's not a probe packet
-       * Or if:
-       *  - it's a IPv6 incoming packet
-       *  - and it's a probe packet
-       */
-      if (IP_IS_V6_VAL(pkt->source_addr) && !mdns->ipv6.multicast_timeout
-          && !reply.probe_query_recv) {
-        LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: add answers to multicast IPv6 waiting list\r\n"));
-
-        mdns_add_msg_to_delayed(&mdns->ipv6.delayed_msg_multicast, &reply);
-
-        mdns_set_timeout(netif, MDNS_RESPONSE_DELAY, mdns_send_multicast_msg_delayed_ipv6,
-                         &mdns->ipv6.multicast_msg_waiting);
-      }
-      else if (IP_IS_V6_VAL(pkt->source_addr) && reply.probe_query_recv) {
-        LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: add answers to probe multicast IPv6 waiting list\r\n"));
-
-        mdns_add_msg_to_delayed(&mdns->ipv6.delayed_msg_multicast, &reply);
-
-        mdns->ipv6.multicast_msg_waiting = 1;
-      }
-#endif
-#if LWIP_IPV4
-      /* Add answers to IPv4 waiting list if:
-       *  - it's a IPv4 incoming packet
-       *  - the 1 second timeout is passed (RFC6762 section 6)
-       *  - and it's not a probe packet
-       * Or if:
-       *  - it's a IPv4 incoming packet
-       *  - and it's a probe packet
-       */
-      if (IP_IS_V4_VAL(pkt->source_addr) && !mdns->ipv4.multicast_timeout
-          && !reply.probe_query_recv) {
-        LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: add answers to multicast IPv4 waiting list\r\n"));
-
-        mdns_add_msg_to_delayed(&mdns->ipv4.delayed_msg_multicast, &reply);
-
-        mdns_set_timeout(netif, MDNS_RESPONSE_DELAY, mdns_send_multicast_msg_delayed_ipv4,
-                         &mdns->ipv4.multicast_msg_waiting);
-      }
-      else if (IP_IS_V4_VAL(pkt->source_addr) && reply.probe_query_recv) {
-        LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: add answers to probe multicast IPv4 waiting list\r\n"));
-
-        mdns_add_msg_to_delayed(&mdns->ipv4.delayed_msg_multicast, &reply);
-
-        mdns->ipv4.multicast_msg_waiting = 1;
-      }
-#endif
-    }
-  }
-  else {
-    if (send_unicast) {
-      /* Copy source IP/port to use when responding unicast */
-      SMEMCPY(&reply.dest_addr, &pkt->source_addr, sizeof(ip_addr_t));
-      reply.dest_port = pkt->source_port;
-      /* send answer directly via unicast */
-      res = mdns_send_outpacket(&reply, netif);
-      if (res != ERR_OK) {
-        LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Unicast answer could not be send\r\n"));
-      }
-      else {
-        LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Unicast answer send successfully\r\n"));
-      }
-      return;
-    }
-    else {
-      /* Set IP/port to use when responding multicast */
-#if LWIP_IPV6
-      if (IP_IS_V6_VAL(pkt->source_addr)) {
-        if (mdns->ipv6.multicast_timeout && !reply.probe_query_recv) {
-          LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: we just multicasted, ignore question\r\n"));
-          return;
-        }
-        SMEMCPY(&reply.dest_addr, &v6group, sizeof(ip_addr_t));
-      }
-#endif
-#if LWIP_IPV4
-      if (IP_IS_V4_VAL(pkt->source_addr)) {
-        if (mdns->ipv4.multicast_timeout && !reply.probe_query_recv) {
-          LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: we just multicasted, ignore question\r\n"));
-          return;
+            pbuf_memcmp(pkt->pbuf, ans.rd_offset, netif_ip4_addr(pkt->netif), ans.rd_length) == 0) {
+          LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Skipping known answer: A\n"));
+          reply.host_replies &= ~REPLY_HOST_A;
         }
-        SMEMCPY(&reply.dest_addr, &v4group, sizeof(ip_addr_t));
-      }
 #endif
-      reply.dest_port = LWIP_IANA_PORT_MDNS;
-      /* send answer directly via multicast */
-      res = mdns_send_outpacket(&reply, netif);
-      if (res != ERR_OK) {
-        LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Multicast answer could not be send\r\n"));
-      }
-      else {
-        LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Multicast answer send successfully\r\n"));
+      } else if (match & REPLY_HOST_AAAA) {
 #if LWIP_IPV6
-        if (IP_IS_V6_VAL(pkt->source_addr)) {
-          mdns_start_multicast_timeouts_ipv6(netif);
-        }
-#endif
-#if LWIP_IPV4
-        if (IP_IS_V4_VAL(pkt->source_addr)) {
-          mdns_start_multicast_timeouts_ipv4(netif);
+        if (ans.rd_length == sizeof(ip6_addr_p_t) &&
+            /* TODO this clears all AAAA responses if first addr is set as known */
+            pbuf_memcmp(pkt->pbuf, ans.rd_offset, netif_ip6_addr(pkt->netif, 0), ans.rd_length) == 0) {
+          LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Skipping known answer: AAAA\n"));
+          reply.host_replies &= ~REPLY_HOST_AAAA;
         }
 #endif
       }
-      return;
     }
-  }
-}
 
-/**
- * Handle a probe conflict:
- *  - Check if we exceeded the maximum of 15 conflicts in 10seconds.
- *  - Let the user know there is a conflict.
- *
- * @param netif network interface on which the conflict occured.
- */
-static void
-mdns_probe_conflict(struct netif *netif)
-{
-  struct mdns_host* mdns = NETIF_TO_HOST(netif);
-  int i;
-  u32_t diff;
-  u8_t index2;
-
-  /* Disable currently running probe / announce timer */
-  sys_untimeout(mdns_probe_and_announce, netif);
-
-  /* Increase the number of conflicts occured */
-  mdns->num_conflicts++;
-  mdns->conflict_time[mdns->index] = sys_now();
-  /* Print timestamp list */
-  LWIP_DEBUGF(MDNS_DEBUG, ("mDNS: conflict timestamp list, insert index = %d\n", mdns->index));
-  for(i = 0; i < MDNS_PROBE_MAX_CONFLICTS_BEFORE_RATE_LIMIT; i++) {
-    LWIP_DEBUGF(MDNS_DEBUG, ("mDNS: time no. %d = %d\n", i, mdns->conflict_time[i]));
-  }
-  /* Check if we had enough conflicts, minimum 15 */
-  if (mdns->num_conflicts >= MDNS_PROBE_MAX_CONFLICTS_BEFORE_RATE_LIMIT) {
-    /* Get the index to the oldest timestamp */
-    index2 = (mdns->index + 1) % MDNS_PROBE_MAX_CONFLICTS_BEFORE_RATE_LIMIT;
-    /* Compare the oldest vs newest time stamp */
-    diff = mdns->conflict_time[mdns->index] - mdns->conflict_time[index2];
-    /* If they are less then 10 seconds apart, initiate rate limit */
-    if (diff < MDNS_PROBE_MAX_CONFLICTS_TIME_WINDOW) {
-      LWIP_DEBUGF(MDNS_DEBUG, ("mDNS: probe rate limit enabled\n"));
-      mdns->rate_limit_activated = 1;
-    }
-  }
-  /* Increase index */
-  mdns->index = (mdns->index + 1) % MDNS_PROBE_MAX_CONFLICTS_BEFORE_RATE_LIMIT;
-
-  /* Inform the host on the conflict, if a callback is set */
-  if (mdns_name_result_cb != NULL) {
-    mdns_name_result_cb(netif, MDNS_PROBING_CONFLICT);
+    for (i = 0; i < MDNS_MAX_SERVICES; i++) {
+      service = mdns->services[i];
+      if (!service) {
+        continue;
+      }
+      match = reply.serv_replies[i] & check_service(service, &ans.info);
+      if (match && (ans.ttl > (service->dns_ttl / 2))) {
+        /* The RR in the known answer matches an RR we are planning to send,
+         * and the TTL is less than half gone.
+         * If the payload matches we should not send that answer.
+         */
+        if (ans.info.type == DNS_RRTYPE_PTR) {
+          /* Read domain and compare */
+          struct mdns_domain known_ans, my_ans;
+          u16_t len;
+          len = mdns_readname(pkt->pbuf, ans.rd_offset, &known_ans);
+          if (len != MDNS_READNAME_ERROR) {
+            if (match & REPLY_SERVICE_TYPE_PTR) {
+              res = mdns_build_service_domain(&my_ans, service, 0);
+              if (res == ERR_OK && mdns_domain_eq(&known_ans, &my_ans)) {
+                LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Skipping known answer: service type PTR\n"));
+                reply.serv_replies[i] &= ~REPLY_SERVICE_TYPE_PTR;
+              }
+            }
+            if (match & REPLY_SERVICE_NAME_PTR) {
+              res = mdns_build_service_domain(&my_ans, service, 1);
+              if (res == ERR_OK && mdns_domain_eq(&known_ans, &my_ans)) {
+                LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Skipping known answer: service name PTR\n"));
+                reply.serv_replies[i] &= ~REPLY_SERVICE_NAME_PTR;
+              }
+            }
+          }
+        } else if (match & REPLY_SERVICE_SRV) {
+          /* Read and compare to my SRV record */
+          u16_t field16, len, read_pos;
+          struct mdns_domain known_ans, my_ans;
+          read_pos = ans.rd_offset;
+          do {
+            /* Check priority field */
+            len = pbuf_copy_partial(pkt->pbuf, &field16, sizeof(field16), read_pos);
+            if (len != sizeof(field16) || lwip_ntohs(field16) != SRV_PRIORITY) {
+              break;
+            }
+            read_pos += len;
+            /* Check weight field */
+            len = pbuf_copy_partial(pkt->pbuf, &field16, sizeof(field16), read_pos);
+            if (len != sizeof(field16) || lwip_ntohs(field16) != SRV_WEIGHT) {
+              break;
+            }
+            read_pos += len;
+            /* Check port field */
+            len = pbuf_copy_partial(pkt->pbuf, &field16, sizeof(field16), read_pos);
+            if (len != sizeof(field16) || lwip_ntohs(field16) != service->port) {
+              break;
+            }
+            read_pos += len;
+            /* Check host field */
+            len = mdns_readname(pkt->pbuf, read_pos, &known_ans);
+            mdns_build_host_domain(&my_ans, mdns);
+            if (len == MDNS_READNAME_ERROR || !mdns_domain_eq(&known_ans, &my_ans)) {
+              break;
+            }
+            LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Skipping known answer: SRV\n"));
+            reply.serv_replies[i] &= ~REPLY_SERVICE_SRV;
+          } while (0);
+        } else if (match & REPLY_SERVICE_TXT) {
+          mdns_prepare_txtdata(service);
+          if (service->txtdata.length == ans.rd_length &&
+              pbuf_memcmp(pkt->pbuf, ans.rd_offset, service->txtdata.name, ans.rd_length) == 0) {
+            LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Skipping known answer: TXT\n"));
+            reply.serv_replies[i] &= ~REPLY_SERVICE_TXT;
+          }
+        }
+      }
+    }
   }
-}
 
+  mdns_send_outpacket(&reply, DNS_FLAG1_RESPONSE | DNS_FLAG1_AUTHORATIVE);
 
-/**
- * Loockup matching request for response MDNS packet
- */
-#if LWIP_MDNS_SEARCH
-static struct mdns_request *
-mdns_lookup_request(struct mdns_rr_info *rr)
-{
-  int i;
-  /* search originating request */
-  for (i = 0; i < MDNS_MAX_REQUESTS; i++) {
-    if ((mdns_requests[i].result_fn != NULL) &&
-        (check_request(&mdns_requests[i], rr) != 0)) {
-      return &mdns_requests[i];
-    }
+cleanup:
+  if (reply.pbuf) {
+    /* This should only happen if we fail to alloc/write question for legacy query */
+    pbuf_free(reply.pbuf);
+    reply.pbuf = NULL;
   }
-  return NULL;
 }
-#endif
 
 /**
- * Handle response MDNS packet:
- *  - Handle responses on probe query
- *  - Perform conflict resolution on every packet (RFC6762 section 9)
- *
- * @param pkt   incoming packet
- * @param netif network interface on which packet was received
+ * Handle response MDNS packet
+ * Only prints debug for now. Will need more code to do conflict resolution.
  */
 static void
-mdns_handle_response(struct mdns_packet *pkt, struct netif *netif)
+mdns_handle_response(struct mdns_packet *pkt)
 {
-  struct mdns_host* mdns = NETIF_TO_HOST(netif);
-  u16_t total_answers_left;
-#if LWIP_MDNS_SEARCH
-  struct mdns_request *req = NULL;
-  s8_t first = 1;
-#endif
-
-  /* Ignore responses with a source port different from 5353
-   * (LWIP_IANA_PORT_MDNS) -> RFC6762 section 6 */
-  if (pkt->source_port != LWIP_IANA_PORT_MDNS) {
-    return;
-  }
+  struct mdns_host* mdns = NETIF_TO_HOST(pkt->netif);
 
   /* Ignore all questions */
   while (pkt->questions_left) {
     struct mdns_question q;
     err_t res;
+
     res = mdns_read_question(pkt, &q);
     if (res != ERR_OK) {
       LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Failed to parse question, skipping response packet\n"));
       return;
     }
-#if LWIP_MDNS_SEARCH
-    else {
-      req = mdns_lookup_request(&q.info);
-    }
-#endif
   }
-  /* We need to check all resource record sections: answers, authoritative and additional */
-  total_answers_left = pkt->answers_left + pkt->authoritative_left + pkt->additional_left;
-  while (total_answers_left) {
+
+  while (pkt->answers_left) {
     struct mdns_answer ans;
     err_t res;
 
-    res = mdns_read_answer(pkt, &ans, &total_answers_left);
+    res = mdns_read_answer(pkt, &ans);
     if (res != ERR_OK) {
       LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Failed to parse answer, skipping response packet\n"));
       return;
@@ -1784,69 +1810,9 @@ mdns_handle_response(struct mdns_packet *pkt, struct netif *netif)
     mdns_domain_debug_print(&ans.info.domain);
     LWIP_DEBUGF(MDNS_DEBUG, (" type %d class %d\n", ans.info.type, ans.info.klass));
 
-    if (ans.info.type == DNS_RRTYPE_ANY || ans.info.klass != DNS_RRCLASS_IN) {
-      /* Skip answers for ANY type or if class != IN */
-      continue;
-    }
-
-#if LWIP_MDNS_SEARCH
-    if (req && req->only_ptr) {
-      /* Need to recheck that this answer match request that match previous answer */
-      if (memcmp (req->service.name, ans.info.domain.name, req->service.length) != 0)
-        req = NULL;
-    }
-    if (!req) {
-      /* Try hard to search matching request */
-      req = mdns_lookup_request(&ans.info);
-    }
-    if (req && req->result_fn) {
-      u16_t offset;
-      struct pbuf *p;
-      int flags = (first ? MDNS_SEARCH_RESULT_FIRST : 0) |
-          (!total_answers_left ? MDNS_SEARCH_RESULT_LAST : 0);
-      if (req->only_ptr) {
-          if (ans.info.type != DNS_RRTYPE_PTR)
-              continue; /* Ignore non matching answer type */
-          flags = MDNS_SEARCH_RESULT_FIRST | MDNS_SEARCH_RESULT_LAST;
-      }
-      p = pbuf_skip(pkt->pbuf, ans.rd_offset, &offset);
-      if (ans.info.type == DNS_RRTYPE_PTR || ans.info.type == DNS_RRTYPE_SRV) {
-        /* Those RR types have compressed domain name. Must uncompress here,
-           since cannot be done without pbuf. */
-        struct {
-          u16_t values[3];        /* SRV: Prio, Weight, Port */
-          struct mdns_domain dom; /* PTR & SRV: Domain (uncompressed) */
-        } data;
-        u16_t off = (ans.info.type == DNS_RRTYPE_SRV ? 6 : 0);
-        u16_t len = mdns_readname(pkt->pbuf, ans.rd_offset + off, &data.dom);
-        if (len == MDNS_READNAME_ERROR) {
-          /* Ensure result_fn is called anyway, just copy failed domain as is */
-          data.dom.length = ans.rd_length - off;
-          memcpy(&data.dom, (const char *)p->payload + offset + off, data.dom.length);
-        }
-        /* Adjust len/off according RR type */
-        if (ans.info.type == DNS_RRTYPE_SRV) {
-          memcpy(&data, (const char *)p->payload + offset, 6);
-          len = data.dom.length + 6;
-          off = 0;
-        } else {
-          len = data.dom.length;
-          off = 6;
-        }
-        req->result_fn(&ans, (const char *)&data + off, len, flags, req->arg);
-      } else {
-        /* Direct call result_fn with varpart pointing in pbuf payload */
-        req->result_fn(&ans, (const char *)p->payload + offset, ans.rd_length, flags, req->arg);
-      }
-      first = 0;
-    }
-#endif
-
-    /* "Conflicting Multicast DNS responses received *before* the first probe
-     * packet is sent MUST be silently ignored" so drop answer if we haven't
-     * started probing yet. */
-    if ((mdns->state == MDNS_STATE_PROBING) ||
-        (mdns->state == MDNS_STATE_ANNOUNCE_WAIT)) {
+    /*"Apparently conflicting Multicast DNS responses received *before* the first probe packet is sent MUST
+      be silently ignored" so drop answer if we haven't started probing yet*/
+    if ((mdns->probing_state == MDNS_PROBING_ONGOING) && (mdns->probes_sent > 0)) {
       struct mdns_domain domain;
       u8_t i;
       u8_t conflict = 0;
@@ -1870,124 +1836,13 @@ mdns_handle_response(struct mdns_packet *pkt, struct netif *netif)
       }
 
       if (conflict != 0) {
-        mdns_probe_conflict(netif);
-        break;
-      }
-    }
-    /* Perform conflict resolution (RFC6762 section 9):
-     * We assume a conflict if the hostname or service name matches the answers
-     * domain. Only if the rdata matches exactly we reset our assumption to no
-     * conflict. As stated in the RFC:
-     * What may be considered inconsistent is context sensitive, except that
-     * resource records with identical rdata are never considered inconsistent,
-     * even if they originate from different hosts.
-     */
-    else if ((mdns->state == MDNS_STATE_ANNOUNCING) ||
-             (mdns->state == MDNS_STATE_COMPLETE)) {
-      struct mdns_domain domain;
-      u8_t i;
-      u8_t conflict = 0;
-
-      /* Evaluate unique hostname records -> A and AAAA */
-      res = mdns_build_host_domain(&domain, mdns);
-      if (res == ERR_OK && mdns_domain_eq(&ans.info.domain, &domain)) {
-        LWIP_DEBUGF(MDNS_DEBUG, ("mDNS: response matches host domain, assuming conflict\n"));
-        /* This means a conflict has taken place, except when the packet contains
-         * exactly the same rdata. */
-        conflict = 1;
-        /* Evaluate rdata -> to see if it's a copy of our own data */
-        if (ans.info.type == DNS_RRTYPE_A) {
-#if LWIP_IPV4
-          if (ans.rd_length == sizeof(ip4_addr_t) &&
-              pbuf_memcmp(pkt->pbuf, ans.rd_offset, netif_ip4_addr(netif), ans.rd_length) == 0) {
-            LWIP_DEBUGF(MDNS_DEBUG, ("mDNS: response equals our own IPv4 address record -> no conflict\n"));
-            conflict = 0;
-          }
-#endif
-        }
-        else if (ans.info.type == DNS_RRTYPE_AAAA) {
-#if LWIP_IPV6
-          if (ans.rd_length == sizeof(ip6_addr_p_t)) {
-            for (i = 0; i < LWIP_IPV6_NUM_ADDRESSES; i++) {
-              if (pbuf_memcmp(pkt->pbuf, ans.rd_offset, netif_ip6_addr(netif, i), ans.rd_length) == 0) {
-                LWIP_DEBUGF(MDNS_DEBUG, ("mDNS: response equals our own iPv6 address record, num = %d -> no conflict\n",i));
-                conflict = 0;
-              }
-            }
-          }
-#endif
-        }
-      }
-      /* Evaluate unique service name records -> SRV and TXT */
-      for (i = 0; i < MDNS_MAX_SERVICES; i++) {
-        struct mdns_service* service = mdns->services[i];
-        if (!service) {
-          continue;
-        }
-        res = mdns_build_service_domain(&domain, service, 1);
-        if ((res == ERR_OK) && mdns_domain_eq(&ans.info.domain, &domain)) {
-          LWIP_DEBUGF(MDNS_DEBUG, ("mDNS: response matches service domain, assuming conflict\n"));
-          /* This means a conflict has taken place, except when the packet contains
-           * exactly the same rdata. */
-          conflict = 1;
-          /* Evaluate rdata -> to see if it's a copy of our own data */
-          if (ans.info.type == DNS_RRTYPE_SRV) {
-            /* Read and compare to with our SRV record */
-            u16_t field16, len, read_pos;
-            struct mdns_domain srv_ans, my_ans;
-            read_pos = ans.rd_offset;
-            do {
-              /* Check priority field */
-              len = pbuf_copy_partial(pkt->pbuf, &field16, sizeof(field16), read_pos);
-              if (len != sizeof(field16) || lwip_ntohs(field16) != SRV_PRIORITY) {
-                break;
-              }
-              read_pos += len;
-              /* Check weight field */
-              len = pbuf_copy_partial(pkt->pbuf, &field16, sizeof(field16), read_pos);
-              if (len != sizeof(field16) || lwip_ntohs(field16) != SRV_WEIGHT) {
-                break;
-              }
-              read_pos += len;
-              /* Check port field */
-              len = pbuf_copy_partial(pkt->pbuf, &field16, sizeof(field16), read_pos);
-              if (len != sizeof(field16) || lwip_ntohs(field16) != service->port) {
-                break;
-              }
-              read_pos += len;
-              /* Check host field */
-              len = mdns_readname(pkt->pbuf, read_pos, &srv_ans);
-              mdns_build_host_domain(&my_ans, mdns);
-              if (len == MDNS_READNAME_ERROR || !mdns_domain_eq(&srv_ans, &my_ans)) {
-                break;
-              }
-              LWIP_DEBUGF(MDNS_DEBUG, ("mDNS: response equals our own SRV record -> no conflict\n"));
-              conflict = 0;
-            } while (0);
-          } else if (ans.info.type == DNS_RRTYPE_TXT) {
-            mdns_prepare_txtdata(service);
-            if (service->txtdata.length == ans.rd_length &&
-                pbuf_memcmp(pkt->pbuf, ans.rd_offset, service->txtdata.name, ans.rd_length) == 0) {
-              LWIP_DEBUGF(MDNS_DEBUG, ("mDNS: response equals our own TXT record -> no conflict\n"));
-              conflict = 0;
-            }
-          }
+        sys_untimeout(mdns_probe, pkt->netif);
+        if (mdns_name_result_cb != NULL) {
+          mdns_name_result_cb(pkt->netif, MDNS_PROBING_CONFLICT);
         }
       }
-      if (conflict != 0) {
-        /* Reset host to probing to reconfirm uniqueness */
-        LWIP_DEBUGF(MDNS_DEBUG, ("mDNS: Conflict resolution -> reset to probing state\n"));
-        mdns->state = MDNS_STATE_PROBE_WAIT;
-        mdns->sent_num = 0;
-        sys_timeout(MDNS_INITIAL_PROBE_DELAY_MS, mdns_probe_and_announce, netif);
-        break;
-      }
     }
   }
-  /* Clear all xxx_left variables because we parsed all answers */
-  pkt->answers_left = 0;
-  pkt->authoritative_left = 0;
-  pkt->additional_left = 0;
 }
 
 /**
@@ -2026,30 +1881,18 @@ mdns_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *addr,
   memset(&packet, 0, sizeof(packet));
   SMEMCPY(&packet.source_addr, addr, sizeof(packet.source_addr));
   packet.source_port = port;
+  packet.netif = recv_netif;
   packet.pbuf = p;
   packet.parse_offset = offset;
   packet.tx_id = lwip_ntohs(hdr.id);
   packet.questions = packet.questions_left = lwip_ntohs(hdr.numquestions);
-  packet.answers = packet.answers_left = lwip_ntohs(hdr.numanswers);
-  packet.authoritative = packet.authoritative_left = lwip_ntohs(hdr.numauthrr);
-  packet.additional = packet.additional_left = lwip_ntohs(hdr.numextrarr);
-
-  /*  Source address check (RFC6762 section 11) -> for responses.
-   *  Source address check (RFC6762 section 5.5) -> for queries.
-   *  When the dest addr == multicast addr we know the packet originated on that
-   *  link. If not, we need to check the source address. We only accept queries
-   *  that originated on the link. Others are discarded.
-   */
+  packet.answers = packet.answers_left = lwip_ntohs(hdr.numanswers) + lwip_ntohs(hdr.numauthrr) + lwip_ntohs(hdr.numextrarr);
+
 #if LWIP_IPV6
   if (IP_IS_V6(ip_current_dest_addr())) {
     /* instead of having one 'v6group' per netif, just compare zoneless here */
     if (!ip_addr_cmp_zoneless(ip_current_dest_addr(), &v6group)) {
       packet.recv_unicast = 1;
-
-      if (ip6_addr_ismulticast_global(ip_2_ip6(ip_current_src_addr()))
-          || ip6_addr_isglobal(ip_2_ip6(ip_current_src_addr()))) {
-        goto dealloc;
-      }
     }
   }
 #endif
@@ -2057,20 +1900,14 @@ mdns_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *addr,
   if (!IP_IS_V6(ip_current_dest_addr())) {
     if (!ip_addr_cmp(ip_current_dest_addr(), &v4group)) {
       packet.recv_unicast = 1;
-
-      if (!ip4_addr_netcmp(ip_2_ip4(ip_current_src_addr()),
-                          netif_ip4_addr(recv_netif),
-                          netif_ip4_netmask(recv_netif))){
-           goto dealloc;
-         }
     }
   }
 #endif
 
   if (hdr.flags1 & DNS_FLAG1_RESPONSE) {
-    mdns_handle_response(&packet, recv_netif);
+    mdns_handle_response(&packet);
   } else {
-    mdns_handle_question(&packet, recv_netif);
+    mdns_handle_question(&packet);
   }
 
 dealloc:
@@ -2107,35 +1944,50 @@ mdns_netif_ext_status_callback(struct netif *netif, netif_nsc_reason_t reason, c
 }
 #endif /* LWIP_NETIF_EXT_STATUS_CALLBACK && MDNS_RESP_USENETIF_EXTCALLBACK */
 
-static void
-mdns_define_probe_rrs_to_send(struct netif *netif, struct mdns_outmsg *outmsg)
+static err_t
+mdns_send_probe(struct netif* netif, const ip_addr_t *destination)
 {
-  struct mdns_host *mdns = NETIF_TO_HOST(netif);
-  int i;
+  struct mdns_host* mdns;
+  struct mdns_outpacket pkt;
+  struct mdns_domain domain;
+  u8_t i;
+  err_t res;
 
-  memset(outmsg, 0, sizeof(struct mdns_outmsg));
+  mdns = NETIF_TO_HOST(netif);
 
-  /* Add unicast questions with rtype ANY for all our desired records */
-  outmsg->host_questions = QUESTION_PROBE_HOST_ANY;
+  memset(&pkt, 0, sizeof(pkt));
+  pkt.netif = netif;
 
+  /* Add unicast questions with rtype ANY for all our desired records */
+  mdns_build_host_domain(&domain, mdns);
+  res = mdns_add_question(&pkt, &domain, DNS_RRTYPE_ANY, DNS_RRCLASS_IN, 1);
+  if (res != ERR_OK) {
+    goto cleanup;
+  }
+  pkt.questions++;
   for (i = 0; i < MDNS_MAX_SERVICES; i++) {
     struct mdns_service* service = mdns->services[i];
     if (!service) {
       continue;
     }
-    outmsg->serv_questions[i] = QUESTION_PROBE_SERVICE_NAME_ANY;
+    mdns_build_service_domain(&domain, service, 1);
+    res = mdns_add_question(&pkt, &domain, DNS_RRTYPE_ANY, DNS_RRCLASS_IN, 1);
+    if (res != ERR_OK) {
+      goto cleanup;
+    }
+    pkt.questions++;
   }
 
   /* Add answers to the questions above into the authority section for tiebreaking */
 #if LWIP_IPV4
   if (!ip4_addr_isany_val(*netif_ip4_addr(netif))) {
-    outmsg->host_replies = REPLY_HOST_A;
+    pkt.host_replies = REPLY_HOST_A;
   }
 #endif
 #if LWIP_IPV6
   for (i = 0; i < LWIP_IPV6_NUM_ADDRESSES; i++) {
     if (ip6_addr_isvalid(netif_ip6_addr_state(netif, i))) {
-      outmsg->host_replies |= REPLY_HOST_AAAA;
+      pkt.host_replies |= REPLY_HOST_AAAA;
     }
   }
 #endif
@@ -2143,92 +1995,54 @@ mdns_define_probe_rrs_to_send(struct netif *netif, struct mdns_outmsg *outmsg)
   for (i = 0; i < MDNS_MAX_SERVICES; i++) {
     struct mdns_service *serv = mdns->services[i];
     if (serv) {
-      outmsg->serv_replies[i] = REPLY_SERVICE_SRV | REPLY_SERVICE_TXT;
+      pkt.serv_replies[i] = REPLY_SERVICE_SRV | REPLY_SERVICE_TXT;
     }
   }
-}
-
-static err_t
-mdns_send_probe(struct netif* netif, const ip_addr_t *destination)
-{
-  struct mdns_outmsg outmsg;
 
-  mdns_define_probe_rrs_to_send(netif, &outmsg);
+  pkt.tx_id = 0;
+  pkt.dest_port = LWIP_IANA_PORT_MDNS;
+  SMEMCPY(&pkt.dest_addr, destination, sizeof(pkt.dest_addr));
+  res = mdns_send_outpacket(&pkt, 0);
 
-  outmsg.tx_id = 0;
-  outmsg.dest_port = LWIP_IANA_PORT_MDNS;
-  SMEMCPY(&outmsg.dest_addr, destination, sizeof(outmsg.dest_addr));
-  return mdns_send_outpacket(&outmsg, netif);
+cleanup:
+  if (pkt.pbuf) {
+    pbuf_free(pkt.pbuf);
+    pkt.pbuf = NULL;
+  }
+  return res;
 }
 
 /**
- * Timer callback for probing and announcing on the network.
+ * Timer callback for probing network.
  */
 static void
-mdns_probe_and_announce(void* arg)
+mdns_probe(void* arg)
 {
   struct netif *netif = (struct netif *)arg;
   struct mdns_host* mdns = NETIF_TO_HOST(netif);
-  u32_t announce_delay;
-
 
-  switch (mdns->state) {
-    case MDNS_STATE_OFF:
-    case MDNS_STATE_PROBE_WAIT:
-    case MDNS_STATE_PROBING:
+  if(mdns->probes_sent >= MDNS_PROBE_COUNT) {
+    /* probing successful, announce the new name */
+    mdns->probing_state = MDNS_PROBING_COMPLETE;
+    mdns_resp_announce(netif);
+    if (mdns_name_result_cb != NULL) {
+      mdns_name_result_cb(netif, MDNS_PROBING_SUCCESSFUL);
+    }
+  } else {
 #if LWIP_IPV4
-      /*if ipv4 wait with probing until address is set*/
-      if (!ip4_addr_isany_val(*netif_ip4_addr(netif)) &&
-          mdns_send_probe(netif, &v4group) == ERR_OK)
+    /*if ipv4 wait with probing until address is set*/
+    if (!ip4_addr_isany_val(*netif_ip4_addr(netif)) &&
+        mdns_send_probe(netif, IP4_ADDR_ANY) == ERR_OK)
 #endif
-      {
+    {
 #if LWIP_IPV6
-        if (mdns_send_probe(netif, &v6group) == ERR_OK)
+      if (mdns_send_probe(netif, IP6_ADDR_ANY) == ERR_OK)
 #endif
-        {
-          mdns->state = MDNS_STATE_PROBING;
-          mdns->sent_num++;
-        }
-      }
-
-      if (mdns->sent_num >= MDNS_PROBE_COUNT) {
-        mdns->state = MDNS_STATE_ANNOUNCE_WAIT;
-        mdns->sent_num = 0;
-      }
-
-      sys_timeout(MDNS_PROBE_DELAY_MS, mdns_probe_and_announce, netif);
-
-      break;
-    case MDNS_STATE_ANNOUNCE_WAIT:
-    case MDNS_STATE_ANNOUNCING:
-      if (mdns->sent_num == 0) {
-        /* probing was succesful, announce all records */
-        mdns->state = MDNS_STATE_ANNOUNCING;
-        /* Reset rate limit max probe conflict timeout flag */
-        mdns->rate_limit_activated = 0;
-        /* Let the client know probing was successful */
-        if (mdns_name_result_cb != NULL) {
-          mdns_name_result_cb(netif, MDNS_PROBING_SUCCESSFUL);
-        }
-      }
-
-      mdns_resp_announce(netif);
-      mdns->sent_num++;
-
-      if (mdns->sent_num >= MDNS_ANNOUNCE_COUNT) {
-        /* Announcing and probing complete */
-        mdns->state = MDNS_STATE_COMPLETE;
-        mdns->sent_num = 0;
-      }
-      else {
-        announce_delay = MDNS_ANNOUNCE_DELAY_MS * (1 << (mdns->sent_num - 1));
-        sys_timeout(announce_delay, mdns_probe_and_announce, netif);
+      {
+        mdns->probes_sent++;
       }
-      break;
-    case MDNS_STATE_COMPLETE:
-    default:
-      /* Do nothing */
-      break;
+    }
+    sys_timeout(MDNS_PROBE_DELAY_MS, mdns_probe, netif);
   }
 }
 
@@ -2239,10 +2053,11 @@ mdns_probe_and_announce(void* arg)
  * @param hostname Name to use. Queries for &lt;hostname&gt;.local will be answered
  *                 with the IP addresses of the netif. The hostname will be copied, the
  *                 given pointer can be on the stack.
+ * @param dns_ttl Validity time in seconds to send out for IP address data in DNS replies
  * @return ERR_OK if netif was added, an err_t otherwise
  */
 err_t
-mdns_resp_add_netif(struct netif *netif, const char *hostname)
+mdns_resp_add_netif(struct netif *netif, const char *hostname, u32_t dns_ttl)
 {
   err_t res;
   struct mdns_host *mdns;
@@ -2258,19 +2073,9 @@ mdns_resp_add_netif(struct netif *netif, const char *hostname)
   netif_set_client_data(netif, mdns_netif_client_id, mdns);
 
   MEMCPY(&mdns->name, hostname, LWIP_MIN(MDNS_LABEL_MAXLEN, strlen(hostname)));
-
-  /* Init delayed message structs with address and port */
-#if LWIP_IPV4
-  mdns->ipv4.delayed_msg_multicast.dest_port = LWIP_IANA_PORT_MDNS;
-  SMEMCPY(&mdns->ipv4.delayed_msg_multicast.dest_addr, &v4group,
-            sizeof(ip_addr_t));
-#endif
-
-#if LWIP_IPV6
-  mdns->ipv6.delayed_msg_multicast.dest_port = LWIP_IANA_PORT_MDNS;
-  SMEMCPY(&mdns->ipv6.delayed_msg_multicast.dest_addr, &v6group,
-            sizeof(ip_addr_t));
-#endif
+  mdns->dns_ttl = dns_ttl;
+  mdns->probes_sent = 0;
+  mdns->probing_state = MDNS_PROBING_NOT_STARTED;
 
   /* Join multicast groups */
 #if LWIP_IPV4
@@ -2314,7 +2119,9 @@ mdns_resp_remove_netif(struct netif *netif)
   mdns = NETIF_TO_HOST(netif);
   LWIP_ERROR("mdns_resp_remove_netif: Not an active netif", (mdns != NULL), return ERR_VAL);
 
-  sys_untimeout(mdns_probe_and_announce, netif);
+  if (mdns->probing_state == MDNS_PROBING_ONGOING) {
+    sys_untimeout(mdns_probe, netif);
+  }
 
   for (i = 0; i < MDNS_MAX_SERVICES; i++) {
     struct mdns_service *service = mdns->services[i];
@@ -2375,13 +2182,14 @@ mdns_resp_rename_netif(struct netif *netif, const char *hostname)
  * @param proto The service protocol, DNSSD_PROTO_TCP for TCP ("_tcp") and DNSSD_PROTO_UDP
  *              for others ("_udp")
  * @param port The port the service listens to
+ * @param dns_ttl Validity time in seconds to send out for service data in DNS replies
  * @param txt_fn Callback to get TXT data. Will be called each time a TXT reply is created to
  *               allow dynamic replies.
  * @param txt_data Userdata pointer for txt_fn
  * @return service_id if the service was added to the netif, an err_t otherwise
  */
 s8_t
-mdns_resp_add_service(struct netif *netif, const char *name, const char *service, enum mdns_sd_proto proto, u16_t port, service_get_txt_fn_t txt_fn, void *txt_data)
+mdns_resp_add_service(struct netif *netif, const char *name, const char *service, enum mdns_sd_proto proto, u16_t port, u32_t dns_ttl, service_get_txt_fn_t txt_fn, void *txt_data)
 {
   s8_t i;
   s8_t slot = -1;
@@ -2414,6 +2222,7 @@ mdns_resp_add_service(struct netif *netif, const char *name, const char *service
   srv->txt_userdata = txt_data;
   srv->proto = (u16_t)proto;
   srv->port = port;
+  srv->dns_ttl = dns_ttl;
 
   mdns->services[slot] = srv;
 
@@ -2499,87 +2308,6 @@ mdns_resp_add_service_txtitem(struct mdns_service *service, const char *txt, u8_
   return mdns_domain_add_label(&service->txtdata, txt, txt_len);
 }
 
-#if LWIP_MDNS_SEARCH
-/**
- * @ingroup mdns
- * Stop a search request.
- * @param request_id The search request to stop
- */
-void
-mdns_search_stop(s8_t request_id)
-{
-  struct mdns_request *req;
-  LWIP_ASSERT("mdns_search_stop: bad request_id", (request_id >= 0) && (request_id < MDNS_MAX_REQUESTS));
-  req = &mdns_requests[request_id];
-  if (req && req->result_fn) {
-    req->result_fn = NULL;
-  }
-}
-
-/**
- * @ingroup mdns
- * Search a specific service on the network.
- * @param name The name of the service
- * @param service The service type, like "_http"
- * @param proto The service protocol, DNSSD_PROTO_TCP for TCP ("_tcp") and DNSSD_PROTO_UDP
- *              for others ("_udp")
- * @param netif The network interface where to send search request
- * @param result_fn Callback to send answer received. Will be called for each answer of a
- *                  responce frame matching request sent
- * @param arg Userdata pointer for result_fn
- * @param request_id Returned request identifier to allow stop it.
- * @return ERR_OK if the search request was created and sent, an err_t otherwise
- */
-err_t
-mdns_search_service(const char *name, const char *service, enum mdns_sd_proto proto,
-                    struct netif *netif, search_result_fn_t result_fn, void *arg,
-                    s8_t *request_id)
-{
-  s8_t i, slot = -1;
-  struct mdns_request *req;
-  if (name) {
-    LWIP_ERROR("mdns_search_service: Name too long", (strlen(name) <= MDNS_LABEL_MAXLEN), return ERR_VAL);
-  }
-  LWIP_ERROR("mdns_search_service: Service too long", (strlen(service) < MDNS_DOMAIN_MAXLEN), return ERR_VAL);
-  LWIP_ERROR("mdns_search_service: Bad reqid pointer", request_id, return ERR_VAL);
-  LWIP_ERROR("mdns_search_service: Bad proto (need TCP or UDP)", (proto == DNSSD_PROTO_TCP || proto == DNSSD_PROTO_UDP), return ERR_VAL);
-  for (i = 0; i < MDNS_MAX_REQUESTS; i++) {
-    if (mdns_requests[i].result_fn == NULL) {
-      slot = i;
-      break;
-    }
-  }
-  if (slot < 0) {
-    /* Don't assert if no more space in mdns_request table. Just return an error. */
-    return ERR_MEM;
-  }
-
-  req = &mdns_requests[slot];
-  memset(req, 0, sizeof(struct mdns_request));
-  req->result_fn = result_fn;
-  req->arg = arg;
-  req->proto = (u16_t)proto;
-  req->qtype = DNS_RRTYPE_PTR;
-  if (proto == DNSSD_PROTO_UDP && strcmp(service, "_services._dns-sd") == 0) {
-      req->only_ptr = 1; /* don't check other answers */
-  }
-  mdns_domain_add_string(&req->service, service);
-  if (name) {
-    MEMCPY(&req->name, name, LWIP_MIN(MDNS_LABEL_MAXLEN, strlen(name)));
-  }
-  /* save request id (slot) in pointer provided by caller */
-  *request_id = slot;
-  /* now prepare a MDNS request and send it (on specified interface) */
-#if LWIP_IPV6
-  mdns_send_request(req, netif, IP6_ADDR_ANY);
-#endif
-#if LWIP_IPV4
-  mdns_send_request(req, netif, IP4_ADDR_ANY);
-#endif
-  return ERR_OK;
-}
-#endif
-
 /**
  * @ingroup mdns
  * Send unsolicited answer containing all our known data
@@ -2597,21 +2325,14 @@ mdns_resp_announce(struct netif *netif)
     return;
   }
 
-  /* Do not announce if the mdns responder is off, waiting to probe, probing or
-   * waiting to announce. */
-  if (!(   (mdns->state == MDNS_STATE_OFF)
-        || (mdns->state == MDNS_STATE_PROBE_WAIT)
-        || (mdns->state == MDNS_STATE_PROBING)
-        || (mdns->state == MDNS_STATE_ANNOUNCE_WAIT))) {
+  if (mdns->probing_state == MDNS_PROBING_COMPLETE) {
     /* Announce on IPv6 and IPv4 */
 #if LWIP_IPV6
-    mdns_announce(netif, &v6group);
-    mdns_start_multicast_timeouts_ipv6(netif);
+    mdns_announce(netif, IP6_ADDR_ANY);
 #endif
 #if LWIP_IPV4
     if (!ip4_addr_isany_val(*netif_ip4_addr(netif))) {
-      mdns_announce(netif, &v4group);
-      mdns_start_multicast_timeouts_ipv4(netif);
+      mdns_announce(netif, IP4_ADDR_ANY);
     }
 #endif
   } /* else: ip address changed while probing was ongoing? @todo reset counter to restart? */
@@ -2642,22 +2363,14 @@ mdns_resp_restart(struct netif *netif)
   if (mdns == NULL) {
     return;
   }
-  /* Make sure timer is not running */
-  sys_untimeout(mdns_probe_and_announce, netif);
 
-  mdns->sent_num = 0;
-  mdns->state = MDNS_STATE_PROBE_WAIT;
-
-  /* RFC6762 section 8.1: If fifteen conflicts occur within any ten-second period,
-   * then the host MUST wait at least five seconds before each successive
-   * additional probe attempt.
-   */
-  if (mdns->rate_limit_activated == 1) {
-    sys_timeout(MDNS_PROBE_MAX_CONFLICTS_TIMEOUT, mdns_probe_and_announce, netif);
-  }
-  else {
-    sys_timeout(MDNS_INITIAL_PROBE_DELAY_MS, mdns_probe_and_announce, netif);
+  if (mdns->probing_state == MDNS_PROBING_ONGOING) {
+    sys_untimeout(mdns_probe, netif);
   }
+  /* @todo if we've failed 15 times within a 10 second period we MUST wait 5 seconds (or wait 5 seconds every time except first)*/
+  mdns->probes_sent = 0;
+  mdns->probing_state = MDNS_PROBING_ONGOING;
+  sys_timeout(MDNS_INITIAL_PROBE_DELAY_MS, mdns_probe, netif);
 }
 
 /**
@@ -2671,15 +2384,12 @@ mdns_resp_init(void)
 
   /* LWIP_ASSERT_CORE_LOCKED(); is checked by udp_new() */
 
-#if LWIP_MDNS_SEARCH
-  memset(mdns_requests, 0, sizeof(mdns_requests));
-#endif
   mdns_pcb = udp_new_ip_type(IPADDR_TYPE_ANY);
   LWIP_ASSERT("Failed to allocate pcb", mdns_pcb != NULL);
 #if LWIP_MULTICAST_TX_OPTIONS
-  udp_set_multicast_ttl(mdns_pcb, MDNS_IP_TTL);
+  udp_set_multicast_ttl(mdns_pcb, MDNS_TTL);
 #else
-  mdns_pcb->ttl = MDNS_IP_TTL;
+  mdns_pcb->ttl = MDNS_TTL;
 #endif
   res = udp_bind(mdns_pcb, IP_ANY_TYPE, LWIP_IANA_PORT_MDNS);
   LWIP_UNUSED_ARG(res); /* in case of LWIP_NOASSERT */
diff --git a/src/apps/mdns/mdns_domain.c b/src/apps/mdns/mdns_domain.c
deleted file mode 100644
index 47934eff..00000000
--- a/src/apps/mdns/mdns_domain.c
+++ /dev/null
@@ -1,635 +0,0 @@
-/**
- * @file
- * MDNS responder implementation - domain related functionalities
- */
-
-/*
- * Copyright (c) 2015 Verisure Innovation AB
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Erik Ekman <erik@kryo.se>
- * Author: Jasper Verschueren <jasper.verschueren@apart-audio.com>
- *
- */
-
-#include "lwip/apps/mdns.h"
-#include "lwip/apps/mdns_domain.h"
-#include "lwip/apps/mdns_priv.h"
-#include "lwip/prot/dns.h"
-
-#include <string.h>
-
-#if LWIP_IPV6
-#include "lwip/prot/ip6.h"
-#endif
-
-#if LWIP_MDNS_RESPONDER
-
-/* Stored offsets to beginning of domain names
- * Used for compression.
- */
-#define DOMAIN_JUMP_SIZE 2
-#define DOMAIN_JUMP 0xc000
-
-#define TOPDOMAIN_LOCAL "local"
-
-#define REVERSE_PTR_TOPDOMAIN "arpa"
-#define REVERSE_PTR_V4_DOMAIN "in-addr"
-#define REVERSE_PTR_V6_DOMAIN "ip6"
-
-static const char *dnssd_protos[] = {
-  "_udp", /* DNSSD_PROTO_UDP */
-  "_tcp", /* DNSSD_PROTO_TCP */
-};
-
-/* forward declarations (function prototypes)*/
-static err_t mdns_domain_add_label_base(struct mdns_domain *domain, u8_t len);
-static err_t mdns_domain_add_label_pbuf(struct mdns_domain *domain,
-                                        const struct pbuf *p, u16_t offset,
-                                        u8_t len);
-static u16_t mdns_readname_loop(struct pbuf *p, u16_t offset,
-                                struct mdns_domain *domain, unsigned depth);
-static err_t mdns_add_dotlocal(struct mdns_domain *domain);
-
-
-static err_t
-mdns_domain_add_label_base(struct mdns_domain *domain, u8_t len)
-{
-  if (len > MDNS_LABEL_MAXLEN) {
-    return ERR_VAL;
-  }
-  if (len > 0 && (1 + len + domain->length >= MDNS_DOMAIN_MAXLEN)) {
-    return ERR_VAL;
-  }
-  /* Allow only zero marker on last byte */
-  if (len == 0 && (1 + domain->length > MDNS_DOMAIN_MAXLEN)) {
-    return ERR_VAL;
-  }
-  domain->name[domain->length] = len;
-  domain->length++;
-  return ERR_OK;
-}
-
-/**
- * Add a label part to a domain
- * @param domain The domain to add a label to
- * @param label The label to add, like &lt;hostname&gt;, 'local', 'com' or ''
- * @param len The length of the label
- * @return ERR_OK on success, an err_t otherwise if label too long
- */
-err_t
-mdns_domain_add_label(struct mdns_domain *domain, const char *label, u8_t len)
-{
-  err_t err = mdns_domain_add_label_base(domain, len);
-  if (err != ERR_OK) {
-    return err;
-  }
-  if (len) {
-    MEMCPY(&domain->name[domain->length], label, len);
-    domain->length += len;
-  }
-  return ERR_OK;
-}
-
-/**
- * Add a label part to a domain (@see mdns_domain_add_label but copy directly from pbuf)
- */
-static err_t
-mdns_domain_add_label_pbuf(struct mdns_domain *domain, const struct pbuf *p, u16_t offset, u8_t len)
-{
-  err_t err = mdns_domain_add_label_base(domain, len);
-  if (err != ERR_OK) {
-    return err;
-  }
-  if (len) {
-    if (pbuf_copy_partial(p, &domain->name[domain->length], len, offset) != len) {
-      /* take back the ++ done before */
-      domain->length--;
-      return ERR_ARG;
-    }
-    domain->length += len;
-  }
-  return ERR_OK;
-}
-
-/**
- * Add a partial domain to a domain
- * @param domain The domain to add a label to
- * @param source The domain to add, like &lt;\\x09_services\\007_dns-sd\\000&gt;
- * @return ERR_OK on success, an err_t otherwise if label too long
- */
-err_t
-mdns_domain_add_domain(struct mdns_domain *domain, struct mdns_domain *source)
-{
-  u16_t len = source->length;
-  if (len > 0 && (1 + len + domain->length >= MDNS_DOMAIN_MAXLEN)) {
-    return ERR_VAL;
-  }
-  /* Allow only zero marker on last byte */
-  if (len == 0 && (1 + domain->length > MDNS_DOMAIN_MAXLEN)) {
-    return ERR_VAL;
-  }
-  if (len) {
-    /* Copy partial domain */
-    MEMCPY(&domain->name[domain->length], source->name, len);
-    domain->length += len;
-  } else {
-    /* Add zero marker */
-    domain->name[domain->length] = 0;
-    domain->length++;
-  }
-  return ERR_OK;
-}
-
-/**
- * Add a string domain to a domain
- * @param domain The domain to add a label to
- * @param source The string to add, like &lt;_services._dns-sd&gt;
- * @return ERR_OK on success, an err_t otherwise if label too long
- */
-err_t
-mdns_domain_add_string(struct mdns_domain *domain, const char *source)
-{
-  u8_t *len = &domain->name[domain->length];
-  u8_t *end = &domain->name[MDNS_DOMAIN_MAXLEN];
-  u8_t *start = len + 1;
-  *len = 0;
-  while (*source && start < end) {
-      if (*source == '.') {
-        len = start++;
-        *len = 0;
-        source++;
-      } else {
-        *start++ = *source++;
-        *len = *len + 1;
-      }
-  }
-  if (start == end) {
-      return ERR_VAL;
-  }
-  domain->length = (u16_t)(start - &domain->name[0]);
-  return ERR_OK;
-}
-
-
-/**
- * Internal readname function with max 6 levels of recursion following jumps
- * while decompressing name
- */
-static u16_t
-mdns_readname_loop(struct pbuf *p, u16_t offset, struct mdns_domain *domain, unsigned depth)
-{
-  u8_t c;
-
-  do {
-    if (depth > 5) {
-      /* Too many jumps */
-      return MDNS_READNAME_ERROR;
-    }
-
-    c = pbuf_get_at(p, offset);
-    offset++;
-
-    /* is this a compressed label? */
-    if ((c & 0xc0) == 0xc0) {
-      u16_t jumpaddr;
-      if (offset >= p->tot_len) {
-        /* Make sure both jump bytes fit in the packet */
-        return MDNS_READNAME_ERROR;
-      }
-      jumpaddr = (((c & 0x3f) << 8) | (pbuf_get_at(p, offset) & 0xff));
-      offset++;
-      if (jumpaddr >= SIZEOF_DNS_HDR && jumpaddr < p->tot_len) {
-        u16_t res;
-        /* Recursive call, maximum depth will be checked */
-        res = mdns_readname_loop(p, jumpaddr, domain, depth + 1);
-        /* Dont return offset since new bytes were not read (jumped to somewhere in packet) */
-        if (res == MDNS_READNAME_ERROR) {
-          return res;
-        }
-      } else {
-        return MDNS_READNAME_ERROR;
-      }
-      break;
-    }
-
-    /* normal label */
-    if (c <= MDNS_LABEL_MAXLEN) {
-      err_t res;
-
-      if (c + domain->length >= MDNS_DOMAIN_MAXLEN) {
-        return MDNS_READNAME_ERROR;
-      }
-      res = mdns_domain_add_label_pbuf(domain, p, offset, c);
-      if (res != ERR_OK) {
-        return MDNS_READNAME_ERROR;
-      }
-      offset += c;
-    } else {
-      /* bad length byte */
-      return MDNS_READNAME_ERROR;
-    }
-  } while (c != 0);
-
-  return offset;
-}
-
-/**
- * Read possibly compressed domain name from packet buffer
- * @param p The packet
- * @param offset start position of domain name in packet
- * @param domain The domain name destination
- * @return The new offset after the domain, or MDNS_READNAME_ERROR
- *         if reading failed
- */
-u16_t
-mdns_readname(struct pbuf *p, u16_t offset, struct mdns_domain *domain)
-{
-  memset(domain, 0, sizeof(struct mdns_domain));
-  return mdns_readname_loop(p, offset, domain, 0);
-}
-
-/**
- * Print domain name to debug output
- * @param domain The domain name
- */
-void
-mdns_domain_debug_print(struct mdns_domain *domain)
-{
-  u8_t *src = domain->name;
-  u8_t i;
-
-  while (*src) {
-    u8_t label_len = *src;
-    src++;
-    for (i = 0; i < label_len; i++) {
-      LWIP_DEBUGF(MDNS_DEBUG, ("%c", src[i]));
-    }
-    src += label_len;
-    LWIP_DEBUGF(MDNS_DEBUG, ("."));
-  }
-}
-
-/**
- * Return 1 if contents of domains match (case-insensitive)
- * @param a Domain name to compare 1
- * @param b Domain name to compare 2
- * @return 1 if domains are equal ignoring case, 0 otherwise
- */
-int
-mdns_domain_eq(struct mdns_domain *a, struct mdns_domain *b)
-{
-  u8_t *ptra, *ptrb;
-  u8_t len;
-  int res;
-
-  if (a->length != b->length) {
-    return 0;
-  }
-
-  ptra = a->name;
-  ptrb = b->name;
-  while (*ptra && *ptrb && ptra < &a->name[a->length]) {
-    if (*ptra != *ptrb) {
-      return 0;
-    }
-    len = *ptra;
-    ptra++;
-    ptrb++;
-    res = lwip_strnicmp((char *) ptra, (char *) ptrb, len);
-    if (res != 0) {
-      return 0;
-    }
-    ptra += len;
-    ptrb += len;
-  }
-  if (*ptra != *ptrb && ptra < &a->name[a->length]) {
-    return 0;
-  }
-  return 1;
-}
-
-#if LWIP_IPV4
-/**
- * Build domain for reverse lookup of IPv4 address
- * like 12.0.168.192.in-addr.arpa. for 192.168.0.12
- * @param domain Where to write the domain name
- * @param addr Pointer to an IPv4 address to encode
- * @return ERR_OK if domain was written, an err_t otherwise
- */
-err_t
-mdns_build_reverse_v4_domain(struct mdns_domain *domain, const ip4_addr_t *addr)
-{
-  int i;
-  err_t res;
-  const u8_t *ptr;
-
-  LWIP_UNUSED_ARG(res);
-  if (!domain || !addr) {
-    return ERR_ARG;
-  }
-  memset(domain, 0, sizeof(struct mdns_domain));
-  ptr = (const u8_t *) addr;
-  for (i = sizeof(ip4_addr_t) - 1; i >= 0; i--) {
-    char buf[4];
-    u8_t val = ptr[i];
-
-    lwip_itoa(buf, sizeof(buf), val);
-    res = mdns_domain_add_label(domain, buf, (u8_t)strlen(buf));
-    LWIP_ERROR("mdns_build_reverse_v4_domain: Failed to add label", (res == ERR_OK), return res);
-  }
-  res = mdns_domain_add_label(domain, REVERSE_PTR_V4_DOMAIN, (u8_t)(sizeof(REVERSE_PTR_V4_DOMAIN) - 1));
-  LWIP_ERROR("mdns_build_reverse_v4_domain: Failed to add label", (res == ERR_OK), return res);
-  res = mdns_domain_add_label(domain, REVERSE_PTR_TOPDOMAIN, (u8_t)(sizeof(REVERSE_PTR_TOPDOMAIN) - 1));
-  LWIP_ERROR("mdns_build_reverse_v4_domain: Failed to add label", (res == ERR_OK), return res);
-  res = mdns_domain_add_label(domain, NULL, 0);
-  LWIP_ERROR("mdns_build_reverse_v4_domain: Failed to add label", (res == ERR_OK), return res);
-
-  return ERR_OK;
-}
-#endif
-
-#if LWIP_IPV6
-/**
- * Build domain for reverse lookup of IP address
- * like b.a.9.8.7.6.5.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.b.d.0.1.0.0.2.ip6.arpa. for 2001:db8::567:89ab
- * @param domain Where to write the domain name
- * @param addr Pointer to an IPv6 address to encode
- * @return ERR_OK if domain was written, an err_t otherwise
- */
-err_t
-mdns_build_reverse_v6_domain(struct mdns_domain *domain, const ip6_addr_t *addr)
-{
-  int i;
-  err_t res;
-  const u8_t *ptr;
-  LWIP_UNUSED_ARG(res);
-  if (!domain || !addr) {
-    return ERR_ARG;
-  }
-  memset(domain, 0, sizeof(struct mdns_domain));
-  ptr = (const u8_t *) addr;
-  for (i = sizeof(ip6_addr_p_t) - 1; i >= 0; i--) {
-    char buf;
-    u8_t byte = ptr[i];
-    int j;
-    for (j = 0; j < 2; j++) {
-      if ((byte & 0x0F) < 0xA) {
-        buf = '0' + (byte & 0x0F);
-      } else {
-        buf = 'a' + (byte & 0x0F) - 0xA;
-      }
-      res = mdns_domain_add_label(domain, &buf, sizeof(buf));
-      LWIP_ERROR("mdns_build_reverse_v6_domain: Failed to add label", (res == ERR_OK), return res);
-      byte >>= 4;
-    }
-  }
-  res = mdns_domain_add_label(domain, REVERSE_PTR_V6_DOMAIN, (u8_t)(sizeof(REVERSE_PTR_V6_DOMAIN) - 1));
-  LWIP_ERROR("mdns_build_reverse_v6_domain: Failed to add label", (res == ERR_OK), return res);
-  res = mdns_domain_add_label(domain, REVERSE_PTR_TOPDOMAIN, (u8_t)(sizeof(REVERSE_PTR_TOPDOMAIN) - 1));
-  LWIP_ERROR("mdns_build_reverse_v6_domain: Failed to add label", (res == ERR_OK), return res);
-  res = mdns_domain_add_label(domain, NULL, 0);
-  LWIP_ERROR("mdns_build_reverse_v6_domain: Failed to add label", (res == ERR_OK), return res);
-
-  return ERR_OK;
-}
-#endif
-
-/* Add .local. to domain */
-static err_t
-mdns_add_dotlocal(struct mdns_domain *domain)
-{
-  err_t res = mdns_domain_add_label(domain, TOPDOMAIN_LOCAL, (u8_t)(sizeof(TOPDOMAIN_LOCAL) - 1));
-  LWIP_UNUSED_ARG(res);
-  LWIP_ERROR("mdns_add_dotlocal: Failed to add label", (res == ERR_OK), return res);
-  return mdns_domain_add_label(domain, NULL, 0);
-}
-
-/**
- * Build the \<hostname\>.local. domain name
- * @param domain Where to write the domain name
- * @param mdns TMDNS netif descriptor.
- * @return ERR_OK if domain \<hostname\>.local. was written, an err_t otherwise
- */
-err_t
-mdns_build_host_domain(struct mdns_domain *domain, struct mdns_host *mdns)
-{
-  err_t res;
-  LWIP_UNUSED_ARG(res);
-  memset(domain, 0, sizeof(struct mdns_domain));
-  LWIP_ERROR("mdns_build_host_domain: mdns != NULL", (mdns != NULL), return ERR_VAL);
-  res = mdns_domain_add_label(domain, mdns->name, (u8_t)strlen(mdns->name));
-  LWIP_ERROR("mdns_build_host_domain: Failed to add label", (res == ERR_OK), return res);
-  return mdns_add_dotlocal(domain);
-}
-
-/**
- * Build the lookup-all-services special DNS-SD domain name
- * @param domain Where to write the domain name
- * @return ERR_OK if domain _services._dns-sd._udp.local. was written, an err_t otherwise
- */
-err_t
-mdns_build_dnssd_domain(struct mdns_domain *domain)
-{
-  err_t res;
-  LWIP_UNUSED_ARG(res);
-  memset(domain, 0, sizeof(struct mdns_domain));
-  res = mdns_domain_add_label(domain, "_services", (u8_t)(sizeof("_services") - 1));
-  LWIP_ERROR("mdns_build_dnssd_domain: Failed to add label", (res == ERR_OK), return res);
-  res = mdns_domain_add_label(domain, "_dns-sd", (u8_t)(sizeof("_dns-sd") - 1));
-  LWIP_ERROR("mdns_build_dnssd_domain: Failed to add label", (res == ERR_OK), return res);
-  res = mdns_domain_add_label(domain, dnssd_protos[DNSSD_PROTO_UDP], (u8_t)strlen(dnssd_protos[DNSSD_PROTO_UDP]));
-  LWIP_ERROR("mdns_build_dnssd_domain: Failed to add label", (res == ERR_OK), return res);
-  return mdns_add_dotlocal(domain);
-}
-
-/**
- * Build domain name for a service
- * @param domain Where to write the domain name
- * @param service The service struct, containing service name, type and protocol
- * @param include_name Whether to include the service name in the domain
- * @return ERR_OK if domain was written. If service name is included,
- *         \<name\>.\<type\>.\<proto\>.local. will be written, otherwise \<type\>.\<proto\>.local.
- *         An err_t is returned on error.
- */
-err_t
-mdns_build_service_domain(struct mdns_domain *domain, struct mdns_service *service, int include_name)
-{
-  err_t res;
-  LWIP_UNUSED_ARG(res);
-  memset(domain, 0, sizeof(struct mdns_domain));
-  if (include_name) {
-    res = mdns_domain_add_label(domain, service->name, (u8_t)strlen(service->name));
-    LWIP_ERROR("mdns_build_service_domain: Failed to add label", (res == ERR_OK), return res);
-  }
-  res = mdns_domain_add_label(domain, service->service, (u8_t)strlen(service->service));
-  LWIP_ERROR("mdns_build_service_domain: Failed to add label", (res == ERR_OK), return res);
-  res = mdns_domain_add_label(domain, dnssd_protos[service->proto], (u8_t)strlen(dnssd_protos[service->proto]));
-  LWIP_ERROR("mdns_build_service_domain: Failed to add label", (res == ERR_OK), return res);
-  return mdns_add_dotlocal(domain);
-}
-
-#if LWIP_MDNS_SEARCH
-/**
- * Build domain name for a request
- * @param domain Where to write the domain name
- * @param request The request struct, containing service name, type and protocol
- * @param include_name Whether to include the service name in the domain
- * @return ERR_OK if domain was written. If service name is included,
- *         \<name\>.\<type\>.\<proto\>.local. will be written, otherwise \<type\>.\<proto\>.local.
- *         An err_t is returned on error.
- */
-err_t
-mdns_build_request_domain(struct mdns_domain *domain, struct mdns_request *request, int include_name)
-{
-  err_t res;
-  memset(domain, 0, sizeof(struct mdns_domain));
-  if (include_name) {
-    res = mdns_domain_add_label(domain, request->name, (u8_t)strlen(request->name));
-    LWIP_ERROR("mdns_build_request_domain: Failed to add label", (res == ERR_OK), return res);
-  }
-  res = mdns_domain_add_domain(domain, &request->service);
-  LWIP_ERROR("mdns_build_request_domain: Failed to add domain", (res == ERR_OK), return res);
-  res = mdns_domain_add_label(domain, dnssd_protos[request->proto], (u8_t)strlen(dnssd_protos[request->proto]));
-  LWIP_ERROR("mdns_build_request_domain: Failed to add label", (res == ERR_OK), return res);
-  return mdns_add_dotlocal(domain);
-}
-#endif
-
-/**
- * Return bytes needed to write before jump for best result of compressing supplied domain
- * against domain in outpacket starting at specified offset.
- * If a match is found, offset is updated to where to jump to
- * @param pbuf Pointer to pbuf with the partially constructed DNS packet
- * @param offset Start position of a domain written earlier. If this location is suitable
- *               for compression, the pointer is updated to where in the domain to jump to.
- * @param domain The domain to write
- * @return Number of bytes to write of the new domain before writing a jump to the offset.
- *         If compression can not be done against this previous domain name, the full new
- *         domain length is returned.
- */
-u16_t
-mdns_compress_domain(struct pbuf *pbuf, u16_t *offset, struct mdns_domain *domain)
-{
-  struct mdns_domain target;
-  u16_t target_end;
-  u8_t target_len;
-  u8_t writelen = 0;
-  u8_t *ptr;
-  if (pbuf == NULL) {
-    return domain->length;
-  }
-  target_end = mdns_readname(pbuf, *offset, &target);
-  if (target_end == MDNS_READNAME_ERROR) {
-    return domain->length;
-  }
-  target_len = (u8_t)(target_end - *offset);
-  ptr = domain->name;
-  while (writelen < domain->length) {
-    u8_t domainlen = (u8_t)(domain->length - writelen);
-    u8_t labellen;
-    if (domainlen <= target.length && domainlen > DOMAIN_JUMP_SIZE) {
-      /* Compare domains if target is long enough, and we have enough left of the domain */
-      u8_t targetpos = (u8_t)(target.length - domainlen);
-      if ((targetpos + DOMAIN_JUMP_SIZE) >= target_len) {
-        /* We are checking at or beyond a jump in the original, stop looking */
-        break;
-      }
-      if (target.length >= domainlen &&
-          memcmp(&domain->name[writelen], &target.name[targetpos], domainlen) == 0) {
-        *offset += targetpos;
-        return writelen;
-      }
-    }
-    /* Skip to next label in domain */
-    labellen = *ptr;
-    writelen += 1 + labellen;
-    ptr += 1 + labellen;
-  }
-  /* Nothing found */
-  return domain->length;
-}
-
-/**
- * Write domain to outpacket. Compression will be attempted,
- * unless domain->skip_compression is set.
- * @param outpkt The outpacket to write to
- * @param domain The domain name to write
- * @return ERR_OK on success, an err_t otherwise
- */
-err_t
-mdns_write_domain(struct mdns_outpacket *outpkt, struct mdns_domain *domain)
-{
-  int i;
-  err_t res;
-  u16_t writelen = domain->length;
-  u16_t jump_offset = 0;
-  u16_t jump;
-
-  if (!domain->skip_compression) {
-    for (i = 0; i < NUM_DOMAIN_OFFSETS; i++) {
-      u16_t offset = outpkt->domain_offsets[i];
-      if (offset) {
-        u16_t len = mdns_compress_domain(outpkt->pbuf, &offset, domain);
-        if (len < writelen) {
-          writelen = len;
-          jump_offset = offset;
-        }
-      }
-    }
-  }
-
-  if (writelen) {
-    /* Write uncompressed part of name */
-    res = pbuf_take_at(outpkt->pbuf, domain->name, writelen, outpkt->write_offset);
-    if (res != ERR_OK) {
-      return res;
-    }
-
-    /* Store offset of this new domain */
-    for (i = 0; i < NUM_DOMAIN_OFFSETS; i++) {
-      if (outpkt->domain_offsets[i] == 0) {
-        outpkt->domain_offsets[i] = outpkt->write_offset;
-        break;
-      }
-    }
-
-    outpkt->write_offset += writelen;
-  }
-  if (jump_offset) {
-    /* Write jump */
-    jump = lwip_htons(DOMAIN_JUMP | jump_offset);
-    res = pbuf_take_at(outpkt->pbuf, &jump, DOMAIN_JUMP_SIZE, outpkt->write_offset);
-    if (res != ERR_OK) {
-      return res;
-    }
-    outpkt->write_offset += DOMAIN_JUMP_SIZE;
-  }
-  return ERR_OK;
-}
-
-#endif /* LWIP_MDNS_RESPONDER */
diff --git a/src/apps/mdns/mdns_out.c b/src/apps/mdns/mdns_out.c
deleted file mode 100644
index 10a61929..00000000
--- a/src/apps/mdns/mdns_out.c
+++ /dev/null
@@ -1,1166 +0,0 @@
-/**
- * @file
- * MDNS responder implementation - output related functionalities
- */
-
-/*
- * Copyright (c) 2015 Verisure Innovation AB
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Erik Ekman <erik@kryo.se>
- * Author: Jasper Verschueren <jasper.verschueren@apart-audio.com>
- *
- */
-
-#include "lwip/apps/mdns_out.h"
-#include "lwip/apps/mdns_priv.h"
-#include "lwip/apps/mdns_domain.h"
-#include "lwip/prot/dns.h"
-#include "lwip/prot/iana.h"
-#include "lwip/udp.h"
-
-#include <string.h>
-
-#if LWIP_IPV6
-#include "lwip/prot/ip6.h"
-#endif
-
-
-#if LWIP_MDNS_RESPONDER
-
-/* Payload size allocated for each outgoing UDP packet */
-#define OUTPACKET_SIZE 500
-
-/* Function prototypes */
-static void mdns_clear_outmsg(struct mdns_outmsg *outmsg);
-
-/**
- * Call user supplied function to setup TXT data
- * @param service The service to build TXT record for
- */
-void
-mdns_prepare_txtdata(struct mdns_service *service)
-{
-  memset(&service->txtdata, 0, sizeof(struct mdns_domain));
-  if (service->txt_fn) {
-    service->txt_fn(service, service->txt_userdata);
-  }
-}
-
-/**
- * Write a question to an outpacket
- * A question contains domain, type and class. Since an answer also starts with these fields this function is also
- * called from mdns_add_answer().
- * @param outpkt The outpacket to write to
- * @param domain The domain name the answer is for
- * @param type The DNS type of the answer (like 'AAAA', 'SRV')
- * @param klass The DNS type of the answer (like 'IN')
- * @param unicast If highest bit in class should be set, to instruct the responder to
- *                reply with a unicast packet
- * @return ERR_OK on success, an err_t otherwise
- */
-static err_t
-mdns_add_question(struct mdns_outpacket *outpkt, struct mdns_domain *domain,
-                  u16_t type, u16_t klass, u16_t unicast)
-{
-  u16_t question_len;
-  u16_t field16;
-  err_t res;
-
-  if (!outpkt->pbuf) {
-    /* If no pbuf is active, allocate one */
-    outpkt->pbuf = pbuf_alloc(PBUF_TRANSPORT, OUTPACKET_SIZE, PBUF_RAM);
-    if (!outpkt->pbuf) {
-      return ERR_MEM;
-    }
-    outpkt->write_offset = SIZEOF_DNS_HDR;
-  }
-
-  /* Worst case calculation. Domain string might be compressed */
-  question_len = domain->length + sizeof(type) + sizeof(klass);
-  if (outpkt->write_offset + question_len > outpkt->pbuf->tot_len) {
-    /* No space */
-    return ERR_MEM;
-  }
-
-  /* Write name */
-  res = mdns_write_domain(outpkt, domain);
-  if (res != ERR_OK) {
-    return res;
-  }
-
-  /* Write type */
-  field16 = lwip_htons(type);
-  res = pbuf_take_at(outpkt->pbuf, &field16, sizeof(field16), outpkt->write_offset);
-  if (res != ERR_OK) {
-    return res;
-  }
-  outpkt->write_offset += sizeof(field16);
-
-  /* Write class */
-  if (unicast) {
-    klass |= 0x8000;
-  }
-  field16 = lwip_htons(klass);
-  res = pbuf_take_at(outpkt->pbuf, &field16, sizeof(field16), outpkt->write_offset);
-  if (res != ERR_OK) {
-    return res;
-  }
-  outpkt->write_offset += sizeof(field16);
-
-  return ERR_OK;
-}
-
-/**
- * Write answer to reply packet.
- * buf or answer_domain can be null. The rd_length written will be buf_length +
- * size of (compressed) domain. Most uses will need either buf or answer_domain,
- * special case is SRV that starts with 3 u16 and then a domain name.
- * @param reply The outpacket to write to
- * @param domain The domain name the answer is for
- * @param type The DNS type of the answer (like 'AAAA', 'SRV')
- * @param klass The DNS type of the answer (like 'IN')
- * @param cache_flush If highest bit in class should be set, to instruct receiver that
- *                    this reply replaces any earlier answer for this domain/type/class
- * @param ttl Validity time in seconds to send out for IP address data in DNS replies
- * @param buf Pointer to buffer of answer data
- * @param buf_length Length of variable data
- * @param answer_domain A domain to write after any buffer data as answer
- * @return ERR_OK on success, an err_t otherwise
- */
-static err_t
-mdns_add_answer(struct mdns_outpacket *reply, struct mdns_domain *domain,
-                u16_t type, u16_t klass, u16_t cache_flush, u32_t ttl,
-                const u8_t *buf, size_t buf_length, struct mdns_domain *answer_domain)
-{
-  u16_t answer_len;
-  u16_t field16;
-  u16_t rdlen_offset;
-  u16_t answer_offset;
-  u32_t field32;
-  err_t res;
-
-  if (!reply->pbuf) {
-    /* If no pbuf is active, allocate one */
-    reply->pbuf = pbuf_alloc(PBUF_TRANSPORT, OUTPACKET_SIZE, PBUF_RAM);
-    if (!reply->pbuf) {
-      return ERR_MEM;
-    }
-    reply->write_offset = SIZEOF_DNS_HDR;
-  }
-
-  /* Worst case calculation. Domain strings might be compressed */
-  answer_len = domain->length + sizeof(type) + sizeof(klass) + sizeof(ttl) + sizeof(field16)/*rd_length*/;
-  if (buf) {
-    answer_len += (u16_t)buf_length;
-  }
-  if (answer_domain) {
-    answer_len += answer_domain->length;
-  }
-  if (reply->write_offset + answer_len > reply->pbuf->tot_len) {
-    /* No space */
-    return ERR_MEM;
-  }
-
-  /* Answer starts with same data as question, then more fields */
-  mdns_add_question(reply, domain, type, klass, cache_flush);
-
-  /* Write TTL */
-  field32 = lwip_htonl(ttl);
-  res = pbuf_take_at(reply->pbuf, &field32, sizeof(field32), reply->write_offset);
-  if (res != ERR_OK) {
-    return res;
-  }
-  reply->write_offset += sizeof(field32);
-
-  /* Store offsets and skip forward to the data */
-  rdlen_offset = reply->write_offset;
-  reply->write_offset += sizeof(field16);
-  answer_offset = reply->write_offset;
-
-  if (buf) {
-    /* Write static data */
-    res = pbuf_take_at(reply->pbuf, buf, (u16_t)buf_length, reply->write_offset);
-    if (res != ERR_OK) {
-      return res;
-    }
-    reply->write_offset += (u16_t)buf_length;
-  }
-
-  if (answer_domain) {
-    /* Write name answer (compressed if possible) */
-    res = mdns_write_domain(reply, answer_domain);
-    if (res != ERR_OK) {
-      return res;
-    }
-  }
-
-  /* Write rd_length after when we know the answer size */
-  field16 = lwip_htons(reply->write_offset - answer_offset);
-  res = pbuf_take_at(reply->pbuf, &field16, sizeof(field16), rdlen_offset);
-
-  return res;
-}
-
-/** Write an ANY host question to outpacket */
-static err_t
-mdns_add_any_host_question(struct mdns_outpacket *outpkt,
-                           struct mdns_host *mdns,
-                           u16_t request_unicast_reply)
-{
-  struct mdns_domain host;
-  mdns_build_host_domain(&host, mdns);
-  LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Adding host question for ANY type\n"));
-  return mdns_add_question(outpkt, &host, DNS_RRTYPE_ANY, DNS_RRCLASS_IN,
-                           request_unicast_reply);
-}
-
-/** Write an ANY service instance question to outpacket */
-static err_t
-mdns_add_any_service_question(struct mdns_outpacket *outpkt,
-                              struct mdns_service *service,
-                              u16_t request_unicast_reply)
-{
-  struct mdns_domain domain;
-  mdns_build_service_domain(&domain, service, 1);
-  LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Adding service instance question for ANY type\n"));
-  return mdns_add_question(outpkt, &domain, DNS_RRTYPE_ANY, DNS_RRCLASS_IN,
-                           request_unicast_reply);
-}
-
-#if LWIP_IPV4
-/** Write an IPv4 address (A) RR to outpacket */
-static err_t
-mdns_add_a_answer(struct mdns_outpacket *reply, struct mdns_outmsg *msg,
-                  struct netif *netif)
-{
-  err_t res;
-  u32_t ttl = MDNS_TTL_120;
-  struct mdns_domain host;
-  mdns_build_host_domain(&host, netif_mdns_data(netif));
-  /* When answering to a legacy querier, we need to repeat the question and
-   * limit the ttl to the short legacy ttl */
-  if(msg->legacy_query) {
-    /* Repeating the question only needs to be done for the question asked
-     * (max one question), not for the additional records. */
-    if(reply->questions < 1) {
-      LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Add question for legacy query\n"));
-      res = mdns_add_question(reply, &host, DNS_RRTYPE_A, DNS_RRCLASS_IN, 0);
-      if (res != ERR_OK) {
-        return res;
-      }
-      reply->questions = 1;
-    }
-    /* ttl of legacy answer may not be greater then 10 seconds */
-    ttl = MDNS_TTL_10;
-  }
-  LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Responding with A record\n"));
-  return mdns_add_answer(reply, &host, DNS_RRTYPE_A, DNS_RRCLASS_IN, msg->cache_flush,
-                         ttl, (const u8_t *) netif_ip4_addr(netif),
-                         sizeof(ip4_addr_t), NULL);
-}
-
-/** Write a 4.3.2.1.in-addr.arpa -> hostname.local PTR RR to outpacket */
-static err_t
-mdns_add_hostv4_ptr_answer(struct mdns_outpacket *reply, struct mdns_outmsg *msg,
-                           struct netif *netif)
-{
-  err_t res;
-  u32_t ttl = MDNS_TTL_120;
-  struct mdns_domain host, revhost;
-  mdns_build_host_domain(&host, netif_mdns_data(netif));
-  mdns_build_reverse_v4_domain(&revhost, netif_ip4_addr(netif));
-  /* When answering to a legacy querier, we need to repeat the question and
-   * limit the ttl to the short legacy ttl */
-  if(msg->legacy_query) {
-    /* Repeating the question only needs to be done for the question asked
-     * (max one question), not for the additional records. */
-    if(reply->questions < 1) {
-      LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Add question for legacy query\n"));
-      res = mdns_add_question(reply, &revhost, DNS_RRTYPE_PTR, DNS_RRCLASS_IN, 0);
-      if (res != ERR_OK) {
-        return res;
-      }
-      reply->questions = 1;
-    }
-    /* ttl of legacy answer may not be greater then 10 seconds */
-    ttl = MDNS_TTL_10;
-  }
-  LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Responding with v4 PTR record\n"));
-  return mdns_add_answer(reply, &revhost, DNS_RRTYPE_PTR, DNS_RRCLASS_IN,
-                         msg->cache_flush, ttl, NULL, 0, &host);
-}
-#endif
-
-#if LWIP_IPV6
-/** Write an IPv6 address (AAAA) RR to outpacket */
-static err_t
-mdns_add_aaaa_answer(struct mdns_outpacket *reply, struct mdns_outmsg *msg,
-                     struct netif *netif, int addrindex)
-{
-  err_t res;
-  u32_t ttl = MDNS_TTL_120;
-  struct mdns_domain host;
-  mdns_build_host_domain(&host, netif_mdns_data(netif));
-  /* When answering to a legacy querier, we need to repeat the question and
-   * limit the ttl to the short legacy ttl */
-  if(msg->legacy_query) {
-    /* Repeating the question only needs to be done for the question asked
-     * (max one question), not for the additional records. */
-    if(reply->questions < 1) {
-      LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Add question for legacy query\n"));
-      res = mdns_add_question(reply, &host, DNS_RRTYPE_AAAA, DNS_RRCLASS_IN, 0);
-      if (res != ERR_OK) {
-        return res;
-      }
-      reply->questions = 1;
-    }
-    /* ttl of legacy answer may not be greater then 10 seconds */
-    ttl = MDNS_TTL_10;
-  }
-  LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Responding with AAAA record\n"));
-  return mdns_add_answer(reply, &host, DNS_RRTYPE_AAAA, DNS_RRCLASS_IN, msg->cache_flush,
-                         ttl, (const u8_t *) netif_ip6_addr(netif, addrindex),
-                         sizeof(ip6_addr_p_t), NULL);
-}
-
-/** Write a x.y.z.ip6.arpa -> hostname.local PTR RR to outpacket */
-static err_t
-mdns_add_hostv6_ptr_answer(struct mdns_outpacket *reply, struct mdns_outmsg *msg,
-                           struct netif *netif, int addrindex)
-{
-  err_t res;
-  u32_t ttl = MDNS_TTL_120;
-  struct mdns_domain host, revhost;
-  mdns_build_host_domain(&host, netif_mdns_data(netif));
-  mdns_build_reverse_v6_domain(&revhost, netif_ip6_addr(netif, addrindex));
-  /* When answering to a legacy querier, we need to repeat the question and
-   * limit the ttl to the short legacy ttl */
-  if(msg->legacy_query) {
-    /* Repeating the question only needs to be done for the question asked
-     * (max one question), not for the additional records. */
-    if(reply->questions < 1) {
-      LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Add question for legacy query\n"));
-      res = mdns_add_question(reply, &revhost, DNS_RRTYPE_PTR, DNS_RRCLASS_IN, 0);
-      if (res != ERR_OK) {
-        return res;
-      }
-      reply->questions = 1;
-    }
-    /* ttl of legacy answer may not be greater then 10 seconds */
-    ttl = MDNS_TTL_10;
-  }
-  LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Responding with v6 PTR record\n"));
-  return mdns_add_answer(reply, &revhost, DNS_RRTYPE_PTR, DNS_RRCLASS_IN,
-                         msg->cache_flush, ttl, NULL, 0, &host);
-}
-#endif
-
-/** Write an all-services -> servicetype PTR RR to outpacket */
-static err_t
-mdns_add_servicetype_ptr_answer(struct mdns_outpacket *reply, struct mdns_outmsg *msg,
-                                struct mdns_service *service)
-{
-  err_t res;
-  u32_t ttl = MDNS_TTL_4500;
-  struct mdns_domain service_type, service_dnssd;
-  mdns_build_service_domain(&service_type, service, 0);
-  mdns_build_dnssd_domain(&service_dnssd);
-  /* When answering to a legacy querier, we need to repeat the question and
-   * limit the ttl to the short legacy ttl */
-  if(msg->legacy_query) {
-    /* Repeating the question only needs to be done for the question asked
-     * (max one question), not for the additional records. */
-    if(reply->questions < 1) {
-      LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Add question for legacy query\n"));
-      res = mdns_add_question(reply, &service_dnssd, DNS_RRTYPE_PTR, DNS_RRCLASS_IN, 0);
-      if (res != ERR_OK) {
-        return res;
-      }
-      reply->questions = 1;
-    }
-    /* ttl of legacy answer may not be greater then 10 seconds */
-    ttl = MDNS_TTL_10;
-  }
-  LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Responding with service type PTR record\n"));
-  return mdns_add_answer(reply, &service_dnssd, DNS_RRTYPE_PTR, DNS_RRCLASS_IN,
-                         0, ttl, NULL, 0, &service_type);
-}
-
-/** Write a servicetype -> servicename PTR RR to outpacket */
-static err_t
-mdns_add_servicename_ptr_answer(struct mdns_outpacket *reply, struct mdns_outmsg *msg,
-                                struct mdns_service *service)
-{
-  err_t res;
-  u32_t ttl = MDNS_TTL_120;
-  struct mdns_domain service_type, service_instance;
-  mdns_build_service_domain(&service_type, service, 0);
-  mdns_build_service_domain(&service_instance, service, 1);
-  /* When answering to a legacy querier, we need to repeat the question and
-   * limit the ttl to the short legacy ttl */
-  if(msg->legacy_query) {
-    /* Repeating the question only needs to be done for the question asked
-     * (max one question), not for the additional records. */
-    if(reply->questions < 1) {
-      LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Add question for legacy query\n"));
-      res = mdns_add_question(reply, &service_type, DNS_RRTYPE_PTR, DNS_RRCLASS_IN, 0);
-      if (res != ERR_OK) {
-        return res;
-      }
-      reply->questions = 1;
-    }
-    /* ttl of legacy answer may not be greater then 10 seconds */
-    ttl = MDNS_TTL_10;
-  }
-  LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Responding with service name PTR record\n"));
-  return mdns_add_answer(reply, &service_type, DNS_RRTYPE_PTR, DNS_RRCLASS_IN,
-                         0, ttl, NULL, 0, &service_instance);
-}
-
-/** Write a SRV RR to outpacket */
-static err_t
-mdns_add_srv_answer(struct mdns_outpacket *reply, struct mdns_outmsg *msg,
-                    struct mdns_host *mdns, struct mdns_service *service)
-{
-  err_t res;
-  u32_t ttl = MDNS_TTL_120;
-  struct mdns_domain service_instance, srvhost;
-  u16_t srvdata[3];
-  mdns_build_service_domain(&service_instance, service, 1);
-  mdns_build_host_domain(&srvhost, mdns);
-  if (msg->legacy_query) {
-    /* RFC 6762 section 18.14:
-     * In legacy unicast responses generated to answer legacy queries,
-     * name compression MUST NOT be performed on SRV records.
-     */
-    srvhost.skip_compression = 1;
-    /* When answering to a legacy querier, we need to repeat the question and
-     * limit the ttl to the short legacy ttl.
-     * Repeating the question only needs to be done for the question asked
-     * (max one question), not for the additional records. */
-    if(reply->questions < 1) {
-      LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Add question for legacy query\n"));
-      res = mdns_add_question(reply, &service_instance, DNS_RRTYPE_SRV, DNS_RRCLASS_IN, 0);
-      if (res != ERR_OK) {
-        return res;
-      }
-      reply->questions = 1;
-    }
-    /* ttl of legacy answer may not be greater then 10 seconds */
-    ttl = MDNS_TTL_10;
-  }
-  srvdata[0] = lwip_htons(SRV_PRIORITY);
-  srvdata[1] = lwip_htons(SRV_WEIGHT);
-  srvdata[2] = lwip_htons(service->port);
-  LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Responding with SRV record\n"));
-  return mdns_add_answer(reply, &service_instance, DNS_RRTYPE_SRV, DNS_RRCLASS_IN,
-                         msg->cache_flush, ttl,
-                         (const u8_t *) &srvdata, sizeof(srvdata), &srvhost);
-}
-
-/** Write a TXT RR to outpacket */
-static err_t
-mdns_add_txt_answer(struct mdns_outpacket *reply, struct mdns_outmsg *msg,
-                    struct mdns_service *service)
-{
-  err_t res;
-  u32_t ttl = MDNS_TTL_120;
-  struct mdns_domain service_instance;
-  mdns_build_service_domain(&service_instance, service, 1);
-  mdns_prepare_txtdata(service);
-  /* When answering to a legacy querier, we need to repeat the question and
-   * limit the ttl to the short legacy ttl */
-  if(msg->legacy_query) {
-    /* Repeating the question only needs to be done for the question asked
-     * (max one question), not for the additional records. */
-    if(reply->questions < 1) {
-      LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Add question for legacy query\n"));
-      res = mdns_add_question(reply, &service_instance, DNS_RRTYPE_TXT, DNS_RRCLASS_IN, 0);
-      if (res != ERR_OK) {
-        return res;
-      }
-      reply->questions = 1;
-    }
-    /* ttl of legacy answer may not be greater then 10 seconds */
-    ttl = MDNS_TTL_10;
-  }
-  LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Responding with TXT record\n"));
-  return mdns_add_answer(reply, &service_instance, DNS_RRTYPE_TXT, DNS_RRCLASS_IN,
-                         msg->cache_flush, ttl, (u8_t *) &service->txtdata.name,
-                         service->txtdata.length, NULL);
-}
-
-
-static err_t
-mdns_add_probe_questions_to_outpacket(struct mdns_outpacket *outpkt, struct mdns_outmsg *msg,
-                                      struct netif *netif)
-{
-  err_t res;
-  int i;
-  struct mdns_host *mdns = netif_mdns_data(netif);
-
-  /* Write host questions (probing or legacy query) */
-  if(msg->host_questions & QUESTION_PROBE_HOST_ANY) {
-    res = mdns_add_any_host_question(outpkt, mdns, 1);
-    if (res != ERR_OK) {
-      return res;
-    }
-    outpkt->questions++;
-  }
-  /* Write service questions (probing or legacy query) */
-  for (i = 0; i < MDNS_MAX_SERVICES; i++) {
-    struct mdns_service* service = mdns->services[i];
-    if (!service) {
-      continue;
-    }
-    if(msg->serv_questions[i] & QUESTION_PROBE_SERVICE_NAME_ANY) {
-      res = mdns_add_any_service_question(outpkt, service, 1);
-      if (res != ERR_OK) {
-        return res;
-      }
-      outpkt->questions++;
-    }
-  }
-  return ERR_OK;
-}
-
-#if LWIP_MDNS_SEARCH
-static err_t
-mdns_add_query_question_to_outpacket(struct mdns_outpacket *outpkt, struct mdns_outmsg *msg)
-{
-  err_t res;
-  /* Write legacy query question */
-  if(msg->query) {
-    struct mdns_request *req = msg->query;
-    struct mdns_domain dom;
-    /* Build question domain */
-    mdns_build_request_domain(&dom, req, req->name[0]);
-    /* Add query question to output packet */
-    res = mdns_add_question(outpkt, &dom, req->qtype, DNS_RRCLASS_IN, 0);
-    if (res != ERR_OK) {
-      return res;
-    }
-    outpkt->questions++;
-  }
-  return ERR_OK;
-}
-#endif
-
-/**
- * Create packet with chosen answers as a reply
- *
- * Add all selected answers / questions
- * Add additional answers based on the selected answers
- */
-err_t
-mdns_create_outpacket(struct netif *netif, struct mdns_outmsg *msg,
-                      struct mdns_outpacket *outpkt)
-{
-  struct mdns_host *mdns = netif_mdns_data(netif);
-  struct mdns_service *service;
-  err_t res;
-  int i;
-  u16_t answers = 0;
-
-#if LWIP_MDNS_SEARCH
-  res = mdns_add_query_question_to_outpacket(outpkt, msg);
-  if (res != ERR_OK) {
-    return res;
-  }
-#endif
-
-  res = mdns_add_probe_questions_to_outpacket(outpkt, msg, netif);
-  if (res != ERR_OK) {
-    return res;
-  }
-
-  /* Write answers to host questions */
-#if LWIP_IPV4
-  if (msg->host_replies & REPLY_HOST_A) {
-    res = mdns_add_a_answer(outpkt, msg, netif);
-    if (res != ERR_OK) {
-      return res;
-    }
-    answers++;
-  }
-  if (msg->host_replies & REPLY_HOST_PTR_V4) {
-    res = mdns_add_hostv4_ptr_answer(outpkt, msg, netif);
-    if (res != ERR_OK) {
-      return res;
-    }
-    answers++;
-  }
-#endif
-#if LWIP_IPV6
-  if (msg->host_replies & REPLY_HOST_AAAA) {
-    int addrindex;
-    for (addrindex = 0; addrindex < LWIP_IPV6_NUM_ADDRESSES; addrindex++) {
-      if (ip6_addr_isvalid(netif_ip6_addr_state(netif, addrindex))) {
-        res = mdns_add_aaaa_answer(outpkt, msg, netif, addrindex);
-        if (res != ERR_OK) {
-          return res;
-        }
-        answers++;
-      }
-    }
-  }
-  if (msg->host_replies & REPLY_HOST_PTR_V6) {
-    u8_t rev_addrs = msg->host_reverse_v6_replies;
-    int addrindex = 0;
-    while (rev_addrs) {
-      if (rev_addrs & 1) {
-        res = mdns_add_hostv6_ptr_answer(outpkt, msg, netif, addrindex);
-        if (res != ERR_OK) {
-          return res;
-        }
-        answers++;
-      }
-      addrindex++;
-      rev_addrs >>= 1;
-    }
-  }
-#endif
-
-  /* Write answers to service questions */
-  for (i = 0; i < MDNS_MAX_SERVICES; i++) {
-    service = mdns->services[i];
-    if (!service) {
-      continue;
-    }
-
-    if (msg->serv_replies[i] & REPLY_SERVICE_TYPE_PTR) {
-      res = mdns_add_servicetype_ptr_answer(outpkt, msg, service);
-      if (res != ERR_OK) {
-        return res;
-      }
-      answers++;
-    }
-
-    if (msg->serv_replies[i] & REPLY_SERVICE_NAME_PTR) {
-      res = mdns_add_servicename_ptr_answer(outpkt, msg, service);
-      if (res != ERR_OK) {
-        return res;
-      }
-      answers++;
-    }
-
-    if (msg->serv_replies[i] & REPLY_SERVICE_SRV) {
-      res = mdns_add_srv_answer(outpkt, msg, mdns, service);
-      if (res != ERR_OK) {
-        return res;
-      }
-      answers++;
-    }
-
-    if (msg->serv_replies[i] & REPLY_SERVICE_TXT) {
-      res = mdns_add_txt_answer(outpkt, msg, service);
-      if (res != ERR_OK) {
-        return res;
-      }
-      answers++;
-    }
-  }
-
-  /* if this is a response, the data above is anwers, else this is a probe and
-   * the answers above goes into auth section */
-  if (msg->flags & DNS_FLAG1_RESPONSE) {
-    outpkt->answers += answers;
-  } else {
-    outpkt->authoritative += answers;
-  }
-
-  /* All answers written, add additional RRs */
-  for (i = 0; i < MDNS_MAX_SERVICES; i++) {
-    service = mdns->services[i];
-    if (!service) {
-      continue;
-    }
-
-    if (msg->serv_replies[i] & REPLY_SERVICE_NAME_PTR) {
-      /* Our service instance requested, include SRV & TXT
-       * if they are already not requested. */
-      if (!(msg->serv_replies[i] & REPLY_SERVICE_SRV)) {
-        res = mdns_add_srv_answer(outpkt, msg, mdns, service);
-        if (res != ERR_OK) {
-          return res;
-        }
-        outpkt->additional++;
-      }
-
-      if (!(msg->serv_replies[i] & REPLY_SERVICE_TXT)) {
-        res = mdns_add_txt_answer(outpkt, msg, service);
-        if (res != ERR_OK) {
-          return res;
-        }
-        outpkt->additional++;
-      }
-    }
-
-    /* If service instance, SRV, record or an IP address is requested,
-     * supply all addresses for the host
-     */
-    if ((msg->serv_replies[i] & (REPLY_SERVICE_NAME_PTR | REPLY_SERVICE_SRV)) ||
-        (msg->host_replies & (REPLY_HOST_A | REPLY_HOST_AAAA))) {
-#if LWIP_IPV6
-      if (!(msg->host_replies & REPLY_HOST_AAAA)) {
-        int addrindex;
-        for (addrindex = 0; addrindex < LWIP_IPV6_NUM_ADDRESSES; addrindex++) {
-          if (ip6_addr_isvalid(netif_ip6_addr_state(netif, addrindex))) {
-            res = mdns_add_aaaa_answer(outpkt, msg, netif, addrindex);
-            if (res != ERR_OK) {
-              return res;
-            }
-            outpkt->additional++;
-          }
-        }
-      }
-#endif
-#if LWIP_IPV4
-      if (!(msg->host_replies & REPLY_HOST_A) &&
-          !ip4_addr_isany_val(*netif_ip4_addr(netif))) {
-        res = mdns_add_a_answer(outpkt, msg, netif);
-        if (res != ERR_OK) {
-          return res;
-        }
-        outpkt->additional++;
-      }
-#endif
-    }
-  }
-
-  return res;
-}
-
-/**
- * Send chosen answers as a reply
- *
- * Create the packet
- * Send the packet
- */
-err_t
-mdns_send_outpacket(struct mdns_outmsg *msg, struct netif *netif)
-{
-  struct mdns_outpacket outpkt;
-  err_t res;
-
-  memset(&outpkt, 0, sizeof(outpkt));
-
-  res = mdns_create_outpacket(netif, msg, &outpkt);
-  if (res != ERR_OK) {
-    goto cleanup;
-  }
-
-  if (outpkt.pbuf) {
-    struct dns_hdr hdr;
-
-    /* Write header */
-    memset(&hdr, 0, sizeof(hdr));
-    hdr.flags1 = msg->flags;
-    hdr.numquestions = lwip_htons(outpkt.questions);
-    hdr.numanswers = lwip_htons(outpkt.answers);
-    hdr.numauthrr = lwip_htons(outpkt.authoritative);
-    hdr.numextrarr = lwip_htons(outpkt.additional);
-    hdr.id = lwip_htons(msg->tx_id);
-    pbuf_take(outpkt.pbuf, &hdr, sizeof(hdr));
-
-    /* Shrink packet */
-    pbuf_realloc(outpkt.pbuf, outpkt.write_offset);
-
-    /* Send created packet */
-    LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Sending packet, len=%d\n",
-                outpkt.write_offset));
-
-    res = udp_sendto_if(get_mdns_pcb(), outpkt.pbuf, &msg->dest_addr, msg->dest_port, netif);
-  }
-
-cleanup:
-  if (outpkt.pbuf) {
-    pbuf_free(outpkt.pbuf);
-    outpkt.pbuf = NULL;
-  }
-  return res;
-}
-
-#if LWIP_IPV4
-/**
- *  Called by timeouts when timer is passed, allows multicast IPv4 traffic again.
- *
- *  @param arg  pointer to netif of timeout.
- */
-void
-mdns_multicast_timeout_reset_ipv4(void *arg)
-{
-  struct netif *netif = (struct netif*)arg;
-  struct mdns_host *mdns = netif_mdns_data(netif);
-
-  LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: multicast timeout finished - IPv4\n"));
-
-  mdns->ipv4.multicast_timeout = 0;
-}
-
-/**
- *  Called by timeouts when timer is passed, allows direct multicast IPv4 probe
- *  response traffic again and sends out probe response if one was pending
- *
- *  @param arg  pointer to netif of timeout.
- */
-void
-mdns_multicast_probe_timeout_reset_ipv4(void *arg)
-{
-  struct netif *netif = (struct netif*)arg;
-  struct mdns_host *mdns = netif_mdns_data(netif);
-  err_t res;
-
-  LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: multicast probe timeout finished - IPv4\n"));
-
-  mdns->ipv4.multicast_probe_timeout = 0;
-
-  if (mdns->ipv4.multicast_msg_waiting) {
-    res = mdns_send_outpacket(&mdns->ipv4.delayed_msg_multicast, netif);
-    if(res != ERR_OK) {
-      LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Waiting probe multicast send failed - IPv4\n"));
-    }
-    else {
-      LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Waiting probe multicast send successful - IPv4\n"));
-      mdns_clear_outmsg(&mdns->ipv4.delayed_msg_multicast);
-      mdns->ipv4.multicast_msg_waiting = 0;
-      mdns_start_multicast_timeouts_ipv4(netif);
-    }
-  }
-}
-
-/**
- *  Called by timeouts when timer is passed, allows to send an answer on a QU
- *  question via multicast.
- *
- *  @param arg  pointer to netif of timeout.
- */
-void
-mdns_multicast_timeout_25ttl_reset_ipv4(void *arg)
-{
-  struct netif *netif = (struct netif*)arg;
-  struct mdns_host *mdns = netif_mdns_data(netif);
-
-  LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: multicast timeout 1/4 of ttl finished - IPv4\n"));
-
-  mdns->ipv4.multicast_timeout_25TTL = 0;
-}
-
-/**
- *  Called by timeouts when timer is passed, sends out delayed multicast IPv4 response.
- *
- *  @param arg  pointer to netif of timeout.
- */
-void
-mdns_send_multicast_msg_delayed_ipv4(void *arg)
-{
-  struct netif *netif = (struct netif*)arg;
-  struct mdns_host *mdns = netif_mdns_data(netif);
-  err_t res;
-
-  res = mdns_send_outpacket(&mdns->ipv4.delayed_msg_multicast, netif);
-  if(res != ERR_OK) {
-    LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Delayed multicast send failed - IPv4\n"));
-  }
-  else {
-    LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Delayed multicast send successful - IPv4\n"));
-    mdns_clear_outmsg(&mdns->ipv4.delayed_msg_multicast);
-    mdns->ipv4.multicast_msg_waiting = 0;
-    mdns_start_multicast_timeouts_ipv4(netif);
-  }
-}
-
-/**
- *  Called by timeouts when timer is passed, sends out delayed unicast IPv4 response.
- *
- *  @param arg  pointer to netif of timeout.
- */
-void
-mdns_send_unicast_msg_delayed_ipv4(void *arg)
-{
-  struct netif *netif = (struct netif*)arg;
-  struct mdns_host *mdns = netif_mdns_data(netif);
-  err_t res;
-
-  res = mdns_send_outpacket(&mdns->ipv4.delayed_msg_unicast, netif);
-  if(res != ERR_OK) {
-    LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Delayed unicast send failed - IPv4\n"));
-  }
-  else {
-    LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Delayed unicast send successful - IPv4\n"));
-    mdns_clear_outmsg(&mdns->ipv4.delayed_msg_unicast);
-    mdns->ipv4.unicast_msg_in_use = 0;
-  }
-}
-
-/** Start all multicast timeouts for IPv4
- *  Timeouts started:
- *    - do not multicast within one second
- *    - do not multicast a probe response within 250ms
- *    - send a multicast answer on a QU question if not send recently.
- *
- *  @param netif network interface to start timeouts on
- */
-void
-mdns_start_multicast_timeouts_ipv4(struct netif *netif)
-{
-  struct mdns_host *mdns = netif_mdns_data(netif);
-
-  mdns_set_timeout(netif, MDNS_MULTICAST_TIMEOUT, mdns_multicast_timeout_reset_ipv4,
-                   &mdns->ipv4.multicast_timeout);
-  LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: multicast timeout started - IPv4\n"));
-  mdns_set_timeout(netif, MDNS_MULTICAST_PROBE_TIMEOUT, mdns_multicast_probe_timeout_reset_ipv4,
-                   &mdns->ipv4.multicast_probe_timeout);
-  LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: multicast probe timeout started - IPv4\n"));
-  mdns_set_timeout(netif, MDNS_MULTICAST_TIMEOUT_25TTL, mdns_multicast_timeout_25ttl_reset_ipv4,
-                   &mdns->ipv4.multicast_timeout_25TTL);
-  LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: multicast timeout 1/4 of ttl started - IPv4\n"));
-}
-#endif
-
-#if LWIP_IPV6
-/**
- *  Called by timeouts when timer is passed, allows multicast IPv6 traffic again.
- *
- *  @param arg  pointer to netif of timeout.
- */
-void
-mdns_multicast_timeout_reset_ipv6(void *arg)
-{
-  struct netif *netif = (struct netif*)arg;
-  struct mdns_host *mdns = netif_mdns_data(netif);
-
-  LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: multicast timeout finished - IPv6\n"));
-
-  mdns->ipv6.multicast_timeout = 0;
-}
-
-/**
- *  Called by timeouts when timer is passed, allows direct multicast IPv6 probe
- *  response traffic again and sends out probe response if one was pending
- *
- *  @param arg  pointer to netif of timeout.
- */
-void
-mdns_multicast_probe_timeout_reset_ipv6(void *arg)
-{
-  struct netif *netif = (struct netif*)arg;
-  struct mdns_host *mdns = netif_mdns_data(netif);
-  err_t res;
-
-  LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: multicast probe timeout finished - IPv6\n"));
-
-  mdns->ipv6.multicast_probe_timeout = 0;
-
-  if (mdns->ipv6.multicast_msg_waiting) {
-    res = mdns_send_outpacket(&mdns->ipv6.delayed_msg_multicast, netif);
-    if(res != ERR_OK) {
-      LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Waiting probe multicast send failed - IPv6\n"));
-    }
-    else {
-      LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Waiting probe multicast send successful - IPv6\n"));
-      mdns_clear_outmsg(&mdns->ipv6.delayed_msg_multicast);
-      mdns->ipv6.multicast_msg_waiting = 0;
-      mdns_start_multicast_timeouts_ipv6(netif);
-    }
-  }
-}
-
-/**
- *  Called by timeouts when timer is passed, allows to send an answer on a QU
- *  question via multicast.
- *
- *  @param arg  pointer to netif of timeout.
- */
-void
-mdns_multicast_timeout_25ttl_reset_ipv6(void *arg)
-{
-  struct netif *netif = (struct netif*)arg;
-  struct mdns_host *mdns = netif_mdns_data(netif);
-
-  LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: multicast timeout 1/4 of ttl finished - IPv6\n"));
-
-  mdns->ipv6.multicast_timeout_25TTL = 0;
-}
-
-/**
- *  Called by timeouts when timer is passed, sends out delayed multicast IPv6 response.
- *
- *  @param arg  pointer to netif of timeout.
- */
-void
-mdns_send_multicast_msg_delayed_ipv6(void *arg)
-{
-  struct netif *netif = (struct netif*)arg;
-  struct mdns_host *mdns = netif_mdns_data(netif);
-  err_t res;
-
-  res = mdns_send_outpacket(&mdns->ipv6.delayed_msg_multicast, netif);
-  if(res != ERR_OK) {
-    LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Delayed multicast send failed - IPv6\n"));
-  }
-  else {
-    LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Delayed multicast send successful - IPv6\n"));
-    mdns_clear_outmsg(&mdns->ipv6.delayed_msg_multicast);
-    mdns->ipv6.multicast_msg_waiting = 0;
-    mdns_start_multicast_timeouts_ipv6(netif);
-  }
-}
-
-/**
- *  Called by timeouts when timer is passed, sends out delayed unicast IPv6 response.
- *
- *  @param arg  pointer to netif of timeout.
- */
-void
-mdns_send_unicast_msg_delayed_ipv6(void *arg)
-{
-  struct netif *netif = (struct netif*)arg;
-  struct mdns_host *mdns = netif_mdns_data(netif);
-  err_t res;
-
-  res = mdns_send_outpacket(&mdns->ipv6.delayed_msg_unicast, netif);
-  if(res != ERR_OK) {
-    LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Delayed unicast send failed - IPv6\n"));
-  }
-  else {
-    LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Delayed unicast send successful - IPv6\n"));
-    mdns_clear_outmsg(&mdns->ipv6.delayed_msg_unicast);
-    mdns->ipv6.unicast_msg_in_use = 0;
-  }
-}
-
-/** Start all multicast timeouts for IPv6
- *  Timeouts started:
- *    - do not multicast within one second
- *    - do not multicast a probe response within 250ms
- *    - send a multicast answer on a QU question if not send recently.
- *
- *  @param netif network interface to start timeouts on
- */
-void
-mdns_start_multicast_timeouts_ipv6(struct netif *netif)
-{
-  struct mdns_host *mdns = netif_mdns_data(netif);
-
-  mdns_set_timeout(netif, MDNS_MULTICAST_TIMEOUT, mdns_multicast_timeout_reset_ipv6,
-                   &mdns->ipv6.multicast_timeout);
-  LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: multicast timeout started - IPv6\n"));
-  mdns_set_timeout(netif, MDNS_MULTICAST_PROBE_TIMEOUT, mdns_multicast_probe_timeout_reset_ipv6,
-                   &mdns->ipv6.multicast_probe_timeout);
-  LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: multicast probe timeout started - IPv6\n"));
-  mdns_set_timeout(netif, MDNS_MULTICAST_TIMEOUT_25TTL, mdns_multicast_timeout_25ttl_reset_ipv6,
-                   &mdns->ipv6.multicast_timeout_25TTL);
-  LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: multicast timeout 1/4 of ttl started - IPv6\n"));
-}
-#endif
-
-/**
- *  This function clears the output message without changing the destination
- *  address or port. This is useful for clearing the delayed msg structs without
- *  loosing the set IP.
- *
- *  @param outmsg pointer to output message to clear.
- */
-static void
-mdns_clear_outmsg(struct mdns_outmsg *outmsg)
-{
-  int i;
-
-  outmsg->tx_id = 0;
-  outmsg->flags = 0;
-  outmsg->cache_flush = 0;
-  outmsg->unicast_reply_requested = 0;
-  outmsg->legacy_query = 0;
-  outmsg->probe_query_recv = 0;
-  outmsg->host_questions = 0;
-  outmsg->host_replies = 0;
-  outmsg->host_reverse_v6_replies = 0;
-
-  for(i = 0; i < MDNS_MAX_SERVICES; i++) {
-    outmsg->serv_questions[i] = 0;
-    outmsg->serv_replies[i] = 0;
-  }
-}
-
-/**
- *  Sets a timer that calls the handler when finished.
- *  Depending on the busy_flag the timer is restarted or started. The flag is
- *  set before return. Sys_timeout does not give us this functionality.
- *
- *  @param netif      Network interface info
- *  @param msecs      Time value to set
- *  @param handler    Callback function to call
- *  @param busy_flag  Pointer to flag that displays if the timer is running or not.
- */
-void
-mdns_set_timeout(struct netif *netif, u32_t msecs, sys_timeout_handler handler,
-                 u8_t *busy_flag)
-{
-  if(*busy_flag) {
-    /* restart timer */
-    sys_untimeout(handler, netif);
-    sys_timeout(msecs, handler, netif);
-  }
-  else {
-    /* start timer */
-    sys_timeout(msecs, handler, netif);
-  }
-  /* Now we have a timer running */
-  *busy_flag = 1;
-}
-
-#ifdef LWIP_MDNS_SEARCH
-/**
- * Send search request containing all our known data
- * @param req The request to send
- * @param netif The network interface to send on
- * @param destination The target address to send to (usually multicast address)
- */
-err_t
-mdns_send_request(struct mdns_request *req, struct netif *netif, const ip_addr_t *destination)
-{
-  struct mdns_outmsg outmsg;
-  err_t res;
-
-  memset(&outmsg, 0, sizeof(outmsg));
-  outmsg.query = req;
-  outmsg.dest_port = LWIP_IANA_PORT_MDNS;
-  SMEMCPY(&outmsg.dest_addr, destination, sizeof(outmsg.dest_addr));
-  res = mdns_send_outpacket(&outmsg, netif);
-  if(res != ERR_OK) {
-    LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Multicast query request send failed\n"));
-  }
-  else {
-    LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Multicast query request send successful\n"));
-  }
-  return res;
-}
-#endif
-
-#endif /* LWIP_MDNS_RESPONDER */
diff --git a/src/apps/mqtt/mqtt.c b/src/apps/mqtt/mqtt.c
index fab1da8a..269f4a49 100644
--- a/src/apps/mqtt/mqtt.c
+++ b/src/apps/mqtt/mqtt.c
@@ -664,24 +664,25 @@ mqtt_incomming_suback(struct mqtt_request_t *r, u8_t result)
 /**
  * Complete MQTT message received or buffer full
  * @param client MQTT client
- * @param fixed_hdr_len length of fixed header
+ * @param fixed_hdr_idx header index
  * @param length length received part
  * @param remaining_length Remaining length of complete message
  */
 static mqtt_connection_status_t
-mqtt_message_received(mqtt_client_t *client, u8_t fixed_hdr_len, u16_t length, u32_t remaining_length)
+mqtt_message_received(mqtt_client_t *client, u8_t fixed_hdr_idx, u16_t length, u32_t remaining_length)
 {
   mqtt_connection_status_t res = MQTT_CONNECT_ACCEPTED;
 
-  u8_t *var_hdr_payload = client->rx_buffer + fixed_hdr_len;
-  size_t var_hdr_payload_bufsize = sizeof(client->rx_buffer) - fixed_hdr_len;
+  u8_t *var_hdr_payload = client->rx_buffer + fixed_hdr_idx;
+  size_t var_hdr_payload_bufsize = sizeof(client->rx_buffer) - fixed_hdr_idx;
 
   /* Control packet type */
   u8_t pkt_type = MQTT_CTL_PACKET_TYPE(client->rx_buffer[0]);
   u16_t pkt_id = 0;
 
-  LWIP_ASSERT("fixed_hdr_len <= client->msg_idx", fixed_hdr_len <= client->msg_idx);
-  LWIP_ERROR("buffer length mismatch", fixed_hdr_len + length <= MQTT_VAR_HEADER_BUFFER_LEN,
+  LWIP_ASSERT("client->msg_idx < MQTT_VAR_HEADER_BUFFER_LEN", client->msg_idx < MQTT_VAR_HEADER_BUFFER_LEN);
+  LWIP_ASSERT("fixed_hdr_idx <= client->msg_idx", fixed_hdr_idx <= client->msg_idx);
+  LWIP_ERROR("buffer length mismatch", fixed_hdr_idx + length <= MQTT_VAR_HEADER_BUFFER_LEN,
              return MQTT_CONNECT_DISCONNECTED);
 
   if (pkt_type == MQTT_MSG_TYPE_CONNACK) {
@@ -839,59 +840,61 @@ mqtt_parse_incoming(mqtt_client_t *client, struct pbuf *p)
 {
   u16_t in_offset = 0;
   u32_t msg_rem_len = 0;
-  u8_t fixed_hdr_len = 0;
+  u8_t fixed_hdr_idx = 0;
   u8_t b = 0;
 
   while (p->tot_len > in_offset) {
     /* We ALWAYS parse the header here first. Even if the header was not
        included in this segment, we re-parse it here by buffering it in
        client->rx_buffer. client->msg_idx keeps track of this. */
-    if ((fixed_hdr_len < 2) || ((b & 0x80) != 0)) {
+    if ((fixed_hdr_idx < 2) || ((b & 0x80) != 0)) {
 
-      if (fixed_hdr_len < client->msg_idx) {
+      if (fixed_hdr_idx < client->msg_idx) {
         /* parse header from old pbuf (buffered in client->rx_buffer) */
-        b = client->rx_buffer[fixed_hdr_len];
+        b = client->rx_buffer[fixed_hdr_idx];
       } else {
         /* parse header from this pbuf and save it in client->rx_buffer in case
            it comes in segmented */
         b = pbuf_get_at(p, in_offset++);
         client->rx_buffer[client->msg_idx++] = b;
       }
-      fixed_hdr_len++;
+      fixed_hdr_idx++;
 
-      if (fixed_hdr_len >= 2) {
+      if (fixed_hdr_idx >= 2) {
         /* fixed header contains at least 2 bytes but can contain more, depending on
            'remaining length'. All bytes but the last of this have 0x80 set to
            indicate more bytes are coming. */
-        msg_rem_len |= (u32_t)(b & 0x7f) << ((fixed_hdr_len - 2) * 7);
+        msg_rem_len |= (u32_t)(b & 0x7f) << ((fixed_hdr_idx - 2) * 7);
         if ((b & 0x80) == 0) {
           /* fixed header is done */
           LWIP_DEBUGF(MQTT_DEBUG_TRACE, ("mqtt_parse_incoming: Remaining length after fixed header: %"U32_F"\n", msg_rem_len));
           if (msg_rem_len == 0) {
             /* Complete message with no extra headers of payload received */
-            mqtt_message_received(client, fixed_hdr_len, 0, 0);
+            mqtt_message_received(client, fixed_hdr_idx, 0, 0);
             client->msg_idx = 0;
-            fixed_hdr_len = 0;
+            fixed_hdr_idx = 0;
           } else {
             /* Bytes remaining in message (changes remaining length if this is
                not the first segment of this message) */
-            msg_rem_len = (msg_rem_len + fixed_hdr_len) - client->msg_idx;
+            msg_rem_len = (msg_rem_len + fixed_hdr_idx) - client->msg_idx;
           }
         }
       }
     } else {
       /* Fixed header has been parsed, parse variable header */
-      u16_t cpy_len, buffer_space;
+      u16_t cpy_len, cpy_start, buffer_space;
+
+      cpy_start = (client->msg_idx - fixed_hdr_idx) % (MQTT_VAR_HEADER_BUFFER_LEN - fixed_hdr_idx) + fixed_hdr_idx;
 
       /* Allow to copy the lesser one of available length in input data or bytes remaining in message */
       cpy_len = (u16_t)LWIP_MIN((u16_t)(p->tot_len - in_offset), msg_rem_len);
 
       /* Limit to available space in buffer */
-      buffer_space = MQTT_VAR_HEADER_BUFFER_LEN - fixed_hdr_len;
+      buffer_space = MQTT_VAR_HEADER_BUFFER_LEN - cpy_start;
       if (cpy_len > buffer_space) {
         cpy_len = buffer_space;
       }
-      pbuf_copy_partial(p, client->rx_buffer + fixed_hdr_len, cpy_len, in_offset);
+      pbuf_copy_partial(p, client->rx_buffer + cpy_start, cpy_len, in_offset);
 
       /* Advance get and put indexes  */
       client->msg_idx += cpy_len;
@@ -901,7 +904,7 @@ mqtt_parse_incoming(mqtt_client_t *client, struct pbuf *p)
       LWIP_DEBUGF(MQTT_DEBUG_TRACE, ("mqtt_parse_incoming: msg_idx: %"U32_F", cpy_len: %"U16_F", remaining %"U32_F"\n", client->msg_idx, cpy_len, msg_rem_len));
       if ((msg_rem_len == 0) || (cpy_len == buffer_space)) {
         /* Whole message received or buffer is full */
-        mqtt_connection_status_t res = mqtt_message_received(client, fixed_hdr_len, cpy_len, msg_rem_len);
+        mqtt_connection_status_t res = mqtt_message_received(client, fixed_hdr_idx, (cpy_start + cpy_len) - fixed_hdr_idx, msg_rem_len);
         if (res != MQTT_CONNECT_ACCEPTED) {
           return res;
         }
@@ -909,7 +912,7 @@ mqtt_parse_incoming(mqtt_client_t *client, struct pbuf *p)
           /* Reset parser state */
           client->msg_idx = 0;
           /* msg_tot_len = 0; */
-          fixed_hdr_len = 0;
+          fixed_hdr_idx = 0;
         }
       }
     }
diff --git a/src/apps/netbiosns/netbiosns.c b/src/apps/netbiosns/netbiosns.c
index 479c375b..c94a7791 100644
--- a/src/apps/netbiosns/netbiosns.c
+++ b/src/apps/netbiosns/netbiosns.c
@@ -240,12 +240,12 @@ static struct udp_pcb *netbiosns_pcb;
 
 /** Decode a NetBIOS name (from packet to string) */
 static int
-netbiosns_name_decode(const char *name_enc, char *name_dec, int name_dec_len)
+netbiosns_name_decode(char *name_enc, char *name_dec, int name_dec_len)
 {
-  const char *pname;
-  char       cname;
-  char       cnbname;
-  int        idx = 0;
+  char *pname;
+  char  cname;
+  char  cnbname;
+  int   idx = 0;
 
   LWIP_UNUSED_ARG(name_dec_len);
 
diff --git a/src/apps/smtp/smtp.c b/src/apps/smtp/smtp.c
index a87b1761..55303c35 100644
--- a/src/apps/smtp/smtp.c
+++ b/src/apps/smtp/smtp.c
@@ -1,12 +1,12 @@
 /**
  * @file
  * SMTP client module
- *
+ * 
  * Author: Simon Goldschmidt
  *
  * @defgroup smtp SMTP client
  * @ingroup apps
- *
+ * 
  * This is simple SMTP client for raw API.
  * It is a minimal implementation of SMTP as specified in RFC 5321.
  *
@@ -29,7 +29,7 @@
 
  * When using from any other thread than the tcpip_thread (for NO_SYS==0), use
  * smtp_send_mail_int()!
- *
+ * 
  * SMTP_BODYDH usage:
 @code{.c}
  int my_smtp_bodydh_fn(void *arg, struct smtp_bodydh *bdh)
@@ -42,11 +42,11 @@
     ++bdh->state;
     return BDH_WORKING;
  }
-
- smtp_send_mail_bodycback("sender", "recipient", "subject",
+ 
+ smtp_send_mail_bodycback("sender", "recipient", "subject", 
                 my_smtp_bodydh_fn, my_smtp_result_fn, some_argument);
 @endcode
- *
+ * 
  * @todo:
  * - attachments (the main difficulty here is streaming base64-encoding to
  *   prevent having to allocate a buffer for the whole encoded file at once)
@@ -1498,6 +1498,7 @@ smtp_send_mail_bodycback(const char *from, const char* to, const char* subject,
   LWIP_ASSERT("string is too long", len <= 0xffff);
   s->subject_len = (u16_t)len;
   s->body = NULL;
+  LWIP_ASSERT("string is too long", len <= 0xffff);
   s->callback_fn = callback_fn;
   s->callback_arg = callback_arg;
   s->bodydh->callback_fn = bodycback_fn;
diff --git a/src/apps/snmp/snmp_core.c b/src/apps/snmp/snmp_core.c
index 95d0ff78..987f1066 100644
--- a/src/apps/snmp/snmp_core.c
+++ b/src/apps/snmp/snmp_core.c
@@ -37,8 +37,8 @@
  * @defgroup snmp SNMPv2c/v3 agent
  * @ingroup apps
  * SNMPv2c and SNMPv3 compatible agent\n
- * There is also a MIB compiler and a MIB viewer in lwIP/contrib subdir
- * (lwip/contrib/apps/LwipMibCompiler).\n
+ * There is also a MIB compiler and a MIB viewer in lwIP contrib repository
+ * (lwip-contrib/apps/LwipMibCompiler).\n
  * The agent implements the most important MIB2 MIBs including IPv6 support
  * (interfaces, UDP, TCP, SNMP, ICMP, SYSTEM). IP MIB is an older version
  * without IPv6 statistics (TODO).\n
diff --git a/src/apps/snmp/snmp_msg.c b/src/apps/snmp/snmp_msg.c
index 8b2b8a82..0b6693a7 100644
--- a/src/apps/snmp/snmp_msg.c
+++ b/src/apps/snmp/snmp_msg.c
@@ -71,11 +71,8 @@ const char *snmp_community_write = SNMP_COMMUNITY_WRITE;
 /** SNMP community string for sending traps */
 const char *snmp_community_trap = SNMP_COMMUNITY_TRAP;
 
-snmp_write_callback_fct snmp_write_callback;
-void *snmp_write_callback_arg;
-
-snmp_inform_callback_fct snmp_inform_callback;
-void *snmp_inform_callback_arg;
+snmp_write_callback_fct snmp_write_callback     = NULL;
+void                   *snmp_write_callback_arg = NULL;
 
 #if LWIP_SNMP_CONFIGURE_VERSIONS
 
@@ -252,17 +249,6 @@ snmp_set_write_callback(snmp_write_callback_fct write_callback, void *callback_a
   snmp_write_callback_arg = callback_arg;
 }
 
-/**
- * @ingroup snmp_core
- * Callback fired on every received INFORM confirmation (get-response)
- */
-void
-snmp_set_inform_callback(snmp_inform_callback_fct inform_callback, void* callback_arg)
-{
-  snmp_inform_callback     = inform_callback;
-  snmp_inform_callback_arg = callback_arg;
-}
-
 /* ----------------------------------------------------------------------- */
 /* forward declarations */
 /* ----------------------------------------------------------------------- */
@@ -298,16 +284,6 @@ snmp_receive(void *handle, struct pbuf *p, const ip_addr_t *source_ip, u16_t por
 
   err = snmp_parse_inbound_frame(&request);
   if (err == ERR_OK) {
-    if (request.request_type == SNMP_ASN1_CONTEXT_PDU_GET_RESP) {
-      if (request.error_status == SNMP_ERR_NOERROR) {
-        /* If callback function has been defined call it. */
-        if (snmp_inform_callback != NULL) {
-          snmp_inform_callback(&request, snmp_inform_callback_arg);
-        }
-      }
-      /* stop further handling of GET RESP PDU, we are an agent */
-      return;
-    }
     err = snmp_prepare_outbound_frame(&request);
     if (err == ERR_OK) {
 
@@ -839,7 +815,7 @@ snmp_parse_inbound_frame(struct snmp_request *request)
     /* @todo: Differentiate read/write access */
     strncpy((char *)request->community, snmp_community, SNMP_MAX_COMMUNITY_STR_LEN);
     request->community[SNMP_MAX_COMMUNITY_STR_LEN] = 0; /* ensure NULL termination (strncpy does NOT guarantee it!) */
-    request->community_strlen = (u16_t)strlen((char *)request->community);
+    request->community_strlen = (u16_t)strnlen((char *)request->community, SNMP_MAX_COMMUNITY_STR_LEN);
 
     /* RFC3414 globalData */
     IF_PARSE_EXEC(snmp_asn1_dec_tlv(&pbuf_stream, &tlv));
@@ -1198,10 +1174,6 @@ snmp_parse_inbound_frame(struct snmp_request *request)
       /* SetRequest PDU */
       snmp_stats.insetrequests++;
       break;
-    case (SNMP_ASN1_CLASS_CONTEXT | SNMP_ASN1_CONTENTTYPE_CONSTRUCTED | SNMP_ASN1_CONTEXT_PDU_GET_RESP):
-      /* GetResponse PDU */
-      snmp_stats.ingetresponses++;
-      break;
     default:
       /* unsupported input PDU for this agent (no parse error) */
       LWIP_DEBUGF(SNMP_DEBUG, ("Unknown/Invalid SNMP PDU type received: %d", tlv.type)); \
diff --git a/src/apps/snmp/snmp_traps.c b/src/apps/snmp/snmp_traps.c
index 3f83f2df..3c9c8176 100644
--- a/src/apps/snmp/snmp_traps.c
+++ b/src/apps/snmp/snmp_traps.c
@@ -1,6 +1,6 @@
 /**
  * @file
- * SNMPv1 and SNMPv2 traps implementation.
+ * SNMPv1 traps implementation.
  */
 
 /*
@@ -51,11 +51,7 @@
 #include "snmp_asn1.h"
 #include "snmp_core_priv.h"
 
-#define SNMP_IS_INFORM                            1
-#define SNMP_IS_TRAP                              0
-
-struct snmp_msg_trap
-{
+struct snmp_msg_trap {
   /* source enterprise ID (sysObjectID) */
   const struct snmp_obj_id *enterprise;
   /* source IP address, raw network order format */
@@ -78,26 +74,12 @@ struct snmp_msg_trap
   u16_t seqlen;
   /* encoding varbinds sequence length */
   u16_t vbseqlen;
-
-  /* error status */
-  s32_t error_status;
-  /* error index */
-  s32_t error_index;
-  /* trap or inform? */
-  u8_t trap_or_inform;
 };
 
 static u16_t snmp_trap_varbind_sum(struct snmp_msg_trap *trap, struct snmp_varbind *varbinds);
 static u16_t snmp_trap_header_sum(struct snmp_msg_trap *trap, u16_t vb_len);
 static err_t snmp_trap_header_enc(struct snmp_msg_trap *trap, struct snmp_pbuf_stream *pbuf_stream);
 static err_t snmp_trap_varbind_enc(struct snmp_msg_trap *trap, struct snmp_pbuf_stream *pbuf_stream, struct snmp_varbind *varbinds);
-static u16_t snmp_trap_header_sum_v1_specific(struct snmp_msg_trap *trap);
-static u16_t snmp_trap_header_sum_v2c_specific(struct snmp_msg_trap *trap);
-static err_t snmp_trap_header_enc_v1_specific(struct snmp_msg_trap *trap, struct snmp_pbuf_stream *pbuf_stream);
-static err_t snmp_trap_header_enc_v2c_specific(struct snmp_msg_trap *trap, struct snmp_pbuf_stream *pbuf_stream);
-static err_t snmp_prepare_trap_oid(struct snmp_obj_id *dest_snmp_trap_oid, const struct snmp_obj_id *eoid, s32_t generic_trap, s32_t specific_trap);
-static void snmp_prepare_necessary_msg_fields(struct snmp_msg_trap *trap_msg, const struct snmp_obj_id *eoid, s32_t generic_trap, s32_t specific_trap, struct snmp_varbind *varbinds);
-static err_t snmp_send_msg(struct snmp_msg_trap *trap_msg, struct snmp_varbind *varbinds, u16_t tot_len, ip_addr_t *dip);
 
 #define BUILD_EXEC(code) \
   if ((code) != ERR_OK) { \
@@ -110,12 +92,7 @@ extern const char *snmp_community_trap;
 
 void *snmp_traps_handle;
 
-/**
- * @ingroup snmp_traps
- * @struct snmp_trap_dst
- */
-struct snmp_trap_dst
-{
+struct snmp_trap_dst {
   /* destination IP address in network order */
   ip_addr_t dip;
   /* set to 0 when disabled, >0 when enabled */
@@ -125,19 +102,11 @@ static struct snmp_trap_dst trap_dst[SNMP_TRAP_DESTINATIONS];
 
 static u8_t snmp_auth_traps_enabled = 0;
 
-/* This is used in functions like snmp_coldstart_trap where user didn't specify which version of trap to use */
-static u8_t snmp_default_trap_version = SNMP_VERSION_1;
-
-/* This is used in trap messages v2c */
-static s32_t req_id = 1;
-
 /**
  * @ingroup snmp_traps
  * Sets enable switch for this trap destination.
  * @param dst_idx index in 0 .. SNMP_TRAP_DESTINATIONS-1
  * @param enable switch if 0 destination is disabled >0 enabled.
- *
- * @retval void
  */
 void
 snmp_trap_dst_enable(u8_t dst_idx, u8_t enable)
@@ -153,8 +122,6 @@ snmp_trap_dst_enable(u8_t dst_idx, u8_t enable)
  * Sets IPv4 address for this trap destination.
  * @param dst_idx index in 0 .. SNMP_TRAP_DESTINATIONS-1
  * @param dst IPv4 address in host order.
- *
- * @retval void
  */
 void
 snmp_trap_dst_ip_set(u8_t dst_idx, const ip_addr_t *dst)
@@ -168,10 +135,6 @@ snmp_trap_dst_ip_set(u8_t dst_idx, const ip_addr_t *dst)
 /**
  * @ingroup snmp_traps
  * Enable/disable authentication traps
- *
- * @param enable enable SNMP traps
- *
- * @retval void
  */
 void
 snmp_set_auth_traps_enabled(u8_t enable)
@@ -182,8 +145,6 @@ snmp_set_auth_traps_enabled(u8_t enable)
 /**
  * @ingroup snmp_traps
  * Get authentication traps enabled state
- *
- * @return TRUE if traps are enabled, FALSE if they aren't
  */
 u8_t
 snmp_get_auth_traps_enabled(void)
@@ -191,146 +152,11 @@ snmp_get_auth_traps_enabled(void)
   return snmp_auth_traps_enabled;
 }
 
-/**
- * @ingroup snmp_traps
- * Choose default SNMP version for sending traps (if not specified, default version is SNMP_VERSION_1)
- * SNMP_VERSION_1  0
- * SNMP_VERSION_2c 1
- * SNMP_VERSION_3  3
- *
- * @param snmp_version version that will be used for sending traps
- *
- * @retval void
- */
-void
-snmp_set_default_trap_version(u8_t snmp_version)
-{
-  snmp_default_trap_version = snmp_version;
-}
 
 /**
  * @ingroup snmp_traps
- * Get default SNMP version for sending traps
+ * Sends a generic or enterprise specific trap message.
  *
- * @return selected default version:
- * 0 - SNMP_VERSION_1
- * 1 - SNMP_VERSION_2c
- * 3 - SNMP_VERSION_3
- */
-u8_t
-snmp_get_default_trap_version(void)
-{
-  return snmp_default_trap_version;
-}
-
-/**
- * @ingroup snmp_traps
- * Prepares snmpTrapOID for SNMP v2c
- * @param dest_snmp_trap_oid pointer to destination snmpTrapOID
- * @param eoid enterprise oid (can be NULL)
- * @param generic_trap SNMP v1 generic trap
- * @param specific_trap SNMP v1 specific trap
- * @return ERR_OK if completed successfully;
- *         ERR_MEM if there wasn't enough memory allocated for destination;
- *         ERR_VAL if value for generic trap was incorrect;
- */
-static err_t
-snmp_prepare_trap_oid(struct snmp_obj_id *dest_snmp_trap_oid, const struct snmp_obj_id *eoid, s32_t generic_trap, s32_t specific_trap)
-{
-  err_t err = ERR_OK;
-  const u32_t snmpTrapOID[] = {1, 3, 6, 1, 6, 3, 1, 1, 5};     /* please see rfc3584 */
-
-  if (generic_trap == SNMP_GENTRAP_ENTERPRISE_SPECIFIC) {
-    if (eoid == NULL) {
-      MEMCPY(dest_snmp_trap_oid, snmp_get_device_enterprise_oid(), sizeof(*dest_snmp_trap_oid));
-    } else {
-      MEMCPY(dest_snmp_trap_oid, eoid, sizeof(*dest_snmp_trap_oid));
-    }
-    if (dest_snmp_trap_oid->len + 2 < SNMP_MAX_OBJ_ID_LEN) {
-      dest_snmp_trap_oid->id[dest_snmp_trap_oid->len++] = 0;
-      dest_snmp_trap_oid->id[dest_snmp_trap_oid->len++] = specific_trap;
-    } else {
-      err = ERR_MEM;
-    }
-  } else if ((generic_trap >= SNMP_GENTRAP_COLDSTART) && (generic_trap < SNMP_GENTRAP_ENTERPRISE_SPECIFIC)) {
-    if (sizeof(dest_snmp_trap_oid->id) >= sizeof(snmpTrapOID)) {
-      MEMCPY(&dest_snmp_trap_oid->id, snmpTrapOID , sizeof(snmpTrapOID));
-      dest_snmp_trap_oid->len = LWIP_ARRAYSIZE(snmpTrapOID);
-      dest_snmp_trap_oid->id[dest_snmp_trap_oid->len++] = specific_trap + 1;
-    } else {
-      err = ERR_MEM;
-    }
-  } else {
-    err = ERR_VAL;
-  }
-  return err;
-}
-
-/**
- * @ingroup snmp_traps
- * Prepare the rest of the necessary fields for trap/notification/inform message.
- * @param trap_msg message that should be set
- * @param eoid enterprise oid (can be NULL)
- * @param generic_trap SNMP v1 generic trap
- * @param specific_trap SNMP v1 specific trap
- * @param varbinds list of varbinds
- * @retval void
- */
-static void
-snmp_prepare_necessary_msg_fields(struct snmp_msg_trap *trap_msg, const struct snmp_obj_id *eoid, s32_t generic_trap, s32_t specific_trap, struct snmp_varbind *varbinds)
-{
-  if (trap_msg->snmp_version == SNMP_VERSION_1) {
-    trap_msg->enterprise = (eoid == NULL) ? snmp_get_device_enterprise_oid() : eoid;
-    trap_msg->gen_trap = generic_trap;
-    trap_msg->spc_trap = (generic_trap == SNMP_GENTRAP_ENTERPRISE_SPECIFIC) ? specific_trap : 0;
-    MIB2_COPY_SYSUPTIME_TO(&trap_msg->ts);
-  } else if (trap_msg->snmp_version == SNMP_VERSION_2c) {
-    /* Copy sysUpTime into the first varbind */
-    MIB2_COPY_SYSUPTIME_TO((u32_t *)varbinds[0].value);
-  }
-}
-
-/**
- * @ingroup snmp_traps
- * Copy trap message structure to pbuf and sends it
- * @param trap_msg contains the data that should be sent
- * @param varbinds list of varbinds
- * @param tot_len total length of encoded data
- * @param dip destination IP address
- * @return ERR_OK if sending was successful
- */
-static err_t
-snmp_send_msg(struct snmp_msg_trap *trap_msg, struct snmp_varbind *varbinds, u16_t tot_len, ip_addr_t *dip)
-{
-  err_t err = ERR_OK;
-  struct pbuf *p = NULL;
-  /* allocate pbuf(s) */
-  p = pbuf_alloc(PBUF_TRANSPORT, tot_len, PBUF_RAM);
-  if (p != NULL) {
-    struct snmp_pbuf_stream pbuf_stream;
-    snmp_pbuf_stream_init(&pbuf_stream, p, 0, tot_len);
-
-    /* pass 1, encode packet ino the pbuf(s) */
-    BUILD_EXEC( snmp_trap_header_enc(trap_msg, &pbuf_stream) );
-    BUILD_EXEC( snmp_trap_varbind_enc(trap_msg, &pbuf_stream, varbinds) );
-
-    snmp_stats.outtraps++;
-    snmp_stats.outpkts++;
-
-    /** send to the TRAP destination */
-    err = snmp_sendto(snmp_traps_handle, p, dip, LWIP_IANA_PORT_SNMP_TRAP);
-    pbuf_free(p);
-  } else {
-    err = ERR_MEM;
-  }
-  return err;
-}
-
-/**
- * @ingroup snmp_traps
- * Prepare and sends a generic or enterprise specific trap message, notification or inform.
- *
- * @param trap_msg defines msg type
  * @param eoid points to enterprise object identifier
  * @param generic_trap is the trap code
  * @param specific_trap used for enterprise traps when generic_trap == 6
@@ -343,162 +169,94 @@ snmp_send_msg(struct snmp_msg_trap *trap_msg, struct snmp_varbind *varbinds, u16
  * and .iso.org.dod.internet.private.enterprises.yourenterprise
  * (sysObjectID) for specific traps.
  */
-static err_t
-snmp_send_trap_or_notification_or_inform_generic(struct snmp_msg_trap *trap_msg, const struct snmp_obj_id *eoid, s32_t generic_trap, s32_t specific_trap, struct snmp_varbind *varbinds)
+err_t
+snmp_send_trap(const struct snmp_obj_id *eoid, s32_t generic_trap, s32_t specific_trap, struct snmp_varbind *varbinds)
 {
-  struct snmp_trap_dst *td = NULL;
-  u16_t i = 0;
-  u16_t tot_len = 0;
+  struct snmp_msg_trap trap_msg;
+  struct snmp_trap_dst *td;
+  struct pbuf *p;
+  u16_t i, tot_len;
   err_t err = ERR_OK;
-  u32_t timestamp = 0;
-  struct snmp_varbind *original_varbinds = varbinds;
-  struct snmp_varbind *original_prev = NULL;
-  struct snmp_varbind snmp_v2_special_varbinds[] = {
-                                                     /* First varbind is used to store sysUpTime */
-                                                     {
-                                                       NULL,                            /* *next */
-                                                       NULL,                            /* *prev */
-                                                       {                                /* oid */
-                                                         8,                             /* oid len */
-                                                         {1, 3, 6, 1, 2, 1, 1, 3}       /* oid for sysUpTime */
-                                                       },
-                                                       SNMP_ASN1_TYPE_TIMETICKS,        /* type */
-                                                       sizeof(u32_t),                   /* value_len */
-                                                       NULL                             /* value */
-                                                     },
-                                                     /* Second varbind is used to store snmpTrapOID */
-                                                     {
-                                                       NULL,                            /* *next */
-                                                       NULL,                            /* *prev */
-                                                       {                                /* oid */
-                                                         10,                            /* oid len */
-                                                         {1, 3, 6, 1, 6, 3, 1, 1, 4, 1} /* oid for snmpTrapOID */
-                                                       },
-                                                       SNMP_ASN1_TYPE_OBJECT_ID,        /* type */
-                                                       0,                               /* value_len */
-                                                       NULL                             /* value */
-                                                     }
-   };
 
   LWIP_ASSERT_CORE_LOCKED();
 
-  snmp_v2_special_varbinds[0].next = &snmp_v2_special_varbinds[1];
-  snmp_v2_special_varbinds[1].prev = &snmp_v2_special_varbinds[0];
+  trap_msg.snmp_version = 0;
 
-  snmp_v2_special_varbinds[0].value = &timestamp;
-
-  snmp_v2_special_varbinds[1].next = varbinds;
-
-  /* see rfc3584 */
-  if (trap_msg->snmp_version == SNMP_VERSION_2c) {
-    struct snmp_obj_id snmp_trap_oid =  { 0 };  /* used for converting SNMPv1 generic/specific trap parameter to SNMPv2 snmpTrapOID */
-    err = snmp_prepare_trap_oid(&snmp_trap_oid, eoid, generic_trap, specific_trap);
-    if (err == ERR_OK) {
-      snmp_v2_special_varbinds[1].value_len = snmp_trap_oid.len * sizeof(snmp_trap_oid.id[0]);
-      snmp_v2_special_varbinds[1].value = snmp_trap_oid.id;
-      if (varbinds != NULL) {
-        original_prev = varbinds->prev;
-        varbinds->prev = &snmp_v2_special_varbinds[1];
-      }
-      varbinds = snmp_v2_special_varbinds;  /* After inserting two varbinds at the beginning of the list, make sure that pointer is pointing to the first element  */
-    }
-  }
-
-  for (i = 0, td = &trap_dst[0]; (i < SNMP_TRAP_DESTINATIONS) && (err == ERR_OK); i++, td++) {
+  for (i = 0, td = &trap_dst[0]; i < SNMP_TRAP_DESTINATIONS; i++, td++) {
     if ((td->enable != 0) && !ip_addr_isany(&td->dip)) {
       /* lookup current source address for this dst */
-      if (snmp_get_local_ip_for_dst(snmp_traps_handle, &td->dip, &trap_msg->sip)) {
-        snmp_prepare_necessary_msg_fields(trap_msg, eoid, generic_trap, specific_trap, varbinds);
+      if (snmp_get_local_ip_for_dst(snmp_traps_handle, &td->dip, &trap_msg.sip)) {
+        if (eoid == NULL) {
+          trap_msg.enterprise = snmp_get_device_enterprise_oid();
+        } else {
+          trap_msg.enterprise = eoid;
+        }
+
+        trap_msg.gen_trap = generic_trap;
+        if (generic_trap == SNMP_GENTRAP_ENTERPRISE_SPECIFIC) {
+          trap_msg.spc_trap = specific_trap;
+        } else {
+          trap_msg.spc_trap = 0;
+        }
+
+        MIB2_COPY_SYSUPTIME_TO(&trap_msg.ts);
 
         /* pass 0, calculate length fields */
-        tot_len = snmp_trap_varbind_sum(trap_msg, varbinds);
-        tot_len = snmp_trap_header_sum(trap_msg, tot_len);
-
-        /* allocate pbuf, fill it and send it */
-        err = snmp_send_msg(trap_msg, varbinds, tot_len, &td->dip);
+        tot_len = snmp_trap_varbind_sum(&trap_msg, varbinds);
+        tot_len = snmp_trap_header_sum(&trap_msg, tot_len);
+
+        /* allocate pbuf(s) */
+        p = pbuf_alloc(PBUF_TRANSPORT, tot_len, PBUF_RAM);
+        if (p != NULL) {
+          struct snmp_pbuf_stream pbuf_stream;
+          snmp_pbuf_stream_init(&pbuf_stream, p, 0, tot_len);
+
+          /* pass 1, encode packet into the pbuf(s) */
+          snmp_trap_header_enc(&trap_msg, &pbuf_stream);
+          snmp_trap_varbind_enc(&trap_msg, &pbuf_stream, varbinds);
+
+          snmp_stats.outtraps++;
+          snmp_stats.outpkts++;
+
+          /** send to the TRAP destination */
+          snmp_sendto(snmp_traps_handle, p, &td->dip, LWIP_IANA_PORT_SNMP_TRAP);
+          pbuf_free(p);
+        } else {
+          err = ERR_MEM;
+        }
       } else {
         /* routing error */
         err = ERR_RTE;
       }
     }
   }
-  if ((trap_msg->snmp_version == SNMP_VERSION_2c) && (original_varbinds != NULL)) {
-    original_varbinds->prev = original_prev;
-  }
-  req_id++;
   return err;
 }
 
-/**
- * @ingroup snmp_traps
- * This function is a wrapper function for preparing and sending generic or specific traps.
- *
- * @param oid points to enterprise object identifier
- * @param generic_trap is the trap code
- * @param specific_trap used for enterprise traps when generic_trap == 6
- * @param varbinds linked list of varbinds to be sent
- * @return ERR_OK when success, ERR_MEM if we're out of memory
- *
- * @note the use of the enterprise identifier field
- * is per RFC1215.
- * Use .iso.org.dod.internet.mgmt.mib-2.snmp for generic traps
- * and .iso.org.dod.internet.private.enterprises.yourenterprise
- * (sysObjectID) for specific traps.
- */
-err_t
-snmp_send_trap(const struct snmp_obj_id* oid, s32_t generic_trap, s32_t specific_trap, struct snmp_varbind *varbinds)
-{
-  struct snmp_msg_trap trap_msg = {0};
-  trap_msg.snmp_version = snmp_default_trap_version;
-  trap_msg.trap_or_inform = SNMP_IS_TRAP;
-  return snmp_send_trap_or_notification_or_inform_generic(&trap_msg, oid, generic_trap, specific_trap, varbinds);
-}
-
 /**
  * @ingroup snmp_traps
  * Send generic SNMP trap
- * @param generic_trap is the trap code
- * return ERR_OK when success
  */
 err_t
 snmp_send_trap_generic(s32_t generic_trap)
 {
-  err_t err = ERR_OK;
-  struct snmp_msg_trap trap_msg = {0};
-  trap_msg.snmp_version = snmp_default_trap_version;
-  trap_msg.trap_or_inform = SNMP_IS_TRAP;
-
-  if(snmp_default_trap_version == SNMP_VERSION_1) {
-    static const struct snmp_obj_id oid = { 7, { 1, 3, 6, 1, 2, 1, 11 } };
-    err = snmp_send_trap_or_notification_or_inform_generic(&trap_msg, &oid, generic_trap, 0, NULL);
-  } else if (snmp_default_trap_version == SNMP_VERSION_2c) {
-    err = snmp_send_trap_or_notification_or_inform_generic(&trap_msg, NULL, generic_trap, 0, NULL);
-  } else {
-    err = ERR_VAL;
-  }
-  return err;
+  static const struct snmp_obj_id oid = { 7, { 1, 3, 6, 1, 2, 1, 11 } };
+  return snmp_send_trap(&oid, generic_trap, 0, NULL);
 }
 
 /**
  * @ingroup snmp_traps
  * Send specific SNMP trap with variable bindings
- * @param specific_trap used for enterprise traps (generic_trap = 6)
- * @param varbinds linked list of varbinds to be sent
- * @return ERR_OK when success
  */
 err_t
 snmp_send_trap_specific(s32_t specific_trap, struct snmp_varbind *varbinds)
 {
-  struct snmp_msg_trap trap_msg = {0};
-  trap_msg.snmp_version = snmp_default_trap_version;
-  trap_msg.trap_or_inform = SNMP_IS_TRAP;
-  return snmp_send_trap_or_notification_or_inform_generic(&trap_msg, NULL, SNMP_GENTRAP_ENTERPRISE_SPECIFIC, specific_trap, varbinds);
+  return snmp_send_trap(NULL, SNMP_GENTRAP_ENTERPRISE_SPECIFIC, specific_trap, varbinds);
 }
 
 /**
  * @ingroup snmp_traps
  * Send coldstart trap
- * @retval void
  */
 void
 snmp_coldstart_trap(void)
@@ -509,7 +267,6 @@ snmp_coldstart_trap(void)
 /**
  * @ingroup snmp_traps
  * Send authentication failure trap (used internally by agent)
- * @retval void
  */
 void
 snmp_authfail_trap(void)
@@ -519,14 +276,6 @@ snmp_authfail_trap(void)
   }
 }
 
-/**
- * @ingroup snmp_traps
- * Sums trap varbinds
- *
- * @param trap Trap message
- * @param varbinds linked list of varbinds
- * @return the required length for encoding of this part of the trap header
- */
 static u16_t
 snmp_trap_varbind_sum(struct snmp_msg_trap *trap, struct snmp_varbind *varbinds)
 {
@@ -554,18 +303,21 @@ snmp_trap_varbind_sum(struct snmp_msg_trap *trap, struct snmp_varbind *varbinds)
 }
 
 /**
- * @ingroup snmp_traps
- * Sums trap header fields that are specific for SNMP v1
+ * Sums trap header field lengths from tail to head and
+ * returns trap_header_lengths for second encoding pass.
  *
  * @param trap Trap message
- * @return the required length for encoding of this part of the trap header
+ * @param vb_len varbind-list length
+ * @return the required length for encoding the trap header
  */
 static u16_t
-snmp_trap_header_sum_v1_specific(struct snmp_msg_trap *trap)
+snmp_trap_header_sum(struct snmp_msg_trap *trap, u16_t vb_len)
 {
-  u16_t tot_len = 0;
-  u16_t len = 0;
-  u8_t lenlen = 0;
+  u16_t tot_len;
+  u16_t len;
+  u8_t lenlen;
+
+  tot_len = vb_len;
 
   snmp_asn1_enc_u32t_cnt(trap->ts, &len);
   snmp_asn1_enc_length_cnt(len, &lenlen);
@@ -595,57 +347,6 @@ snmp_trap_header_sum_v1_specific(struct snmp_msg_trap *trap)
   snmp_asn1_enc_length_cnt(len, &lenlen);
   tot_len += 1 + len + lenlen;
 
-  return tot_len;
-}
-
-/**
- * @ingroup snmp_traps
- * Sums trap header fields that are specific for SNMP v2c
- *
- * @param trap Trap message
- * @return the required length for encoding of this part of the trap header
- */
-static u16_t
-snmp_trap_header_sum_v2c_specific(struct snmp_msg_trap *trap)
-{
-  u16_t tot_len = 0;
-  u16_t len = 0;
-  u8_t lenlen = 0;
-
-  snmp_asn1_enc_u32t_cnt(req_id, &len);
-  snmp_asn1_enc_length_cnt(len, &lenlen);
-  tot_len += 1 + len + lenlen;
-  snmp_asn1_enc_u32t_cnt(trap->error_status, &len);
-  snmp_asn1_enc_length_cnt(len, &lenlen);
-  tot_len += 1 + len + lenlen;
-  snmp_asn1_enc_u32t_cnt(trap->error_index, &len);
-  snmp_asn1_enc_length_cnt(len, &lenlen);
-  tot_len += 1 + len + lenlen;
-
-  return tot_len;
-}
-
-/**
- * @ingroup snmp_traps
- * Sums trap header field lengths from tail to head and
- * returns trap_header_lengths for second encoding pass.
- *
- * @param trap Trap message
- * @param vb_len varbind-list length
- * @return the required length for encoding the trap header
- */
-static u16_t
-snmp_trap_header_sum(struct snmp_msg_trap *trap, u16_t vb_len)
-{
-  u16_t tot_len = vb_len;
-  u16_t len = 0;
-  u8_t lenlen = 0;
-
-  if (trap->snmp_version == SNMP_VERSION_1) {
-    tot_len += snmp_trap_header_sum_v1_specific(trap);
-  } else if (trap->snmp_version == SNMP_VERSION_2c) {
-    tot_len += snmp_trap_header_sum_v2c_specific(trap);
-  }
   trap->pdulen = tot_len;
   snmp_asn1_enc_length_cnt(trap->pdulen, &lenlen);
   tot_len += 1 + lenlen;
@@ -665,14 +366,6 @@ snmp_trap_header_sum(struct snmp_msg_trap *trap, u16_t vb_len)
   return tot_len;
 }
 
-/**
- * @ingroup snmp_traps
- * Encodes varbinds.
- * @param trap Trap message
- * @param pbuf_stream stream used for storing data inside pbuf
- * @param varbinds linked list of varbinds
- * @retval err_t ERR_OK if successful, ERR_ARG otherwise
- */
 static err_t
 snmp_trap_varbind_enc(struct snmp_msg_trap *trap, struct snmp_pbuf_stream *pbuf_stream, struct snmp_varbind *varbinds)
 {
@@ -694,45 +387,32 @@ snmp_trap_varbind_enc(struct snmp_msg_trap *trap, struct snmp_pbuf_stream *pbuf_
 }
 
 /**
- * @ingroup snmp_traps
- * Encodes trap header PDU part.
- * @param trap Trap message
- * @param pbuf_stream stream used for storing data inside pbuf
- * @retval err_t ERR_OK if successful, ERR_ARG otherwise
+ * Encodes trap header from head to tail.
  */
 static err_t
-snmp_trap_header_enc_pdu(struct snmp_msg_trap *trap, struct snmp_pbuf_stream *pbuf_stream)
+snmp_trap_header_enc(struct snmp_msg_trap *trap, struct snmp_pbuf_stream *pbuf_stream)
 {
   struct snmp_asn1_tlv tlv;
-  /* 'PDU' sequence */
-  if (trap->snmp_version == SNMP_VERSION_1) {
-    /* TRAP V1 */
-    SNMP_ASN1_SET_TLV_PARAMS(tlv, (SNMP_ASN1_CLASS_CONTEXT | SNMP_ASN1_CONTENTTYPE_CONSTRUCTED | SNMP_ASN1_CONTEXT_PDU_TRAP), 0, trap->pdulen);
-    BUILD_EXEC( snmp_ans1_enc_tlv(pbuf_stream, &tlv) );
-  } else if ((trap->snmp_version == SNMP_VERSION_2c) && (trap->trap_or_inform == SNMP_IS_INFORM)) {
-    /* TRAP v2 - INFORM */
-    SNMP_ASN1_SET_TLV_PARAMS(tlv, (SNMP_ASN1_CLASS_CONTEXT | SNMP_ASN1_CONTENTTYPE_CONSTRUCTED | SNMP_ASN1_CONTEXT_PDU_INFORM_REQ), 0, trap->pdulen);
-    BUILD_EXEC( snmp_ans1_enc_tlv(pbuf_stream, &tlv) );
-  } else if (trap->snmp_version == SNMP_VERSION_2c) {
-    /* TRAP v2 - NOTIFICATION*/
-    SNMP_ASN1_SET_TLV_PARAMS(tlv, (SNMP_ASN1_CLASS_CONTEXT | SNMP_ASN1_CONTENTTYPE_CONSTRUCTED | SNMP_ASN1_CONTEXT_PDU_V2_TRAP), 0, trap->pdulen);
-    BUILD_EXEC( snmp_ans1_enc_tlv(pbuf_stream, &tlv) );
-  }
 
-  return ERR_OK;
-}
+  /* 'Message' sequence */
+  SNMP_ASN1_SET_TLV_PARAMS(tlv, SNMP_ASN1_TYPE_SEQUENCE, 0, trap->seqlen);
+  BUILD_EXEC( snmp_ans1_enc_tlv(pbuf_stream, &tlv) );
+
+  /* version */
+  SNMP_ASN1_SET_TLV_PARAMS(tlv, SNMP_ASN1_TYPE_INTEGER, 0, 0);
+  snmp_asn1_enc_s32t_cnt(trap->snmp_version, &tlv.value_len);
+  BUILD_EXEC( snmp_ans1_enc_tlv(pbuf_stream, &tlv) );
+  BUILD_EXEC( snmp_asn1_enc_s32t(pbuf_stream, tlv.value_len, trap->snmp_version) );
+
+  /* community */
+  SNMP_ASN1_SET_TLV_PARAMS(tlv, SNMP_ASN1_TYPE_OCTET_STRING, 0, trap->comlen);
+  BUILD_EXEC( snmp_ans1_enc_tlv(pbuf_stream, &tlv) );
+  BUILD_EXEC( snmp_asn1_enc_raw(pbuf_stream,  (const u8_t *)snmp_community_trap, trap->comlen) );
+
+  /* 'PDU' sequence */
+  SNMP_ASN1_SET_TLV_PARAMS(tlv, (SNMP_ASN1_CLASS_CONTEXT | SNMP_ASN1_CONTENTTYPE_CONSTRUCTED | SNMP_ASN1_CONTEXT_PDU_TRAP), 0, trap->pdulen);
+  BUILD_EXEC( snmp_ans1_enc_tlv(pbuf_stream, &tlv) );
 
-/**
- * @ingroup snmp_traps
- * Encodes trap header part that is SNMP v1 header specific.
- * @param trap Trap message
- * @param pbuf_stream stream used for storing data inside pbuf
- * @retval void
- */
-static err_t
-snmp_trap_header_enc_v1_specific(struct snmp_msg_trap *trap, struct snmp_pbuf_stream *pbuf_stream)
-{
-  struct snmp_asn1_tlv tlv;
   /* object ID */
   SNMP_ASN1_SET_TLV_PARAMS(tlv, SNMP_ASN1_TYPE_OBJECT_ID, 0, 0);
   snmp_asn1_enc_oid_cnt(trap->enterprise->id, trap->enterprise->len, &tlv.value_len);
@@ -754,7 +434,7 @@ snmp_trap_header_enc_v1_specific(struct snmp_msg_trap *trap, struct snmp_pbuf_st
 #endif
   }
 
-  /* generic trap */
+  /* trap length */
   SNMP_ASN1_SET_TLV_PARAMS(tlv, SNMP_ASN1_TYPE_INTEGER, 0, 0);
   snmp_asn1_enc_s32t_cnt(trap->gen_trap, &tlv.value_len);
   BUILD_EXEC( snmp_ans1_enc_tlv(pbuf_stream, &tlv) );
@@ -775,126 +455,4 @@ snmp_trap_header_enc_v1_specific(struct snmp_msg_trap *trap, struct snmp_pbuf_st
   return ERR_OK;
 }
 
-/**
- * @ingroup snmp_traps
- * Encodes trap header part that is SNMP v2c header specific.
- *
- * @param trap Trap message
- * @param pbuf_stream stream used for storing data inside pbuf
- * @retval void
- */
-static err_t
-snmp_trap_header_enc_v2c_specific(struct snmp_msg_trap *trap, struct snmp_pbuf_stream *pbuf_stream)
-{
-  struct snmp_asn1_tlv tlv;
-  /* request id */
-  SNMP_ASN1_SET_TLV_PARAMS(tlv, SNMP_ASN1_TYPE_INTEGER, 0, 0);
-  snmp_asn1_enc_s32t_cnt(req_id, &tlv.value_len);
-  BUILD_EXEC( snmp_ans1_enc_tlv(pbuf_stream, &tlv) );
-  BUILD_EXEC( snmp_asn1_enc_s32t(pbuf_stream, tlv.value_len, req_id) );
-
-  /* error status */
-  SNMP_ASN1_SET_TLV_PARAMS(tlv, SNMP_ASN1_TYPE_INTEGER, 0, 0);
-  snmp_asn1_enc_s32t_cnt(trap->error_status, &tlv.value_len);
-  BUILD_EXEC( snmp_ans1_enc_tlv(pbuf_stream, &tlv) );
-  BUILD_EXEC( snmp_asn1_enc_s32t(pbuf_stream, tlv.value_len, trap->error_status) );
-
-  /* error index */
-  SNMP_ASN1_SET_TLV_PARAMS(tlv, SNMP_ASN1_TYPE_INTEGER, 0, 0);
-  snmp_asn1_enc_s32t_cnt(trap->error_index, &tlv.value_len);
-  BUILD_EXEC( snmp_ans1_enc_tlv(pbuf_stream, &tlv) );
-  BUILD_EXEC( snmp_asn1_enc_s32t(pbuf_stream, tlv.value_len, trap->error_index) );
-
-  return ERR_OK;
-}
-
-/**
- * @ingroup snmp_traps
- * Encodes trap header from head to tail.
- *
- * @param trap Trap message
- * @param pbuf_stream stream used for storing data inside pbuf
- * @retval void
- */
-static err_t
-snmp_trap_header_enc(struct snmp_msg_trap *trap, struct snmp_pbuf_stream *pbuf_stream)
-{
-  struct snmp_asn1_tlv tlv;
-
-  /* 'Message' sequence */
-  SNMP_ASN1_SET_TLV_PARAMS(tlv, SNMP_ASN1_TYPE_SEQUENCE, 0, trap->seqlen);
-  BUILD_EXEC( snmp_ans1_enc_tlv(pbuf_stream, &tlv) );
-
-  /* version */
-  SNMP_ASN1_SET_TLV_PARAMS(tlv, SNMP_ASN1_TYPE_INTEGER, 0, 0);
-  snmp_asn1_enc_s32t_cnt(trap->snmp_version, &tlv.value_len);
-  BUILD_EXEC( snmp_ans1_enc_tlv(pbuf_stream, &tlv) );
-  BUILD_EXEC( snmp_asn1_enc_s32t(pbuf_stream, tlv.value_len, trap->snmp_version) );
-
-  /* community */
-  SNMP_ASN1_SET_TLV_PARAMS(tlv, SNMP_ASN1_TYPE_OCTET_STRING, 0, trap->comlen);
-  BUILD_EXEC( snmp_ans1_enc_tlv(pbuf_stream, &tlv) );
-  BUILD_EXEC( snmp_asn1_enc_raw(pbuf_stream,  (const u8_t *)snmp_community_trap, trap->comlen) );
-
-  /* PDU */
-  BUILD_EXEC( snmp_trap_header_enc_pdu(trap, pbuf_stream) );
-  if (trap->snmp_version == SNMP_VERSION_1) {
-    /* object ID, IP addr, generic trap, specific trap, timestamp */
-    BUILD_EXEC( snmp_trap_header_enc_v1_specific(trap, pbuf_stream) );
-  } else if (SNMP_VERSION_2c == trap->snmp_version) {
-    /* request id, error status, error index */
-    BUILD_EXEC( snmp_trap_header_enc_v2c_specific(trap, pbuf_stream) );
-  }
-
-  return ERR_OK;
-}
-
-/**
- * @ingroup snmp_traps
- * Wrapper function for sending informs
- * @param specific_trap will be appended to enterprise oid [see RFC 3584]
- * @param varbinds linked list of varbinds (at the beginning of this list function will insert 2 special purpose varbinds [see RFC 3584])
- * @param ptr_request_id [out] variable in which to store request_id needed to verify acknowledgement
- * @return ERR_OK if successful
- */
-err_t
-snmp_send_inform_specific(s32_t specific_trap, struct snmp_varbind *varbinds, s32_t *ptr_request_id)
-{
-  return snmp_send_inform(NULL, SNMP_GENTRAP_ENTERPRISE_SPECIFIC, specific_trap, varbinds, ptr_request_id);
-}
-
-/**
- * @ingroup snmp_traps
- * Wrapper function for sending informs
- * @param generic_trap is the trap code
- * @param varbinds linked list of varbinds (at the beginning of this list function will insert 2 special purpose varbinds [see RFC 3584])
- * @param ptr_request_id [out] variable in which to store request_id needed to verify acknowledgement
- * @return ERR_OK if successful
- */
-err_t
-snmp_send_inform_generic(s32_t generic_trap, struct snmp_varbind *varbinds, s32_t *ptr_request_id)
-{
-  return snmp_send_inform(NULL, generic_trap, 0, varbinds, ptr_request_id);
-}
-
-/**
- * @ingroup snmp_traps
- * Generic function for sending informs
- * @param oid points to object identifier
- * @param generic_trap is the trap code
- * @param specific_trap used for enterprise traps when generic_trap == 6
- * @param varbinds linked list of varbinds (at the beginning of this list function will insert 2 special purpose varbinds [see RFC 3584])
- * @param ptr_request_id [out] variable in which to store request_id needed to verify acknowledgement
- * @return ERR_OK if successful
- */
-err_t
-snmp_send_inform(const struct snmp_obj_id* oid, s32_t generic_trap, s32_t specific_trap, struct snmp_varbind *varbinds, s32_t *ptr_request_id)
-{
-  struct snmp_msg_trap trap_msg = {0};
-  trap_msg.snmp_version = SNMP_VERSION_2c;
-  trap_msg.trap_or_inform = SNMP_IS_INFORM;
-  *ptr_request_id = req_id;
-  return snmp_send_trap_or_notification_or_inform_generic(&trap_msg, oid, generic_trap, specific_trap, varbinds);
-}
-
 #endif /* LWIP_SNMP */
diff --git a/src/apps/sntp/sntp.c b/src/apps/sntp/sntp.c
index edafc0f8..cee5c184 100644
--- a/src/apps/sntp/sntp.c
+++ b/src/apps/sntp/sntp.c
@@ -235,9 +235,7 @@ struct sntp_server {
   /** Reachability shift register as described in RFC 5905 */
   u8_t reachability;
 #endif /* SNTP_MONITOR_SERVER_REACHABILITY */
-#if SNTP_SUPPORT_MULTIPLE_SERVERS
-  u8_t kod_received;
-#endif
+  u32_t update_delay;
 };
 static struct sntp_server sntp_servers[SNTP_MAX_SERVERS];
 
@@ -411,10 +409,6 @@ sntp_try_next_server(void *arg)
     if (sntp_current_server >= SNTP_MAX_SERVERS) {
       sntp_current_server = 0;
     }
-    if (sntp_servers[sntp_current_server].kod_received) {
-      /* KOD received, don't use this server */
-      continue;
-    }
     if (!ip_addr_isany(&sntp_servers[sntp_current_server].addr)
 #if SNTP_SERVER_DNS
         || (sntp_servers[sntp_current_server].name != NULL)
@@ -433,18 +427,9 @@ sntp_try_next_server(void *arg)
   sntp_current_server = old_server;
   sntp_retry(NULL);
 }
-
-static void
-sntp_kod_try_next_server(void *arg)
-{
-  sntp_servers[sntp_current_server].kod_received = 1;
-  sntp_try_next_server(arg);
-}
-
 #else /* SNTP_SUPPORT_MULTIPLE_SERVERS */
 /* Always retry on error if only one server is supported */
-#define sntp_try_next_server     sntp_retry
-#define sntp_kod_try_next_server sntp_retry
+#define sntp_try_next_server    sntp_retry
 #endif /* SNTP_SUPPORT_MULTIPLE_SERVERS */
 
 /** UDP recv callback for the sntp pcb */
@@ -532,7 +517,7 @@ sntp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *addr,
       /* Correct response, reset retry timeout */
       SNTP_RESET_RETRY_TIMEOUT();
 
-      sntp_update_delay = (u32_t)SNTP_UPDATE_DELAY;
+      sntp_update_delay = sntp_servers[sntp_current_server].update_delay;
       sys_timeout(sntp_update_delay, sntp_request, NULL);
       LWIP_DEBUGF(SNTP_DEBUG_STATE, ("sntp_recv: Scheduled next time request: %"U32_F" ms\n",
                                      sntp_update_delay));
@@ -541,7 +526,7 @@ sntp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *addr,
     /* KOD errors are only processed in case of an explicit poll response */
     if (sntp_opmode == SNTP_OPMODE_POLL) {
       /* Kiss-of-death packet. Use another server or increase UPDATE_DELAY. */
-      sntp_kod_try_next_server(NULL);
+      sntp_try_next_server(NULL);
     }
   } else {
     /* ignore any broken packet, poll mode: retry after timeout to avoid flooding */
@@ -797,14 +782,12 @@ sntp_setserver(u8_t idx, const ip_addr_t *server)
   if (idx < SNTP_MAX_SERVERS) {
     if (server != NULL) {
       sntp_servers[idx].addr = (*server);
-#if SNTP_SUPPORT_MULTIPLE_SERVERS
-      sntp_servers[idx].kod_received = 0;
-#endif
     } else {
       ip_addr_set_zero(&sntp_servers[idx].addr);
     }
 #if SNTP_SERVER_DNS
     sntp_servers[idx].name = NULL;
+	sntp_servers[idx].update_delay = SNTP_UPDATE_DELAY;
 #endif
   }
 }
@@ -863,6 +846,11 @@ dhcp6_set_ntp_servers(u8_t num_ntp_servers, ip_addr_t* ntp_server_addrs)
 }
 #endif /* LWIP_DHCPv6 && SNTP_GET_SERVERS_FROM_DHCPV6 */
 
+u8_t sntp_get_current_server()
+{
+	return sntp_current_server;
+}
+
 /**
  * @ingroup sntp
  * Obtain one of the currently configured by IP address (or DHCP) NTP servers
@@ -880,25 +868,25 @@ sntp_getserver(u8_t idx)
   return IP_ADDR_ANY;
 }
 
-/**
- * @ingroup sntp
- * Check if a Kiss-of-Death has been received from this server (only valid for
- * SNTP_MAX_SERVERS > 1).
- *
- * @param idx the index of the NTP server
- * @return 1 if a KoD has been received, 0 if not.
- */
-u8_t
-sntp_getkodreceived(u8_t idx)
+void
+sntp_setserver_update_delay(u8_t idx, u32_t update_delay)
+{
+	LWIP_ASSERT_CORE_LOCKED();
+	if (idx < SNTP_MAX_SERVERS) {
+		if (update_delay < 15000) {
+			update_delay = SNTP_UPDATE_DELAY;
+		} else {
+			sntp_servers[idx].update_delay = update_delay;
+		}
+	}
+}
+
+u32_t sntp_getserver_update_delay(u8_t idx)
 {
-#if SNTP_SUPPORT_MULTIPLE_SERVERS
   if (idx < SNTP_MAX_SERVERS) {
-    return sntp_servers[idx].kod_received;
+    return sntp_servers[idx].update_delay;
   }
-#else
-  LWIP_UNUSED_ARG(idx);
-#endif
-  return 0;
+  return (u32_t)NULL;
 }
 
 #if SNTP_SERVER_DNS
@@ -914,9 +902,7 @@ sntp_setservername(u8_t idx, const char *server)
   LWIP_ASSERT_CORE_LOCKED();
   if (idx < SNTP_MAX_SERVERS) {
     sntp_servers[idx].name = server;
-#if SNTP_SUPPORT_MULTIPLE_SERVERS
-    sntp_servers[idx].kod_received = 0;
-#endif
+	sntp_servers[idx].update_delay = SNTP_UPDATE_DELAY;
   }
 }
 
diff --git a/src/apps/tftp/tftp.c b/src/apps/tftp/tftp_server.c
similarity index 69%
rename from src/apps/tftp/tftp.c
rename to src/apps/tftp/tftp_server.c
index c5b89ff3..e3f15124 100644
--- a/src/apps/tftp/tftp.c
+++ b/src/apps/tftp/tftp_server.c
@@ -1,6 +1,6 @@
 /**
  *
- * @file tftp.c
+ * @file tftp_server.c
  *
  * @author   Logan Gunthorpe <logang@deltatee.com>
  *           Dirk Ziegelmeier <dziegel@gmx.de>
@@ -41,13 +41,12 @@
  */
 
 /**
- * @defgroup tftp TFTP client/server
+ * @defgroup tftp TFTP server
  * @ingroup apps
  *
- * This is simple TFTP client/server for the lwIP raw API.
+ * This is simple TFTP server for the lwIP raw API.
  */
 
-#include "lwip/apps/tftp_client.h"
 #include "lwip/apps/tftp_server.h"
 
 #if LWIP_UDP
@@ -89,7 +88,6 @@ struct tftp_state {
   u16_t blknum;
   u8_t retries;
   u8_t mode_write;
-  u8_t tftp_mode;
 };
 
 static struct tftp_state tftp_state;
@@ -116,102 +114,64 @@ close_handle(void)
   }
 }
 
-static struct pbuf*
-init_packet(u16_t opcode, u16_t extra, size_t size)
-{
-  struct pbuf* p = pbuf_alloc(PBUF_TRANSPORT, (u16_t)(TFTP_HEADER_LENGTH + size), PBUF_RAM);
-  u16_t* payload;
-
-  if (p != NULL) {
-    payload = (u16_t*) p->payload;
-    payload[0] = PP_HTONS(opcode);
-    payload[1] = lwip_htons(extra);
-  }
-
-  return p;
-}
-
-static err_t
-send_request(const ip_addr_t *addr, u16_t port, u16_t opcode, const char* fname, const char* mode)
-{
-  size_t fname_length = strlen(fname)+1;
-  size_t mode_length = strlen(mode)+1;
-  struct pbuf* p = init_packet(opcode, 0, fname_length + mode_length - 2);
-  char* payload;
-  err_t ret;
-
-  if (p == NULL) {
-    return ERR_MEM;
-  }
-
-  payload = (char*) p->payload;
-  MEMCPY(payload+2,              fname, fname_length);
-  MEMCPY(payload+2+fname_length, mode,  mode_length);
-
-  ret = udp_sendto(tftp_state.upcb, p, addr, port);
-  pbuf_free(p);
-  return ret;
-}
-
-static err_t
+static void
 send_error(const ip_addr_t *addr, u16_t port, enum tftp_error code, const char *str)
 {
   int str_length = strlen(str);
   struct pbuf *p;
   u16_t *payload;
-  err_t ret;
 
-  p = init_packet(TFTP_ERROR, code, str_length + 1);
+  p = pbuf_alloc(PBUF_TRANSPORT, (u16_t)(TFTP_HEADER_LENGTH + str_length + 1), PBUF_RAM);
   if (p == NULL) {
-    return ERR_MEM;
+    return;
   }
 
   payload = (u16_t *) p->payload;
+  payload[0] = PP_HTONS(TFTP_ERROR);
+  payload[1] = lwip_htons(code);
   MEMCPY(&payload[2], str, str_length + 1);
 
-  ret = udp_sendto(tftp_state.upcb, p, addr, port);
+  udp_sendto(tftp_state.upcb, p, addr, port);
   pbuf_free(p);
-  return ret;
 }
 
-static err_t
-send_ack(const ip_addr_t *addr, u16_t port, u16_t blknum)
+static void
+send_ack(u16_t blknum)
 {
   struct pbuf *p;
-  err_t ret;
+  u16_t *payload;
 
-  p = init_packet(TFTP_ACK, blknum, 0);
+  p = pbuf_alloc(PBUF_TRANSPORT, TFTP_HEADER_LENGTH, PBUF_RAM);
   if (p == NULL) {
-    return ERR_MEM;
+    return;
   }
+  payload = (u16_t *) p->payload;
 
-  ret = udp_sendto(tftp_state.upcb, p, addr, port);
+  payload[0] = PP_HTONS(TFTP_ACK);
+  payload[1] = lwip_htons(blknum);
+  udp_sendto(tftp_state.upcb, p, &tftp_state.addr, tftp_state.port);
   pbuf_free(p);
-  return ret;
 }
 
-static err_t
-resend_data(const ip_addr_t *addr, u16_t port)
+static void
+resend_data(void)
 {
-  err_t ret;
   struct pbuf *p = pbuf_alloc(PBUF_TRANSPORT, tftp_state.last_data->len, PBUF_RAM);
   if (p == NULL) {
-    return ERR_MEM;
+    return;
   }
 
-  ret = pbuf_copy(p, tftp_state.last_data);
-  if (ret != ERR_OK) {
+  if (pbuf_copy(p, tftp_state.last_data) != ERR_OK) {
     pbuf_free(p);
-    return ret;
+    return;
   }
 
-  ret = udp_sendto(tftp_state.upcb, p, addr, port);
+  udp_sendto(tftp_state.upcb, p, &tftp_state.addr, tftp_state.port);
   pbuf_free(p);
-  return ret;
 }
 
 static void
-send_data(const ip_addr_t *addr, u16_t port)
+send_data(void)
 {
   u16_t *payload;
   int ret;
@@ -220,22 +180,24 @@ send_data(const ip_addr_t *addr, u16_t port)
     pbuf_free(tftp_state.last_data);
   }
 
-  tftp_state.last_data = init_packet(TFTP_DATA, tftp_state.blknum, TFTP_MAX_PAYLOAD_SIZE);
+  tftp_state.last_data = pbuf_alloc(PBUF_TRANSPORT, TFTP_HEADER_LENGTH + TFTP_MAX_PAYLOAD_SIZE, PBUF_RAM);
   if (tftp_state.last_data == NULL) {
     return;
   }
 
   payload = (u16_t *) tftp_state.last_data->payload;
+  payload[0] = PP_HTONS(TFTP_DATA);
+  payload[1] = lwip_htons(tftp_state.blknum);
 
   ret = tftp_state.ctx->read(tftp_state.handle, &payload[2], TFTP_MAX_PAYLOAD_SIZE);
   if (ret < 0) {
-    send_error(addr, port, TFTP_ERROR_ACCESS_VIOLATION, "Error occured while reading the file.");
+    send_error(&tftp_state.addr, tftp_state.port, TFTP_ERROR_ACCESS_VIOLATION, "Error occured while reading the file.");
     close_handle();
     return;
   }
 
   pbuf_realloc(tftp_state.last_data, (u16_t)(TFTP_HEADER_LENGTH + ret));
-  resend_data(addr, port);
+  resend_data();
 }
 
 static void
@@ -273,11 +235,6 @@ recv(void *arg, struct udp_pcb *upcb, struct pbuf *p, const ip_addr_t *addr, u16
         break;
       }
 
-      if ((tftp_state.tftp_mode & LWIP_TFTP_MODE_SERVER) == 0) {
-        send_error(addr, port, TFTP_ERROR_ACCESS_VIOLATION, "TFTP server not enabled");
-        break;
-      }
-
       sys_timeout(TFTP_TIMER_MSECS, tftp_tmr, NULL);
 
       /* find \0 in pbuf -> end of filename string */
@@ -313,10 +270,10 @@ recv(void *arg, struct udp_pcb *upcb, struct pbuf *p, const ip_addr_t *addr, u16
 
       if (opcode == PP_HTONS(TFTP_WRQ)) {
         tftp_state.mode_write = 1;
-        send_ack(addr, port, 0);
+        send_ack(0);
       } else {
         tftp_state.mode_write = 0;
-        send_data(addr, port);
+        send_data();
       }
 
       break;
@@ -345,7 +302,7 @@ recv(void *arg, struct udp_pcb *upcb, struct pbuf *p, const ip_addr_t *addr, u16
           send_error(addr, port, TFTP_ERROR_ACCESS_VIOLATION, "error writing file");
           close_handle();
         } else {
-          send_ack(addr, port, blknum);
+          send_ack(blknum);
         }
 
         if (p->tot_len < TFTP_MAX_PAYLOAD_SIZE) {
@@ -355,7 +312,7 @@ recv(void *arg, struct udp_pcb *upcb, struct pbuf *p, const ip_addr_t *addr, u16
         }
       } else if ((u16_t)(blknum + 1) == tftp_state.blknum) {
         /* retransmit of previous block, ack again (casting to u16_t to care for overflow) */
-        send_ack(addr, port, blknum);
+        send_ack(blknum);
       } else {
         send_error(addr, port, TFTP_ERROR_UNKNOWN_TRFR_ID, "Wrong block number");
       }
@@ -390,20 +347,14 @@ recv(void *arg, struct udp_pcb *upcb, struct pbuf *p, const ip_addr_t *addr, u16
 
       if (!lastpkt) {
         tftp_state.blknum++;
-        send_data(addr, port);
+        send_data();
       } else {
         close_handle();
       }
 
       break;
     }
-    case PP_HTONS(TFTP_ERROR):
-      if (tftp_state.handle != NULL) {
-        pbuf_remove_header(p, TFTP_HEADER_LENGTH);
-        tftp_state.ctx->error(tftp_state.handle, sbuf[1], (const char*)p->payload, p->len);
-        close_handle();
-      }
-      break;
+
     default:
       send_error(addr, port, TFTP_ERROR_ILLEGAL_OPERATION, "Unknown operation");
       break;
@@ -428,7 +379,7 @@ tftp_tmr(void *arg)
   if ((tftp_state.timer - tftp_state.last_pkt) > (TFTP_TIMEOUT_MSECS / TFTP_TIMER_MSECS)) {
     if ((tftp_state.last_data != NULL) && (tftp_state.retries < TFTP_MAX_RETRIES)) {
       LWIP_DEBUGF(TFTP_DEBUG | LWIP_DBG_STATE, ("tftp: timeout, retrying\n"));
-      resend_data(&tftp_state.addr, tftp_state.port);
+      resend_data();
       tftp_state.retries++;
     } else {
       LWIP_DEBUGF(TFTP_DEBUG | LWIP_DBG_STATE, ("tftp: timeout\n"));
@@ -437,13 +388,12 @@ tftp_tmr(void *arg)
   }
 }
 
-/**
- * Initialize TFTP client/server.
- * @param mode TFTP mode (client/server)
+/** @ingroup tftp
+ * Initialize TFTP server.
  * @param ctx TFTP callback struct
  */
 err_t
-tftp_init_common(u8_t mode, const struct tftp_context *ctx)
+tftp_init(const struct tftp_context *ctx)
 {
   err_t ret;
 
@@ -465,7 +415,6 @@ tftp_init_common(u8_t mode, const struct tftp_context *ctx)
   tftp_state.timer     = 0;
   tftp_state.last_data = NULL;
   tftp_state.upcb      = pcb;
-  tftp_state.tftp_mode = mode;
 
   udp_recv(pcb, recv, NULL);
 
@@ -473,27 +422,7 @@ tftp_init_common(u8_t mode, const struct tftp_context *ctx)
 }
 
 /** @ingroup tftp
- * Initialize TFTP server.
- * @param ctx TFTP callback struct
- */
-err_t
-tftp_init_server(const struct tftp_context *ctx)
-{
-  return tftp_init_common(LWIP_TFTP_MODE_SERVER, ctx);
-}
-
-/** @ingroup tftp
- * Initialize TFTP client.
- * @param ctx TFTP callback struct
- */
-err_t
-tftp_init_client(const struct tftp_context *ctx)
-{
-  return tftp_init_common(LWIP_TFTP_MODE_CLIENT, ctx);
-}
-
-/** @ingroup tftp
- * Deinitialize ("turn off") TFTP client/server.
+ * Deinitialize ("turn off") TFTP server.
  */
 void tftp_cleanup(void)
 {
@@ -503,45 +432,4 @@ void tftp_cleanup(void)
   memset(&tftp_state, 0, sizeof(tftp_state));
 }
 
-static const char *
-mode_to_string(enum tftp_transfer_mode mode)
-{
-  if (mode == TFTP_MODE_OCTET) {
-    return "octet";
-  }
-  if (mode == TFTP_MODE_NETASCII) {
-    return "netascii";
-  }
-  if (mode == TFTP_MODE_BINARY) {
-    return "binary";
-  }
-  return NULL;
-}
-
-err_t
-tftp_get(void* handle, const ip_addr_t *addr, u16_t port, const char* fname, enum tftp_transfer_mode mode)
-{
-  LWIP_ERROR("TFTP client is not enabled (tftp_init)", (tftp_state.tftp_mode & LWIP_TFTP_MODE_CLIENT) != 0, return ERR_VAL);
-  LWIP_ERROR("tftp_get: invalid file name", fname != NULL, return ERR_VAL);
-  LWIP_ERROR("tftp_get: invalid mode", mode <= TFTP_MODE_BINARY, return ERR_VAL);
-
-  tftp_state.handle = handle;
-  tftp_state.blknum = 1;
-  tftp_state.mode_write = 1; /* We want to receive data */
-  return send_request(addr, port, TFTP_RRQ, fname, mode_to_string(mode));
-}
-
-err_t
-tftp_put(void* handle, const ip_addr_t *addr, u16_t port, const char* fname, enum tftp_transfer_mode mode)
-{
-  LWIP_ERROR("TFTP client is not enabled (tftp_init)", (tftp_state.tftp_mode & LWIP_TFTP_MODE_CLIENT) != 0, return ERR_VAL);
-  LWIP_ERROR("tftp_put: invalid file name", fname != NULL, return ERR_VAL);
-  LWIP_ERROR("tftp_put: invalid mode", mode <= TFTP_MODE_BINARY, return ERR_VAL);
-
-  tftp_state.handle = handle;
-  tftp_state.blknum = 1;
-  tftp_state.mode_write = 0; /* We want to send data */
-  return send_request(addr, port, TFTP_WRQ, fname, mode_to_string(mode));
-}
-
 #endif /* LWIP_UDP */
diff --git a/src/core/altcp.c b/src/core/altcp.c
index 028fcbc8..d46d6cdb 100644
--- a/src/core/altcp.c
+++ b/src/core/altcp.c
@@ -158,7 +158,7 @@ altcp_free(struct altcp_pcb *conn)
 
 /**
  * @ingroup altcp
- * altcp_new_ip6: @ref altcp_new for IPv6
+ * altcp_new_ip6: @ref altcp_new for IPv6 
  */
 struct altcp_pcb *
 altcp_new_ip6(altcp_allocator_t *allocator)
@@ -166,9 +166,9 @@ altcp_new_ip6(altcp_allocator_t *allocator)
   return altcp_new_ip_type(allocator, IPADDR_TYPE_V6);
 }
 
-/**
+/** 
  * @ingroup altcp
- * altcp_new: @ref altcp_new for IPv4
+ * altcp_new: @ref altcp_new for IPv4 
  */
 struct altcp_pcb *
 altcp_new(altcp_allocator_t *allocator)
@@ -501,24 +501,6 @@ altcp_get_port(struct altcp_pcb *conn, int local)
   return 0;
 }
 
-#if LWIP_TCP_KEEPALIVE
-void
-altcp_keepalive_disable(struct altcp_pcb *conn)
-{
-  if (conn && conn->fns && conn->fns->keepalive_disable) {
-    conn->fns->keepalive_disable(conn);
-  }
-}
-
-void
-altcp_keepalive_enable(struct altcp_pcb *conn, u32_t idle, u32_t intvl, u32_t count)
-{
-  if (conn && conn->fns && conn->fns->keepalive_enable) {
-      conn->fns->keepalive_enable(conn, idle, intvl, count);
-  }
-}
-#endif
-
 #ifdef LWIP_DEBUG
 enum tcp_state
 altcp_dbg_get_tcp_state(struct altcp_pcb *conn)
@@ -684,24 +666,6 @@ altcp_default_get_port(struct altcp_pcb *conn, int local)
   return 0;
 }
 
-#if LWIP_TCP_KEEPALIVE
-void
-altcp_default_keepalive_disable(struct altcp_pcb *conn)
-{
-  if (conn && conn->inner_conn) {
-    altcp_keepalive_disable(conn->inner_conn);
-  }
-}
-
-void
-altcp_default_keepalive_enable(struct altcp_pcb *conn, u32_t idle, u32_t intvl, u32_t count)
-{
-  if (conn && conn->inner_conn) {
-      altcp_keepalive_enable(conn->inner_conn, idle, intvl, count);
-  }
-}
-#endif
-
 #ifdef LWIP_DEBUG
 enum tcp_state
 altcp_default_dbg_get_tcp_state(struct altcp_pcb *conn)
diff --git a/src/core/altcp_tcp.c b/src/core/altcp_tcp.c
index 867d2b44..b715f045 100644
--- a/src/core/altcp_tcp.c
+++ b/src/core/altcp_tcp.c
@@ -49,7 +49,6 @@
 #include "lwip/altcp_tcp.h"
 #include "lwip/priv/altcp_priv.h"
 #include "lwip/tcp.h"
-#include "lwip/priv/tcp_priv.h"
 #include "lwip/mem.h"
 
 #include <string.h>
@@ -447,31 +446,6 @@ altcp_tcp_setprio(struct altcp_pcb *conn, u8_t prio)
   }
 }
 
-#if LWIP_TCP_KEEPALIVE
-static void
-altcp_tcp_keepalive_disable(struct altcp_pcb *conn)
-{
-  if (conn && conn->state) {
-    struct tcp_pcb *pcb = (struct tcp_pcb *)conn->state;
-    ALTCP_TCP_ASSERT_CONN(conn);
-    ip_reset_option(pcb, SOF_KEEPALIVE);
-  }
-}
-
-static void
-altcp_tcp_keepalive_enable(struct altcp_pcb *conn, u32_t idle, u32_t intvl, u32_t cnt)
-{
-  if (conn && conn->state) {
-    struct tcp_pcb *pcb = (struct tcp_pcb *)conn->state;
-    ALTCP_TCP_ASSERT_CONN(conn);
-    ip_set_option(pcb, SOF_KEEPALIVE);
-    pcb->keep_idle = idle ? idle : TCP_KEEPIDLE_DEFAULT;
-    pcb->keep_intvl = intvl ? intvl : TCP_KEEPINTVL_DEFAULT;
-    pcb->keep_cnt = cnt ? cnt : TCP_KEEPCNT_DEFAULT;
-  }
-}
-#endif
-
 static void
 altcp_tcp_dealloc(struct altcp_pcb *conn)
 {
@@ -561,10 +535,6 @@ const struct altcp_functions altcp_tcp_functions = {
   altcp_tcp_get_tcp_addrinfo,
   altcp_tcp_get_ip,
   altcp_tcp_get_port
-#if LWIP_TCP_KEEPALIVE
-  , altcp_tcp_keepalive_disable
-  , altcp_tcp_keepalive_enable
-#endif
 #ifdef LWIP_DEBUG
   , altcp_tcp_dbg_get_tcp_state
 #endif
diff --git a/src/core/def.c b/src/core/def.c
index 282fb41d..9da36fee 100644
--- a/src/core/def.c
+++ b/src/core/def.c
@@ -118,29 +118,6 @@ lwip_strnstr(const char *buffer, const char *token, size_t n)
 }
 #endif
 
-#ifndef lwip_strnistr
-/**
- * @ingroup sys_nonstandard
- * lwIP default implementation for strnistr() non-standard function.
- * This can be \#defined to strnistr() depending on your platform port.
- */
-char *
-lwip_strnistr(const char *buffer, const char *token, size_t n)
-{
-  const char *p;
-  size_t tokenlen = strlen(token);
-  if (tokenlen == 0) {
-    return LWIP_CONST_CAST(char *, buffer);
-  }
-  for (p = buffer; *p && (p + tokenlen <= buffer + n); p++) {
-    if (lwip_strnicmp(p, token, tokenlen) == 0) {
-      return LWIP_CONST_CAST(char *, p);
-    }
-  }
-  return NULL;
-}
-#endif
-
 #ifndef lwip_stricmp
 /**
  * @ingroup sys_nonstandard
diff --git a/src/core/dns.c b/src/core/dns.c
index 121ea12b..9d2f61ed 100644
--- a/src/core/dns.c
+++ b/src/core/dns.c
@@ -277,7 +277,7 @@ DNS_LOCAL_HOSTLIST_STORAGE_PRE struct local_hostlist_entry local_hostlist_static
 #endif /* DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
 
 static void dns_init_local(void);
-static err_t dns_lookup_local(const char *hostname, size_t hostnamelen, ip_addr_t *addr LWIP_DNS_ADDRTYPE_ARG(u8_t dns_addrtype));
+static err_t dns_lookup_local(const char *hostname, ip_addr_t *addr LWIP_DNS_ADDRTYPE_ARG(u8_t dns_addrtype));
 #endif /* DNS_LOCAL_HOSTLIST */
 
 
@@ -476,32 +476,18 @@ dns_local_iterate(dns_found_callback iterator_fn, void *iterator_arg)
 err_t
 dns_local_lookup(const char *hostname, ip_addr_t *addr, u8_t dns_addrtype)
 {
-  size_t hostnamelen;
   LWIP_UNUSED_ARG(dns_addrtype);
-  if ((addr == NULL) ||
-      (!hostname) || (!hostname[0])) {
-    return ERR_ARG;
-  }
-  hostnamelen = strlen(hostname);
-  if (hostname[hostnamelen - 1] == '.') {
-    hostnamelen--;
-  }
-  if (hostnamelen >= DNS_MAX_NAME_LENGTH) {
-    LWIP_DEBUGF(DNS_DEBUG, ("dns_local_lookup: name too long to resolve"));
-    return ERR_ARG;
-  }
-  return dns_lookup_local(hostname, hostnamelen, addr LWIP_DNS_ADDRTYPE_ARG(dns_addrtype));
+  return dns_lookup_local(hostname, addr LWIP_DNS_ADDRTYPE_ARG(dns_addrtype));
 }
 
 /* Internal implementation for dns_local_lookup and dns_lookup */
 static err_t
-dns_lookup_local(const char *hostname, size_t hostnamelen, ip_addr_t *addr LWIP_DNS_ADDRTYPE_ARG(u8_t dns_addrtype))
+dns_lookup_local(const char *hostname, ip_addr_t *addr LWIP_DNS_ADDRTYPE_ARG(u8_t dns_addrtype))
 {
 #if DNS_LOCAL_HOSTLIST_IS_DYNAMIC
   struct local_hostlist_entry *entry = local_hostlist_dynamic;
   while (entry != NULL) {
-    if ((lwip_strnicmp(entry->name, hostname, hostnamelen) == 0) &&
-        !entry->name[hostnamelen] &&
+    if ((lwip_stricmp(entry->name, hostname) == 0) &&
         LWIP_DNS_ADDRTYPE_MATCH_IP(dns_addrtype, entry->addr)) {
       if (addr) {
         ip_addr_copy(*addr, entry->addr);
@@ -513,8 +499,7 @@ dns_lookup_local(const char *hostname, size_t hostnamelen, ip_addr_t *addr LWIP_
 #else /* DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
   size_t i;
   for (i = 0; i < LWIP_ARRAYSIZE(local_hostlist_static); i++) {
-    if ((lwip_strnicmp(local_hostlist_static[i].name, hostname, hostnamelen) == 0) &&
-        !local_hostlist_static[i].name[hostnamelen] &&
+    if ((lwip_stricmp(local_hostlist_static[i].name, hostname) == 0) &&
         LWIP_DNS_ADDRTYPE_MATCH_IP(dns_addrtype, local_hostlist_static[i].addr)) {
       if (addr) {
         ip_addr_copy(*addr, local_hostlist_static[i].addr);
@@ -608,34 +593,30 @@ dns_local_addhost(const char *hostname, const ip_addr_t *addr)
  * for a hostname.
  *
  * @param name the hostname to look up
- * @param hostnamelen length of the hostname
  * @param addr the hostname's IP address, as u32_t (instead of ip_addr_t to
  *         better check for failure: != IPADDR_NONE) or IPADDR_NONE if the hostname
  *         was not found in the cached dns_table.
  * @return ERR_OK if found, ERR_ARG if not found
  */
 static err_t
-dns_lookup(const char *name, size_t hostnamelen, ip_addr_t *addr LWIP_DNS_ADDRTYPE_ARG(u8_t dns_addrtype))
+dns_lookup(const char *name, ip_addr_t *addr LWIP_DNS_ADDRTYPE_ARG(u8_t dns_addrtype))
 {
-  size_t namelen;
   u8_t i;
 #if DNS_LOCAL_HOSTLIST
-  if (dns_lookup_local(name, hostnamelen, addr LWIP_DNS_ADDRTYPE_ARG(dns_addrtype)) == ERR_OK) {
+  if (dns_lookup_local(name, addr LWIP_DNS_ADDRTYPE_ARG(dns_addrtype)) == ERR_OK) {
     return ERR_OK;
   }
 #endif /* DNS_LOCAL_HOSTLIST */
 #ifdef DNS_LOOKUP_LOCAL_EXTERN
-  if (DNS_LOOKUP_LOCAL_EXTERN(name, hostnamelen, addr, LWIP_DNS_ADDRTYPE_ARG_OR_ZERO(dns_addrtype)) == ERR_OK) {
+  if (DNS_LOOKUP_LOCAL_EXTERN(name, addr, LWIP_DNS_ADDRTYPE_ARG_OR_ZERO(dns_addrtype)) == ERR_OK) {
     return ERR_OK;
   }
 #endif /* DNS_LOOKUP_LOCAL_EXTERN */
 
-  namelen = LWIP_MIN(hostnamelen, DNS_MAX_NAME_LENGTH - 1);
   /* Walk through name list, return entry if found. If not, return NULL. */
   for (i = 0; i < DNS_TABLE_SIZE; ++i) {
     if ((dns_table[i].state == DNS_STATE_DONE) &&
-        (lwip_strnicmp(name, dns_table[i].name, namelen) == 0) &&
-        !dns_table[i].name[namelen] &&
+        (lwip_strnicmp(name, dns_table[i].name, sizeof(dns_table[i].name)) == 0) &&
         LWIP_DNS_ADDRTYPE_MATCH_IP(dns_addrtype, dns_table[i].ipaddr)) {
       LWIP_DEBUGF(DNS_DEBUG, ("dns_lookup: \"%s\": found = ", name));
       ip_addr_debug_print_val(DNS_DEBUG, dns_table[i].ipaddr);
@@ -1399,18 +1380,13 @@ dns_enqueue(const char *name, size_t hostnamelen, dns_found_callback found,
   struct dns_table_entry *entry = NULL;
   size_t namelen;
   struct dns_req_entry *req;
-#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_NO_MULTIPLE_OUTSTANDING) != 0)
-  u8_t r;
-#endif
-
-  namelen = LWIP_MIN(hostnamelen, DNS_MAX_NAME_LENGTH - 1);
 
 #if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_NO_MULTIPLE_OUTSTANDING) != 0)
+  u8_t r;
   /* check for duplicate entries */
   for (i = 0; i < DNS_TABLE_SIZE; i++) {
     if ((dns_table[i].state == DNS_STATE_ASKING) &&
-        (lwip_strnicmp(name, dns_table[i].name, namelen) == 0) &&
-        !dns_table[i].name[namelen]) {
+        (lwip_strnicmp(name, dns_table[i].name, sizeof(dns_table[i].name)) == 0)) {
 #if LWIP_IPV4 && LWIP_IPV6
       if (dns_table[i].reqaddrtype != dns_addrtype) {
         /* requested address types don't match
@@ -1497,6 +1473,7 @@ dns_enqueue(const char *name, size_t hostnamelen, dns_found_callback found,
   LWIP_DNS_SET_ADDRTYPE(req->reqaddrtype, dns_addrtype);
   req->found = found;
   req->arg   = callback_arg;
+  namelen = LWIP_MIN(hostnamelen, DNS_MAX_NAME_LENGTH - 1);
   MEMCPY(entry->name, name, namelen);
   entry->name[namelen] = 0;
 
@@ -1586,9 +1563,6 @@ dns_gethostbyname_addrtype(const char *hostname, ip_addr_t *addr, dns_found_call
   }
 #endif
   hostnamelen = strlen(hostname);
-  if (hostname[hostnamelen - 1] == '.') {
-    hostnamelen--;
-  }
   if (hostnamelen >= DNS_MAX_NAME_LENGTH) {
     LWIP_DEBUGF(DNS_DEBUG, ("dns_gethostbyname: name too long to resolve"));
     return ERR_ARG;
@@ -1613,7 +1587,7 @@ dns_gethostbyname_addrtype(const char *hostname, ip_addr_t *addr, dns_found_call
     }
   }
   /* already have this address cached? */
-  if (dns_lookup(hostname, hostnamelen, addr LWIP_DNS_ADDRTYPE_ARG(dns_addrtype)) == ERR_OK) {
+  if (dns_lookup(hostname, addr LWIP_DNS_ADDRTYPE_ARG(dns_addrtype)) == ERR_OK) {
     return ERR_OK;
   }
 #if LWIP_IPV4 && LWIP_IPV6
@@ -1625,7 +1599,7 @@ dns_gethostbyname_addrtype(const char *hostname, ip_addr_t *addr, dns_found_call
     } else {
       fallback = LWIP_DNS_ADDRTYPE_IPV4;
     }
-    if (dns_lookup(hostname, hostnamelen, addr LWIP_DNS_ADDRTYPE_ARG(fallback)) == ERR_OK) {
+    if (dns_lookup(hostname, addr LWIP_DNS_ADDRTYPE_ARG(fallback)) == ERR_OK) {
       return ERR_OK;
     }
   }
diff --git a/src/core/init.c b/src/core/init.c
index 1f658676..b3737a35 100644
--- a/src/core/init.c
+++ b/src/core/init.c
@@ -184,8 +184,8 @@ PACK_STRUCT_END
 #if (((!LWIP_DHCP) || (!LWIP_AUTOIP)) && LWIP_DHCP_AUTOIP_COOP)
 #error "If you want to use DHCP/AUTOIP cooperation mode, you have to define LWIP_DHCP=1 and LWIP_AUTOIP=1 in your lwipopts.h"
 #endif
-#if (((!LWIP_DHCP) || (!LWIP_ARP) || (!LWIP_ACD)) && LWIP_DHCP_DOES_ACD_CHECK)
-#error "If you want to use DHCP ACD checking, you have to define LWIP_DHCP=1, LWIP_ARP=1 and LWIP_ACD=1 in your lwipopts.h"
+#if (((!LWIP_DHCP) || (!LWIP_ARP)) && DHCP_DOES_ARP_CHECK)
+#error "If you want to use DHCP ARP checking, you have to define LWIP_DHCP=1 and LWIP_ARP=1 in your lwipopts.h"
 #endif
 #if (!LWIP_ARP && LWIP_AUTOIP)
 #error "If you want to use AUTOIP, you have to define LWIP_ARP=1 in your lwipopts.h"
@@ -305,9 +305,6 @@ PACK_STRUCT_END
 #if TCP_SNDLOWAT >= TCP_SND_BUF
 #error "lwip_sanity_check: WARNING: TCP_SNDLOWAT must be less than TCP_SND_BUF. If you know what you are doing, define LWIP_DISABLE_TCP_SANITY_CHECKS to 1 to disable this error."
 #endif
-#if TCP_MSS >= ((16 * 1024) - 1)
-#error "lwip_sanity_check: WARNING: TCP_MSS must be <= 16382 to prevent u16_t underflow in TCP_SNDLOWAT calculation!"
-#endif
 #if TCP_SNDLOWAT >= (0xFFFF - (4 * TCP_MSS))
 #error "lwip_sanity_check: WARNING: TCP_SNDLOWAT must at least be 4*MSS below u16_t overflow!"
 #endif
diff --git a/src/core/ipv4/acd.c b/src/core/ipv4/acd.c
deleted file mode 100644
index 138859a7..00000000
--- a/src/core/ipv4/acd.c
+++ /dev/null
@@ -1,525 +0,0 @@
-/**
- * @file
- *
- * ACD IPv4 Address Conflict Detection
- *
- * This is an IPv4 address conflict detection implementation for the lwIP TCP/IP
- * stack. It aims to be conform to RFC5227.
- *
- * @defgroup acd ACD
- * @ingroup ip4
- * ACD related functions
- * USAGE:
- *
- * define @ref LWIP_ACD 1 in your lwipopts.h
- * Options:
- * ACD_TMR_INTERVAL msecs,
- *   I recommend a value of 100. The value must divide 1000 with a remainder almost 0.
- *   Possible values are 1000, 500, 333, 250, 200, 166, 142, 125, 111, 100 ....
- *
- * For fixed IP:
- * - call acd_start after selecting an IP address. The caller will be informed
- *   on conflict status via the callback function.
- *
- * With AUTOIP:
- * - will be called from the autoip module. No extra's needed.
- *
- * With DHCP:
- * - enable LWIP_DHCP_DOES_ACD_CHECK. Then it will be called from the dhcp module.
- *   No extra's needed.
- */
-
-/*
- *
- * Copyright (c) 2007 Dominik Spies <kontakt@dspies.de>
- * Copyright (c) 2018 Jasper Verschueren <jasper.verschueren@apart-audio.com>
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * Author: Jasper Verschueren <jasper.verschueren@apart-audio.com>
- * Author: Dominik Spies <kontakt@dspies.de>
- */
-
-#include "lwip/opt.h"
-
-/* don't build if not configured for use in lwipopts.h */
-#if LWIP_IPV4 && LWIP_ACD
-
-#include <string.h>
-
-#include "lwip/acd.h"
-#include "lwip/prot/acd.h"
-
-#define ACD_FOREACH(acd, acd_list) for ((acd) = acd_list; (acd) != NULL; (acd) = (acd)->next)
-
-#define ACD_TICKS_PER_SECOND  (1000 / ACD_TMR_INTERVAL)
-
-/* Define good random function (LWIP_RAND) in lwipopts.h */
-#ifdef LWIP_RAND
-#define LWIP_ACD_RAND(netif, acd)    LWIP_RAND()
-#else /* LWIP_RAND */
-#ifdef LWIP_AUTOIP_RAND
-#include "lwip/autoip.h"
-#define LWIP_ACD_RAND(netif, acd)    LWIP_AUTOIP_RAND(netif) /* for backwards compatibility */
-#else
-#define LWIP_ACD_RAND(netif, acd) ((((u32_t)((netif->hwaddr[5]) & 0xff) << 24) | \
-                                    ((u32_t)((netif->hwaddr[3]) & 0xff) << 16) | \
-                                    ((u32_t)((netif->hwaddr[2]) & 0xff) << 8) | \
-                                    ((u32_t)((netif->hwaddr[4]) & 0xff))) + \
-                                    (acd->sent_num))
-#endif /* LWIP_AUTOIP_RAND */
-#endif /* LWIP_RAND */
-
-
-#define ACD_RANDOM_PROBE_WAIT(netif, acd) (LWIP_ACD_RAND(netif, acd) % \
-                                    (PROBE_WAIT * ACD_TICKS_PER_SECOND))
-
-#define ACD_RANDOM_PROBE_INTERVAL(netif, acd) ((LWIP_ACD_RAND(netif, acd) % \
-                                    ((PROBE_MAX - PROBE_MIN) * ACD_TICKS_PER_SECOND)) + \
-                                    (PROBE_MIN * ACD_TICKS_PER_SECOND ))
-
-/* Function definitions */
-static void acd_restart(struct netif *netif, struct acd *acd);
-static void acd_handle_arp_conflict(struct netif *netif, struct acd *acd);
-static void acd_put_in_passive_mode(struct netif *netif, struct acd *acd);
-
-/**
- * @ingroup acd
- * Add ACD client to the client list and initialize callback function
- *
- * @param netif                 network interface on which to start the acd
- *                              client
- * @param acd                   acd module to be added to the list
- * @param acd_conflict_callback callback to be called when conflict information
- *                              is available
- */
-err_t
-acd_add(struct netif *netif, struct acd *acd,
-         acd_conflict_callback_t acd_conflict_callback)
-{
-  struct acd *acd2;
-
-  /* Set callback */
-  LWIP_ASSERT_CORE_LOCKED();
-  LWIP_ASSERT("acd_conflict_callback != NULL", acd_conflict_callback != NULL);
-  acd->acd_conflict_callback = acd_conflict_callback;
-
-  /* Check if the acd struct is already added */
-  for (acd2 = netif->acd_list; acd2 != NULL; acd2 = acd2->next) {
-    if (acd2 == acd) {
-      LWIP_DEBUGF(ACD_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
-                  ("acd_add(): acd already added to list\n"));
-      return ERR_OK;
-    }
-  }
-
-  /* add acd struct to the list */
-  acd->next = netif->acd_list;
-  netif->acd_list = acd;
-
-  return ERR_OK;
-}
-
-/**
- * @ingroup acd
- * Start ACD client
- *
- * @param netif   network interface on which to start the acd client
- * @param acd     acd module to start
- * @param ipaddr  ip address to perform acd on
- */
-err_t
-acd_start(struct netif *netif, struct acd *acd, ip4_addr_t ipaddr)
-{
-  err_t result = ERR_OK;
-
-  LWIP_UNUSED_ARG(netif);
-  LWIP_DEBUGF(ACD_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
-              ("acd_start(netif=%p) %c%c%"U16_F"\n",
-              (void *)netif, netif->name[0],
-               netif->name[1], (u16_t)netif->num));
-
-  /* init probing state */
-  acd->sent_num = 0;
-  acd->lastconflict = 0;
-  ip4_addr_copy(acd->ipaddr, ipaddr);
-  acd->state = ACD_STATE_PROBE_WAIT;
-
-  acd->ttw = (u16_t)(ACD_RANDOM_PROBE_WAIT(netif, acd));
-
-  return result;
-}
-
-/**
- * @ingroup acd
- * Stop ACD client
- *
- * @param acd   acd module to stop
- */
-err_t
-acd_stop(struct acd *acd)
-{
-  LWIP_DEBUGF(ACD_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("acd_stop\n"));
-
-  if (acd != NULL) {
-    acd->state = ACD_STATE_OFF;
-  }
-  return ERR_OK;
-}
-
-/**
- * @ingroup acd
- * Inform the ACD modules when the link goes down
- *
- * @param netif network interface on which to inform the ACD clients
- */
-void
-acd_network_changed_link_down(struct netif *netif)
-{
-  struct acd *acd;
-  /* loop over the acd's*/
-  ACD_FOREACH(acd, netif->acd_list) {
-    acd_stop(acd);
-  }
-}
-
-/**
- * Has to be called in loop every ACD_TMR_INTERVAL milliseconds
- */
-void
-acd_tmr(void)
-{
-  struct netif *netif;
-  struct acd *acd;
-  /* loop through netif's */
-  NETIF_FOREACH(netif) {
-    ACD_FOREACH(acd, netif->acd_list) {
-      if (acd->lastconflict > 0) {
-        acd->lastconflict--;
-      }
-
-      LWIP_DEBUGF(ACD_DEBUG | LWIP_DBG_TRACE,
-                  ("acd_tmr() ACD-State: %"U16_F", ttw=%"U16_F"\n",
-                   (u16_t)(acd->state), acd->ttw));
-
-      if (acd->ttw > 0) {
-        acd->ttw--;
-      }
-
-      switch (acd->state) {
-        case ACD_STATE_PROBE_WAIT:
-        case ACD_STATE_PROBING:
-          if (acd->ttw == 0) {
-            acd->state = ACD_STATE_PROBING;
-            etharp_acd_probe(netif, &acd->ipaddr);
-            LWIP_DEBUGF(ACD_DEBUG | LWIP_DBG_TRACE,
-                        ("acd_tmr() PROBING Sent Probe\n"));
-            acd->sent_num++;
-            if (acd->sent_num >= PROBE_NUM) {
-              /* Switch to ANNOUNCE_WAIT: last probe is sent*/
-              acd->state = ACD_STATE_ANNOUNCE_WAIT;
-
-              acd->sent_num = 0;
-
-              /* calculate time to wait before announcing */
-              acd->ttw = (u16_t)(ANNOUNCE_WAIT * ACD_TICKS_PER_SECOND);
-            } else {
-              /* calculate time to wait to next probe */
-              acd->ttw = (u16_t)(ACD_RANDOM_PROBE_INTERVAL(netif, acd));
-            }
-          }
-          break;
-
-        case ACD_STATE_ANNOUNCE_WAIT:
-        case ACD_STATE_ANNOUNCING:
-          if (acd->ttw == 0) {
-            if (acd->sent_num == 0) {
-              acd->state = ACD_STATE_ANNOUNCING;
-
-              /* let acd user know that the address is good and can be used */
-              acd->acd_conflict_callback(netif, ACD_IP_OK);
-
-              LWIP_DEBUGF(ACD_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
-                    ("acd_tmr(): changing state to ANNOUNCING: %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
-                     ip4_addr1_16(&acd->ipaddr), ip4_addr2_16(&acd->ipaddr),
-                     ip4_addr3_16(&acd->ipaddr), ip4_addr4_16(&acd->ipaddr)));
-            }
-
-            etharp_acd_announce(netif, &acd->ipaddr);
-            LWIP_DEBUGF(ACD_DEBUG | LWIP_DBG_TRACE,
-                        ("acd_tmr() ANNOUNCING Sent Announce\n"));
-            acd->ttw = ANNOUNCE_INTERVAL * ACD_TICKS_PER_SECOND;
-            acd->sent_num++;
-
-            if (acd->sent_num >= ANNOUNCE_NUM) {
-              acd->state = ACD_STATE_ONGOING;
-              acd->sent_num = 0;
-              acd->ttw = 0;
-              LWIP_DEBUGF(ACD_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
-                    ("acd_tmr(): changing state to ONGOING: %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
-                     ip4_addr1_16(&acd->ipaddr), ip4_addr2_16(&acd->ipaddr),
-                     ip4_addr3_16(&acd->ipaddr), ip4_addr4_16(&acd->ipaddr)));
-            }
-          }
-          break;
-
-        case ACD_STATE_RATE_LIMIT:
-          if (acd->ttw == 0) {
-            /* acd should be stopped because ipaddr isn't valid any more */
-            acd_stop(acd);
-            /* let the acd user (after rate limit interval) know that their is
-             * a conflict detected. So it can restart the address acquiring
-             * process.*/
-            acd->acd_conflict_callback(netif, ACD_RESTART_CLIENT);
-          }
-          break;
-
-        default:
-          /* nothing to do in other states */
-          break;
-      }
-    }
-  }
-}
-
-/**
- * Restarts the acd module
- *
- * The number of conflicts is increased and the upper layer is informed.
- */
-static void
-acd_restart(struct netif *netif, struct acd *acd)
-{
-  /* increase conflict counter. */
-  acd->num_conflicts++;
-
-  /* Decline the address */
-  acd->acd_conflict_callback(netif, ACD_DECLINE);
-
-  /* if we tried more then MAX_CONFLICTS we must limit our rate for
-   * acquiring and probing addresses. compliant to RFC 5227 Section 2.1.1 */
-  if (acd->num_conflicts > MAX_CONFLICTS) {
-    acd->state = ACD_STATE_RATE_LIMIT;
-    acd->ttw = (u16_t)(RATE_LIMIT_INTERVAL * ACD_TICKS_PER_SECOND);
-    LWIP_DEBUGF(ACD_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | LWIP_DBG_LEVEL_WARNING,
-                ("acd_restart(): rate limiting initiated. too many conflicts\n"));
-  }
-  else {
-    /* acd should be stopped because ipaddr isn't valid any more */
-    acd_stop(acd);
-    /* let the acd user know right away that their is a conflict detected.
-     * So it can restart the address acquiring process. */
-    acd->acd_conflict_callback(netif, ACD_RESTART_CLIENT);
-  }
-}
-
-/**
- * Handles every incoming ARP Packet, called by etharp_input().
- *
- * @param netif network interface to use for acd processing
- * @param hdr   Incoming ARP packet
- */
-void
-acd_arp_reply(struct netif *netif, struct etharp_hdr *hdr)
-{
-  struct acd *acd;
-  ip4_addr_t sipaddr, dipaddr;
-  struct eth_addr netifaddr;
-  SMEMCPY(netifaddr.addr, netif->hwaddr, ETH_HWADDR_LEN);
-
-  /* Copy struct ip4_addr_wordaligned to aligned ip4_addr, to support
-   * compilers without structure packing (not using structure copy which
-   * breaks strict-aliasing rules).
-   */
-  IPADDR_WORDALIGNED_COPY_TO_IP4_ADDR_T(&sipaddr, &hdr->sipaddr);
-  IPADDR_WORDALIGNED_COPY_TO_IP4_ADDR_T(&dipaddr, &hdr->dipaddr);
-
-  LWIP_DEBUGF(ACD_DEBUG | LWIP_DBG_TRACE, ("acd_arp_reply()\n"));
-
-  /* loop over the acd's*/
-  ACD_FOREACH(acd, netif->acd_list) {
-    switch(acd->state) {
-      case ACD_STATE_OFF:
-      case ACD_STATE_RATE_LIMIT:
-      default:
-        /* do nothing */
-        break;
-
-      case ACD_STATE_PROBE_WAIT:
-      case ACD_STATE_PROBING:
-      case ACD_STATE_ANNOUNCE_WAIT:
-        /* RFC 5227 Section 2.1.1:
-         * from beginning to after ANNOUNCE_WAIT seconds we have a conflict if
-         * ip.src == ipaddr (someone is already using the address)
-         * OR
-         * ip.dst == ipaddr && hw.src != own hwaddr (someone else is probing it)
-         */
-        if ((ip4_addr_cmp(&sipaddr, &acd->ipaddr)) ||
-            (ip4_addr_isany_val(sipaddr) &&
-             ip4_addr_cmp(&dipaddr, &acd->ipaddr) &&
-             !eth_addr_cmp(&netifaddr, &hdr->shwaddr))) {
-          LWIP_DEBUGF(ACD_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | LWIP_DBG_LEVEL_WARNING,
-                      ("acd_arp_reply(): Probe Conflict detected\n"));
-          acd_restart(netif, acd);
-        }
-        break;
-
-      case ACD_STATE_ANNOUNCING:
-      case ACD_STATE_ONGOING:
-      case ACD_STATE_PASSIVE_ONGOING:
-        /* RFC 5227 Section 2.4:
-         * in any state we have a conflict if
-         * ip.src == ipaddr && hw.src != own hwaddr (someone is using our address)
-         */
-        if (ip4_addr_cmp(&sipaddr, &acd->ipaddr) &&
-            !eth_addr_cmp(&netifaddr, &hdr->shwaddr)) {
-          LWIP_DEBUGF(ACD_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | LWIP_DBG_LEVEL_WARNING,
-                      ("acd_arp_reply(): Conflicting ARP-Packet detected\n"));
-          acd_handle_arp_conflict(netif, acd);
-        }
-        break;
-    }
-  }
-}
-
-/**
- * Handle a IP address conflict after an ARP conflict detection
- */
-static void
-acd_handle_arp_conflict(struct netif *netif, struct acd *acd)
-{
-  /* RFC5227, 2.4 "Ongoing Address Conflict Detection and Address Defense"
-     allows three options where:
-     a) means retreat on the first conflict,
-     b) allows to keep an already configured address when having only one
-        conflict in DEFEND_INTERVAL seconds and
-     c) the host will not give up it's address and defend it indefinitely
-
-     We use option b) when the acd module represents the netif address, since it
-     helps to improve the chance that one of the two conflicting hosts may be
-     able to retain its address. while we are flexible enough to help network
-     performance
-
-     We use option a) when the acd module does not represent the netif address,
-     since we cannot have the acd module announcing or restarting. This
-     situation occurs for the LL acd module when a routable address is used on
-     the netif but the LL address is still open in the background. */
-
-  if (acd->state == ACD_STATE_PASSIVE_ONGOING) {
-    /* Imediatly back off on a conflict. */
-    LWIP_DEBUGF(ACD_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
-      ("acd_handle_arp_conflict(): conflict when we are in passive mode -> back off\n"));
-    acd_stop(acd);
-    acd->acd_conflict_callback(netif, ACD_DECLINE);
-  }
-  else {
-    if (acd->lastconflict > 0) {
-      /* retreat, there was a conflicting ARP in the last DEFEND_INTERVAL seconds */
-      LWIP_DEBUGF(ACD_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
-        ("acd_handle_arp_conflict(): conflict within DEFEND_INTERVAL -> retreating\n"));
-
-      /* Active TCP sessions are aborted when removing the ip address but a bad
-       * connection was inevitable anyway with conflicting hosts */
-       acd_restart(netif, acd);
-    } else {
-      LWIP_DEBUGF(ACD_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
-          ("acd_handle_arp_conflict(): we are defending, send ARP Announce\n"));
-      etharp_acd_announce(netif, &acd->ipaddr);
-      acd->lastconflict = DEFEND_INTERVAL * ACD_TICKS_PER_SECOND;
-    }
-  }
-}
-
-/**
- * Put the acd module in passive ongoing conflict detection.
- */
-static void
-acd_put_in_passive_mode(struct netif *netif, struct acd *acd)
-{
-  switch(acd->state) {
-    case ACD_STATE_OFF:
-    case ACD_STATE_PASSIVE_ONGOING:
-    default:
-      /* do nothing */
-      break;
-
-    case ACD_STATE_PROBE_WAIT:
-    case ACD_STATE_PROBING:
-    case ACD_STATE_ANNOUNCE_WAIT:
-    case ACD_STATE_RATE_LIMIT:
-      acd_stop(acd);
-      acd->acd_conflict_callback(netif, ACD_DECLINE);
-      break;
-
-    case ACD_STATE_ANNOUNCING:
-    case ACD_STATE_ONGOING:
-      acd->state = ACD_STATE_PASSIVE_ONGOING;
-      LWIP_DEBUGF(ACD_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
-        ("acd_put_in_passive_mode()\n"));
-      break;
-  }
-}
-
-/**
- * @ingroup acd
- * Inform the ACD modules of address changes
- *
- * @param netif     network interface on which the address is changing
- * @param old_addr  old ip address
- * @param new_addr  new ip address
- */
-void
-acd_netif_ip_addr_changed(struct netif *netif, const ip_addr_t *old_addr,
-                          const ip_addr_t *new_addr)
-{
-  struct acd *acd;
-
-  LWIP_DEBUGF(ACD_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
-    ("acd_netif_ip_addr_changed(): Address changed\n"));
-
-  LWIP_DEBUGF(ACD_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
-    ("acd_netif_ip_addr_changed(): old address = %s\n", ipaddr_ntoa(old_addr)));
-  LWIP_DEBUGF(ACD_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
-    ("acd_netif_ip_addr_changed(): new address = %s\n", ipaddr_ntoa(new_addr)));
-
-  /* If we change from ANY to an IP or from an IP to ANY we do nothing */
-  if (ip_addr_isany(old_addr) || ip_addr_isany(new_addr)) {
-    return;
-  }
-
-  ACD_FOREACH(acd, netif->acd_list) {
-    /* Find ACD module of old address */
-    if(ip4_addr_cmp(&acd->ipaddr, ip_2_ip4(old_addr))) {
-      /* Did we change from a LL address to a routable address? */
-      if (ip_addr_islinklocal(old_addr) && !ip_addr_islinklocal(new_addr)) {
-        LWIP_DEBUGF(ACD_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
-          ("acd_netif_ip_addr_changed(): changed from LL to routable address\n"));
-        /* Put the module in passive conflict detection mode */
-        acd_put_in_passive_mode(netif, acd);
-      }
-    }
-  }
-}
-
-#endif /* LWIP_IPV4 && LWIP_ACD */
diff --git a/src/core/ipv4/autoip.c b/src/core/ipv4/autoip.c
index 90e6388d..9f7139bc 100644
--- a/src/core/ipv4/autoip.c
+++ b/src/core/ipv4/autoip.c
@@ -3,9 +3,7 @@
  * AutoIP Automatic LinkLocal IP Configuration
  *
  * This is a AutoIP implementation for the lwIP TCP/IP stack. It aims to conform
- * with RFC 3927. It uses IPv4 address conflict detection to evaluate the chosen
- * address. The ACD module aims to be conform to RFC 5227.
- * RFC 5227 is extracted out of RFC 3927 so the acd module fits nicely in autoip.
+ * with RFC 3927.
  *
  * @defgroup autoip AUTOIP
  * @ingroup ip4
@@ -13,6 +11,10 @@
  * USAGE:
  *
  * define @ref LWIP_AUTOIP 1 in your lwipopts.h
+ * Options:
+ * AUTOIP_TMR_INTERVAL msecs,
+ *   I recommend a value of 100. The value must divide 1000 with a remainder almost 0.
+ *   Possible values are 1000, 500, 333, 250, 200, 166, 142, 125, 111, 100 ....
  *
  * Without DHCP:
  * - Call autoip_start() after netif_add().
@@ -63,12 +65,21 @@
 #include "lwip/ip_addr.h"
 #include "lwip/netif.h"
 #include "lwip/autoip.h"
-#include "lwip/acd.h"
 #include "lwip/etharp.h"
 #include "lwip/prot/autoip.h"
 
 #include <string.h>
 
+/** Pseudo random macro based on netif informations.
+ * You could use "rand()" from the C Library if you define LWIP_AUTOIP_RAND in lwipopts.h */
+#ifndef LWIP_AUTOIP_RAND
+#define LWIP_AUTOIP_RAND(netif) ( (((u32_t)((netif->hwaddr[5]) & 0xff) << 24) | \
+                                   ((u32_t)((netif->hwaddr[3]) & 0xff) << 16) | \
+                                   ((u32_t)((netif->hwaddr[2]) & 0xff) << 8) | \
+                                   ((u32_t)((netif->hwaddr[4]) & 0xff))) + \
+                                   (netif_autoip_data(netif)? netif_autoip_data(netif)->tried_llipaddr : 0))
+#endif /* LWIP_AUTOIP_RAND */
+
 /**
  * Macro that generates the initial IP address to be tried by AUTOIP.
  * If you want to override this, define it to something else in lwipopts.h.
@@ -79,12 +90,9 @@
                  ((u32_t)((u8_t)(netif->hwaddr[5]))) << 8)))
 #endif /* LWIP_AUTOIP_CREATE_SEED_ADDR */
 
-/* Function definitions */
-static void autoip_restart(struct netif *netif);
-static void autoip_create_addr(struct netif *netif, ip4_addr_t *ipaddr);
-static err_t autoip_bind(struct netif *netif);
-static void autoip_conflict_callback(struct netif *netif,
-                                     acd_callback_enum_t state);
+/* static functions */
+static err_t autoip_arp_announce(struct netif *netif);
+static void autoip_start_probing(struct netif *netif);
 
 /**
  * @ingroup autoip
@@ -121,6 +129,35 @@ autoip_restart(struct netif *netif)
   autoip_start(netif);
 }
 
+/**
+ * Handle a IP address conflict after an ARP conflict detection
+ */
+static void
+autoip_handle_arp_conflict(struct netif *netif)
+{
+  struct autoip *autoip = netif_autoip_data(netif);
+
+  /* RFC3927, 2.5 "Conflict Detection and Defense" allows two options where
+     a) means retreat on the first conflict and
+     b) allows to keep an already configured address when having only one
+        conflict in 10 seconds
+     We use option b) since it helps to improve the chance that one of the two
+     conflicting hosts may be able to retain its address. */
+
+  if (autoip->lastconflict > 0) {
+    /* retreat, there was a conflicting ARP in the last DEFEND_INTERVAL seconds */
+    LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
+                ("autoip_handle_arp_conflict(): we are defending, but in DEFEND_INTERVAL, retreating\n"));
+
+    /* Active TCP sessions are aborted when removing the ip addresss */
+    autoip_restart(netif);
+  } else {
+    LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
+                ("autoip_handle_arp_conflict(): we are defend, send ARP Announce\n"));
+    autoip_arp_announce(netif);
+    autoip->lastconflict = DEFEND_INTERVAL * AUTOIP_TICKS_PER_SECOND;
+  }
+}
 
 /**
  * Create an IP-Address out of range 169.254.1.0 to 169.254.254.255
@@ -158,6 +195,29 @@ autoip_create_addr(struct netif *netif, ip4_addr_t *ipaddr)
                ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr)));
 }
 
+/**
+ * Sends an ARP probe from a network interface
+ *
+ * @param netif network interface used to send the probe
+ */
+static err_t
+autoip_arp_probe(struct netif *netif)
+{
+  struct autoip *autoip = netif_autoip_data(netif);
+  /* this works because netif->ip_addr is ANY */
+  return etharp_request(netif, &autoip->llipaddr);
+}
+
+/**
+ * Sends an ARP announce from a network interface
+ *
+ * @param netif network interface used to send the announce
+ */
+static err_t
+autoip_arp_announce(struct netif *netif)
+{
+  return etharp_gratuitous(netif);
+}
 
 /**
  * Configure interface for use with current LL IP-Address
@@ -170,8 +230,6 @@ autoip_bind(struct netif *netif)
   struct autoip *autoip = netif_autoip_data(netif);
   ip4_addr_t sn_mask, gw_addr;
 
-  autoip->state = AUTOIP_STATE_BOUND;
-
   LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE,
               ("autoip_bind(netif=%p) %c%c%"U16_F" %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
                (void *)netif, netif->name[0], netif->name[1], (u16_t)netif->num,
@@ -187,35 +245,6 @@ autoip_bind(struct netif *netif)
   return ERR_OK;
 }
 
-/**
-* Handle conflict information from ACD module
-*
-* @param netif   network interface to handle conflict information on
-* @param state   acd_callback_enum_t
- */
-static void
-autoip_conflict_callback(struct netif *netif, acd_callback_enum_t state)
-{
-  struct autoip *autoip = netif_autoip_data(netif);
-
-  switch (state) {
-    case ACD_IP_OK:
-      autoip_bind(netif);
-      break;
-    case ACD_RESTART_CLIENT:
-      autoip_restart(netif);
-      break;
-    case ACD_DECLINE:
-      /* "delete" conflicting address so a new one will be selected in
-       * autoip_start() */
-      ip4_addr_set_any(&autoip->llipaddr);
-      autoip_stop(netif);
-      break;
-      default:
-      break;
-  }
-}
-
 /**
  * @ingroup autoip
  * Start AutoIP client
@@ -231,85 +260,82 @@ autoip_start(struct netif *netif)
   LWIP_ASSERT_CORE_LOCKED();
   LWIP_ERROR("netif is not up, old style port?", netif_is_up(netif), return ERR_ARG;);
 
-  if (autoip->state == AUTOIP_STATE_OFF) {
-    LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
-                ("autoip_start(netif=%p) %c%c%"U16_F"\n", (void *)netif, netif->name[0],
-                 netif->name[1], (u16_t)netif->num));
+  /* Set IP-Address, Netmask and Gateway to 0 to make sure that
+   * ARP Packets are formed correctly
+   */
+  netif_set_addr(netif, IP4_ADDR_ANY4, IP4_ADDR_ANY4, IP4_ADDR_ANY4);
+
+  LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
+              ("autoip_start(netif=%p) %c%c%"U16_F"\n", (void *)netif, netif->name[0],
+               netif->name[1], (u16_t)netif->num));
+  if (autoip == NULL) {
+    /* no AutoIP client attached yet? */
+    LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE,
+                ("autoip_start(): starting new AUTOIP client\n"));
+    autoip = (struct autoip *)mem_calloc(1, sizeof(struct autoip));
     if (autoip == NULL) {
-      /* no AutoIP client attached yet? */
       LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE,
-                  ("autoip_start(): starting new AUTOIP client\n"));
-      autoip = (struct autoip *)mem_calloc(1, sizeof(struct autoip));
-      if (autoip == NULL) {
-        LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE,
-                    ("autoip_start(): could not allocate autoip\n"));
-        return ERR_MEM;
-      }
-      /* store this AutoIP client in the netif */
-      netif_set_client_data(netif, LWIP_NETIF_CLIENT_DATA_INDEX_AUTOIP, autoip);
-      LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE, ("autoip_start(): allocated autoip"));
+                  ("autoip_start(): could not allocate autoip\n"));
+      return ERR_MEM;
     }
-
-    /* add acd struct to list*/
-    acd_add(netif, &autoip->acd, autoip_conflict_callback);
-
-    /* In accordance to RFC3927 section 2.1:
-     * Keep using the same link local address as much as possible.
-     * Only when their is none or when their was a conflict, select a new one.
-     */
-    if (!ip4_addr_islinklocal(&autoip->llipaddr)) {
-      autoip_create_addr(netif, &(autoip->llipaddr));
-    }
-    autoip->state = AUTOIP_STATE_CHECKING;
-    acd_start(netif, &autoip->acd, autoip->llipaddr);
-  }
-  else {
-    LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
-                ("autoip_start(): already started on netif=%p %c%c%"U16_F"\n",
-                (void *)netif, netif->name[0],
-                 netif->name[1], (u16_t)netif->num));
+    /* store this AutoIP client in the netif */
+    netif_set_client_data(netif, LWIP_NETIF_CLIENT_DATA_INDEX_AUTOIP, autoip);
+    LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE, ("autoip_start(): allocated autoip"));
+  } else {
+    autoip->state = AUTOIP_STATE_OFF;
+    autoip->ttw = 0;
+    autoip->sent_num = 0;
+    ip4_addr_set_zero(&autoip->llipaddr);
+    autoip->lastconflict = 0;
   }
 
+  autoip_create_addr(netif, &(autoip->llipaddr));
+  autoip_start_probing(netif);
+
   return result;
 }
 
-
-/**
- * Handle a possible change in the network configuration: link up
- *
- * If there is an AutoIP address configured and AutoIP is not in cooperation
- * with DHCP, start probing for previous address.
- */
-void
-autoip_network_changed_link_up(struct netif *netif)
+static void
+autoip_start_probing(struct netif *netif)
 {
   struct autoip *autoip = netif_autoip_data(netif);
 
-  if (autoip && (autoip->state != AUTOIP_STATE_OFF) && !LWIP_DHCP_AUTOIP_COOP) {
-    LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE,
-                ("autoip_network_changed_link_up(): start acd"));
-    autoip->state = AUTOIP_STATE_CHECKING;
-    /* Start acd check again for the last used address */
-    acd_start(netif, &autoip->acd, autoip->llipaddr);
+  autoip->state = AUTOIP_STATE_PROBING;
+  autoip->sent_num = 0;
+  LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
+              ("autoip_start_probing(): changing state to PROBING: %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
+               ip4_addr1_16(&autoip->llipaddr), ip4_addr2_16(&autoip->llipaddr),
+               ip4_addr3_16(&autoip->llipaddr), ip4_addr4_16(&autoip->llipaddr)));
+
+  /* time to wait to first probe, this is randomly
+   * chosen out of 0 to PROBE_WAIT seconds.
+   * compliant to RFC 3927 Section 2.2.1
+   */
+  autoip->ttw = (u16_t)(LWIP_AUTOIP_RAND(netif) % (PROBE_WAIT * AUTOIP_TICKS_PER_SECOND));
+
+  /*
+   * if we tried more then MAX_CONFLICTS we must limit our rate for
+   * acquiring and probing address
+   * compliant to RFC 3927 Section 2.2.1
+   */
+  if (autoip->tried_llipaddr > MAX_CONFLICTS) {
+    autoip->ttw = RATE_LIMIT_INTERVAL * AUTOIP_TICKS_PER_SECOND;
   }
 }
 
 /**
- * Handle a possible change in the network configuration: link down
+ * Handle a possible change in the network configuration.
  *
- * If there is an AutoIP address configured and AutoIP is in cooperation
- * with DHCP, then stop the autoip module. When the link goes up, we do not want
- * the autoip module to start again. DHCP will initiate autoip when needed.
+ * If there is an AutoIP address configured, take the interface down
+ * and begin probing with the same address.
  */
 void
-autoip_network_changed_link_down(struct netif *netif)
+autoip_network_changed(struct netif *netif)
 {
   struct autoip *autoip = netif_autoip_data(netif);
 
-  if (autoip && (autoip->state != AUTOIP_STATE_OFF) && LWIP_DHCP_AUTOIP_COOP) {
-    LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE,
-                ("autoip_network_changed_link_down(): stop autoip"));
-    autoip_stop(netif);
+  if (autoip && (autoip->state != AUTOIP_STATE_OFF)) {
+    autoip_start_probing(netif);
   }
 }
 
@@ -330,33 +356,172 @@ autoip_stop(struct netif *netif)
     if (ip4_addr_islinklocal(netif_ip4_addr(netif))) {
       netif_set_addr(netif, IP4_ADDR_ANY4, IP4_ADDR_ANY4, IP4_ADDR_ANY4);
     }
-    LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE,("autoip_stop()"));
   }
   return ERR_OK;
 }
 
+/**
+ * Has to be called in loop every AUTOIP_TMR_INTERVAL milliseconds
+ */
+void
+autoip_tmr(void)
+{
+  struct netif *netif;
+  /* loop through netif's */
+  NETIF_FOREACH(netif) {
+    struct autoip *autoip = netif_autoip_data(netif);
+    /* only act on AutoIP configured interfaces */
+    if (autoip != NULL) {
+      if (autoip->lastconflict > 0) {
+        autoip->lastconflict--;
+      }
+
+      LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE,
+                  ("autoip_tmr() AutoIP-State: %"U16_F", ttw=%"U16_F"\n",
+                   (u16_t)(autoip->state), autoip->ttw));
+
+      if (autoip->ttw > 0) {
+        autoip->ttw--;
+      }
+
+      switch (autoip->state) {
+        case AUTOIP_STATE_PROBING:
+          if (autoip->ttw == 0) {
+            if (autoip->sent_num >= PROBE_NUM) {
+              /* Switch to ANNOUNCING: now we can bind to an IP address and use it */
+              autoip->state = AUTOIP_STATE_ANNOUNCING;
+              autoip_bind(netif);
+              /* autoip_bind() calls netif_set_addr(): this triggers a gratuitous ARP
+                 which counts as an announcement */
+              autoip->sent_num = 1;
+              autoip->ttw = ANNOUNCE_WAIT * AUTOIP_TICKS_PER_SECOND;
+              LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
+                          ("autoip_tmr(): changing state to ANNOUNCING: %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
+                           ip4_addr1_16(&autoip->llipaddr), ip4_addr2_16(&autoip->llipaddr),
+                           ip4_addr3_16(&autoip->llipaddr), ip4_addr4_16(&autoip->llipaddr)));
+            } else {
+              autoip_arp_probe(netif);
+              LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE, ("autoip_tmr() PROBING Sent Probe\n"));
+              autoip->sent_num++;
+              if (autoip->sent_num == PROBE_NUM) {
+                /* calculate time to wait to for announce */
+                autoip->ttw = ANNOUNCE_WAIT * AUTOIP_TICKS_PER_SECOND;
+              } else {
+                /* calculate time to wait to next probe */
+                autoip->ttw = (u16_t)((LWIP_AUTOIP_RAND(netif) %
+                                       ((PROBE_MAX - PROBE_MIN) * AUTOIP_TICKS_PER_SECOND) ) +
+                                      PROBE_MIN * AUTOIP_TICKS_PER_SECOND);
+              }
+            }
+          }
+          break;
+
+        case AUTOIP_STATE_ANNOUNCING:
+          if (autoip->ttw == 0) {
+            autoip_arp_announce(netif);
+            LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE, ("autoip_tmr() ANNOUNCING Sent Announce\n"));
+            autoip->ttw = ANNOUNCE_INTERVAL * AUTOIP_TICKS_PER_SECOND;
+            autoip->sent_num++;
+
+            if (autoip->sent_num >= ANNOUNCE_NUM) {
+              autoip->state = AUTOIP_STATE_BOUND;
+              autoip->sent_num = 0;
+              autoip->ttw = 0;
+              LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
+                          ("autoip_tmr(): changing state to BOUND: %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
+                           ip4_addr1_16(&autoip->llipaddr), ip4_addr2_16(&autoip->llipaddr),
+                           ip4_addr3_16(&autoip->llipaddr), ip4_addr4_16(&autoip->llipaddr)));
+            }
+          }
+          break;
+
+        default:
+          /* nothing to do in other states */
+          break;
+      }
+    }
+  }
+}
+
+/**
+ * Handles every incoming ARP Packet, called by etharp_input().
+ *
+ * @param netif network interface to use for autoip processing
+ * @param hdr Incoming ARP packet
+ */
+void
+autoip_arp_reply(struct netif *netif, struct etharp_hdr *hdr)
+{
+  struct autoip *autoip = netif_autoip_data(netif);
+
+  LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE, ("autoip_arp_reply()\n"));
+  if ((autoip != NULL) && (autoip->state != AUTOIP_STATE_OFF)) {
+    /* when ip.src == llipaddr && hw.src != netif->hwaddr
+     *
+     * when probing  ip.dst == llipaddr && hw.src != netif->hwaddr
+     * we have a conflict and must solve it
+     */
+    ip4_addr_t sipaddr, dipaddr;
+    struct eth_addr netifaddr;
+    SMEMCPY(netifaddr.addr, netif->hwaddr, ETH_HWADDR_LEN);
+
+    /* Copy struct ip4_addr_wordaligned to aligned ip4_addr, to support compilers without
+     * structure packing (not using structure copy which breaks strict-aliasing rules).
+     */
+    IPADDR_WORDALIGNED_COPY_TO_IP4_ADDR_T(&sipaddr, &hdr->sipaddr);
+    IPADDR_WORDALIGNED_COPY_TO_IP4_ADDR_T(&dipaddr, &hdr->dipaddr);
+
+    if (autoip->state == AUTOIP_STATE_PROBING) {
+      /* RFC 3927 Section 2.2.1:
+       * from beginning to after ANNOUNCE_WAIT
+       * seconds we have a conflict if
+       * ip.src == llipaddr OR
+       * ip.dst == llipaddr && hw.src != own hwaddr
+       */
+      if ((ip4_addr_cmp(&sipaddr, &autoip->llipaddr)) ||
+          (ip4_addr_isany_val(sipaddr) &&
+           ip4_addr_cmp(&dipaddr, &autoip->llipaddr) &&
+           !eth_addr_cmp(&netifaddr, &hdr->shwaddr))) {
+        LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | LWIP_DBG_LEVEL_WARNING,
+                    ("autoip_arp_reply(): Probe Conflict detected\n"));
+        autoip_restart(netif);
+      }
+    } else {
+      /* RFC 3927 Section 2.5:
+       * in any state we have a conflict if
+       * ip.src == llipaddr && hw.src != own hwaddr
+       */
+      if (ip4_addr_cmp(&sipaddr, &autoip->llipaddr) &&
+          !eth_addr_cmp(&netifaddr, &hdr->shwaddr)) {
+        LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | LWIP_DBG_LEVEL_WARNING,
+                    ("autoip_arp_reply(): Conflicting ARP-Packet detected\n"));
+        autoip_handle_arp_conflict(netif);
+      }
+    }
+  }
+}
+
 /** check if AutoIP supplied netif->ip_addr
  *
  * @param netif the netif to check
- * @return 1 if AutoIP supplied netif->ip_addr (state BOUND),
+ * @return 1 if AutoIP supplied netif->ip_addr (state BOUND or ANNOUNCING),
  *         0 otherwise
  */
 u8_t
-autoip_supplied_address(struct netif *netif)
+autoip_supplied_address(const struct netif *netif)
 {
-  struct autoip *autoip = netif_autoip_data(netif);
-  return     (autoip != NULL)
-          && (ip4_addr_cmp(netif_ip4_addr(netif), &(autoip->llipaddr)))
-          && (autoip->state == AUTOIP_STATE_BOUND);
+  if ((netif != NULL) && (netif_autoip_data(netif) != NULL)) {
+    struct autoip *autoip = netif_autoip_data(netif);
+    return (autoip->state == AUTOIP_STATE_BOUND) || (autoip->state == AUTOIP_STATE_ANNOUNCING);
+  }
+  return 0;
 }
 
 u8_t
 autoip_accept_packet(struct netif *netif, const ip4_addr_t *addr)
 {
   struct autoip *autoip = netif_autoip_data(netif);
-  return     (autoip != NULL)
-          && (ip4_addr_cmp(addr, &(autoip->llipaddr)))
-          && (autoip->state == AUTOIP_STATE_BOUND);
+  return (autoip != NULL) && ip4_addr_cmp(addr, &(autoip->llipaddr));
 }
 
 #endif /* LWIP_IPV4 && LWIP_AUTOIP */
diff --git a/src/core/ipv4/dhcp.c b/src/core/ipv4/dhcp.c
index d2195255..534574fe 100644
--- a/src/core/ipv4/dhcp.c
+++ b/src/core/ipv4/dhcp.c
@@ -75,7 +75,6 @@
 #include "lwip/def.h"
 #include "lwip/dhcp.h"
 #include "lwip/autoip.h"
-#include "lwip/acd.h"
 #include "lwip/dns.h"
 #include "lwip/etharp.h"
 #include "lwip/prot/dhcp.h"
@@ -192,9 +191,9 @@ static u8_t dhcp_pcb_refcount;
 static err_t dhcp_discover(struct netif *netif);
 static err_t dhcp_select(struct netif *netif);
 static void dhcp_bind(struct netif *netif);
-#if LWIP_DHCP_DOES_ACD_CHECK
+#if DHCP_DOES_ARP_CHECK
 static err_t dhcp_decline(struct netif *netif);
-#endif /* LWIP_DHCP_DOES_ACD_CHECK */
+#endif /* DHCP_DOES_ARP_CHECK */
 static err_t dhcp_rebind(struct netif *netif);
 static err_t dhcp_reboot(struct netif *netif);
 static void dhcp_set_state(struct dhcp *dhcp, u8_t new_state);
@@ -290,53 +289,13 @@ dhcp_handle_nak(struct netif *netif)
   dhcp_discover(netif);
 }
 
-#if LWIP_DHCP_DOES_ACD_CHECK
-/**
-* Handle conflict information from ACD module
-*
-* @param netif   network interface to handle conflict information on
-* @param state   acd_callback_enum_t
- */
-static void
-dhcp_conflict_callback(struct netif *netif, acd_callback_enum_t state)
-{
-  struct dhcp *dhcp = netif_dhcp_data(netif);
-  u16_t msecs;
-
-  switch (state) {
-    case ACD_IP_OK:
-      dhcp_bind(netif);
-      break;
-    case ACD_RESTART_CLIENT:
-      /* wait 10s before restarting
-       * According to RFC2131 section 3.1 point 5:
-       * If the client detects that the address is already in use (e.g., through
-       * the use of ARP), the client MUST send a DHCPDECLINE message to the
-       * server and restarts the configuration process.  The client SHOULD wait
-       * a minimum of ten seconds before restarting the configuration process to
-       * avoid excessive network traffic in case of looping. */
-       dhcp_set_state(dhcp, DHCP_STATE_BACKING_OFF);
-       msecs = 10 * 1000;
-       dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
-       LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline(): set request timeout %"U16_F" msecs\n", msecs));
-      break;
-    case ACD_DECLINE:
-      /* remove IP address from interface
-       * (prevents routing from selecting this interface) */
-      netif_set_addr(netif, IP4_ADDR_ANY4, IP4_ADDR_ANY4, IP4_ADDR_ANY4);
-      /* Let the DHCP server know we will not use the address */
-      dhcp_decline(netif);
-      break;
-    default:
-      break;
-  }
-}
-
+#if DHCP_DOES_ARP_CHECK
 /**
  * Checks if the offered IP address is already in use.
  *
- * It does this according to the address conflict detection method described in
- * RFC5227.
+ * It does so by sending an ARP request for the offered address and
+ * entering CHECKING state. If no ARP reply is received within a small
+ * interval, the address is assumed to be free for use by us.
  *
  * @param netif the netif under DHCP control
  */
@@ -344,15 +303,25 @@ static void
 dhcp_check(struct netif *netif)
 {
   struct dhcp *dhcp = netif_dhcp_data(netif);
-
+  err_t result;
+  u16_t msecs;
   LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_check(netif=%p) %c%c\n", (void *)netif, (s16_t)netif->name[0],
               (s16_t)netif->name[1]));
   dhcp_set_state(dhcp, DHCP_STATE_CHECKING);
-
-  /* start ACD module */
-  acd_start(netif, &dhcp->acd, dhcp->offered_ip_addr);
+  /* create an ARP query for the offered IP address, expecting that no host
+     responds, as the IP address should not be in use. */
+  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
+  if (result != ERR_OK) {
+    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("dhcp_check: could not perform ARP query\n"));
+  }
+  if (dhcp->tries < 255) {
+    dhcp->tries++;
+  }
+  msecs = 500;
+  dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
+  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_check(): set request timeout %"U16_F" msecs\n", msecs));
 }
-#endif /* LWIP_DHCP_DOES_ACD_CHECK */
+#endif /* DHCP_DOES_ARP_CHECK */
 
 /**
  * Remember the configuration offered by a DHCP server.
@@ -546,6 +515,19 @@ dhcp_timeout(struct netif *netif)
       dhcp_release_and_stop(netif);
       dhcp_start(netif);
     }
+#if DHCP_DOES_ARP_CHECK
+    /* received no ARP reply for the offered address (which is good) */
+  } else if (dhcp->state == DHCP_STATE_CHECKING) {
+    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): CHECKING, ARP request timed out\n"));
+    if (dhcp->tries <= 1) {
+      dhcp_check(netif);
+      /* no ARP replies on the offered address,
+         looks like the IP address is indeed free */
+    } else {
+      /* bind the interface to the offered address */
+      dhcp_bind(netif);
+    }
+#endif /* DHCP_DOES_ARP_CHECK */
   } else if (dhcp->state == DHCP_STATE_REBOOTING) {
     if (dhcp->tries < REBOOT_TRIES) {
       dhcp_reboot(netif);
@@ -795,13 +777,6 @@ dhcp_start(struct netif *netif)
   memset(dhcp, 0, sizeof(struct dhcp));
   /* dhcp_set_state(&dhcp, DHCP_STATE_OFF); */
 
-
-#if LWIP_DHCP_DOES_ACD_CHECK
-  /* add acd struct to list*/
-  acd_add(netif, &dhcp->acd, dhcp_conflict_callback);
-#endif /* LWIP_DHCP_DOES_ACD_CHECK */
-
-
   LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));
 
   if (dhcp_inc_pcb_refcount() != ERR_OK) { /* ensure DHCP PCB is allocated */
@@ -880,7 +855,7 @@ dhcp_inform(struct netif *netif)
  * address is still valid.
  */
 void
-dhcp_network_changed_link_up(struct netif *netif)
+dhcp_network_changed(struct netif *netif)
 {
   struct dhcp *dhcp = netif_dhcp_data(netif);
 
@@ -903,6 +878,12 @@ dhcp_network_changed_link_up(struct netif *netif)
       /* INIT/REQUESTING/CHECKING/BACKING_OFF restart with new 'rid' because the
          state changes, SELECTING: continue with current 'rid' as we stay in the
          same state */
+#if LWIP_DHCP_AUTOIP_COOP
+      if (dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_ON) {
+        autoip_stop(netif);
+        dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_OFF;
+      }
+#endif /* LWIP_DHCP_AUTOIP_COOP */
       /* ensure we start with short timeouts, even if already discovering */
       dhcp->tries = 0;
       dhcp_discover(netif);
@@ -910,7 +891,37 @@ dhcp_network_changed_link_up(struct netif *netif)
   }
 }
 
-#if LWIP_DHCP_DOES_ACD_CHECK
+#if DHCP_DOES_ARP_CHECK
+/**
+ * Match an ARP reply with the offered IP address:
+ * check whether the offered IP address is not in use using ARP
+ *
+ * @param netif the network interface on which the reply was received
+ * @param addr The IP address we received a reply from
+ */
+void
+dhcp_arp_reply(struct netif *netif, const ip4_addr_t *addr)
+{
+  struct dhcp *dhcp;
+
+  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
+  dhcp = netif_dhcp_data(netif);
+  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_arp_reply()\n"));
+  /* is a DHCP client doing an ARP check? */
+  if ((dhcp != NULL) && (dhcp->state == DHCP_STATE_CHECKING)) {
+    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_arp_reply(): CHECKING, arp reply for 0x%08"X32_F"\n",
+                ip4_addr_get_u32(addr)));
+    /* did a host respond with the address we
+       were offered by the DHCP server? */
+    if (ip4_addr_cmp(addr, &dhcp->offered_ip_addr)) {
+      /* we will not accept the offered address */
+      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | LWIP_DBG_LEVEL_WARNING,
+                  ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"));
+      dhcp_decline(netif);
+    }
+  }
+}
+
 /**
  * Decline an offered lease.
  *
@@ -925,12 +936,12 @@ dhcp_decline(struct netif *netif)
 {
   struct dhcp *dhcp = netif_dhcp_data(netif);
   err_t result;
+  u16_t msecs;
   struct pbuf *p_out;
   u16_t options_out_len;
 
   LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline()\n"));
   dhcp_set_state(dhcp, DHCP_STATE_BACKING_OFF);
-
   /* create and initialize the DHCP message header */
   p_out = dhcp_create_msg(netif, dhcp, DHCP_DECLINE, &options_out_len);
   if (p_out != NULL) {
@@ -950,9 +961,15 @@ dhcp_decline(struct netif *netif)
                 ("dhcp_decline: could not allocate DHCP request\n"));
     result = ERR_MEM;
   }
+  if (dhcp->tries < 255) {
+    dhcp->tries++;
+  }
+  msecs = 10 * 1000;
+  dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
+  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline(): set request timeout %"U16_F" msecs\n", msecs));
   return result;
 }
-#endif /* LWIP_DHCP_DOES_ACD_CHECK */
+#endif /* DHCP_DOES_ARP_CHECK */
 
 
 /**
@@ -972,12 +989,6 @@ dhcp_discover(struct netif *netif)
 
   LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover()\n"));
 
-#if LWIP_DHCP_AUTOIP_COOP
-  if (dhcp->tries >= LWIP_DHCP_AUTOIP_COOP_TRIES) {
-    autoip_start(netif);
-  }
-#endif /* LWIP_DHCP_AUTOIP_COOP */
-
   ip4_addr_set_any(&dhcp->offered_ip_addr);
   dhcp_set_state(dhcp, DHCP_STATE_SELECTING);
   /* create and initialize the DHCP message header */
@@ -998,16 +1009,21 @@ dhcp_discover(struct netif *netif)
 
     LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: sendto(DISCOVER, IP_ADDR_BROADCAST, LWIP_IANA_PORT_DHCP_SERVER)\n"));
     udp_sendto_if_src(dhcp_pcb, p_out, IP_ADDR_BROADCAST, LWIP_IANA_PORT_DHCP_SERVER, netif, IP4_ADDR_ANY);
-    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()\n"));
+    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()ing\n"));
     pbuf_free(p_out);
     LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
   } else {
     LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_discover: could not allocate DHCP request\n"));
   }
-
   if (dhcp->tries < 255) {
     dhcp->tries++;
   }
+#if LWIP_DHCP_AUTOIP_COOP
+  if (dhcp->tries >= LWIP_DHCP_AUTOIP_COOP_TRIES && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
+    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
+    autoip_start(netif);
+  }
+#endif /* LWIP_DHCP_AUTOIP_COOP */
   msecs = (u16_t)((dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000);
   dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
   LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
@@ -1107,6 +1123,13 @@ dhcp_bind(struct netif *netif)
     ip4_addr_set_u32(&gw_addr, ip4_addr_get_u32(&gw_addr) | PP_HTONL(0x00000001UL));
   }
 
+#if LWIP_DHCP_AUTOIP_COOP
+  if (dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_ON) {
+    autoip_stop(netif);
+    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_OFF;
+  }
+#endif /* LWIP_DHCP_AUTOIP_COOP */
+
   LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): IP: 0x%08"X32_F" SN: 0x%08"X32_F" GW: 0x%08"X32_F"\n",
               ip4_addr_get_u32(&dhcp->offered_ip_addr), ip4_addr_get_u32(&sn_mask), ip4_addr_get_u32(&gw_addr)));
   /* netif is now bound to DHCP leased address - set this before assigning the address
@@ -1342,10 +1365,17 @@ dhcp_release_and_stop(struct netif *netif)
       /* sending release failed, but that's not a problem since the correct behaviour of dhcp does not rely on release */
       LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_release: could not allocate DHCP request\n"));
     }
+  }
 
-    /* remove IP address from interface (prevents routing from selecting this interface) */
-    netif_set_addr(netif, IP4_ADDR_ANY4, IP4_ADDR_ANY4, IP4_ADDR_ANY4);
+  /* remove IP address from interface (prevents routing from selecting this interface) */
+  netif_set_addr(netif, IP4_ADDR_ANY4, IP4_ADDR_ANY4, IP4_ADDR_ANY4);
+
+#if LWIP_DHCP_AUTOIP_COOP
+  if (dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_ON) {
+    autoip_stop(netif);
+    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_OFF;
   }
+#endif /* LWIP_DHCP_AUTOIP_COOP */
 
   dhcp_set_state(dhcp, DHCP_STATE_OFF);
 
@@ -1479,7 +1509,6 @@ dhcp_parse_reply(struct pbuf *p, struct dhcp *dhcp)
   u8_t *options;
   u16_t offset;
   u16_t offset_max;
-  u16_t options_offset;
   u16_t options_idx;
   u16_t options_idx_max;
   struct pbuf *q;
@@ -1512,7 +1541,6 @@ dhcp_parse_reply(struct pbuf *p, struct dhcp *dhcp)
   options_idx_max = p->tot_len;
 again:
   q = p;
-  options_offset = options_idx;
   while ((q != NULL) && (options_idx >= q->len)) {
     options_idx = (u16_t)(options_idx - q->len);
     options_idx_max = (u16_t)(options_idx_max - q->len);
@@ -1586,7 +1614,7 @@ again:
       case (DHCP_OPTION_OVERLOAD):
         LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
         /* decode overload only in options, not in file/sname: invalid packet */
-        LWIP_ERROR("overload in file/sname", options_offset == DHCP_OPTIONS_OFS, return ERR_VAL;);
+        LWIP_ERROR("overload in file/sname", options_idx == DHCP_OPTIONS_OFS, return ERR_VAL;);
         decode_idx = DHCP_OPTION_IDX_OVERLOAD;
         break;
       case (DHCP_OPTION_MESSAGE_TYPE):
@@ -1715,7 +1743,7 @@ decode_next:
     /* make sure the string is really NULL-terminated */
     dhcp->boot_file_name[DHCP_FILE_LEN-1] = 0;
   }
-#endif /* LWIP_DHCP_BOOTP_FILE */
+#endif /* LWIP_DHCP_BOOTP_FILE */ 
   return ERR_OK;
 }
 
@@ -1794,11 +1822,10 @@ dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *addr,
   /* message type is DHCP ACK? */
   if (msg_type == DHCP_ACK) {
     LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_ACK received\n"));
-    /* in requesting state or just reconnected to the network? */
-    if ((dhcp->state == DHCP_STATE_REQUESTING) ||
-        (dhcp->state == DHCP_STATE_REBOOTING)) {
+    /* in requesting state? */
+    if (dhcp->state == DHCP_STATE_REQUESTING) {
       dhcp_handle_ack(netif, msg_in);
-#if LWIP_DHCP_DOES_ACD_CHECK
+#if DHCP_DOES_ARP_CHECK
       if ((netif->flags & NETIF_FLAG_ETHARP) != 0) {
         /* check if the acknowledged lease address is already in use */
         dhcp_check(netif);
@@ -1811,8 +1838,8 @@ dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *addr,
       dhcp_bind(netif);
 #endif
     }
-    /* already bound to the given lease address and using it? */
-    else if ((dhcp->state == DHCP_STATE_REBINDING) ||
+    /* already bound to the given lease address? */
+    else if ((dhcp->state == DHCP_STATE_REBOOTING) || (dhcp->state == DHCP_STATE_REBINDING) ||
              (dhcp->state == DHCP_STATE_RENEWING)) {
       dhcp_handle_ack(netif, msg_in);
       dhcp_bind(netif);
diff --git a/src/core/ipv4/etharp.c b/src/core/ipv4/etharp.c
index 9d7bf299..442aac08 100644
--- a/src/core/ipv4/etharp.c
+++ b/src/core/ipv4/etharp.c
@@ -52,7 +52,6 @@
 #include "lwip/snmp.h"
 #include "lwip/dhcp.h"
 #include "lwip/autoip.h"
-#include "lwip/acd.h"
 #include "lwip/prot/iana.h"
 #include "netif/ethernet.h"
 
@@ -644,7 +643,7 @@ etharp_input(struct pbuf *p, struct netif *netif)
   struct etharp_hdr *hdr;
   /* these are aligned properly, whereas the ARP header fields might not be */
   ip4_addr_t sipaddr, dipaddr;
-  u8_t for_us, from_us;
+  u8_t for_us;
 
   LWIP_ASSERT_CORE_LOCKED();
 
@@ -667,16 +666,12 @@ etharp_input(struct pbuf *p, struct netif *netif)
   }
   ETHARP_STATS_INC(etharp.recv);
 
-#if LWIP_ACD
-  /* We have to check if a host already has configured our ip address and
-   * continuously check if there is a host with this IP-address so we can
-   * detect collisions.
-   * acd_arp_reply ensures the detection of conflicts. It will handle possible
-   * defending or retreating and will make sure a new IP address is selected.
-   * etharp_input does not need to handle packets that originate "from_us".
-   */
-  acd_arp_reply(netif, hdr);
-#endif /* LWIP_ACD */
+#if LWIP_AUTOIP
+  /* We have to check if a host already has configured our random
+   * created link local address and continuously check if there is
+   * a host with this IP-address so we can detect collisions */
+  autoip_arp_reply(netif, hdr);
+#endif /* LWIP_AUTOIP */
 
   /* Copy struct ip4_addr_wordaligned to aligned ip4_addr, to support compilers without
    * structure packing (not using structure copy which breaks strict-aliasing rules). */
@@ -686,12 +681,9 @@ etharp_input(struct pbuf *p, struct netif *netif)
   /* this interface is not configured? */
   if (ip4_addr_isany_val(*netif_ip4_addr(netif))) {
     for_us = 0;
-    from_us = 0;
   } else {
     /* ARP packet directed to us? */
     for_us = (u8_t)ip4_addr_cmp(&dipaddr, netif_ip4_addr(netif));
-    /* ARP packet from us? */
-    from_us = (u8_t)ip4_addr_cmp(&sipaddr, netif_ip4_addr(netif));
   }
 
   /* ARP message directed to us?
@@ -712,7 +704,7 @@ etharp_input(struct pbuf *p, struct netif *netif)
 
       LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_input: incoming ARP request\n"));
       /* ARP request for our address? */
-      if (for_us && !from_us) {
+      if (for_us) {
         /* send ARP response */
         etharp_raw(netif,
                    (struct eth_addr *)netif->hwaddr, &hdr->shwaddr,
@@ -732,6 +724,13 @@ etharp_input(struct pbuf *p, struct netif *netif)
     case PP_HTONS(ARP_REPLY):
       /* ARP reply. We already updated the ARP cache earlier. */
       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_input: incoming ARP reply\n"));
+#if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
+      /* DHCP wants to know about ARP replies from any host with an
+       * IP address also offered to us by the DHCP server. We do not
+       * want to take a duplicate IP address on a single network.
+       * @todo How should we handle redundant (fail-over) interfaces? */
+      dhcp_arp_reply(netif, &sipaddr);
+#endif /* (LWIP_DHCP && DHCP_DOES_ARP_CHECK) */
       break;
     default:
       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_input: ARP unknown opcode type %"S16_F"\n", lwip_htons(hdr->opcode)));
@@ -984,14 +983,6 @@ etharp_query(struct netif *netif, const ip4_addr_t *ipaddr, struct pbuf *q)
       /* We don't re-send arp request in etharp_tmr, but we still queue packets,
          since this failure could be temporary, and the next packet calling
          etharp_query again could lead to sending the queued packets. */
-    } else {
-      /* ARP request successfully sent */
-      if ((arp_table[i].state == ETHARP_STATE_PENDING) && !is_new_entry) {
-        /* A new ARP request has been sent for a pending entry. Reset the ctime to
-           not let it expire too fast. */
-        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: reset ctime for entry %"S16_F"\n", (s16_t)i));
-        arp_table[i].ctime = 0;
-      }
     }
     if (q == NULL) {
       return result;
@@ -1210,42 +1201,4 @@ etharp_request(struct netif *netif, const ip4_addr_t *ipaddr)
   return etharp_request_dst(netif, ipaddr, &ethbroadcast);
 }
 
-#if LWIP_ACD
-/**
- * Send an ARP request packet probing for an ipaddr.
- * Used to send probe messages for address conflict detection.
- *
- * @param netif the lwip network interface on which to send the request
- * @param ipaddr the IP address to probe
- * @return ERR_OK if the request has been sent
- *         ERR_MEM if the ARP packet couldn't be allocated
- *         any other err_t on failure
- */
-err_t
-etharp_acd_probe(struct netif *netif, const ip4_addr_t *ipaddr)
-{
-  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
-                    (struct eth_addr *)netif->hwaddr, IP4_ADDR_ANY4, &ethzero,
-                    ipaddr, ARP_REQUEST);
-}
-
-/**
- * Send an ARP request packet announcing an ipaddr.
- * Used to send announce messages for address conflict detection.
- *
- * @param netif the lwip network interface on which to send the request
- * @param ipaddr the IP address to announce
- * @return ERR_OK if the request has been sent
- *         ERR_MEM if the ARP packet couldn't be allocated
- *         any other err_t on failure
- */
-err_t
-etharp_acd_announce(struct netif *netif, const ip4_addr_t *ipaddr)
-{
-  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
-                    (struct eth_addr *)netif->hwaddr, ipaddr, &ethzero,
-                    ipaddr, ARP_REQUEST);
-}
-#endif /* LWIP_ACD */
-
 #endif /* LWIP_IPV4 && LWIP_ARP */
diff --git a/src/core/ipv4/ip4.c b/src/core/ipv4/ip4.c
index 60d4042d..26c26a91 100644
--- a/src/core/ipv4/ip4.c
+++ b/src/core/ipv4/ip4.c
@@ -184,10 +184,10 @@ ip4_route(const ip4_addr_t *dest)
   }
 
 #if LWIP_NETIF_LOOPBACK && !LWIP_HAVE_LOOPIF
-  /* loopif is disabled, loopback traffic is passed through any netif */
+  /* loopif is disabled, looopback traffic is passed through any netif */
   if (ip4_addr_isloopback(dest)) {
     /* don't check for link on loopback traffic */
-    if ((netif_default != NULL) && netif_is_up(netif_default)) {
+    if (netif_default != NULL && netif_is_up(netif_default)) {
       return netif_default;
     }
     /* default netif is not up, just use any netif for loopback traffic */
diff --git a/src/core/ipv6/ip6.c b/src/core/ipv6/ip6.c
index afa69f1b..13633fa6 100644
--- a/src/core/ipv6/ip6.c
+++ b/src/core/ipv6/ip6.c
@@ -694,6 +694,10 @@ netif_found:
     goto ip6_input_cleanup;
   }
 
+  LWIP_DEBUGF(IP6_DEBUG, ("ip6_input: \n"));
+  ip6_debug_print(p);
+  LWIP_DEBUGF(IP6_DEBUG, ("ip6_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));
+
   /* current netif pointer. */
   ip_data.current_netif = netif;
 
@@ -1042,12 +1046,9 @@ netif_found:
 options_done:
 
   /* send to upper layers */
-  LWIP_DEBUGF(IP6_DEBUG, ("ip6_input: \n"));
-  ip6_debug_print(p);
-  LWIP_DEBUGF(IP6_DEBUG, ("ip6_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));
 
   ip_data.current_ip_header_tot_len = hlen_tot;
-
+  
 #if LWIP_RAW
   /* p points to IPv6 header again for raw_input. */
   pbuf_add_header_force(p, hlen_tot);
diff --git a/src/core/ipv6/mld6.c b/src/core/ipv6/mld6.c
index fb4e9ef4..6387d468 100644
--- a/src/core/ipv6/mld6.c
+++ b/src/core/ipv6/mld6.c
@@ -6,7 +6,7 @@
  * @ingroup ip6
  * Multicast listener discovery for IPv6. Aims to be compliant with RFC 2710.
  * No support for MLDv2.\n
- * Note: The allnodes (ff01::1, ff02::1) group is assumed be received by your
+ * Note: The allnodes (ff01::1, ff02::1) group is assumed be received by your 
  * netif since it must always be received for correct IPv6 operation (e.g. SLAAC).
  * Ensure the netif filters are configured accordingly!\n
  * The netif flags also need NETIF_FLAG_MLD6 flag set to enable MLD6 on a
diff --git a/src/core/ipv6/nd6.c b/src/core/ipv6/nd6.c
index da7a708f..ffe2340d 100644
--- a/src/core/ipv6/nd6.c
+++ b/src/core/ipv6/nd6.c
@@ -739,7 +739,9 @@ nd6_input(struct pbuf *p, struct netif *inp)
             }
           }
 #if LWIP_IPV6_AUTOCONFIG
-          if (prefix_opt->flags & ND6_PREFIX_FLAG_AUTONOMOUS) {
+          if ((prefix_opt->flags & ND6_PREFIX_FLAG_AUTONOMOUS) ||
+              ((prefix_opt->flags & ND6_PREFIX_FLAG_ON_LINK) &&
+               (prefix_opt->prefix_length == 64))) {
             /* Perform processing for autoconfiguration. */
             nd6_process_autoconfig_prefix(inp, prefix_opt, &prefix_addr);
           }
@@ -766,7 +768,7 @@ nd6_input(struct pbuf *p, struct netif *inp)
 
         rdnss_opt = (struct rdnss_option *)buffer;
         num = (rdnss_opt->length - 1) / 2;
-        for (n = 0; (rdnss_server_idx < DNS_MAX_SERVERS) && (n < num); n++, copy_offset += sizeof(ip6_addr_p_t)) {
+        for (n = 0; (rdnss_server_idx < DNS_MAX_SERVERS) && (n < num); n++) {
           ip_addr_t rdnss_address;
 
           /* Copy directly from pbuf to get an aligned, zoned copy of the prefix. */
@@ -1835,9 +1837,9 @@ nd6_new_router(const ip6_addr_t *router_addr, struct netif *netif)
   for (router_index = LWIP_ND6_NUM_ROUTERS - 1; router_index >= 0; router_index--) {
     /* check if router already exists (this is a special case for 2 netifs on the same subnet
        - e.g. wifi and cable) */
-    if(default_router_list[router_index].neighbor_entry == &(neighbor_cache[neighbor_index])){
-      return router_index;
-    }
+    if(default_router_list[router_index].neighbor_entry == &(neighbor_cache[neighbor_index])){ 
+      return router_index; 
+    } 
     if (default_router_list[router_index].neighbor_entry == NULL) {
       /* remember lowest free index to create a new entry */
       free_router_index = router_index;
diff --git a/src/core/netif.c b/src/core/netif.c
index 477a12f6..15200a27 100644
--- a/src/core/netif.c
+++ b/src/core/netif.c
@@ -80,9 +80,6 @@
 #if LWIP_DHCP
 #include "lwip/dhcp.h"
 #endif /* LWIP_DHCP */
-#if LWIP_ACD
-#include "lwip/acd.h"
-#endif /* LWIP_ACD */
 #if LWIP_IPV6_DHCP6
 #include "lwip/dhcp6.h"
 #endif /* LWIP_IPV6_DHCP6 */
@@ -143,14 +140,6 @@ static err_t netif_loop_output_ipv6(struct netif *netif, struct pbuf *p, const i
 
 static struct netif loop_netif;
 
-#if LWIP_TESTMODE
-struct netif* netif_get_loopif(void)
-{
-  return &loop_netif;
-}
-#endif
-
-
 /**
  * Initialize a lwip network interface structure for a loopback interface
  *
@@ -481,10 +470,6 @@ netif_do_set_ipaddr(struct netif *netif, const ip4_addr_t *ipaddr, ip_addr_t *ol
     LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
     netif_do_ip_addr_changed(old_addr, &new_addr);
 
-#if LWIP_ACD
-    acd_netif_ip_addr_changed(netif, old_addr, &new_addr);
-#endif /* LWIP_ACD */
-
     mib2_remove_ip4(netif);
     mib2_remove_route_ip4(0, netif);
     /* set new IP address to netif */
@@ -900,11 +885,8 @@ netif_issue_reports(struct netif *netif, u8_t report_type)
 #if LWIP_IPV4
   if ((report_type & NETIF_REPORT_TYPE_IPV4) &&
       !ip4_addr_isany_val(*netif_ip4_addr(netif))) {
-#if LWIP_ARP && !LWIP_ACD
-    /* For Ethernet network interfaces:
-     * we would like to send a "gratuitous ARP".
-     * Only needs to be done here if ACD isn't configured.
-     */
+#if LWIP_ARP
+    /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */
     if (netif->flags & (NETIF_FLAG_ETHARP)) {
       etharp_gratuitous(netif);
     }
@@ -1013,11 +995,11 @@ netif_set_link_up(struct netif *netif)
     netif_set_flags(netif, NETIF_FLAG_LINK_UP);
 
 #if LWIP_DHCP
-    dhcp_network_changed_link_up(netif);
+    dhcp_network_changed(netif);
 #endif /* LWIP_DHCP */
 
 #if LWIP_AUTOIP
-    autoip_network_changed_link_up(netif);
+    autoip_network_changed(netif);
 #endif /* LWIP_AUTOIP */
 
     netif_issue_reports(netif, NETIF_REPORT_TYPE_IPV4 | NETIF_REPORT_TYPE_IPV6);
@@ -1049,15 +1031,6 @@ netif_set_link_down(struct netif *netif)
 
   if (netif->flags & NETIF_FLAG_LINK_UP) {
     netif_clear_flags(netif, NETIF_FLAG_LINK_UP);
-
-#if LWIP_AUTOIP
-    autoip_network_changed_link_down(netif);
-#endif /* LWIP_AUTOIP */
-
-#if LWIP_ACD
-    acd_network_changed_link_down(netif);
-#endif /* LWIP_ACD */
-
     NETIF_LINK_CALLBACK(netif);
 #if LWIP_NETIF_EXT_STATUS_CALLBACK
     {
diff --git a/src/core/stats.c b/src/core/stats.c
index 95445ec9..34e9b270 100644
--- a/src/core/stats.c
+++ b/src/core/stats.c
@@ -166,3 +166,4 @@ stats_display(void)
 #endif /* LWIP_STATS_DISPLAY */
 
 #endif /* LWIP_STATS */
+
diff --git a/src/core/sys.c b/src/core/sys.c
index 69d7197a..5f08352b 100644
--- a/src/core/sys.c
+++ b/src/core/sys.c
@@ -45,30 +45,30 @@
  * No need to implement functions in this section in NO_SYS mode.
  * The OS-specific code should be implemented in arch/sys_arch.h
  * and sys_arch.c of your port.
- *
+ * 
  * The operating system emulation layer provides a common interface
  * between the lwIP code and the underlying operating system kernel. The
  * general idea is that porting lwIP to new architectures requires only
  * small changes to a few header files and a new sys_arch
  * implementation. It is also possible to do a sys_arch implementation
  * that does not rely on any underlying operating system.
- *
+ * 
  * The sys_arch provides semaphores, mailboxes and mutexes to lwIP. For the full
  * lwIP functionality, multiple threads support can be implemented in the
  * sys_arch, but this is not required for the basic lwIP
  * functionality. Timer scheduling is implemented in lwIP, but can be implemented
  * by the sys_arch port (LWIP_TIMERS_CUSTOM==1).
- *
+ * 
  * In addition to the source file providing the functionality of sys_arch,
  * the OS emulation layer must provide several header files defining
  * macros used throughout lwip.  The files required and the macros they
  * must define are listed below the sys_arch description.
- *
+ * 
  * Since lwIP 1.4.0, semaphore, mutexes and mailbox functions are prototyped in a way that
  * allows both using pointers or actual OS structures to be used. This way, memory
  * required for such types can be either allocated in place (globally or on the
  * stack) or on the heap (allocated internally in the "*_new()" functions).
- *
+ * 
  * Note:
  * -----
  * Be careful with using mem_malloc() in sys_arch. When malloc() refers to
@@ -96,7 +96,7 @@
  * Mailboxes should be implemented as a queue which allows multiple messages
  * to be posted (implementing as a rendez-vous point where only one message can be
  * posted at a time can have a highly negative impact on performance). A message
- * in a mailbox is just a pointer, nothing more.
+ * in a mailbox is just a pointer, nothing more. 
  *
  * @defgroup sys_time Time
  * @ingroup sys_layer
diff --git a/src/core/tcp.c b/src/core/tcp.c
index afb6a430..f57b42eb 100644
--- a/src/core/tcp.c
+++ b/src/core/tcp.c
@@ -11,7 +11,7 @@
  * Common functions for the TCP implementation, such as functions
  * for manipulating the data structures and the TCP timer functions. TCP functions
  * related to input and output is found in tcp_in.c and tcp_out.c respectively.\n
- *
+ * 
  * TCP connection setup
  * --------------------
  * The functions used for setting up connections is similar to that of
@@ -24,7 +24,7 @@
  * - tcp_listen() and tcp_listen_with_backlog()
  * - tcp_accept()
  * - tcp_connect()
- *
+ * 
  * Sending TCP data
  * ----------------
  * TCP data is sent by enqueueing the data with a call to tcp_write() and
@@ -34,7 +34,7 @@
  * - tcp_write()
  * - tcp_output()
  * - tcp_sent()
- *
+ * 
  * Receiving TCP data
  * ------------------
  * TCP data reception is callback based - an application specified
@@ -44,7 +44,7 @@
  * window.
  * - tcp_recv()
  * - tcp_recved()
- *
+ * 
  * Application polling
  * -------------------
  * When a connection is idle (i.e., no data is either transmitted or
@@ -62,7 +62,7 @@
  * - tcp_close()
  * - tcp_abort()
  * - tcp_err()
- *
+ * 
  */
 
 /*
@@ -469,7 +469,7 @@ tcp_close_shutdown_fin(struct tcp_pcb *pcb)
  * a closing state), the connection is closed, and put in a closing state.
  * The pcb is then automatically freed in tcp_slowtmr(). It is therefore
  * unsafe to reference it (unless an error is returned).
- *
+ * 
  * The function may return ERR_MEM if no memory
  * was available for closing the connection. If so, the application
  * should wait and try again either by using the acknowledgment
@@ -647,7 +647,6 @@ tcp_abort(struct tcp_pcb *pcb)
  * bound to all local IP addresses.
  * If another connection is bound to the same port, the function will
  * return ERR_USE, otherwise ERR_OK is returned.
- * @see MEMP_NUM_TCP_PCB_LISTEN and MEMP_NUM_TCP_PCB
  *
  * @param pcb the tcp_pcb to bind (no check is done whether this pcb is
  *        already bound!)
@@ -798,7 +797,7 @@ tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
  * When an incoming connection is accepted, the function specified with
  * the tcp_accept() function will be called. The pcb has to be bound
  * to a local port with the tcp_bind() function.
- *
+ * 
  * The tcp_listen() function returns a new connection identifier, and
  * the one passed as an argument to the function will be
  * deallocated. The reason for this behavior is that less memory is
@@ -813,7 +812,7 @@ tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
  * The backlog limits the number of outstanding connections
  * in the listen queue to the value specified by the backlog argument.
  * To use it, your need to set TCP_LISTEN_BACKLOG=1 in your lwipopts.h.
- *
+ * 
  * @param pcb the original tcp_pcb
  * @param backlog the incoming connections queue limit
  * @return tcp_pcb used for listening, consumes less memory.
@@ -893,9 +892,6 @@ tcp_listen_with_backlog_and_err(struct tcp_pcb *pcb, u8_t backlog, err_t *err)
   lpcb->netif_idx = NETIF_NO_INDEX;
   lpcb->ttl = pcb->ttl;
   lpcb->tos = pcb->tos;
-#if LWIP_VLAN_PCP
-  lpcb->netif_hints.tci = pcb->netif_hints.tci;
-#endif /* LWIP_VLAN_PCP */
 #if LWIP_IPV4 && LWIP_IPV6
   IP_SET_TYPE_VAL(lpcb->remote_ip, pcb->local_ip.type);
 #endif /* LWIP_IPV4 && LWIP_IPV6 */
@@ -1043,7 +1039,7 @@ again:
  * Connects to another host. The function given as the "connected"
  * argument will be called when the connection has been established.
  *  Sets up the pcb to connect to the remote host and sends the
- * initial SYN segment which opens the connection.
+ * initial SYN segment which opens the connection. 
  *
  * The tcp_connect() function returns immediately; it does not wait for
  * the connection to be properly setup. Instead, it will call the
@@ -1715,14 +1711,14 @@ tcp_kill_prio(u8_t prio)
 
   mprio = LWIP_MIN(TCP_PRIO_MAX, prio);
 
-  /* We want to kill connections with a lower prio, so bail out if
+  /* We want to kill connections with a lower prio, so bail out if 
    * supplied prio is 0 - there can never be a lower prio
    */
   if (mprio == 0) {
     return;
   }
 
-  /* We only want kill connections with a lower prio, so decrement prio by one
+  /* We only want kill connections with a lower prio, so decrement prio by one 
    * and start searching for oldest connection with same or lower priority than mprio.
    * We want to find the connections with the lowest possible prio, and among
    * these the one with the longest inactivity time.
@@ -1784,7 +1780,7 @@ tcp_kill_state(enum tcp_state state)
  * Kills the oldest connection that is in TIME_WAIT state.
  * Called from tcp_alloc() if no more connections are available.
  */
-static void
+void
 tcp_kill_timewait(void)
 {
   struct tcp_pcb *pcb, *inactive;
@@ -1937,7 +1933,6 @@ tcp_alloc(u8_t prio)
  * any of the TCP PCB lists.
  * The pcb is not put on any list until binding using tcp_bind().
  * If memory is not available for creating the new pcb, NULL is returned.
- * @see MEMP_NUM_TCP_PCB_LISTEN and MEMP_NUM_TCP_PCB
  *
  * @internal: Maybe there should be a idle TCP PCB list where these
  * PCBs are put on. Port reservation using tcp_bind() is implemented but
@@ -1957,7 +1952,6 @@ tcp_new(void)
  * Creates a new TCP protocol control block but doesn't
  * place it on any of the TCP PCB lists.
  * The pcb is not put on any list until binding using tcp_bind().
- * @see MEMP_NUM_TCP_PCB_LISTEN and MEMP_NUM_TCP_PCB
  *
  * @param type IP address type, see @ref lwip_ip_addr_type definitions.
  * If you want to listen to IPv4 and IPv6 (dual-stack) connections,
@@ -2047,7 +2041,7 @@ tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent)
  * @ingroup tcp_raw
  * Used to specify the function that should be called when a fatal error
  * has occurred on the connection.
- *
+ * 
  * If a connection is aborted because of an error, the application is
  * alerted of this event by the err callback. Errors that might abort a
  * connection are when there is a shortage of memory. The callback
@@ -2073,7 +2067,6 @@ tcp_err(struct tcp_pcb *pcb, tcp_err_fn err)
  * @ingroup tcp_raw
  * Used for specifying the function that should be called when a
  * LISTENing connection has been connected to another host.
- * @see MEMP_NUM_TCP_PCB_LISTEN and MEMP_NUM_TCP_PCB
  *
  * @param pcb tcp_pcb to set the accept callback
  * @param accept callback function to call for this pcb when LISTENing
@@ -2098,7 +2091,7 @@ tcp_accept(struct tcp_pcb *pcb, tcp_accept_fn accept)
  * number of TCP coarse grained timer shots, which typically occurs
  * twice a second. An interval of 10 means that the application would
  * be polled every 5 seconds.
- *
+ * 
  * When a connection is idle (i.e., no data is either transmitted or
  * received), lwIP will repeatedly poll the application by calling a
  * specified callback function. This can be used either as a watchdog
@@ -2598,7 +2591,7 @@ tcp_ext_arg_alloc_id(void)
  * @param callbacks callback table (const since it is referenced, not copied!)
  */
 void
-tcp_ext_arg_set_callbacks(struct tcp_pcb *pcb, u8_t id, const struct tcp_ext_arg_callbacks * const callbacks)
+tcp_ext_arg_set_callbacks(struct tcp_pcb *pcb, uint8_t id, const struct tcp_ext_arg_callbacks * const callbacks)
 {
   LWIP_ASSERT("pcb != NULL", pcb != NULL);
   LWIP_ASSERT("id < LWIP_TCP_PCB_NUM_EXT_ARGS", id < LWIP_TCP_PCB_NUM_EXT_ARGS);
@@ -2617,7 +2610,7 @@ tcp_ext_arg_set_callbacks(struct tcp_pcb *pcb, u8_t id, const struct tcp_ext_arg
  * @param id ext_args index to set (allocated via @ref tcp_ext_arg_alloc_id)
  * @param arg data pointer to set
  */
-void tcp_ext_arg_set(struct tcp_pcb *pcb, u8_t id, void *arg)
+void tcp_ext_arg_set(struct tcp_pcb *pcb, uint8_t id, void *arg)
 {
   LWIP_ASSERT("pcb != NULL", pcb != NULL);
   LWIP_ASSERT("id < LWIP_TCP_PCB_NUM_EXT_ARGS", id < LWIP_TCP_PCB_NUM_EXT_ARGS);
@@ -2635,7 +2628,7 @@ void tcp_ext_arg_set(struct tcp_pcb *pcb, u8_t id, void *arg)
  * @param id ext_args index to set (allocated via @ref tcp_ext_arg_alloc_id)
  * @return data pointer at the given index
  */
-void *tcp_ext_arg_get(const struct tcp_pcb *pcb, u8_t id)
+void *tcp_ext_arg_get(const struct tcp_pcb *pcb, uint8_t id)
 {
   LWIP_ASSERT("pcb != NULL", pcb != NULL);
   LWIP_ASSERT("id < LWIP_TCP_PCB_NUM_EXT_ARGS", id < LWIP_TCP_PCB_NUM_EXT_ARGS);
diff --git a/src/core/tcp_in.c b/src/core/tcp_in.c
index b6a4e4af..efd4a516 100644
--- a/src/core/tcp_in.c
+++ b/src/core/tcp_in.c
@@ -690,9 +690,6 @@ tcp_listen_input(struct tcp_pcb_listen *pcb)
 #if LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG
     npcb->listener = pcb;
 #endif /* LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG */
-#if LWIP_VLAN_PCP
-    npcb->netif_hints.tci = pcb->netif_hints.tci;
-#endif /* LWIP_VLAN_PCP */
     /* inherit socket options */
     npcb->so_options = pcb->so_options & SOF_INHERITED;
     npcb->netif_idx = pcb->netif_idx;
@@ -855,9 +852,8 @@ tcp_process(struct tcp_pcb *pcb)
   /* Do different things depending on the TCP state. */
   switch (pcb->state) {
     case SYN_SENT:
-      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %s %"U32_F"\n",
-                                    ackno, pcb->snd_nxt, pcb->unacked ? "" : " empty:",
-                                    pcb->unacked ? lwip_ntohl(pcb->unacked->tcphdr->seqno) : 0));
+      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
+                                    pcb->snd_nxt, lwip_ntohl(pcb->unacked->tcphdr->seqno)));
       /* received SYN ACK with expected sequence number? */
       if ((flags & TCP_ACK) && (flags & TCP_SYN)
           && (ackno == pcb->lastack + 1)) {
@@ -1001,6 +997,7 @@ tcp_process(struct tcp_pcb *pcb)
           TCP_RMV_ACTIVE(pcb);
           pcb->state = TIME_WAIT;
           TCP_REG(&tcp_tw_pcbs, pcb);
+          TCP_TW_LIMIT(MEMP_NUM_TCP_PCB_TIME_WAIT);
         } else {
           tcp_ack_now(pcb);
           pcb->state = CLOSING;
@@ -1019,6 +1016,7 @@ tcp_process(struct tcp_pcb *pcb)
         TCP_RMV_ACTIVE(pcb);
         pcb->state = TIME_WAIT;
         TCP_REG(&tcp_tw_pcbs, pcb);
+        TCP_TW_LIMIT(MEMP_NUM_TCP_PCB_TIME_WAIT);
       }
       break;
     case CLOSING:
@@ -1029,6 +1027,7 @@ tcp_process(struct tcp_pcb *pcb)
         TCP_RMV_ACTIVE(pcb);
         pcb->state = TIME_WAIT;
         TCP_REG(&tcp_tw_pcbs, pcb);
+        TCP_TW_LIMIT(MEMP_NUM_TCP_PCB_TIME_WAIT);
       }
       break;
     case LAST_ACK:
@@ -1146,6 +1145,7 @@ tcp_receive(struct tcp_pcb *pcb)
 {
   s16_t m;
   u32_t right_wnd_edge;
+  int found_dupack = 0;
 
   LWIP_ASSERT("tcp_receive: invalid pcb", pcb != NULL);
   LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
@@ -1207,6 +1207,7 @@ tcp_receive(struct tcp_pcb *pcb)
           if (pcb->rtime >= 0) {
             /* Clause 5 */
             if (pcb->lastack == ackno) {
+              found_dupack = 1;
               if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
                 ++pcb->dupacks;
               }
@@ -1222,6 +1223,11 @@ tcp_receive(struct tcp_pcb *pcb)
           }
         }
       }
+      /* If Clause (1) or more is true, but not a duplicate ack, reset
+       * count of consecutive duplicate acks */
+      if (!found_dupack) {
+        pcb->dupacks = 0;
+      }
     } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
       /* We come here when the ACK acknowledges new data. */
       tcpwnd_size_t acked;
diff --git a/src/core/tcp_out.c b/src/core/tcp_out.c
index a00ce23f..724df109 100644
--- a/src/core/tcp_out.c
+++ b/src/core/tcp_out.c
@@ -355,7 +355,7 @@ tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
  * it can send them more efficiently by combining them together).
  * To prompt the system to send data now, call tcp_output() after
  * calling tcp_write().
- *
+ * 
  * This function enqueues the data pointed to by the argument dataptr. The length of
  * the data is passed as the len parameter. The apiflags can be one or more of:
  * - TCP_WRITE_FLAG_COPY: indicates whether the new memory should be allocated
diff --git a/src/core/timeouts.c b/src/core/timeouts.c
index 91657eb7..f37acfec 100644
--- a/src/core/timeouts.c
+++ b/src/core/timeouts.c
@@ -51,7 +51,7 @@
 #include "lwip/ip4_frag.h"
 #include "lwip/etharp.h"
 #include "lwip/dhcp.h"
-#include "lwip/acd.h"
+#include "lwip/autoip.h"
 #include "lwip/igmp.h"
 #include "lwip/dns.h"
 #include "lwip/nd6.h"
@@ -91,9 +91,9 @@ const struct lwip_cyclic_timer lwip_cyclic_timers[] = {
   {DHCP_COARSE_TIMER_MSECS, HANDLER(dhcp_coarse_tmr)},
   {DHCP_FINE_TIMER_MSECS, HANDLER(dhcp_fine_tmr)},
 #endif /* LWIP_DHCP */
-#if LWIP_ACD
-  {ACD_TMR_INTERVAL, HANDLER(acd_tmr)},
-#endif /* LWIP_ACD */
+#if LWIP_AUTOIP
+  {AUTOIP_TMR_INTERVAL, HANDLER(autoip_tmr)},
+#endif /* LWIP_AUTOIP */
 #if LWIP_IGMP
   {IGMP_TMR_INTERVAL, HANDLER(igmp_tmr)},
 #endif /* LWIP_IGMP */
@@ -241,7 +241,7 @@ lwip_cyclic_timer(void *arg)
   cyclic->handler();
 
   now = sys_now();
-  next_timeout_time = (u32_t)(current_timeout_due_time + cyclic->interval_ms);  /* overflow handled by TIME_LESS_THAN macro */
+  next_timeout_time = (u32_t)(current_timeout_due_time + cyclic->interval_ms);  /* overflow handled by TIME_LESS_THAN macro */ 
   if (TIME_LESS_THAN(next_timeout_time, now)) {
     /* timer would immediately expire again -> "overload" -> restart without any correction */
 #if LWIP_DEBUG_TIMERNAMES
@@ -296,7 +296,7 @@ sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg)
 
   LWIP_ASSERT("Timeout time too long, max is LWIP_UINT32_MAX/4 msecs", msecs <= (LWIP_UINT32_MAX / 4));
 
-  next_timeout_time = (u32_t)(sys_now() + msecs); /* overflow handled by TIME_LESS_THAN macro */
+  next_timeout_time = (u32_t)(sys_now() + msecs); /* overflow handled by TIME_LESS_THAN macro */ 
 
 #if LWIP_DEBUG_TIMERNAMES
   sys_timeout_abs(next_timeout_time, handler, arg, handler_name);
diff --git a/src/core/udp.c b/src/core/udp.c
index 9013cccb..40cdf190 100644
--- a/src/core/udp.c
+++ b/src/core/udp.c
@@ -911,7 +911,7 @@ udp_sendto_if_src_chksum(struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *d
 /**
  * @ingroup udp_raw
  * Bind an UDP PCB.
- *
+ * 
  * @param pcb UDP PCB to be bound with a local address ipaddr and port.
  * @param ipaddr local IP address to bind with. Use IP_ANY_TYPE to
  * bind to all local interfaces.
@@ -997,13 +997,9 @@ udp_bind(struct udp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port)
         {
           /* port matches that of PCB in list and REUSEADDR not set -> reject */
           if ((ipcb->local_port == port) &&
-              (((IP_GET_TYPE(&ipcb->local_ip) == IP_GET_TYPE(ipaddr)) &&
               /* IP address matches or any IP used? */
-              (ip_addr_cmp(&ipcb->local_ip, ipaddr) ||
-              ip_addr_isany(ipaddr) ||
-              ip_addr_isany(&ipcb->local_ip))) ||
-              (IP_GET_TYPE(&ipcb->local_ip) == IPADDR_TYPE_ANY) ||
-              (IP_GET_TYPE(ipaddr) == IPADDR_TYPE_ANY))) {
+              (ip_addr_cmp(&ipcb->local_ip, ipaddr) || ip_addr_isany(ipaddr) ||
+              ip_addr_isany(&ipcb->local_ip))) {
             /* other PCB already binds to this local IP and port */
             LWIP_DEBUGF(UDP_DEBUG,
                         ("udp_bind: local port %"U16_F" already bound by another pcb\n", port));
@@ -1172,8 +1168,8 @@ udp_recv(struct udp_pcb *pcb, udp_recv_fn recv, void *recv_arg)
 
 /**
  * @ingroup udp_raw
- * Removes and deallocates the pcb.
- *
+ * Removes and deallocates the pcb.  
+ * 
  * @param pcb UDP PCB to be removed. The PCB is removed from the list of
  * UDP PCB's and the data structure is freed from memory.
  *
@@ -1212,7 +1208,6 @@ udp_remove(struct udp_pcb *pcb)
  * Creates a new UDP pcb which can be used for UDP communication. The
  * pcb is not active until it has either been bound to a local address
  * or connected to a remote address.
- * @see MEMP_NUM_UDP_PCB
  *
  * @return The UDP PCB which was created. NULL if the PCB data structure
  * could not be allocated.
@@ -1238,6 +1233,12 @@ udp_new(void)
 #if LWIP_MULTICAST_TX_OPTIONS
     udp_set_multicast_ttl(pcb, UDP_TTL);
 #endif /* LWIP_MULTICAST_TX_OPTIONS */
+// Defaults to IPADDR_TYPE_V4 (0)
+#if LWIP_IPV4 && LWIP_IPV6
+    pcb->local_ip.type = IPADDR_TYPE_ANY;
+#elif LWIP_IPV6
+    pcb->local_ip.type = IPADDR_TYPE_V6;
+#endif
   }
   return pcb;
 }
@@ -1247,8 +1248,7 @@ udp_new(void)
  * Create a UDP PCB for specific IP type.
  * The pcb is not active until it has either been bound to a local address
  * or connected to a remote address.
- * @see MEMP_NUM_UDP_PCB
- *
+ * 
  * @param type IP address type, see @ref lwip_ip_addr_type definitions.
  * If you want to listen to IPv4 and IPv6 (dual-stack) packets,
  * supply @ref IPADDR_TYPE_ANY as argument and bind to @ref IP_ANY_TYPE.
diff --git a/src/include/compat/posix/net/if.h b/src/include/compat/posix/net/if.h
index 8b8e4819..6b8e63a5 100644
--- a/src/include/compat/posix/net/if.h
+++ b/src/include/compat/posix/net/if.h
@@ -7,7 +7,7 @@
  * Copyright (c) 2017 Joel Cunningham, Garmin International, Inc. <joel.cunningham@garmin.com>
  * All rights reserved.
  *
- * Redistribution and use in source and binary forms, with or without modification,
+ * Redistribution and use in source and binary forms, with or without modification, 
  * are permitted provided that the following conditions are met:
  *
  * 1. Redistributions of source code must retain the above copyright notice,
@@ -16,17 +16,17 @@
  *    this list of conditions and the following disclaimer in the documentation
  *    and/or other materials provided with the distribution.
  * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
+ *    derived from this software without specific prior written permission. 
  *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
  * OF SUCH DAMAGE.
  *
  * This file is part of the lwIP TCP/IP stack.
diff --git a/src/include/lwip/acd.h b/src/include/lwip/acd.h
deleted file mode 100644
index a5f36586..00000000
--- a/src/include/lwip/acd.h
+++ /dev/null
@@ -1,114 +0,0 @@
-/**
- * @file
- *
- * ACD IPv4 Address Conflict Detection
- */
-
-/*
- *
- * Copyright (c) 2007 Dominik Spies <kontakt@dspies.de>
- * Copyright (c) 2018 Jasper Verschueren <jasper.verschueren@apart-audio.com>
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * Author: Jasper Verschueren <jasper.verschueren@apart-audio.com>
- * Author: Dominik Spies <kontakt@dspies.de>
- */
-
-#ifndef LWIP_HDR_ACD_H
-#define LWIP_HDR_ACD_H
-
-#include "lwip/opt.h"
-
-/* don't build if not configured for use in lwipopts.h */
-#if LWIP_IPV4 && LWIP_ACD
-
-#include "lwip/netif.h"
-#include "lwip/etharp.h"
-#include "lwip/prot/acd.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/** ACD Timing
- *  ACD_TMR_INTERVAL msecs, I recommend a value of 100.
- *  The value must divide 1000 with a remainder almost 0. Possible values are
- *  1000, 500, 333, 250, 200, 166, 142, 125, 111, 100 ....
- */
-#define ACD_TMR_INTERVAL      100
-
-/**
- * Callback function: Handle conflict information from ACD module
- *
- * @param netif   network interface to handle conflict information on
- * @param state   acd_callback_enum_t
- */
-typedef void (*acd_conflict_callback_t)(struct netif *netif, acd_callback_enum_t state);
-
-/** ACD state information per netif */
-struct acd
-{
-  /** next acd module */
-  struct acd *next;
-  /** the currently selected, probed, announced or used IP-Address */
-  ip4_addr_t ipaddr;
-  /** current ACD state machine state */
-  acd_state_enum_t state;
-  /** sent number of probes or announces, dependent on state */
-  u8_t sent_num;
-  /** ticks to wait, tick is ACD_TMR_INTERVAL long */
-  u16_t ttw;
-  /** ticks until a conflict can again be solved by defending */
-  u8_t lastconflict;
-  /** total number of probed/used IP-Addresses that resulted in a conflict */
-  u8_t num_conflicts;
-  /** callback function -> let's the acd user know if the address is good or
-      if a conflict is detected */
-  acd_conflict_callback_t acd_conflict_callback;
-};
-
-err_t acd_add(struct netif *netif, struct acd *acd,
-              acd_conflict_callback_t acd_conflict_callback);
-
-err_t acd_start(struct netif *netif, struct acd *acd, ip4_addr_t ipaddr);
-
-err_t acd_stop(struct acd *acd);
-
-void acd_arp_reply(struct netif *netif, struct etharp_hdr *hdr);
-
-void acd_tmr(void);
-
-void acd_network_changed_link_down(struct netif *netif);
-
-void acd_netif_ip_addr_changed(struct netif *netif, const ip_addr_t *old_addr,
-                               const ip_addr_t *new_addr);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* LWIP_IPV4 && LWIP_ACD */
-
-#endif /* LWIP_HDR_ACD_H */
diff --git a/src/include/lwip/altcp.h b/src/include/lwip/altcp.h
index 1b245449..97abc54d 100644
--- a/src/include/lwip/altcp.h
+++ b/src/include/lwip/altcp.h
@@ -129,11 +129,6 @@ err_t altcp_get_tcp_addrinfo(struct altcp_pcb *conn, int local, ip_addr_t *addr,
 ip_addr_t *altcp_get_ip(struct altcp_pcb *conn, int local);
 u16_t altcp_get_port(struct altcp_pcb *conn, int local);
 
-#if LWIP_TCP_KEEPALIVE
-void  altcp_keepalive_disable(struct altcp_pcb *conn);
-void  altcp_keepalive_enable(struct altcp_pcb *conn, u32_t idle, u32_t intvl, u32_t count);
-#endif
-
 #ifdef LWIP_DEBUG
 enum tcp_state altcp_dbg_get_tcp_state(struct altcp_pcb *conn);
 #endif
diff --git a/src/include/lwip/altcp_tls.h b/src/include/lwip/altcp_tls.h
index cf09d490..7b17c608 100644
--- a/src/include/lwip/altcp_tls.h
+++ b/src/include/lwip/altcp_tls.h
@@ -61,22 +61,7 @@ extern "C" {
 struct altcp_tls_config;
 
 /** @ingroup altcp_tls
- * Create an ALTCP_TLS server configuration handle prepared for multiple certificates
- */
-struct altcp_tls_config *altcp_tls_create_config_server(u8_t cert_count);
-
-/** @ingroup altcp_tls
- * Add a certificate to an ALTCP_TLS server configuration handle
- */
-err_t altcp_tls_config_server_add_privkey_cert(struct altcp_tls_config *config,
-      const u8_t *privkey, size_t privkey_len,
-      const u8_t *privkey_pass, size_t privkey_pass_len,
-      const u8_t *cert, size_t cert_len);
-
-/** @ingroup altcp_tls
- * Create an ALTCP_TLS server configuration handle with one certificate
- * (short version of calling @ref altcp_tls_create_config_server and
- * @ref altcp_tls_config_server_add_privkey_cert)
+ * Create an ALTCP_TLS server configuration handle
  */
 struct altcp_tls_config *altcp_tls_create_config_server_privkey_cert(const u8_t *privkey, size_t privkey_len,
                             const u8_t *privkey_pass, size_t privkey_pass_len,
@@ -99,17 +84,6 @@ struct altcp_tls_config *altcp_tls_create_config_client_2wayauth(const u8_t *ca,
  */
 void altcp_tls_free_config(struct altcp_tls_config *conf);
 
-/** @ingroup altcp_tls
- * Free an ALTCP_TLS global entropy instance.
- * All ALTCP_TLS configuration are linked to one altcp_tls_entropy_rng structure
- * that handle an unique system entropy & ctr_drbg instance.
- * This function allow application to free this altcp_tls_entropy_rng structure
- * when all configuration referencing it were destroyed.
- * This function does nothing if some ALTCP_TLS configuration handle are still
- * active.
- */
-void altcp_tls_free_entropy(void);
-
 /** @ingroup altcp_tls
  * Create new ALTCP_TLS layer wrapping an existing pcb as inner connection (e.g. TLS over TCP)
  */
diff --git a/src/include/lwip/api.h b/src/include/lwip/api.h
index 739f8be5..c2afaf26 100644
--- a/src/include/lwip/api.h
+++ b/src/include/lwip/api.h
@@ -153,27 +153,27 @@ enum netconn_state {
 };
 
 /** Used to inform the callback function about changes
- *
+ * 
  * Event explanation:
- *
+ * 
  * In the netconn implementation, there are three ways to block a client:
- *
+ * 
  * - accept mbox (sys_arch_mbox_fetch(&conn->acceptmbox, &accept_ptr, 0); in netconn_accept())
  * - receive mbox (sys_arch_mbox_fetch(&conn->recvmbox, &buf, 0); in netconn_recv_data())
  * - send queue is full (sys_arch_sem_wait(LWIP_API_MSG_SEM(msg), 0); in lwip_netconn_do_write())
- *
+ * 
  * The events have to be seen as events signaling the state of these mboxes/semaphores. For non-blocking
  * connections, you need to know in advance whether a call to a netconn function call would block or not,
  * and these events tell you about that.
- *
- * RCVPLUS events say: Safe to perform a potentially blocking call call once more.
+ * 
+ * RCVPLUS events say: Safe to perform a potentially blocking call call once more. 
  * They are counted in sockets - three RCVPLUS events for accept mbox means you are safe
  * to call netconn_accept 3 times without being blocked.
  * Same thing for receive mbox.
- *
+ * 
  * RCVMINUS events say: Your call to to a possibly blocking function is "acknowledged".
  * Socket implementation decrements the counter.
- *
+ * 
  * For TX, there is no need to count, its merely a flag. SENDPLUS means you may send something.
  * SENDPLUS occurs when enough data was delivered to peer so netconn_send() can be called again.
  * A SENDMINUS event occurs when the next call to a netconn_send() would be blocking.
diff --git a/src/include/lwip/apps/altcp_tls_mbedtls_opts.h b/src/include/lwip/apps/altcp_tls_mbedtls_opts.h
index 71aa5993..36cddd93 100644
--- a/src/include/lwip/apps/altcp_tls_mbedtls_opts.h
+++ b/src/include/lwip/apps/altcp_tls_mbedtls_opts.h
@@ -55,49 +55,11 @@
 #define ALTCP_MBEDTLS_DEBUG                           LWIP_DBG_OFF
 #endif
 
-/** Configure lwIP debug level of the mbedTLS library */
-#ifndef ALTCP_MBEDTLS_LIB_DEBUG
-#define ALTCP_MBEDTLS_LIB_DEBUG                       LWIP_DBG_OFF
-#endif
-
-/** Configure minimum internal debug level of the mbedTLS library */
-#ifndef ALTCP_MBEDTLS_LIB_DEBUG_LEVEL_MIN
-#define ALTCP_MBEDTLS_LIB_DEBUG_LEVEL_MIN             0
-#endif
-
-/** Enable the basic session cache
+/** Set a session timeout in seconds for the basic session cache
  * ATTENTION: Using a session cache can lower security by reusing keys!
  */
-#ifndef ALTCP_MBEDTLS_USE_SESSION_CACHE
-#define ALTCP_MBEDTLS_USE_SESSION_CACHE               0
-#endif
-
-/** Maximum cache size of the basic session cache */
-#ifndef ALTCP_MBEDTLS_SESSION_CACHE_SIZE
-#define ALTCP_MBEDTLS_SESSION_CACHE_SIZE              30
-#endif
-
-/** Set a session timeout in seconds for the basic session cache  */
 #ifndef ALTCP_MBEDTLS_SESSION_CACHE_TIMEOUT_SECONDS
-#define ALTCP_MBEDTLS_SESSION_CACHE_TIMEOUT_SECONDS   (60 * 60)
-#endif
-
-/** Use session tickets to speed up connection setup (needs
- * MBEDTLS_SSL_SESSION_TICKETS enabled in mbedTLS config).
- * ATTENTION: Using session tickets can lower security by reusing keys!
- */
-#ifndef ALTCP_MBEDTLS_USE_SESSION_TICKETS
-#define ALTCP_MBEDTLS_USE_SESSION_TICKETS             0
-#endif
-
-/** Session ticket cipher */
-#ifndef ALTCP_MBEDTLS_SESSION_TICKET_CIPHER
-#define ALTCP_MBEDTLS_SESSION_TICKET_CIPHER           MBEDTLS_CIPHER_AES_256_GCM
-#endif
-
-/** Maximum timeout for session tickets */
-#ifndef ALTCP_MBEDTLS_SESSION_TICKET_TIMEOUT_SECONDS
-#define ALTCP_MBEDTLS_SESSION_TICKET_TIMEOUT_SECONDS  (60 * 60 * 24)
+#define ALTCP_MBEDTLS_SESSION_CACHE_TIMEOUT_SECONDS   0
 #endif
 
 #endif /* LWIP_ALTCP */
diff --git a/src/include/lwip/apps/fs.h b/src/include/lwip/apps/fs.h
index 5be77c1b..67b9a60a 100644
--- a/src/include/lwip/apps/fs.h
+++ b/src/include/lwip/apps/fs.h
@@ -1,8 +1,8 @@
 /*
  * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
+ * All rights reserved. 
+ * 
+ * Redistribution and use in source and binary forms, with or without modification, 
  * are permitted provided that the following conditions are met:
  *
  * 1. Redistributions of source code must retain the above copyright notice,
@@ -11,21 +11,21 @@
  *    this list of conditions and the following disclaimer in the documentation
  *    and/or other materials provided with the distribution.
  * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
+ *    derived from this software without specific prior written permission. 
  *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
  * OF SUCH DAMAGE.
  *
  * This file is part of the lwIP TCP/IP stack.
- *
+ * 
  * Author: Adam Dunkels <adam@sics.se>
  *
  */
diff --git a/src/include/lwip/apps/http_client.h b/src/include/lwip/apps/http_client.h
index d39e1bf8..8a063083 100644
--- a/src/include/lwip/apps/http_client.h
+++ b/src/include/lwip/apps/http_client.h
@@ -52,7 +52,7 @@ extern "C" {
 #endif
 
 /**
- * @ingroup httpc
+ * @ingroup httpc 
  * HTTPC_HAVE_FILE_IO: define this to 1 to have functions dowloading directly
  * to disk via fopen/fwrite.
  * These functions are example implementations of the interface only.
@@ -62,13 +62,13 @@ extern "C" {
 #endif
 
 /**
- * @ingroup httpc
+ * @ingroup httpc 
  * The default TCP port used for HTTP
  */
 #define HTTP_DEFAULT_PORT         LWIP_IANA_PORT_HTTP
 
 /**
- * @ingroup httpc
+ * @ingroup httpc 
  * HTTP client result codes
  */
 typedef enum ehttpc_result {
@@ -97,7 +97,7 @@ typedef enum ehttpc_result {
 typedef struct _httpc_state httpc_state_t;
 
 /**
- * @ingroup httpc
+ * @ingroup httpc 
  * Prototype of a http client callback function
  *
  * @param arg argument specified when initiating the request
@@ -110,7 +110,7 @@ typedef struct _httpc_state httpc_state_t;
 typedef void (*httpc_result_fn)(void *arg, httpc_result_t httpc_result, u32_t rx_content_len, u32_t srv_res, err_t err);
 
 /**
- * @ingroup httpc
+ * @ingroup httpc 
  * Prototype of http client callback: called when the headers are received
  *
  * @param connection http client connection
diff --git a/src/include/lwip/apps/httpd_opts.h b/src/include/lwip/apps/httpd_opts.h
index 573eb86c..8723961f 100644
--- a/src/include/lwip/apps/httpd_opts.h
+++ b/src/include/lwip/apps/httpd_opts.h
@@ -112,9 +112,7 @@
 /** Set this to 0 to prevent parsing the file extension at runtime to decide
  * if a file should be scanned for SSI tags or not.
  * Default is 1 (file extensions are checked using the g_pcSSIExtensions array)
- * Set to 2 to override this runtime test function. In this case, you have to
- * provide an external function that does the check:
- *   u8_t http_uri_is_ssi(struct fs_file *file, const char *uri)
+ * Set to 2 to override this runtime test function.
  *
  * This is enabled by default, but if you only use a newer version of makefsdata
  * supporting the "-ssi" option, this info is already present in
@@ -123,14 +121,6 @@
 #define LWIP_HTTPD_SSI_BY_FILE_EXTENSION  1
 #endif
 
-/** This is a list of file extensions handled as SSI files. This define
- * is used to initialize a 'const char *const[]'. It is only used if
- * LWIP_HTTPD_SSI_BY_FILE_EXTENSION != 0.
- */
-#if !defined LWIP_HTTPD_SSI_EXTENSIONS || defined __DOXYGEN__
-#define LWIP_HTTPD_SSI_EXTENSIONS ".shtml", ".shtm", ".ssi", ".xml", ".json"
-#endif
-
 /** Set this to 1 to support HTTP POST */
 #if !defined LWIP_HTTPD_SUPPORT_POST || defined __DOXYGEN__
 #define LWIP_HTTPD_SUPPORT_POST   0
@@ -185,7 +175,7 @@
 #define HTTPD_DEBUG         LWIP_DBG_OFF
 #endif
 
-/** Set this to 1 to use a memp pool for allocating
+/** Set this to 1 to use a memp pool for allocating 
  * struct http_state instead of the heap.
  * If enabled, you'll need to define MEMP_NUM_PARALLEL_HTTPD_CONNS
  * (and MEMP_NUM_PARALLEL_HTTPD_SSI_CONNS for SSI) to set the size of
diff --git a/src/include/lwip/apps/mdns.h b/src/include/lwip/apps/mdns.h
index 2666875c..20d7ee2a 100644
--- a/src/include/lwip/apps/mdns.h
+++ b/src/include/lwip/apps/mdns.h
@@ -32,7 +32,6 @@
  * This file is part of the lwIP TCP/IP stack.
  *
  * Author: Erik Ekman <erik@kryo.se>
- * Author: Jasper Verschueren <jasper.verschueren@apart-audio.com>
  *
  */
 
@@ -57,41 +56,10 @@ enum mdns_sd_proto {
 #define MDNS_PROBING_SUCCESSFUL 1
 
 #define MDNS_LABEL_MAXLEN  63
-#define MDNS_DOMAIN_MAXLEN 256
 
 struct mdns_host;
 struct mdns_service;
 
-/* Domain structs */
-struct mdns_domain {
-  /* Encoded domain name */
-  u8_t name[MDNS_DOMAIN_MAXLEN];
-  /* Total length of domain name, including zero */
-  u16_t length;
-  /* Set if compression of this domain is not allowed */
-  u8_t skip_compression;
-};
-
-/** Domain, type and class.
- *  Shared between questions and answers */
-struct mdns_rr_info {
-  struct mdns_domain domain;
-  u16_t type;
-  u16_t klass;
-};
-
-struct mdns_answer {
-  struct mdns_rr_info info;
-  /** cache flush command bit */
-  u16_t cache_flush;
-  /* Validity time in seconds */
-  u32_t ttl;
-  /** Length of variable answer */
-  u16_t rd_length;
-  /** Offset of start of variable answer in packet */
-  u16_t rd_offset;
-};
-
 /** Callback function to add text to a reply, called when generating the reply */
 typedef void (*service_get_txt_fn_t)(struct mdns_service *service, void *txt_userdata);
 
@@ -105,11 +73,11 @@ void mdns_resp_init(void);
 
 void mdns_resp_register_name_result_cb(mdns_name_result_cb_t cb);
 
-err_t mdns_resp_add_netif(struct netif *netif, const char *hostname);
+err_t mdns_resp_add_netif(struct netif *netif, const char *hostname, u32_t dns_ttl);
 err_t mdns_resp_remove_netif(struct netif *netif);
 err_t mdns_resp_rename_netif(struct netif *netif, const char *hostname);
 
-s8_t  mdns_resp_add_service(struct netif *netif, const char *name, const char *service, enum mdns_sd_proto proto, u16_t port, service_get_txt_fn_t txt_fn, void *txt_userdata);
+s8_t  mdns_resp_add_service(struct netif *netif, const char *name, const char *service, enum mdns_sd_proto proto, u16_t port, u32_t dns_ttl, service_get_txt_fn_t txt_fn, void *txt_userdata);
 err_t mdns_resp_del_service(struct netif *netif, s8_t slot);
 err_t mdns_resp_rename_service(struct netif *netif, s8_t slot, const char *name);
 
@@ -128,19 +96,6 @@ void mdns_resp_announce(struct netif *netif);
  */
 #define mdns_resp_netif_settings_changed(netif) mdns_resp_announce(netif)
 
-#if LWIP_MDNS_SEARCH
-typedef void (*search_result_fn_t)(struct mdns_answer *answer, const char *varpart, int varlen, int flags, void *arg);
-/* flags bits, both can be set! */
-#define MDNS_SEARCH_RESULT_FIRST    1 /* First answer in received frame. */
-#define MDNS_SEARCH_RESULT_LAST     2 /* Last answer. */
-
-err_t mdns_search_service(const char *name, const char *service, enum mdns_sd_proto proto,
-                          struct netif *netif, search_result_fn_t result_fn, void *arg,
-                          s8_t *request_id);
-void mdns_search_stop(s8_t request_id);
-
-#endif /* LWIP_MDNS_SEARCH */
-
 #endif /* LWIP_MDNS_RESPONDER */
 
 #ifdef __cplusplus
diff --git a/src/include/lwip/apps/mdns_domain.h b/src/include/lwip/apps/mdns_domain.h
deleted file mode 100644
index 9fa804e6..00000000
--- a/src/include/lwip/apps/mdns_domain.h
+++ /dev/null
@@ -1,80 +0,0 @@
-/**
- * @file
- * MDNS responder - domain related functionalities 
- */
-
- /*
- * Copyright (c) 2015 Verisure Innovation AB
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Erik Ekman <erik@kryo.se>
- * Author: Jasper Verschueren <jasper.verschueren@apart-audio.com>
- *
- */
-
-#ifndef LWIP_HDR_APPS_MDNS_DOMAIN_H
-#define LWIP_HDR_APPS_MDNS_DOMAIN_H
-
-#include "lwip/apps/mdns_opts.h"
-#include "lwip/apps/mdns_priv.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#if LWIP_MDNS_RESPONDER
-
-/* Domain methods - also visible for unit tests */
-
-err_t mdns_domain_add_label(struct mdns_domain *domain, const char *label, u8_t len);
-err_t mdns_domain_add_domain(struct mdns_domain *domain, struct mdns_domain *source);
-err_t mdns_domain_add_string(struct mdns_domain *domain, const char *source);
-u16_t mdns_readname(struct pbuf *p, u16_t offset, struct mdns_domain *domain);
-void mdns_domain_debug_print(struct mdns_domain *domain);
-int mdns_domain_eq(struct mdns_domain *a, struct mdns_domain *b);
-#if LWIP_IPV4
-err_t mdns_build_reverse_v4_domain(struct mdns_domain *domain, const ip4_addr_t *addr);
-#endif
-#if LWIP_IPV6
-err_t mdns_build_reverse_v6_domain(struct mdns_domain *domain, const ip6_addr_t *addr);
-#endif
-err_t mdns_build_host_domain(struct mdns_domain *domain, struct mdns_host *mdns);
-err_t mdns_build_dnssd_domain(struct mdns_domain *domain);
-err_t mdns_build_service_domain(struct mdns_domain *domain, struct mdns_service *service, int include_name);
-#if LWIP_MDNS_SEARCH
-err_t mdns_build_request_domain(struct mdns_domain *domain, struct mdns_request *request, int include_name);
-#endif
-u16_t mdns_compress_domain(struct pbuf *pbuf, u16_t *offset, struct mdns_domain *domain);
-err_t mdns_write_domain(struct mdns_outpacket *outpkt, struct mdns_domain *domain);
-
-#endif /* LWIP_MDNS_RESPONDER */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* LWIP_HDR_APPS_MDNS_DOMAIN_H */
diff --git a/src/include/lwip/apps/mdns_opts.h b/src/include/lwip/apps/mdns_opts.h
index 684d631e..45f2c50c 100644
--- a/src/include/lwip/apps/mdns_opts.h
+++ b/src/include/lwip/apps/mdns_opts.h
@@ -32,7 +32,6 @@
  * This file is part of the lwIP TCP/IP stack.
  *
  * Author: Erik Ekman <erik@kryo.se>
- * Author: Jasper Verschueren <jasper.verschueren@apart-audio.com>
  *
  */
 
@@ -67,18 +66,6 @@
 #define MDNS_RESP_USENETIF_EXTCALLBACK  LWIP_NETIF_EXT_STATUS_CALLBACK
 #endif
 
-/**
- * LWIP_MDNS_SEARCH==1: Turn on search over multicast DNS module.
- */
-#ifndef LWIP_MDNS_SEARCH
-#define LWIP_MDNS_SEARCH                1
-#endif
-
-/** The maximum number of running requests */
-#ifndef MDNS_MAX_REQUESTS
-#define MDNS_MAX_REQUESTS               2
-#endif
-
 /**
  * MDNS_DEBUG: Enable debugging for multicast DNS.
  */
@@ -91,3 +78,4 @@
  */
 
 #endif /* LWIP_HDR_APPS_MDNS_OPTS_H */
+
diff --git a/src/include/lwip/apps/mdns_out.h b/src/include/lwip/apps/mdns_out.h
deleted file mode 100644
index e6a7e388..00000000
--- a/src/include/lwip/apps/mdns_out.h
+++ /dev/null
@@ -1,138 +0,0 @@
-/**
- * @file
- * MDNS responder - output related functionalities
- */
-
- /*
- * Copyright (c) 2015 Verisure Innovation AB
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- * Author: Erik Ekman <erik@kryo.se>
- * Author: Jasper Verschueren <jasper.verschueren@apart-audio.com>
- *
- */
-
-#ifndef LWIP_HDR_APPS_MDNS_OUT_H
-#define LWIP_HDR_APPS_MDNS_OUT_H
-
-#include "lwip/apps/mdns_opts.h"
-#include "lwip/apps/mdns_priv.h"
-#include "lwip/netif.h"
-#include "lwip/timeouts.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#if LWIP_MDNS_RESPONDER
-
-/** Bitmasks outmsg generation */
-/* Probe for ALL types with hostname */
-#define QUESTION_PROBE_HOST_ANY          0x10
-/* Probe for ALL types with service instance name */
-#define QUESTION_PROBE_SERVICE_NAME_ANY  0x10
-
-/* Lookup from hostname -> IPv4 */
-#define REPLY_HOST_A            0x01
-/* Lookup from IPv4/v6 -> hostname */
-#define REPLY_HOST_PTR_V4       0x02
-/* Lookup from hostname -> IPv6 */
-#define REPLY_HOST_AAAA         0x04
-/* Lookup from hostname -> IPv6 */
-#define REPLY_HOST_PTR_V6       0x08
-
-/* Lookup for service types */
-#define REPLY_SERVICE_TYPE_PTR  0x10
-/* Lookup for instances of service */
-#define REPLY_SERVICE_NAME_PTR  0x20
-/* Lookup for location of service instance */
-#define REPLY_SERVICE_SRV       0x40
-/* Lookup for text info on service instance */
-#define REPLY_SERVICE_TXT       0x80
-
-/* RFC6762 section 6:
- * To protect the network against excessive packet flooding due to software bugs
- * or malicious attack, a Multicast DNS responder MUST NOT (except in the one
- * special case of answering probe queries) multicast a record on a given
- * interface until at least one second has elapsed since the last time that
- * record was multicast on that particular interface.
- */
-#define MDNS_MULTICAST_TIMEOUT    1000
-
-/* RFC6762 section 6:
- * In this special case only, when responding via multicast to a probe, a
- * Multicast DNS responder is only required to delay its transmission as
- * necessary to ensure an interval of at least 250 ms since the last time the
- * record was multicast on that interface.
- */
-#define MDNS_MULTICAST_PROBE_TIMEOUT    250
-
-/* RFC6762 section 5.4:
- * When receiving a question with the unicast-response bit set, a responder
- * SHOULD usually respond with a unicast packet directed back to the querier.
- * However, if the responder has not multicast that record recently (within one
- * quarter of its TTL), then the responder SHOULD instead multicast the response
- * so as to keep all the peer caches up to date, and to permit passive conflict
- * detection.
- * -> we implement a stripped down version. Depending on a timeout of 30s
- *    (25% of 120s) all QU questions are send via multicast or unicast.
- */
-#define MDNS_MULTICAST_TIMEOUT_25TTL  30000
-
-err_t mdns_create_outpacket(struct netif *netif, struct mdns_outmsg *msg,
-                            struct mdns_outpacket *outpkt);
-err_t mdns_send_outpacket(struct mdns_outmsg *msg, struct netif *netif);
-void mdns_set_timeout(struct netif *netif, u32_t msecs,
-                        sys_timeout_handler handler, u8_t *busy_flag);
-#if LWIP_IPV4
-void mdns_multicast_timeout_reset_ipv4(void *arg);
-void mdns_multicast_probe_timeout_reset_ipv4(void *arg);
-void mdns_multicast_timeout_25ttl_reset_ipv4(void *arg);
-void mdns_send_multicast_msg_delayed_ipv4(void *arg);
-void mdns_send_unicast_msg_delayed_ipv4(void *arg);
-void mdns_start_multicast_timeouts_ipv4(struct netif *netif);
-#endif
-#if LWIP_IPV6
-void mdns_multicast_timeout_reset_ipv6(void *arg);
-void mdns_multicast_probe_timeout_reset_ipv6(void *arg);
-void mdns_multicast_timeout_25ttl_reset_ipv6(void *arg);
-void mdns_send_multicast_msg_delayed_ipv6(void *arg);
-void mdns_send_unicast_msg_delayed_ipv6(void *arg);
-void mdns_start_multicast_timeouts_ipv6(struct netif *netif);
-#endif
-void mdns_prepare_txtdata(struct mdns_service *service);
-#ifdef LWIP_MDNS_SEARCH
-err_t mdns_send_request(struct mdns_request *req, struct netif *netif, const ip_addr_t *destination);
-#endif
-
-#endif /* LWIP_MDNS_RESPONDER */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* LWIP_HDR_APPS_MDNS_OUT_H */
diff --git a/src/include/lwip/apps/mdns_priv.h b/src/include/lwip/apps/mdns_priv.h
index 2bc9ef0d..9635b5b1 100644
--- a/src/include/lwip/apps/mdns_priv.h
+++ b/src/include/lwip/apps/mdns_priv.h
@@ -32,13 +32,11 @@
  * This file is part of the lwIP TCP/IP stack.
  *
  * Author: Erik Ekman <erik@kryo.se>
- * Author: Jasper Verschueren <jasper.verschueren@apart-audio.com>
  *
  */
 #ifndef LWIP_HDR_MDNS_PRIV_H
 #define LWIP_HDR_MDNS_PRIV_H
 
-#include "lwip/apps/mdns.h"
 #include "lwip/apps/mdns_opts.h"
 #include "lwip/pbuf.h"
 
@@ -48,185 +46,24 @@ extern "C" {
 
 #if LWIP_MDNS_RESPONDER
 
-#define MDNS_READNAME_ERROR 0xFFFF
-#define NUM_DOMAIN_OFFSETS 10
-
-#define SRV_PRIORITY 0
-#define SRV_WEIGHT   0
-
-/* mDNS TTL: (RFC6762 section 10)
- *  - 120 seconds if the hostname appears somewhere in the RR
- *  - 75 minutes if not (4500 seconds)
- *  - 10 seconds if responding to a legacy query
- */
-#define MDNS_TTL_10    10
-#define MDNS_TTL_120   120
-#define MDNS_TTL_4500  4500
-
-/* RFC6762 section 8.1: If fifteen conflicts occur within any ten-second period,
- * then the host MUST wait at least five seconds before each successive
- * additional probe attempt.
- */
-#define MDNS_PROBE_MAX_CONFLICTS_BEFORE_RATE_LIMIT  15
-#define MDNS_PROBE_MAX_CONFLICTS_TIME_WINDOW        10000
-#define MDNS_PROBE_MAX_CONFLICTS_TIMEOUT            5000
-
-#if LWIP_MDNS_SEARCH
-/** Description of a search request */
-struct mdns_request {
-  /** Name of service, like 'myweb' */
-  char name[MDNS_LABEL_MAXLEN + 1];
-  /** Type of service, like '_http' or '_services._dns-sd' */
-  struct mdns_domain service;
-  /** Callback function called for each response */
-  search_result_fn_t result_fn;
-  void *arg;
-  /** Protocol, TCP or UDP */
-  u16_t proto;
-  /** Query type (PTR, SRV, ...) */
-  u8_t qtype;
-  /** PTR only request. */
-  u16_t only_ptr;
-};
-#endif
-
-/** Description of a service */
-struct mdns_service {
-  /** TXT record to answer with */
-  struct mdns_domain txtdata;
-  /** Name of service, like 'myweb' */
-  char name[MDNS_LABEL_MAXLEN + 1];
-  /** Type of service, like '_http' */
-  char service[MDNS_LABEL_MAXLEN + 1];
-  /** Callback function and userdata
-   * to update txtdata buffer */
-  service_get_txt_fn_t txt_fn;
-  void *txt_userdata;
-  /** Protocol, TCP or UDP */
-  u16_t proto;
-  /** Port of the service */
-  u16_t port;
-};
+/* Domain struct and methods - visible for unit tests */
 
-/** mDNS output packet */
-struct mdns_outpacket {
-  /** Packet data */
-  struct pbuf *pbuf;
-  /** Current write offset in packet */
-  u16_t write_offset;
-  /** Number of questions written */
-  u16_t questions;
-  /** Number of normal answers written */
-  u16_t answers;
-  /** Number of authoritative answers written */
-  u16_t authoritative;
-  /** Number of additional answers written */
-  u16_t additional;
-  /** Offsets for written domain names in packet.
-   *  Used for compression */
-  u16_t domain_offsets[NUM_DOMAIN_OFFSETS];
-};
-
-/** mDNS output message */
-struct mdns_outmsg {
-  /** Identifier. Used in legacy queries */
-  u16_t tx_id;
-  /** dns flags */
-  u8_t flags;
-  /** Destination IP/port if sent unicast */
-  ip_addr_t dest_addr;
-  u16_t dest_port;
-  /** If all answers in packet should set cache_flush bit */
-  u8_t cache_flush;
-  /** If reply should be sent unicast (as requested) */
-  u8_t unicast_reply_requested;
-  /** If legacy query. (tx_id needed, and write
-   *  question again in reply before answer) */
-  u8_t legacy_query;
-  /** If the query is a probe msg we need to respond immediatly. Independent of
-   *  the QU or QM flag. */
-  u8_t probe_query_recv;
-  /* Question bitmask for host information */
-  u8_t host_questions;
-  /* Questions bitmask per service */
-  u8_t serv_questions[MDNS_MAX_SERVICES];
-  /* Reply bitmask for host information */
-  u8_t host_replies;
-  /* Bitmask for which reverse IPv6 hosts to answer */
-  u8_t host_reverse_v6_replies;
-  /* Reply bitmask per service */
-  u8_t serv_replies[MDNS_MAX_SERVICES];
-#ifdef LWIP_MDNS_SEARCH
-  /** Search query to send */
-  struct mdns_request *query;
-#endif
-};
-
-/** Delayed msg info */
-struct mdns_delayed_msg {
-  /** Signals if a multicast msg needs to be send out */
-  u8_t multicast_msg_waiting;
-  /** Multicast timeout for all multicast traffic except probe answers */
-  u8_t multicast_timeout;
-  /** Multicast timeout only for probe answers */
-  u8_t multicast_probe_timeout;
-  /** Output msg used for delayed multicast responses */
-  struct mdns_outmsg delayed_msg_multicast;
-  /** Prefer multicast over unicast timeout -> 25% of TTL = we take 30s as
-      general delay. */
-  u8_t multicast_timeout_25TTL;
-  /** Only send out new unicast message if previous was send */
-  u8_t unicast_msg_in_use;
-  /** Output msg used for delayed unicast responses */
-  struct mdns_outmsg delayed_msg_unicast;
-};
-
-/* MDNS states */
-typedef enum {
-  /* MDNS module is off */
-  MDNS_STATE_OFF,
-  /* Waiting before probing can be started */
-  MDNS_STATE_PROBE_WAIT,
-  /* Probing the unique records */
-  MDNS_STATE_PROBING,
-  /* Waiting before announcing the probed unique records */
-  MDNS_STATE_ANNOUNCE_WAIT,
-  /* Announcing all records */
-  MDNS_STATE_ANNOUNCING,
-  /* Probing and announcing completed */
-  MDNS_STATE_COMPLETE
-} acd_state_enum_t;
+#define MDNS_DOMAIN_MAXLEN 256
+#define MDNS_READNAME_ERROR 0xFFFF
 
-/** Description of a host/netif */
-struct mdns_host {
-  /** Hostname */
-  char name[MDNS_LABEL_MAXLEN + 1];
-  /** Pointer to services */
-  struct mdns_service *services[MDNS_MAX_SERVICES];
-  /** Number of probes/announces sent for the current name */
-  u8_t sent_num;
-  /** State of the mdns responder */
-  acd_state_enum_t state;
-#if LWIP_IPV4
-  /** delayed msg struct for IPv4 */
-  struct mdns_delayed_msg ipv4;
-#endif
-#if LWIP_IPV6
-  /** delayed msg struct for IPv6 */
-  struct mdns_delayed_msg ipv6;
-#endif
-  /** Timestamp of probe conflict saved in list */
-  u32_t conflict_time[MDNS_PROBE_MAX_CONFLICTS_BEFORE_RATE_LIMIT];
-  /** Rate limit flag */
-  u8_t rate_limit_activated;
-  /** List index for timestamps */
-  u8_t index;
-  /** number of conflicts since startup */
-  u8_t num_conflicts;
+struct mdns_domain {
+  /* Encoded domain name */
+  u8_t name[MDNS_DOMAIN_MAXLEN];
+  /* Total length of domain name, including zero */
+  u16_t length;
+  /* Set if compression of this domain is not allowed */
+  u8_t skip_compression;
 };
 
-struct mdns_host* netif_mdns_data(struct netif *netif);
-struct udp_pcb* get_mdns_pcb(void);
+err_t mdns_domain_add_label(struct mdns_domain *domain, const char *label, u8_t len);
+u16_t mdns_readname(struct pbuf *p, u16_t offset, struct mdns_domain *domain);
+int mdns_domain_eq(struct mdns_domain *a, struct mdns_domain *b);
+u16_t mdns_compress_domain(struct pbuf *pbuf, u16_t *offset, struct mdns_domain *domain);
 
 #endif /* LWIP_MDNS_RESPONDER */
 
diff --git a/src/include/lwip/apps/mqtt.h b/src/include/lwip/apps/mqtt.h
index f099812d..c2bb2288 100644
--- a/src/include/lwip/apps/mqtt.h
+++ b/src/include/lwip/apps/mqtt.h
@@ -134,7 +134,7 @@ enum {
   MQTT_DATA_FLAG_LAST = 1
 };
 
-/**
+/** 
  * @ingroup mqtt
  * Function prototype for MQTT incoming publish data callback function. Called when data
  * arrives to a subscribed topic @see mqtt_subscribe
@@ -149,7 +149,7 @@ enum {
 typedef void (*mqtt_incoming_data_cb_t)(void *arg, const u8_t *data, u16_t len, u8_t flags);
 
 
-/**
+/** 
  * @ingroup mqtt
  * Function prototype for MQTT incoming publish function. Called when an incoming publish
  * arrives to a subscribed topic @see mqtt_subscribe
diff --git a/src/include/lwip/apps/smtp_opts.h b/src/include/lwip/apps/smtp_opts.h
index c588fb9d..bc743f67 100644
--- a/src/include/lwip/apps/smtp_opts.h
+++ b/src/include/lwip/apps/smtp_opts.h
@@ -6,14 +6,14 @@
 #ifdef __cplusplus
 extern "C" {
 #endif
-
+    
 /**
  * @defgroup smtp_opts Options
  * @ingroup smtp
- *
+ * 
  * @{
  */
-
+    
 /** Set this to 1 to enable data handler callback on BODY */
 #ifndef SMTP_BODYDH
 #define SMTP_BODYDH             0
@@ -78,3 +78,4 @@ extern "C" {
 #endif
 
 #endif /* SMTP_OPTS_H */
+
diff --git a/src/include/lwip/apps/snmp.h b/src/include/lwip/apps/snmp.h
index db9f51b8..a3f8eb15 100644
--- a/src/include/lwip/apps/snmp.h
+++ b/src/include/lwip/apps/snmp.h
@@ -101,16 +101,6 @@ err_t snmp_send_trap_generic(s32_t generic_trap);
 err_t snmp_send_trap_specific(s32_t specific_trap, struct snmp_varbind *varbinds);
 err_t snmp_send_trap(const struct snmp_obj_id* oid, s32_t generic_trap, s32_t specific_trap, struct snmp_varbind *varbinds);
 
-err_t snmp_send_inform_generic(s32_t generic_trap, struct snmp_varbind *varbinds, s32_t *ptr_request_id);
-err_t snmp_send_inform_specific(s32_t specific_trap, struct snmp_varbind *varbinds, s32_t *ptr_request_id);
-err_t snmp_send_inform(const struct snmp_obj_id* oid, s32_t generic_trap, s32_t specific_trap, struct snmp_varbind *varbinds, s32_t *ptr_request_id);
-struct snmp_request;
-typedef void (*snmp_inform_callback_fct)(struct snmp_request *request, void* callback_arg);
-void snmp_set_inform_callback(snmp_inform_callback_fct inform_callback, void* callback_arg);
-
-void snmp_set_default_trap_version(u8_t snmp_version);
-u8_t snmp_get_default_trap_version(void);
-
 #define SNMP_AUTH_TRAPS_DISABLED 0
 #define SNMP_AUTH_TRAPS_ENABLED  1
 void snmp_set_auth_traps_enabled(u8_t enable);
diff --git a/src/include/lwip/apps/snmp_core.h b/src/include/lwip/apps/snmp_core.h
index 5a8a49f8..6021c722 100644
--- a/src/include/lwip/apps/snmp_core.h
+++ b/src/include/lwip/apps/snmp_core.h
@@ -101,7 +101,7 @@ extern "C" {
 /** error codes predefined by SNMP prot. */
 typedef enum {
   SNMP_ERR_NOERROR             = 0,
-/*
+/* 
 outdated v1 error codes. do not use anmore!
 #define SNMP_ERR_NOSUCHNAME 2  use SNMP_ERR_NOSUCHINSTANCE instead
 #define SNMP_ERR_BADVALUE   3  use SNMP_ERR_WRONGTYPE,SNMP_ERR_WRONGLENGTH,SNMP_ERR_WRONGENCODING or SNMP_ERR_WRONGVALUE instead
diff --git a/src/include/lwip/apps/sntp.h b/src/include/lwip/apps/sntp.h
index 11dacce9..f4287232 100644
--- a/src/include/lwip/apps/sntp.h
+++ b/src/include/lwip/apps/sntp.h
@@ -57,14 +57,15 @@ u8_t sntp_enabled(void);
 
 void sntp_setserver(u8_t idx, const ip_addr_t *addr);
 const ip_addr_t* sntp_getserver(u8_t idx);
-u8_t sntp_getkodreceived(u8_t idx);
 
 #if SNTP_MONITOR_SERVER_REACHABILITY
 u8_t sntp_getreachability(u8_t idx);
 #endif /* SNTP_MONITOR_SERVER_REACHABILITY */
 
 #if SNTP_SERVER_DNS
-void sntp_setservername(u8_t idx, const char *server);
+void sntp_setserver_update_delay(u8_t idx, u32_t update_delay);
+u32_t sntp_getserver_update_delay(u8_t idx);
+void sntp_setserver(u8_t idx, const ip_addr_t *addr);
 const char *sntp_getservername(u8_t idx);
 #endif /* SNTP_SERVER_DNS */
 
diff --git a/src/include/lwip/apps/tftp_client.h b/src/include/lwip/apps/tftp_client.h
deleted file mode 100644
index 24dbda6a..00000000
--- a/src/include/lwip/apps/tftp_client.h
+++ /dev/null
@@ -1,50 +0,0 @@
-/**
- *
- * @file tftp_client.h
- * TFTP client header
- *
- */
-
-/*
- * Redistribution and use in source and binary forms, with or without
- * modification,are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
- * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
- * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * This file is part of the lwIP TCP/IP stack.
- *
- */
-
-#ifndef LWIP_HDR_APPS_TFTP_CLIENT_H
-#define LWIP_HDR_APPS_TFTP_CLIENT_H
-
-#include "lwip/apps/tftp_common.h"
-
-enum tftp_transfer_mode {
-  TFTP_MODE_OCTET,
-  TFTP_MODE_NETASCII,
-  TFTP_MODE_BINARY /* used in old versions only */
-};
-
-err_t tftp_init_client(const struct tftp_context* ctx);
-err_t tftp_get(void* handle, const ip_addr_t *addr, u16_t port, const char* fname, enum tftp_transfer_mode mode);
-err_t tftp_put(void* handle, const ip_addr_t *addr, u16_t port, const char* fname, enum tftp_transfer_mode mode);
-
-#endif /* LWIP_HDR_APPS_TFTP_CLIENT_H */
diff --git a/src/include/lwip/apps/tftp_common.h b/src/include/lwip/apps/tftp_common.h
deleted file mode 100644
index 4bc2c173..00000000
--- a/src/include/lwip/apps/tftp_common.h
+++ /dev/null
@@ -1,108 +0,0 @@
-/**
- *
- * @file tftp_common.h
- *
- * @author   Logan Gunthorpe <logang@deltatee.com>
- *
- * @brief    Trivial File Transfer Protocol (RFC 1350)
- *
- * Copyright (c) Deltatee Enterprises Ltd. 2013
- * All rights reserved.
- *
- */
-
-/*
- * Redistribution and use in source and binary forms, with or without
- * modification,are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
- * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
- * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * Author: Logan Gunthorpe <logang@deltatee.com>
- *
- */
-
-#ifndef LWIP_HDR_APPS_TFTP_COMMON_H
-#define LWIP_HDR_APPS_TFTP_COMMON_H
-
-#include "lwip/apps/tftp_opts.h"
-#include "lwip/err.h"
-#include "lwip/pbuf.h"
-#include "lwip/ip_addr.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/** @ingroup tftp
- * TFTP context containing callback functions for TFTP transfers
- */
-struct tftp_context {
-  /**
-   * Open file for read/write (server mode only).
-   * @param fname Filename
-   * @param mode Mode string from TFTP RFC 1350 (netascii, octet, mail)
-   * @param write Flag indicating read (0) or write (!= 0) access
-   * @returns File handle supplied to other functions
-   */
-  void* (*open)(const char* fname, const char* mode, u8_t write);
-  /**
-   * Close file handle
-   * @param handle File handle returned by open()/tftp_put()/tftp_get()
-   */
-  void (*close)(void* handle);
-  /**
-   * Read from file
-   * @param handle File handle returned by open()/tftp_put()/tftp_get()
-   * @param buf Target buffer to copy read data to
-   * @param bytes Number of bytes to copy to buf
-   * @returns &gt;= 0: Success; &lt; 0: Error
-   */
-  int (*read)(void* handle, void* buf, int bytes);
-  /**
-   * Write to file
-   * @param handle File handle returned by open()/tftp_put()/tftp_get()
-   * @param pbuf PBUF adjusted such that payload pointer points
-   *             to the beginning of write data. In other words,
-   *             TFTP headers are stripped off.
-   * @returns &gt;= 0: Success; &lt; 0: Error
-   */
-  int (*write)(void* handle, struct pbuf* p);
-  /**
-   * Error indication from client or response from server
-   * @param handle File handle set by open()/tftp_get()/tftp_put()
-   * @param err error code from client or server
-   * @param msg error message from client or server
-   * @param size size of msg
-   */
-  void (*error)(void* handle, int err, const char* msg, int size);
-};
-
-#define LWIP_TFTP_MODE_SERVER       0x01
-#define LWIP_TFTP_MODE_CLIENT       0x02
-#define LWIP_TFTP_MODE_CLIENTSERVER (LWIP_TFTP_MODE_SERVER | LWIP_TFTP_MODE_CLIENT)
-
-err_t tftp_init_common(u8_t mode, const struct tftp_context* ctx);
-void tftp_cleanup(void);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* LWIP_HDR_APPS_TFTP_COMMON_H */
diff --git a/src/include/lwip/apps/tftp_opts.h b/src/include/lwip/apps/tftp_opts.h
index 509fabd6..198f632b 100644
--- a/src/include/lwip/apps/tftp_opts.h
+++ b/src/include/lwip/apps/tftp_opts.h
@@ -11,7 +11,7 @@
  *
  */
 
-/*
+/* 
  * Redistribution and use in source and binary forms, with or without
  * modification,are permitted provided that the following conditions are met:
  *
@@ -96,7 +96,7 @@
  * Max. length of TFTP mode
  */
 #if !defined TFTP_MAX_MODE_LEN || defined __DOXYGEN__
-#define TFTP_MAX_MODE_LEN     10
+#define TFTP_MAX_MODE_LEN     7
 #endif
 
 /**
diff --git a/src/include/lwip/apps/tftp_server.h b/src/include/lwip/apps/tftp_server.h
index a5769ce2..0a7fbee0 100644
--- a/src/include/lwip/apps/tftp_server.h
+++ b/src/include/lwip/apps/tftp_server.h
@@ -1,11 +1,17 @@
 /**
  *
  * @file tftp_server.h
- * TFTP server header
+ *
+ * @author   Logan Gunthorpe <logang@deltatee.com>
+ *
+ * @brief    Trivial File Transfer Protocol (RFC 1350)
+ *
+ * Copyright (c) Deltatee Enterprises Ltd. 2013
+ * All rights reserved.
  *
  */
 
-/*
+/* 
  * Redistribution and use in source and binary forms, with or without
  * modification,are permitted provided that the following conditions are met:
  *
@@ -28,15 +34,62 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
- * This file is part of the lwIP TCP/IP stack.
+ * Author: Logan Gunthorpe <logang@deltatee.com>
  *
  */
 
 #ifndef LWIP_HDR_APPS_TFTP_SERVER_H
 #define LWIP_HDR_APPS_TFTP_SERVER_H
 
-#include "lwip/apps/tftp_common.h"
+#include "lwip/apps/tftp_opts.h"
+#include "lwip/err.h"
+#include "lwip/pbuf.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @ingroup tftp
+ * TFTP context containing callback functions for TFTP transfers
+ */
+struct tftp_context {
+  /**
+   * Open file for read/write.
+   * @param fname Filename
+   * @param mode Mode string from TFTP RFC 1350 (netascii, octet, mail)
+   * @param write Flag indicating read (0) or write (!= 0) access
+   * @returns File handle supplied to other functions
+   */
+  void* (*open)(const char* fname, const char* mode, u8_t write);
+  /**
+   * Close file handle
+   * @param handle File handle returned by open()
+   */
+  void (*close)(void* handle);
+  /**
+   * Read from file 
+   * @param handle File handle returned by open()
+   * @param buf Target buffer to copy read data to
+   * @param bytes Number of bytes to copy to buf
+   * @returns &gt;= 0: Success; &lt; 0: Error
+   */
+  int (*read)(void* handle, void* buf, int bytes);
+  /**
+   * Write to file
+   * @param handle File handle returned by open()
+   * @param pbuf PBUF adjusted such that payload pointer points
+   *             to the beginning of write data. In other words,
+   *             TFTP headers are stripped off.
+   * @returns &gt;= 0: Success; &lt; 0: Error
+   */
+  int (*write)(void* handle, struct pbuf* p);
+};
+
+err_t tftp_init(const struct tftp_context* ctx);
+void tftp_cleanup(void);
 
-err_t tftp_init_server(const struct tftp_context* ctx);
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* LWIP_HDR_APPS_TFTP_SERVER_H */
diff --git a/src/include/lwip/arch.h b/src/include/lwip/arch.h
index 29494da1..58dae33a 100644
--- a/src/include/lwip/arch.h
+++ b/src/include/lwip/arch.h
@@ -74,7 +74,7 @@
 
 /** Platform specific diagnostic output.\n
  * Note the default implementation pulls in printf, which may
- * in turn pull in a lot of standard libary code. In resource-constrained
+ * in turn pull in a lot of standard libary code. In resource-constrained 
  * systems, this should be defined to something less resource-consuming.
  */
 #ifndef LWIP_PLATFORM_DIAG
@@ -85,7 +85,7 @@
 
 /** Platform specific assertion handling.\n
  * Note the default implementation pulls in printf, fflush and abort, which may
- * in turn pull in a lot of standard libary code. In resource-constrained
+ * in turn pull in a lot of standard libary code. In resource-constrained 
  * systems, this should be defined to something less resource-consuming.
  */
 #ifndef LWIP_PLATFORM_ASSERT
@@ -360,7 +360,7 @@ extern "C" {
  * The file included BEFORE the struct is "arch/bpstruct.h".\n
  * The file included AFTER the struct is "arch/epstruct.h".\n
  * This can be used to implement struct packing on MS Visual C compilers, see
- * the Win32 port in the lwIP/contrib subdir for reference.
+ * the Win32 port in the lwIP contrib repository for reference.
  * For examples of packed struct declarations, see include/lwip/prot/ subfolder.\n
  * A port to GCC/clang is included in lwIP, if you use these compilers there is nothing to do here.
  */
diff --git a/src/include/lwip/autoip.h b/src/include/lwip/autoip.h
index b7558eb0..1d85bccf 100644
--- a/src/include/lwip/autoip.h
+++ b/src/include/lwip/autoip.h
@@ -48,12 +48,15 @@
 #include "lwip/netif.h"
 /* #include "lwip/udp.h" */
 #include "lwip/etharp.h"
-#include "lwip/acd.h"
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
+/** AutoIP Timing */
+#define AUTOIP_TMR_INTERVAL      100
+#define AUTOIP_TICKS_PER_SECOND (1000 / AUTOIP_TMR_INTERVAL)
+
 /** AutoIP state information per netif */
 struct autoip
 {
@@ -61,10 +64,14 @@ struct autoip
   ip4_addr_t llipaddr;
   /** current AutoIP state machine state */
   u8_t state;
+  /** sent number of probes or announces, dependent on state */
+  u8_t sent_num;
+  /** ticks to wait, tick is AUTOIP_TMR_INTERVAL long */
+  u16_t ttw;
+  /** ticks until a conflict can be solved by defending */
+  u8_t lastconflict;
   /** total number of probed/used Link Local IP-Addresses */
   u8_t tried_llipaddr;
-  /** acd struct */
-  struct acd acd;
 };
 
 
@@ -73,9 +80,10 @@ void autoip_set_struct(struct netif *netif, struct autoip *autoip);
 #define autoip_remove_struct(netif) do { (netif)->autoip = NULL; } while (0)
 err_t autoip_start(struct netif *netif);
 err_t autoip_stop(struct netif *netif);
-void autoip_network_changed_link_up(struct netif *netif);
-void autoip_network_changed_link_down(struct netif *netif);
-u8_t autoip_supplied_address(struct netif *netif);
+void autoip_arp_reply(struct netif *netif, struct etharp_hdr *hdr);
+void autoip_tmr(void);
+void autoip_network_changed(struct netif *netif);
+u8_t autoip_supplied_address(const struct netif *netif);
 
 /* for lwIP internal use by ip4.c */
 u8_t autoip_accept_packet(struct netif *netif, const ip4_addr_t *addr);
diff --git a/src/include/lwip/debug.h b/src/include/lwip/debug.h
index 579fd242..baa6a409 100644
--- a/src/include/lwip/debug.h
+++ b/src/include/lwip/debug.h
@@ -120,7 +120,9 @@
 #endif /* LWIP_NOASSERT */
 
 #ifndef LWIP_ERROR
-#ifdef LWIP_DEBUG
+#ifndef LWIP_NOASSERT
+#define LWIP_PLATFORM_ERROR(message) LWIP_PLATFORM_ASSERT(message)
+#elif defined LWIP_DEBUG
 #define LWIP_PLATFORM_ERROR(message) LWIP_PLATFORM_DIAG((message))
 #else
 #define LWIP_PLATFORM_ERROR(message)
diff --git a/src/include/lwip/def.h b/src/include/lwip/def.h
index d6bf7630..dfb266d1 100644
--- a/src/include/lwip/def.h
+++ b/src/include/lwip/def.h
@@ -144,10 +144,6 @@ int   lwip_stricmp(const char* str1, const char* str2);
 /* This can be #defined to strnstr() depending on your platform */
 char* lwip_strnstr(const char* buffer, const char* token, size_t n);
 #endif
-#ifndef lwip_strnistr
-/* This can be #defined to strnistr() depending on your platform */
-char* lwip_strnistr(const char* buffer, const char* token, size_t n);
-#endif
 
 #ifdef __cplusplus
 }
diff --git a/src/include/lwip/dhcp.h b/src/include/lwip/dhcp.h
index 49c266e8..c78aa0ba 100644
--- a/src/include/lwip/dhcp.h
+++ b/src/include/lwip/dhcp.h
@@ -45,10 +45,6 @@
 #include "lwip/netif.h"
 #include "lwip/udp.h"
 
-#if LWIP_DHCP_DOES_ACD_CHECK
-#include "lwip/acd.h"
-#endif /* LWIP_DHCP_DOES_ACD_CHECK */
-
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -78,7 +74,9 @@ struct dhcp
   u8_t state;
   /** retries of current request */
   u8_t tries;
-
+#if LWIP_DHCP_AUTOIP_COOP
+  u8_t autoip_coop_state;
+#endif
   u8_t subnet_mask_given;
 
   u16_t request_timeout; /* #ticks with period DHCP_FINE_TIMER_SECS for request timeout */
@@ -100,10 +98,6 @@ struct dhcp
   ip4_addr_t offered_si_addr;
   char boot_file_name[DHCP_BOOT_FILE_LEN];
 #endif /* LWIP_DHCP_BOOTPFILE */
-#if LWIP_DHCP_DOES_ACD_CHECK
-  /** acd struct */
-  struct acd acd;
-#endif /* LWIP_DHCP_DOES_ACD_CHECK */
 };
 
 
@@ -117,8 +111,10 @@ err_t dhcp_release(struct netif *netif);
 void dhcp_stop(struct netif *netif);
 void dhcp_release_and_stop(struct netif *netif);
 void dhcp_inform(struct netif *netif);
-void dhcp_network_changed_link_up(struct netif *netif);
-
+void dhcp_network_changed(struct netif *netif);
+#if DHCP_DOES_ARP_CHECK
+void dhcp_arp_reply(struct netif *netif, const ip4_addr_t *addr);
+#endif
 u8_t dhcp_supplied_address(const struct netif *netif);
 /* to be called every minute */
 void dhcp_coarse_tmr(void);
diff --git a/src/include/lwip/etharp.h b/src/include/lwip/etharp.h
index 48a1d229..2036b246 100644
--- a/src/include/lwip/etharp.h
+++ b/src/include/lwip/etharp.h
@@ -88,11 +88,6 @@ err_t etharp_request(struct netif *netif, const ip4_addr_t *ipaddr);
 #define etharp_gratuitous(netif) etharp_request((netif), netif_ip4_addr(netif))
 void etharp_cleanup_netif(struct netif *netif);
 
-#if LWIP_ACD
-err_t etharp_acd_probe(struct netif *netif, const ip4_addr_t *ipaddr);
-err_t etharp_acd_announce(struct netif *netif, const ip4_addr_t *ipaddr);
-#endif /* LWIP_ACD */
-
 #if ETHARP_SUPPORT_STATIC_ENTRIES
 err_t etharp_add_static_entry(const ip4_addr_t *ipaddr, struct eth_addr *ethaddr);
 err_t etharp_remove_static_entry(const ip4_addr_t *ipaddr);
diff --git a/src/include/lwip/igmp.h b/src/include/lwip/igmp.h
index 0a16db03..ffd80e68 100644
--- a/src/include/lwip/igmp.h
+++ b/src/include/lwip/igmp.h
@@ -99,7 +99,7 @@ err_t  igmp_leavegroup(const ip4_addr_t *ifaddr, const ip4_addr_t *groupaddr);
 err_t  igmp_leavegroup_netif(struct netif *netif, const ip4_addr_t *groupaddr);
 void   igmp_tmr(void);
 
-/** @ingroup igmp
+/** @ingroup igmp 
  * Get list head of IGMP groups for netif.
  * Note: The allsystems group IP is contained in the list as first entry.
  * @see @ref netif_set_igmp_mac_filter()
diff --git a/src/include/lwip/inet.h b/src/include/lwip/inet.h
index 50e8e303..2982a0f4 100644
--- a/src/include/lwip/inet.h
+++ b/src/include/lwip/inet.h
@@ -41,11 +41,6 @@
 #define LWIP_HDR_INET_H
 
 #include "lwip/opt.h"
-
-#if LWIP_SOCKET_EXTERNAL_HEADERS
-#include LWIP_SOCKET_EXTERNAL_HEADER_INET_H
-#else /* LWIP_SOCKET_EXTERNAL_HEADERS */
-
 #include "lwip/def.h"
 #include "lwip/ip_addr.h"
 #include "lwip/ip6_addr.h"
@@ -171,6 +166,4 @@ extern const struct in6_addr in6addr_any;
 }
 #endif
 
-#endif /* LWIP_SOCKET_EXTERNAL_HEADERS */
-
 #endif /* LWIP_HDR_INET_H */
diff --git a/src/include/lwip/inet_chksum.h b/src/include/lwip/inet_chksum.h
index 33296d28..76893ef5 100644
--- a/src/include/lwip/inet_chksum.h
+++ b/src/include/lwip/inet_chksum.h
@@ -102,3 +102,4 @@ u16_t ip_chksum_pseudo_partial(struct pbuf *p, u8_t proto, u16_t proto_len,
 #endif
 
 #endif /* LWIP_HDR_INET_H */
+
diff --git a/src/include/lwip/init.h b/src/include/lwip/init.h
index 34e8937e..a149be18 100644
--- a/src/include/lwip/init.h
+++ b/src/include/lwip/init.h
@@ -52,13 +52,13 @@ extern "C" {
 /** X.x.x: Major version of the stack */
 #define LWIP_VERSION_MAJOR      2
 /** x.X.x: Minor version of the stack */
-#define LWIP_VERSION_MINOR      2
+#define LWIP_VERSION_MINOR      1
 /** x.x.X: Revision of the stack */
-#define LWIP_VERSION_REVISION   0
+#define LWIP_VERSION_REVISION   2
 /** For release candidates, this is set to 1..254
   * For official releases, this is set to 255 (LWIP_RC_RELEASE)
   * For development versions (Git), this is set to 0 (LWIP_RC_DEVELOPMENT) */
-#define LWIP_VERSION_RC         LWIP_RC_DEVELOPMENT
+#define LWIP_VERSION_RC         LWIP_RC_RELEASE
 
 /** LWIP_VERSION_RC is set to LWIP_RC_RELEASE for official releases */
 #define LWIP_RC_RELEASE         255
diff --git a/src/include/lwip/ip.h b/src/include/lwip/ip.h
index 68aed6af..653c3b2f 100644
--- a/src/include/lwip/ip.h
+++ b/src/include/lwip/ip.h
@@ -326,3 +326,5 @@ err_t ip_input(struct pbuf *p, struct netif *inp);
 #endif
 
 #endif /* LWIP_HDR_IP_H */
+
+
diff --git a/src/include/lwip/ip4.h b/src/include/lwip/ip4.h
index 4d7228d0..fd35a336 100644
--- a/src/include/lwip/ip4.h
+++ b/src/include/lwip/ip4.h
@@ -107,3 +107,5 @@ void ip4_debug_print(struct pbuf *p);
 #endif /* LWIP_IPV4 */
 
 #endif /* LWIP_HDR_IP_H */
+
+
diff --git a/src/include/lwip/ip_addr.h b/src/include/lwip/ip_addr.h
index ee7a0c9d..faa9fbcd 100644
--- a/src/include/lwip/ip_addr.h
+++ b/src/include/lwip/ip_addr.h
@@ -169,7 +169,7 @@ extern const ip_addr_t ip_addr_any_type;
   ip6_addr_set_zero(ip_2_ip6(ipaddr)); IP_SET_TYPE(ipaddr, IPADDR_TYPE_V4); }while(0)
 /** @ingroup ip6addr */
 #define ip_addr_set_zero_ip6(ipaddr)     do{ \
-  ip6_addr_set_zero(ip_2_ip6(ipaddr)); IP_SET_TYPE(ipaddr, IPADDR_TYPE_V6); }while(0)
+  ip6_addr_set_zero(ip_2_ip6(ipaddr)); IP_SET_TYPE_VAL(*ipaddr, IPADDR_TYPE_V6); }while(0)
 /** @ingroup ipaddr */
 #define ip_addr_set_any(is_ipv6, ipaddr)      do{if(is_ipv6){ \
   ip6_addr_set_any(ip_2_ip6(ipaddr)); IP_SET_TYPE(ipaddr, IPADDR_TYPE_V6); }else{ \
@@ -404,7 +404,7 @@ extern const ip_addr_t ip_addr_broadcast;
 
 extern const ip_addr_t ip6_addr_any;
 
-/**
+/** 
  * @ingroup ip6addr
  * IP6_ADDR_ANY can be used as a fixed ip_addr_t
  * for the IPv6 wildcard address
diff --git a/src/include/lwip/mld6.h b/src/include/lwip/mld6.h
index 2764fdd4..7fa0797f 100644
--- a/src/include/lwip/mld6.h
+++ b/src/include/lwip/mld6.h
@@ -84,7 +84,7 @@ err_t  mld6_leavegroup_netif(struct netif *netif, const ip6_addr_t *groupaddr);
 
 /** @ingroup mld6
  * Get list head of MLD6 groups for netif.
- * Note: The allnodes group IP is NOT in the list, since it must always
+ * Note: The allnodes group IP is NOT in the list, since it must always 
  * be received for correct IPv6 operation.
  * @see @ref netif_set_mld_mac_filter()
  */
diff --git a/src/include/lwip/netif.h b/src/include/lwip/netif.h
index 8333c6ba..911196ab 100644
--- a/src/include/lwip/netif.h
+++ b/src/include/lwip/netif.h
@@ -119,9 +119,6 @@ enum lwip_internal_netif_client_data_index
 #if LWIP_AUTOIP
    LWIP_NETIF_CLIENT_DATA_INDEX_AUTOIP,
 #endif
-#if LWIP_ACD
-   LWIP_NETIF_CLIENT_DATA_INDEX_ACD,
-#endif
 #if LWIP_IGMP
    LWIP_NETIF_CLIENT_DATA_INDEX_IGMP,
 #endif
@@ -248,20 +245,14 @@ typedef u8_t netif_addr_idx_t;
 #define NETIF_ADDR_IDX_MAX 0x7F
 #endif
 
-#if LWIP_NETIF_HWADDRHINT || LWIP_VLAN_PCP
- #define LWIP_NETIF_USE_HINTS              1
- struct netif_hint {
 #if LWIP_NETIF_HWADDRHINT
-   u8_t addr_hint;
-#endif
-#if LWIP_VLAN_PCP
-  /** VLAN hader is set if this is >= 0 (but must be <= 0xFFFF) */
-  s32_t tci;
-#endif
- };
-#else /* LWIP_NETIF_HWADDRHINT || LWIP_VLAN_PCP */
- #define LWIP_NETIF_USE_HINTS              0
-#endif /* LWIP_NETIF_HWADDRHINT || LWIP_VLAN_PCP*/
+#define LWIP_NETIF_USE_HINTS              1
+struct netif_hint {
+  netif_addr_idx_t addr_hint;
+};
+#else /* LWIP_NETIF_HWADDRHINT */
+#define LWIP_NETIF_USE_HINTS              0
+#endif /* LWIP_NETIF_HWADDRHINT */
 
 /** Generic data structure used for all lwIP network interfaces.
  *  The following fields should be filled in by the initialization
@@ -354,7 +345,7 @@ struct netif {
   u8_t flags;
   /** descriptive abbreviation */
   char name[2];
-  /** number of this interface. Used for @ref if_api and @ref netifapi_netif,
+  /** number of this interface. Used for @ref if_api and @ref netifapi_netif, 
    * as well as for IPv6 zones */
   u8_t num;
 #if LWIP_IPV6_AUTOCONFIG
@@ -385,9 +376,6 @@ struct netif {
       filter table of the ethernet MAC. */
   netif_mld_mac_filter_fn mld_mac_filter;
 #endif /* LWIP_IPV6 && LWIP_IPV6_MLD */
-#if LWIP_ACD
-  struct acd *acd_list;
-#endif /* LWIP_ACD */
 #if LWIP_NETIF_USE_HINTS
   struct netif_hint *hints;
 #endif /* LWIP_NETIF_USE_HINTS */
@@ -674,11 +662,6 @@ void netif_invoke_ext_callback(struct netif* netif, netif_nsc_reason_t reason, c
 #define netif_invoke_ext_callback(netif, reason, args)
 #endif
 
-#if LWIP_TESTMODE && LWIP_HAVE_LOOPIF
-struct netif* netif_get_loopif(void);
-#endif
-
-
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/include/lwip/opt.h b/src/include/lwip/opt.h
index 15882b22..82c420c1 100644
--- a/src/include/lwip/opt.h
+++ b/src/include/lwip/opt.h
@@ -677,18 +677,6 @@
 #define ETHARP_SUPPORT_VLAN             0
 #endif
 
-/**
- * LWIP_VLAN_PCP==1: Enable outgoing VLAN taggning of frames on a per-PCB basis
- * for QoS purposes. With this feature enabled, each PCB has a new variable: "tci".
- * (Tag Control Identifier). The TCI contains three fields: VID, CFI and PCP.
- * VID is the VLAN ID, which should be set to zero.
- * The "CFI" bit is used to enable or disable VLAN tags for the PCB.
- * PCP (Priority Code Point) is a 3 bit field used for Ethernet level QoS.
- */
-#ifndef LWIP_VLAN_PCP
-#define LWIP_VLAN_PCP                   0
-#endif
-
 /** LWIP_ETHERNET==1: enable ethernet support even though ARP might be disabled
  */
 #if !defined LWIP_ETHERNET || defined __DOXYGEN__
@@ -936,10 +924,10 @@
 #endif /* !LWIP_IPV4 */
 
 /**
- * LWIP_DHCP_DOES_ACD_CHECK==1: Perform address conflict detection on the dhcp address.
+ * DHCP_DOES_ARP_CHECK==1: Do an ARP check on the offered address.
  */
-#if !defined LWIP_DHCP_DOES_ACD_CHECK || defined __DOXYGEN__
-#define LWIP_DHCP_DOES_ACD_CHECK        LWIP_DHCP
+#if !defined DHCP_DOES_ARP_CHECK || defined __DOXYGEN__
+#define DHCP_DOES_ARP_CHECK             (LWIP_DHCP && LWIP_ARP)
 #endif
 
 /**
@@ -1021,31 +1009,6 @@
  * @}
  */
 
-/*
-   ------------------------------------
-   ----------- ACD options ------------
-   ------------------------------------
-*/
-/**
- * @defgroup lwip_opts_acd ACD
- * @ingroup lwip_opts_ipv4
- * @{
- */
- /**
-  * LWIP_ACD==1: Enable ACD module. ACD module is needed when using AUTOIP.
-  */
-#if !defined LWIP_ACD || defined __DOXYGEN__
-#define LWIP_ACD                     (LWIP_AUTOIP || LWIP_DHCP_DOES_ACD_CHECK)
-#endif
-#if !LWIP_IPV4
-/* disable ACD when IPv4 is disabled */
-#undef LWIP_ACD
-#define LWIP_ACD                     0
-#endif /* !LWIP_IPV4 */
-/**
- * @}
- */
-
 /*
    ----------------------------------
    ----- SNMP MIB2 support      -----
@@ -1178,9 +1141,7 @@
  *                                    DNS_LOCAL_HOSTLIST_ELEM("host_ip6", IPADDR6_INIT_HOST(123, 234, 345, 456)}
  *
  *  Instead, you can also use an external function:
- *  \#define DNS_LOOKUP_LOCAL_EXTERN(name, namelen, addr, dns_addrtype) my_lookup_function(name, namelen, addr, dns_addrtype)
- *  with function signature:
- *  extern err_t my_lookup_function(const char *name, size_t namelen, ip_addr_t *addr, u8_t dns_addrtype)
+ *  \#define DNS_LOOKUP_LOCAL_EXTERN(x) extern err_t my_lookup_function(const char *name, ip_addr_t *addr, u8_t dns_addrtype)
  *  that looks up the IP address and returns ERR_OK if found (LWIP_DNS_ADDRTYPE_xxx is passed in dns_addrtype).
  */
 #if !defined DNS_LOCAL_HOSTLIST || defined __DOXYGEN__
@@ -1562,13 +1523,13 @@
  * link level header. The default is 14, the standard value for
  * Ethernet.
  */
- #if !defined PBUF_LINK_HLEN || defined __DOXYGEN__
-#if (defined LWIP_HOOK_VLAN_SET || LWIP_VLAN_PCP) && !defined __DOXYGEN__
- #define PBUF_LINK_HLEN                  (18 + ETH_PAD_SIZE)
-#else /* LWIP_HOOK_VLAN_SET || LWIP_VLAN_PCP */
- #define PBUF_LINK_HLEN                  (14 + ETH_PAD_SIZE)
-#endif /* LWIP_HOOK_VLAN_SET || LWIP_VLAN_PCP */
- #endif
+#if !defined PBUF_LINK_HLEN || defined __DOXYGEN__
+#if defined LWIP_HOOK_VLAN_SET && !defined __DOXYGEN__
+#define PBUF_LINK_HLEN                  (18 + ETH_PAD_SIZE)
+#else /* LWIP_HOOK_VLAN_SET */
+#define PBUF_LINK_HLEN                  (14 + ETH_PAD_SIZE)
+#endif /* LWIP_HOOK_VLAN_SET */
+#endif
 
 /**
  * PBUF_LINK_ENCAPSULATION_HLEN: the number of bytes that should be allocated
@@ -1594,14 +1555,6 @@
 #if !defined LWIP_PBUF_REF_T || defined __DOXYGEN__
 #define LWIP_PBUF_REF_T                 u8_t
 #endif
-
-/**
- * LWIP_PBUF_CUSTOM_DATA: Store private data on pbufs (e.g. timestamps)
- * This extends struct pbuf so user can store custom data on every pbuf.
- */
-#if !defined LWIP_PBUF_CUSTOM_DATA || defined __DOXYGEN__
-#define LWIP_PBUF_CUSTOM_DATA
-#endif
 /**
  * @}
  */
@@ -1648,7 +1601,7 @@
 #endif
 
 /**
- * LWIP_NETIF_EXT_STATUS_CALLBACK==1: Support an extended callback function
+ * LWIP_NETIF_EXT_STATUS_CALLBACK==1: Support an extended callback function 
  * for several netif related event that supports multiple subscribers.
  * @see netif_ext_status_callback
  */
@@ -2019,17 +1972,6 @@
 #define LWIP_SOCKET_OFFSET              0
 #endif
 
-/**
- * LWIP_SOCKET_EXTERNAL_HEADERS==1: Use external headers instead of sockets.h
- * and inet.h. In this case, user must provide its own headers by setting the
- * values for LWIP_SOCKET_EXTERNAL_HEADER_SOCKETS_H and
- * LWIP_SOCKET_EXTERNAL_HEADER_INET_H to appropriate include file names and the
- * whole content of the default sockets.h and inet.h is skipped.
- */
-#if !defined LWIP_SOCKET_EXTERNAL_HEADERS || defined __DOXYGEN__
-#define LWIP_SOCKET_EXTERNAL_HEADERS    0
-#endif
-
 /**
  * LWIP_TCP_KEEPALIVE==1: Enable TCP_KEEPIDLE, TCP_KEEPINTVL and TCP_KEEPCNT
  * options processing. Note that TCP_KEEPIDLE and TCP_KEEPINTVL have to be set
@@ -2447,7 +2389,7 @@
  * All addresses that have a scope according to the default policy (link-local
  * unicast addresses, interface-local and link-local multicast addresses) should
  * now have a zone set on them before being passed to the core API, although
- * lwIP will currently attempt to select a zone on the caller's behalf when
+ * lwIP will currently attempt to select a zone on the caller's behalf when 
  * necessary. Applications that directly assign IPv6 addresses to interfaces
  * (which is NOT recommended) must now ensure that link-local addresses carry
  * the netif's zone. See the new ip6_zone.h header file for more information and
@@ -3085,8 +3027,8 @@
  * - src: source eth address
  * - dst: destination eth address
  * - eth_type: ethernet type to packet to be sent\n
- *
- *
+ * 
+ * 
  * Return values:
  * - &lt;0: Packet shall not contain VLAN header.
  * - 0 &lt;= return value &lt;= 0xFFFF: Packet shall contain VLAN header. Return value is prio_vid in host byte order.
@@ -3522,13 +3464,6 @@
 #define AUTOIP_DEBUG                    LWIP_DBG_OFF
 #endif
 
-/**
- * ACD_DEBUG: Enable debugging in acd.c.
- */
-#if !defined ACD_DEBUG || defined __DOXYGEN__
-#define ACD_DEBUG                       LWIP_DBG_OFF
-#endif
-
 /**
  * DNS_DEBUG: Enable debugging for DNS.
  */
diff --git a/src/include/lwip/pbuf.h b/src/include/lwip/pbuf.h
index 84c7f95d..82902a4e 100644
--- a/src/include/lwip/pbuf.h
+++ b/src/include/lwip/pbuf.h
@@ -55,7 +55,7 @@ extern "C" {
 #define LWIP_SUPPORT_CUSTOM_PBUF ((IP_FRAG && !LWIP_NETIF_TX_SINGLE_PBUF) || (LWIP_IPV6 && LWIP_IPV6_FRAG))
 #endif
 
-/** @ingroup pbuf
+/** @ingroup pbuf 
  * PBUF_NEEDS_COPY(p): return a boolean value indicating whether the given
  * pbuf needs to be copied in order to be kept around beyond the current call
  * stack without risking being corrupted. The default setting provides safety:
@@ -219,9 +219,6 @@ struct pbuf {
 
   /** For incoming packets, this contains the input netif's index */
   u8_t if_idx;
-
-  /** In case the user needs to store data custom data on a pbuf */
-  LWIP_PBUF_CUSTOM_DATA
 };
 
 
diff --git a/src/include/lwip/priv/altcp_priv.h b/src/include/lwip/priv/altcp_priv.h
index d1de9b11..2d3b2fdb 100644
--- a/src/include/lwip/priv/altcp_priv.h
+++ b/src/include/lwip/priv/altcp_priv.h
@@ -85,11 +85,6 @@ typedef err_t (*altcp_get_tcp_addrinfo_fn)(struct altcp_pcb *conn, int local, ip
 typedef ip_addr_t *(*altcp_get_ip_fn)(struct altcp_pcb *conn, int local);
 typedef u16_t (*altcp_get_port_fn)(struct altcp_pcb *conn, int local);
 
-#if LWIP_TCP_KEEPALIVE
-typedef void  (*altcp_keepalive_disable_fn)(struct altcp_pcb *conn);
-typedef void  (*altcp_keepalive_enable_fn)(struct altcp_pcb *conn, u32_t idle, u32_t intvl, u32_t count);
-#endif
-
 #ifdef LWIP_DEBUG
 typedef enum tcp_state (*altcp_dbg_get_tcp_state_fn)(struct altcp_pcb *conn);
 #endif
@@ -116,10 +111,6 @@ struct altcp_functions {
   altcp_get_tcp_addrinfo_fn   addrinfo;
   altcp_get_ip_fn             getip;
   altcp_get_port_fn           getport;
-#if LWIP_TCP_KEEPALIVE
-  altcp_keepalive_disable_fn  keepalive_disable;
-  altcp_keepalive_enable_fn   keepalive_enable;
-#endif
 #ifdef LWIP_DEBUG
   altcp_dbg_get_tcp_state_fn  dbg_get_tcp_state;
 #endif
@@ -142,10 +133,6 @@ void  altcp_default_dealloc(struct altcp_pcb *conn);
 err_t altcp_default_get_tcp_addrinfo(struct altcp_pcb *conn, int local, ip_addr_t *addr, u16_t *port);
 ip_addr_t *altcp_default_get_ip(struct altcp_pcb *conn, int local);
 u16_t altcp_default_get_port(struct altcp_pcb *conn, int local);
-#if LWIP_TCP_KEEPALIVE
-void  altcp_default_keepalive_disable(struct altcp_pcb *conn);
-void  altcp_default_keepalive_enable(struct altcp_pcb *conn, u32_t idle, u32_t intvl, u32_t count);
-#endif
 #ifdef LWIP_DEBUG
 enum tcp_state altcp_default_dbg_get_tcp_state(struct altcp_pcb *conn);
 #endif
diff --git a/src/include/lwip/priv/sockets_priv.h b/src/include/lwip/priv/sockets_priv.h
index c604734c..d8f9904d 100644
--- a/src/include/lwip/priv/sockets_priv.h
+++ b/src/include/lwip/priv/sockets_priv.h
@@ -99,7 +99,7 @@ struct lwip_sock {
 /** Maximum optlen used by setsockopt/getsockopt */
 #define LWIP_SETGETSOCKOPT_MAXOPTLEN LWIP_MAX(16, sizeof(struct ifreq))
 
-/** This struct is used to pass data to the set/getsockopt_impl
+/** This struct is used to pass data to the set/getsockopt_internal
  * functions running in tcpip_thread context (only a void* is allowed) */
 struct lwip_setgetsockopt_data {
   /** socket index for which to change options */
diff --git a/src/include/lwip/prot/acd.h b/src/include/lwip/prot/acd.h
deleted file mode 100644
index e6f0dc80..00000000
--- a/src/include/lwip/prot/acd.h
+++ /dev/null
@@ -1,91 +0,0 @@
-/**
- * @file
- * ACD protocol definitions
- */
-
-/*
- *
- * Copyright (c) 2007 Dominik Spies <kontakt@dspies.de>
- * Copyright (c) 2018 Jasper Verschueren <jasper.verschueren@apart-audio.com>
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
- * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGE.
- *
- * Author: Jasper Verschueren <jasper.verschueren@apart-audio.com>
- * Author: Dominik Spies <kontakt@dspies.de>
- */
-
-#ifndef LWIP_HDR_PROT_ACD_H
-#define LWIP_HDR_PROT_ACD_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* RFC 5227 and RFC 3927 Constants */
-#define PROBE_WAIT           1   /* second  (initial random delay)                    */
-#define PROBE_MIN            1   /* second  (minimum delay till repeated probe)       */
-#define PROBE_MAX            2   /* seconds (maximum delay till repeated probe)       */
-#define PROBE_NUM            3   /*         (number of probe packets)                 */
-#define ANNOUNCE_NUM         2   /*         (number of announcement packets)          */
-#define ANNOUNCE_INTERVAL    2   /* seconds (time between announcement packets)       */
-#define ANNOUNCE_WAIT        2   /* seconds (delay before announcing)                 */
-#define MAX_CONFLICTS        10  /*         (max conflicts before rate limiting)      */
-#define RATE_LIMIT_INTERVAL  60  /* seconds (delay between successive attempts)       */
-#define DEFEND_INTERVAL      10  /* seconds (minimum interval between defensive ARPs) */
-
-/* ACD states */
-typedef enum {
-  /* ACD is module is off */
-  ACD_STATE_OFF,
-  /* Waiting before probing can be started */
-  ACD_STATE_PROBE_WAIT,
-  /* Probing the ipaddr */
-  ACD_STATE_PROBING,
-  /* Waiting before announcing the probed ipaddr */
-  ACD_STATE_ANNOUNCE_WAIT,
-  /* Announcing the new ipaddr */
-  ACD_STATE_ANNOUNCING,
-  /* Performing ongoing conflict detection with one defend within defend inferval */
-  ACD_STATE_ONGOING,
-  /* Performing ongoing conflict detection but immediately back off and Release
-   * the address when a conflict occurs. This state is used for LL addresses
-   * that stay active even if the netif has a routable address selected.
-   * In such a case, we cannot defend our address */
-  ACD_STATE_PASSIVE_ONGOING,
-  /* To many conflicts occured, we need to wait before restarting the selection
-   * process */
-  ACD_STATE_RATE_LIMIT
-} acd_state_enum_t;
-
-typedef enum {
-  ACD_IP_OK,            /* IP address is good, no conflicts found in checking state */
-  ACD_RESTART_CLIENT,   /* Conflict found -> the client should try again */
-  ACD_DECLINE           /* Decline the received IP address (rate limiting)*/
-} acd_callback_enum_t;
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* LWIP_HDR_PROT_ACD_H */
diff --git a/src/include/lwip/prot/autoip.h b/src/include/lwip/prot/autoip.h
index adbb1668..fd3af8a9 100644
--- a/src/include/lwip/prot/autoip.h
+++ b/src/include/lwip/prot/autoip.h
@@ -51,11 +51,24 @@ extern "C" {
 /* 169.254.254.255 */
 #define AUTOIP_RANGE_END        (AUTOIP_NET | 0xFEFF)
 
+/* RFC 3927 Constants */
+#define PROBE_WAIT              1   /* second   (initial random delay)                 */
+#define PROBE_MIN               1   /* second   (minimum delay till repeated probe)    */
+#define PROBE_MAX               2   /* seconds  (maximum delay till repeated probe)    */
+#define PROBE_NUM               3   /*          (number of probe packets)              */
+#define ANNOUNCE_NUM            2   /*          (number of announcement packets)       */
+#define ANNOUNCE_INTERVAL       2   /* seconds  (time between announcement packets)    */
+#define ANNOUNCE_WAIT           2   /* seconds  (delay before announcing)              */
+#define MAX_CONFLICTS           10  /*          (max conflicts before rate limiting)   */
+#define RATE_LIMIT_INTERVAL     60  /* seconds  (delay between successive attempts)    */
+#define DEFEND_INTERVAL         10  /* seconds  (min. wait between defensive ARPs)     */
+
 /* AutoIP client states */
 typedef enum {
-  AUTOIP_STATE_OFF,
-  AUTOIP_STATE_CHECKING,
-  AUTOIP_STATE_BOUND
+  AUTOIP_STATE_OFF        = 0,
+  AUTOIP_STATE_PROBING    = 1,
+  AUTOIP_STATE_ANNOUNCING = 2,
+  AUTOIP_STATE_BOUND      = 3
 } autoip_state_enum_t;
 
 #ifdef __cplusplus
diff --git a/src/include/lwip/prot/ieee.h b/src/include/lwip/prot/ieee.h
index cd4d2dea..abbb9e31 100644
--- a/src/include/lwip/prot/ieee.h
+++ b/src/include/lwip/prot/ieee.h
@@ -53,7 +53,7 @@ enum lwip_ieee_eth_type {
   /** Internet protocol v4 */
   ETHTYPE_IP        = 0x0800U,
   /** Address resolution protocol */
-  ETHTYPE_ARP       = 0x0806U,
+  ETHTYPE_ARP       = 0x0806U, 
   /** Wake on lan */
   ETHTYPE_WOL       = 0x0842U,
   /** RARP */
diff --git a/src/include/lwip/sockets.h b/src/include/lwip/sockets.h
index 819357e7..d70d36c4 100644
--- a/src/include/lwip/sockets.h
+++ b/src/include/lwip/sockets.h
@@ -41,10 +41,6 @@
 
 #include "lwip/opt.h"
 
-#if LWIP_SOCKET_EXTERNAL_HEADERS
-#include LWIP_SOCKET_EXTERNAL_HEADER_SOCKETS_H
-#else /* LWIP_SOCKET_EXTERNAL_HEADERS */
-
 #if LWIP_SOCKET /* don't build if not configured for use in lwipopts.h */
 
 #include "lwip/ip_addr.h"
@@ -689,6 +685,4 @@ int lwip_inet_pton(int af, const char *src, void *dst);
 
 #endif /* LWIP_SOCKET */
 
-#endif /* LWIP_SOCKET_EXTERNAL_HEADERS */
-
 #endif /* LWIP_HDR_SOCKETS_H */
diff --git a/src/include/lwip/sys.h b/src/include/lwip/sys.h
index cf13e1dc..168e465b 100644
--- a/src/include/lwip/sys.h
+++ b/src/include/lwip/sys.h
@@ -130,7 +130,7 @@ typedef void (*lwip_thread_fn)(void *arg);
  * If the mutex has been created, ERR_OK should be returned. Returning any
  * other error will provide a hint what went wrong, but except for assertions,
  * no real error handling is implemented.
- *
+ * 
  * @param mutex pointer to the mutex to create
  * @return ERR_OK if successful, another err_t otherwise
  */
@@ -205,13 +205,13 @@ void sys_sem_signal(sys_sem_t *sem);
  * "timeout" argument is non-zero, the thread should only be blocked for the
  * specified time (measured in milliseconds). If the "timeout" argument is zero,
  * the thread should be blocked until the semaphore is signalled.
- *
+ * 
  * The return value is SYS_ARCH_TIMEOUT if the semaphore wasn't signaled within
  * the specified time or any other value if it was signaled (with or without
  * waiting).
  * Notice that lwIP implements a function with a similar name,
  * sys_sem_wait(), that uses the sys_arch_sem_wait() function.
- *
+ * 
  * @param sem the semaphore to wait for
  * @param timeout timeout in milliseconds to wait (0 = wait forever)
  * @return SYS_ARCH_TIMEOUT on timeout, any other value on success
@@ -277,7 +277,7 @@ void sys_msleep(u32_t ms); /* only has a (close to) 1 ms resolution. */
  * If the mailbox has been created, ERR_OK should be returned. Returning any
  * other error will provide a hint what went wrong, but except for assertions,
  * no real error handling is implemented.
- *
+ * 
  * @param mbox pointer to the mbox to create
  * @param size (minimum) number of messages in this mbox
  * @return ERR_OK if successful, another err_t otherwise
@@ -287,7 +287,7 @@ err_t sys_mbox_new(sys_mbox_t *mbox, int size);
  * @ingroup sys_mbox
  * Post a message to an mbox - may not fail
  * -> blocks if full, only to be used from tasks NOT from ISR!
- *
+ * 
  * @param mbox mbox to posts the message
  * @param msg message to post (ATTENTION: can be NULL)
  */
@@ -297,7 +297,7 @@ void sys_mbox_post(sys_mbox_t *mbox, void *msg);
  * Try to post a message to an mbox - may fail if full.
  * Can be used from ISR (if the sys arch layer allows this).
  * Returns ERR_MEM if it is full, else, ERR_OK if the "msg" is posted.
- *
+ * 
  * @param mbox mbox to posts the message
  * @param msg message to post (ATTENTION: can be NULL)
  */
@@ -307,7 +307,7 @@ err_t sys_mbox_trypost(sys_mbox_t *mbox, void *msg);
  * Try to post a message to an mbox - may fail if full.
  * To be be used from ISR.
  * Returns ERR_MEM if it is full, else, ERR_OK if the "msg" is posted.
- *
+ * 
  * @param mbox mbox to posts the message
  * @param msg message to post (ATTENTION: can be NULL)
  */
@@ -324,10 +324,10 @@ err_t sys_mbox_trypost_fromisr(sys_mbox_t *mbox, void *msg);
  * The return values are the same as for the sys_arch_sem_wait() function:
  * SYS_ARCH_TIMEOUT if there was a timeout, any other value if a messages
  * is received.
- *
+ * 
  * Note that a function with a similar name, sys_mbox_fetch(), is
- * implemented by lwIP.
- *
+ * implemented by lwIP. 
+ * 
  * @param mbox mbox to get a message from
  * @param msg pointer where the message is stored
  * @param timeout maximum time (in milliseconds) to wait for a message (0 = wait forever)
@@ -346,7 +346,7 @@ u32_t sys_arch_mbox_fetch(sys_mbox_t *mbox, void **msg, u32_t timeout);
  * example, a naive implementation could be:
  * \#define sys_arch_mbox_tryfetch(mbox,msg) sys_arch_mbox_fetch(mbox,msg,1)
  * although this would introduce unnecessary delays.
- *
+ * 
  * @param mbox mbox to get a message from
  * @param msg pointer where the message is stored
  * @return 0 (milliseconds) if a message has been received
@@ -363,7 +363,7 @@ u32_t sys_arch_mbox_tryfetch(sys_mbox_t *mbox, void **msg);
  * Deallocates a mailbox. If there are messages still present in the
  * mailbox when the mailbox is deallocated, it is an indication of a
  * programming error in lwIP and the developer should be notified.
- *
+ * 
  * @param mbox mbox to delete
  */
 void sys_mbox_free(sys_mbox_t *mbox);
@@ -411,7 +411,7 @@ void sys_mbox_set_invalid(sys_mbox_t *mbox);
  * the "stacksize" parameter. The id of the new thread is returned. Both the id
  * and the priority are system dependent.
  * ATTENTION: although this function returns a value, it MUST NOT FAIL (ports have to assert this!)
- *
+ * 
  * @param name human-readable name for the thread (used for debugging purposes)
  * @param thread thread-function
  * @param arg parameter passed to 'thread'
diff --git a/src/include/lwip/tcp.h b/src/include/lwip/tcp.h
index 6e7c0148..daf75994 100644
--- a/src/include/lwip/tcp.h
+++ b/src/include/lwip/tcp.h
@@ -486,9 +486,9 @@ err_t            tcp_tcp_get_tcp_addrinfo(struct tcp_pcb *pcb, int local, ip_add
 
 #if LWIP_TCP_PCB_NUM_EXT_ARGS
 u8_t tcp_ext_arg_alloc_id(void);
-void tcp_ext_arg_set_callbacks(struct tcp_pcb *pcb, u8_t id, const struct tcp_ext_arg_callbacks * const callbacks);
-void tcp_ext_arg_set(struct tcp_pcb *pcb, u8_t id, void *arg);
-void *tcp_ext_arg_get(const struct tcp_pcb *pcb, u8_t id);
+void tcp_ext_arg_set_callbacks(struct tcp_pcb *pcb, uint8_t id, const struct tcp_ext_arg_callbacks * const callbacks);
+void tcp_ext_arg_set(struct tcp_pcb *pcb, uint8_t id, void *arg);
+void *tcp_ext_arg_get(const struct tcp_pcb *pcb, uint8_t id);
 #endif
 
 #ifdef __cplusplus
diff --git a/src/include/netif/lowpan6_ble.h b/src/include/netif/lowpan6_ble.h
index ff35fcd3..01896a7f 100644
--- a/src/include/netif/lowpan6_ble.h
+++ b/src/include/netif/lowpan6_ble.h
@@ -6,7 +6,7 @@
 /*
  * Copyright (c) 2017 Benjamin Aigner
  * Copyright (c) 2015 Inico Technologies Ltd. , Author: Ivan Delamer <delamer@inicotech.com>
- *
+ * 
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without modification,
@@ -32,10 +32,10 @@
  * OF SUCH DAMAGE.
  *
  * Author: Benjamin Aigner <aignerb@technikum-wien.at>
- *
+ * 
  * Based on the original 6lowpan implementation of lwIP ( @see 6lowpan.c)
  */
-
+ 
 #ifndef LWIP_HDR_LOWPAN6_BLE_H
 #define LWIP_HDR_LOWPAN6_BLE_H
 
@@ -66,8 +66,8 @@ err_t rfc7668_if_init(struct netif *netif);
 err_t tcpip_rfc7668_input(struct pbuf *p, struct netif *inp);
 #endif
 
-void ble_addr_to_eui64(u8_t *dst, const u8_t *src, int public_addr);
-void eui64_to_ble_addr(u8_t *dst, const u8_t *src);
+void ble_addr_to_eui64(uint8_t *dst, const uint8_t *src, int public_addr);
+void eui64_to_ble_addr(uint8_t *dst, const uint8_t *src);
 
 #ifdef __cplusplus
 }
diff --git a/src/include/netif/lowpan6_opts.h b/src/include/netif/lowpan6_opts.h
index 32e5c5ee..17d46cdc 100644
--- a/src/include/netif/lowpan6_opts.h
+++ b/src/include/netif/lowpan6_opts.h
@@ -109,7 +109,7 @@
 #define LWIP_RFC7668_IP_UNCOMPRESSED_DEBUG    LWIP_DBG_OFF
 #endif
 
-/** LWIP_RFC7668_LINUX_WORKAROUND_PUBLIC_ADDRESS:
+/** LWIP_RFC7668_LINUX_WORKAROUND_PUBLIC_ADDRESS: 
  * Currently, the linux kernel driver for 6lowpan sets/clears a bit in
  * the address, depending on the BD address (either public or not).
  * Might not be RFC7668 conform, so you may select to do that (=1) or
diff --git a/src/include/netif/ppp/ppp_opts.h b/src/include/netif/ppp/ppp_opts.h
index 479a006d..6702bec6 100644
--- a/src/include/netif/ppp/ppp_opts.h
+++ b/src/include/netif/ppp/ppp_opts.h
@@ -44,13 +44,6 @@
 #define PPPOE_SUPPORT                   0
 #endif
 
-/**
- * PPPOE_SCNAME_SUPPORT==1: Enable PPP Over Ethernet Service Name and Concentrator Name support
- */
-#ifndef PPPOE_SCNAME_SUPPORT
-#define PPPOE_SCNAME_SUPPORT            0
-#endif
-
 /**
  * PPPOL2TP_SUPPORT==1: Enable PPP Over L2TP
  */
diff --git a/src/include/netif/ppp/pppoe.h b/src/include/netif/ppp/pppoe.h
index 8994d38c..08ab7ab5 100644
--- a/src/include/netif/ppp/pppoe.h
+++ b/src/include/netif/ppp/pppoe.h
@@ -149,10 +149,10 @@ struct pppoe_softc {
   u16_t sc_session;            /* PPPoE session id */
   u8_t sc_state;               /* discovery phase or session connected */
 
-#if PPPOE_SCNAME_SUPPORT
-  const char *sc_service_name;      /* if != NULL: requested name of service */
-  const char *sc_concentrator_name; /* if != NULL: requested concentrator id */
-#endif /* PPPOE_SCNAME_SUPPORT */
+#ifdef PPPOE_TODO
+  u8_t *sc_service_name;       /* if != NULL: requested name of service */
+  u8_t *sc_concentrator_name;  /* if != NULL: requested concentrator id */
+#endif /* PPPOE_TODO */
   u8_t sc_ac_cookie[PPPOE_MAX_AC_COOKIE_LEN]; /* content of AC cookie we must echo back */
   u8_t sc_ac_cookie_len;       /* length of cookie data */
 #ifdef PPPOE_SERVER
diff --git a/src/include/netif/slipif.h b/src/include/netif/slipif.h
index 46d20101..65ba31f8 100644
--- a/src/include/netif/slipif.h
+++ b/src/include/netif/slipif.h
@@ -84,3 +84,4 @@ void slipif_received_bytes(struct netif *netif, u8_t *data, u8_t len);
 #endif
 
 #endif /* LWIP_HDR_NETIF_SLIPIF_H */
+
diff --git a/src/netif/bridgeif_fdb.c b/src/netif/bridgeif_fdb.c
index 2f052ec0..6739fc24 100644
--- a/src/netif/bridgeif_fdb.c
+++ b/src/netif/bridgeif_fdb.c
@@ -69,7 +69,7 @@ typedef struct bridgeif_dfdb_s {
  * remembers known src mac addresses to know which port to send frames destined for that
  * mac address.
  *
- * ATTENTION: This is meant as an example only, in real-world use, you should
+ * ATTENTION: This is meant as an example only, in real-world use, you should 
  * provide a better implementation :-)
  */
 void
@@ -120,9 +120,9 @@ bridgeif_fdb_update_src(void *fdb_ptr, struct eth_addr *src_addr, u8_t port_idx)
   /* not found, no free entry -> flood */
 }
 
-/**
+/** 
  * @ingroup bridgeif_fdb
- * Walk our list of auto-learnt fdb entries and return a port to forward or BR_FLOOD if unknown
+ * Walk our list of auto-learnt fdb entries and return a port to forward or BR_FLOOD if unknown 
  */
 bridgeif_portmask_t
 bridgeif_fdb_get_dst_ports(void *fdb_ptr, struct eth_addr *dst_addr)
diff --git a/src/netif/ethernet.c b/src/netif/ethernet.c
index 6db434b4..dd171e28 100644
--- a/src/netif/ethernet.c
+++ b/src/netif/ethernet.c
@@ -273,16 +273,8 @@ ethernet_output(struct netif * netif, struct pbuf * p,
   struct eth_hdr *ethhdr;
   u16_t eth_type_be = lwip_htons(eth_type);
 
-#if ETHARP_SUPPORT_VLAN && (defined(LWIP_HOOK_VLAN_SET) || LWIP_VLAN_PCP)
-  s32_t vlan_prio_vid;
-#ifdef LWIP_HOOK_VLAN_SET
-  vlan_prio_vid = LWIP_HOOK_VLAN_SET(netif, p, src, dst, eth_type);
-#elif LWIP_VLAN_PCP
-  vlan_prio_vid = -1;
-  if (netif->hints && (netif->hints->tci >= 0)) {
-    vlan_prio_vid = (u16_t)netif->hints->tci;
-  }
-#endif
+#if ETHARP_SUPPORT_VLAN && defined(LWIP_HOOK_VLAN_SET)
+  s32_t vlan_prio_vid = LWIP_HOOK_VLAN_SET(netif, p, src, dst, eth_type);
   if (vlan_prio_vid >= 0) {
     struct eth_vlan_hdr *vlanhdr;
 
@@ -297,7 +289,7 @@ ethernet_output(struct netif * netif, struct pbuf * p,
 
     eth_type_be = PP_HTONS(ETHTYPE_VLAN);
   } else
-#endif /* ETHARP_SUPPORT_VLAN && (defined(LWIP_HOOK_VLAN_SET) || LWIP_VLAN_PCP) */
+#endif /* ETHARP_SUPPORT_VLAN && defined(LWIP_HOOK_VLAN_SET) */
   {
     if (pbuf_add_header(p, SIZEOF_ETH_HDR) != 0) {
       goto pbuf_header_failed;
diff --git a/src/netif/lowpan6.c b/src/netif/lowpan6.c
index 58aa15a8..7f0d2767 100644
--- a/src/netif/lowpan6.c
+++ b/src/netif/lowpan6.c
@@ -679,7 +679,7 @@ lowpan6_input(struct pbuf *p, struct netif *netif)
     /* check for duplicate */
     lrh = lowpan6_data.reass_list;
     while (lrh != NULL) {
-      u8_t discard = 0;
+      uint8_t discard = 0;
       lrh_next = lrh->next_packet;
       if ((lrh->sender_addr.addr_len == src.addr_len) &&
           (memcmp(lrh->sender_addr.addr, src.addr, src.addr_len) == 0)) {
diff --git a/src/netif/lowpan6_ble.c b/src/netif/lowpan6_ble.c
index f13da80d..d89816d3 100644
--- a/src/netif/lowpan6_ble.c
+++ b/src/netif/lowpan6_ble.c
@@ -6,7 +6,7 @@
 /*
  * Copyright (c) 2017 Benjamin Aigner
  * Copyright (c) 2015 Inico Technologies Ltd. , Author: Ivan Delamer <delamer@inicotech.com>
- *
+ * 
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without modification,
@@ -32,7 +32,7 @@
  * OF SUCH DAMAGE.
  *
  * Author: Benjamin Aigner <aignerb@technikum-wien.at>
- *
+ * 
  * Based on the original 6lowpan implementation of lwIP ( @see 6lowpan.c)
  */
 
@@ -95,19 +95,19 @@ static struct lowpan6_link_addr rfc7668_peer_addr;
 /**
  * @ingroup rfc7668if
  *  convert BT address to EUI64 addr
- *
+ * 
  * This method converts a Bluetooth MAC address to an EUI64 address,
  * which is used within IPv6 communication
- *
+ * 
  * @param dst IPv6 destination space
  * @param src BLE MAC address source
  * @param public_addr If the LWIP_RFC7668_LINUX_WORKAROUND_PUBLIC_ADDRESS
  * option is set, bit 0x02 will be set if param=0 (no public addr); cleared otherwise
- *
+ * 
  * @see LWIP_RFC7668_LINUX_WORKAROUND_PUBLIC_ADDRESS
  */
 void
-ble_addr_to_eui64(u8_t *dst, const u8_t *src, int public_addr)
+ble_addr_to_eui64(uint8_t *dst, const uint8_t *src, int public_addr)
 {
   /* according to RFC7668 ch 3.2.2. */
   memcpy(dst, src, 3);
@@ -128,15 +128,15 @@ ble_addr_to_eui64(u8_t *dst, const u8_t *src, int public_addr)
 /**
  * @ingroup rfc7668if
  *  convert EUI64 address to Bluetooth MAC addr
- *
+ * 
  * This method converts an EUI64 address to a Bluetooth MAC address,
- *
+ * 
  * @param dst BLE MAC address destination
  * @param src IPv6 source
- *
+ * 
  */
 void
-eui64_to_ble_addr(u8_t *dst, const u8_t *src)
+eui64_to_ble_addr(uint8_t *dst, const uint8_t *src)
 {
   /* according to RFC7668 ch 3.2.2. */
   memcpy(dst,src,3);
@@ -214,16 +214,16 @@ rfc7668_set_peer_addr_mac48(struct netif *netif, const u8_t *peer_addr, size_t p
 }
 
 /** Encapsulate IPv6 frames for BLE transmission
- *
+ * 
  * This method implements the IPv6 header compression:
  *  *) According to RFC6282
  *  *) See Figure 2, contains base format of bit positions
  *  *) Fragmentation not necessary (done at L2CAP layer of BLE)
  * @note Currently the pbuf allocation uses 256 bytes. If longer packets are used (possible due to MTU=1480Bytes), increase it here!
- *
+ * 
  * @param p Pbuf struct, containing the payload data
  * @param netif Output network interface. Should be of RFC7668 type
- *
+ * 
  * @return Same as netif->output.
  */
 static err_t
@@ -340,7 +340,7 @@ rfc7668_output(struct netif *netif, struct pbuf *q, const ip6_addr_t *ip6addr)
  * @param p the received packet, p->payload pointing to the
  *        IPv6 header (maybe compressed)
  * @param netif the network interface on which the packet was received
- *
+ * 
  * @return ERR_OK if everything was fine
  */
 err_t
@@ -352,7 +352,7 @@ rfc7668_input(struct pbuf * p, struct netif *netif)
 
   /* Load first header byte */
   puc = (u8_t*)p->payload;
-
+  
   /* no IP header compression */
   if (*puc == 0x41) {
     LWIP_DEBUGF(LWIP_LOWPAN6_DECOMPRESSION_DEBUG, ("Completed packet, removing dispatch: 0x%2x \n", *puc));
@@ -386,7 +386,7 @@ rfc7668_input(struct pbuf * p, struct netif *netif)
       if ((i%4)==0) {
         LWIP_DEBUGF(LWIP_RFC7668_IP_UNCOMPRESSED_DEBUG, ("\n"));
       }
-      LWIP_DEBUGF(LWIP_RFC7668_IP_UNCOMPRESSED_DEBUG, ("%2X ", *((u8_t *)p->payload+i)));
+      LWIP_DEBUGF(LWIP_RFC7668_IP_UNCOMPRESSED_DEBUG, ("%2X ", *((uint8_t *)p->payload+i)));
     }
     LWIP_DEBUGF(LWIP_RFC7668_IP_UNCOMPRESSED_DEBUG, ("\np->len: %d\n", p->len));
   }
@@ -398,12 +398,12 @@ rfc7668_input(struct pbuf * p, struct netif *netif)
 /**
  * @ingroup rfc7668if
  * Initialize the netif
- *
+ * 
  * No flags are used (broadcast not possible, not ethernet, ...)
  * The shortname for this netif is "BT"
  *
  * @param netif the network interface to be initialized as RFC7668 netif
- *
+ * 
  * @return ERR_OK if everything went fine
  */
 err_t
@@ -433,7 +433,7 @@ rfc7668_if_init(struct netif *netif)
  * @param p the received packet, p->payload pointing to the
  *          IEEE 802.15.4 header.
  * @param inp the network interface on which the packet was received
- *
+ * 
  * @return see @ref tcpip_inpkt, same return values
  */
 err_t
diff --git a/src/netif/lowpan6_common.c b/src/netif/lowpan6_common.c
index 89758d94..baea206a 100644
--- a/src/netif/lowpan6_common.c
+++ b/src/netif/lowpan6_common.c
@@ -430,7 +430,7 @@ lowpan6_decompress_hdr(u8_t *lowpan6_buffer, size_t lowpan6_bufsize,
 
   /* offset for inline IP headers (RFC 6282 ch3)*/
   lowpan6_offset = 2;
-  /* if CID is set (context identifier), the context byte
+  /* if CID is set (context identifier), the context byte 
    * follows immediately after the header, so other IPHC fields are @+3 */
   if (lowpan6_buffer[1] & 0x80) {
     lowpan6_offset++;
diff --git a/src/netif/ppp/pppoe.c b/src/netif/ppp/pppoe.c
index 971b36b3..8ed2d638 100644
--- a/src/netif/ppp/pppoe.c
+++ b/src/netif/ppp/pppoe.c
@@ -175,10 +175,8 @@ ppp_pcb *pppoe_create(struct netif *pppif,
 {
   ppp_pcb *ppp;
   struct pppoe_softc *sc;
-#if !PPPOE_SCNAME_SUPPORT
   LWIP_UNUSED_ARG(service_name);
   LWIP_UNUSED_ARG(concentrator_name);
-#endif /* !PPPOE_SCNAME_SUPPORT */
   LWIP_ASSERT_CORE_LOCKED();
 
   sc = (struct pppoe_softc *)LWIP_MEMPOOL_ALLOC(PPPOE_IF);
@@ -195,10 +193,6 @@ ppp_pcb *pppoe_create(struct netif *pppif,
   memset(sc, 0, sizeof(struct pppoe_softc));
   sc->pcb = ppp;
   sc->sc_ethif = ethif;
-#if PPPOE_SCNAME_SUPPORT
-  sc->sc_service_name = service_name;
-  sc->sc_concentrator_name = concentrator_name;
-#endif /* PPPOE_SCNAME_SUPPORT */
   /* put the new interface at the head of the list */
   sc->next = pppoe_softc_list;
   pppoe_softc_list = sc;
@@ -306,6 +300,15 @@ pppoe_destroy(ppp_pcb *ppp, void *ctx)
        break;
     }
   }
+
+#ifdef PPPOE_TODO
+  if (sc->sc_concentrator_name) {
+    mem_free(sc->sc_concentrator_name);
+  }
+  if (sc->sc_service_name) {
+    mem_free(sc->sc_service_name);
+  }
+#endif /* PPPOE_TODO */
   LWIP_MEMPOOL_FREE(PPPOE_IF, sc);
 
   return ERR_OK;
@@ -754,13 +757,13 @@ pppoe_send_padi(struct pppoe_softc *sc)
   struct pbuf *pb;
   u8_t *p;
   int len;
-#if PPPOE_SCNAME_SUPPORT
+#ifdef PPPOE_TODO
   int l1 = 0, l2 = 0; /* XXX: gcc */
-#endif /* PPPOE_SCNAME_SUPPORT */
+#endif /* PPPOE_TODO */
 
   /* calculate length of frame (excluding ethernet header + pppoe header) */
   len = 2 + 2 + 2 + 2 + sizeof sc;  /* service name tag is required, host unique is send too */
-#if PPPOE_SCNAME_SUPPORT
+#ifdef PPPOE_TODO
   if (sc->sc_service_name != NULL) {
     l1 = (int)strlen(sc->sc_service_name);
     len += l1;
@@ -769,7 +772,7 @@ pppoe_send_padi(struct pppoe_softc *sc)
     l2 = (int)strlen(sc->sc_concentrator_name);
     len += 2 + 2 + l2;
   }
-#endif /* PPPOE_SCNAME_SUPPORT */
+#endif /* PPPOE_TODO */
   LWIP_ASSERT("sizeof(struct eth_hdr) + PPPOE_HEADERLEN + len <= 0xffff",
     sizeof(struct eth_hdr) + PPPOE_HEADERLEN + len <= 0xffff);
 
@@ -784,24 +787,24 @@ pppoe_send_padi(struct pppoe_softc *sc)
   /* fill in pkt */
   PPPOE_ADD_HEADER(p, PPPOE_CODE_PADI, 0, (u16_t)len);
   PPPOE_ADD_16(p, PPPOE_TAG_SNAME);
-#if PPPOE_SCNAME_SUPPORT
+#ifdef PPPOE_TODO
   if (sc->sc_service_name != NULL) {
     PPPOE_ADD_16(p, l1);
     MEMCPY(p, sc->sc_service_name, l1);
     p += l1;
   } else
-#endif /* PPPOE_SCNAME_SUPPORT */
+#endif /* PPPOE_TODO */
   {
     PPPOE_ADD_16(p, 0);
   }
-#if PPPOE_SCNAME_SUPPORT
+#ifdef PPPOE_TODO
   if (sc->sc_concentrator_name != NULL) {
     PPPOE_ADD_16(p, PPPOE_TAG_ACNAME);
     PPPOE_ADD_16(p, l2);
     MEMCPY(p, sc->sc_concentrator_name, l2);
     p += l2;
   }
-#endif /* PPPOE_SCNAME_SUPPORT */
+#endif /* PPPOE_TODO */
   PPPOE_ADD_16(p, PPPOE_TAG_HUNIQUE);
   PPPOE_ADD_16(p, sizeof(sc));
   MEMCPY(p, &sc, sizeof sc);
@@ -979,17 +982,17 @@ pppoe_send_padr(struct pppoe_softc *sc)
   struct pbuf *pb;
   u8_t *p;
   size_t len;
-#if PPPOE_SCNAME_SUPPORT
+#ifdef PPPOE_TODO
   size_t l1 = 0; /* XXX: gcc */
-#endif /* PPPOE_SCNAME_SUPPORT */
+#endif /* PPPOE_TODO */
 
   len = 2 + 2 + 2 + 2 + sizeof(sc);    /* service name, host unique */
-#if PPPOE_SCNAME_SUPPORT
+#ifdef PPPOE_TODO
   if (sc->sc_service_name != NULL) {    /* service name tag maybe empty */
     l1 = strlen(sc->sc_service_name);
     len += l1;
   }
-#endif /* PPPOE_SCNAME_SUPPORT */
+#endif /* PPPOE_TODO */
   if (sc->sc_ac_cookie_len > 0) {
     len += 2 + 2 + sc->sc_ac_cookie_len;  /* AC cookie */
   }
@@ -1003,13 +1006,13 @@ pppoe_send_padr(struct pppoe_softc *sc)
   p = (u8_t*)pb->payload;
   PPPOE_ADD_HEADER(p, PPPOE_CODE_PADR, 0, len);
   PPPOE_ADD_16(p, PPPOE_TAG_SNAME);
-#if PPPOE_SCNAME_SUPPORT
+#ifdef PPPOE_TODO
   if (sc->sc_service_name != NULL) {
     PPPOE_ADD_16(p, l1);
     MEMCPY(p, sc->sc_service_name, l1);
     p += l1;
   } else
-#endif /* PPPOE_SCNAME_SUPPORT */
+#endif /* PPPOE_TODO */
   {
     PPPOE_ADD_16(p, 0);
   }
diff --git a/test/unit/Filelists.cmake b/test/unit/Filelists.cmake
index 7c7d1f13..e1f40bc9 100644
--- a/test/unit/Filelists.cmake
+++ b/test/unit/Filelists.cmake
@@ -5,13 +5,9 @@
 #
 # This file is NOT designed (on purpose) to be used as cmake
 # subdir via add_subdirectory()
-# The intention is to provide greater flexibility to users to
+# The intention is to provide greater flexibility to users to 
 # create their own targets using the *_SRCS variables.
 
-if(NOT ${CMAKE_VERSION} VERSION_LESS "3.10.0")
-    include_guard(GLOBAL)
-endif()
-
 set(LWIP_TESTDIR ${LWIP_DIR}/test/unit)
 set(LWIP_TESTFILES
 	${LWIP_TESTDIR}/lwip_unittests.c
diff --git a/test/unit/dhcp/test_dhcp.c b/test/unit/dhcp/test_dhcp.c
index b91def07..4cefa33a 100644
--- a/test/unit/dhcp/test_dhcp.c
+++ b/test/unit/dhcp/test_dhcp.c
@@ -6,17 +6,6 @@
 #include "lwip/etharp.h"
 #include "netif/ethernet.h"
 
-#if LWIP_ACD
-#if LWIP_DHCP_DOES_ACD_CHECK
-#define DHCP_TEST_NUM_ARP_FRAMES 5
-#else
-#define DHCP_TEST_NUM_ARP_FRAMES 0
-#endif
-#else
-#define DHCP_TEST_NUM_ARP_FRAMES 1
-#endif
-
-
 struct netif net_test;
 
 static const u8_t broadcast[6] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
@@ -143,9 +132,6 @@ static int tick = 0;
 static void tick_lwip(void)
 {
   tick++;
-#if LWIP_DHCP_DOES_ACD_CHECK
-  acd_tmr();
-#endif
   if (tick % 5 == 0) {
     dhcp_fine_tmr();
   }
@@ -309,20 +295,9 @@ static err_t lwip_tx_func(struct netif *netif, struct pbuf *p)
         }
         break;
       }
-#if DHCP_TEST_NUM_ARP_FRAMES > 0
     case 3:
-#if DHCP_TEST_NUM_ARP_FRAMES > 1
     case 4:
-#if DHCP_TEST_NUM_ARP_FRAMES > 2
     case 5:
-#if DHCP_TEST_NUM_ARP_FRAMES > 3
-    case 6:
-#if DHCP_TEST_NUM_ARP_FRAMES > 4
-    case 7:
-#endif
-#endif
-#endif
-#endif
       {
         const u8_t arpproto[] = { 0x08, 0x06 };
 
@@ -332,8 +307,7 @@ static err_t lwip_tx_func(struct netif *netif, struct pbuf *p)
         check_pkt(p, 12, arpproto, sizeof(arpproto)); /* eth level proto: ip */
         break;
       }
-#endif
-    default:
+      default:
         fail();
         break;
     }
@@ -403,20 +377,9 @@ static err_t lwip_tx_func(struct netif *netif, struct pbuf *p)
         break;
       }
     case 3:
-#if DHCP_TEST_NUM_ARP_FRAMES > 0
     case 4:
-#if DHCP_TEST_NUM_ARP_FRAMES > 1
     case 5:
-#if DHCP_TEST_NUM_ARP_FRAMES > 2
     case 6:
-#if DHCP_TEST_NUM_ARP_FRAMES > 3
-    case 7:
-#if DHCP_TEST_NUM_ARP_FRAMES > 4
-    case 8:
-#endif
-#endif
-#endif
-#endif
       {
         const u8_t arpproto[] = { 0x08, 0x06 };
 
@@ -426,8 +389,7 @@ static err_t lwip_tx_func(struct netif *netif, struct pbuf *p)
         check_pkt(p, 12, arpproto, sizeof(arpproto)); /* eth level proto: ip */
         break;
       }
-#endif
-    case 4 + DHCP_TEST_NUM_ARP_FRAMES:
+    case 7:
       {
         const u8_t fake_arp[6] = { 0x12, 0x34, 0x56, 0x78, 0x9a, 0xab };
         const u8_t ipproto[] = { 0x08, 0x00 };
@@ -516,12 +478,10 @@ START_TEST(test_dhcp)
   memcpy(&dhcp_ack[46], &xid, 4); /* insert transaction id */
   send_pkt(&net_test, dhcp_ack, sizeof(dhcp_ack));
 
-  fail_unless(txpacket == 2);
-
-  for (i = 0; i < 200; i++) {
+  for (i = 0; i < 20; i++) {
     tick_lwip();
   }
-  fail_unless(txpacket == (2 + DHCP_TEST_NUM_ARP_FRAMES), "TX %d packets, expected %d", txpacket, (2 + DHCP_TEST_NUM_ARP_FRAMES));
+  fail_unless(txpacket == 5, "TX %d packets, expected 5", txpacket); /* ARP requests sent */
 
   /* Interface up */
   fail_unless(netif_is_up(&net_test));
@@ -591,12 +551,7 @@ START_TEST(test_dhcp_nak)
   memcpy(&dhcp_ack[46], &xid, 4); /* insert transaction id */
   send_pkt(&net_test, dhcp_ack, sizeof(dhcp_ack));
 
-  fail_unless(txpacket == 2); /* ARP request sent */
-
-  while (txpacket == 2) {
-    tick_lwip();
-  }
-  fail_unless(txpacket == 3);
+  fail_unless(txpacket == 3); /* ARP request sent */
 
   tcase = TEST_LWIP_DHCP_NAK; /* Switch testcase */
 
@@ -811,10 +766,10 @@ START_TEST(test_dhcp_relayed)
   memcpy(&relay_ack1[46], &xid, 4); /* insert transaction id */
   send_pkt(&net_test, relay_ack1, sizeof(relay_ack1));
 
-  for (i = 0; i < 200; i++) {
+  for (i = 0; i < 25; i++) {
     tick_lwip();
   }
-  fail_unless(txpacket == (2 + DHCP_TEST_NUM_ARP_FRAMES), "TX %d packets, expected %d", txpacket, (2 + DHCP_TEST_NUM_ARP_FRAMES));
+  fail_unless(txpacket == 5, "txpkt should be 5, is %d", txpacket); /* ARP requests sent */
 
   /* Interface up */
   fail_unless(netif_is_up(&net_test));
@@ -827,20 +782,20 @@ START_TEST(test_dhcp_relayed)
   fail_if(memcmp(&netmask, &net_test.netmask, sizeof(ip4_addr_t)));
   fail_if(memcmp(&gw, &net_test.gw, sizeof(ip4_addr_t)));
 
-  fail_unless(txpacket == (2 + DHCP_TEST_NUM_ARP_FRAMES), "TX %d packets, expected %d", txpacket, (2 + DHCP_TEST_NUM_ARP_FRAMES));
+  fail_unless(txpacket == 5, "txpacket = %d", txpacket);
 
   for (i = 0; i < 108000 - 25; i++) {
     tick_lwip();
   }
 
   fail_unless(netif_is_up(&net_test));
-  fail_unless(txpacket == (3 + DHCP_TEST_NUM_ARP_FRAMES), "TX %d packets, expected %d", txpacket, (3 + DHCP_TEST_NUM_ARP_FRAMES));
+  fail_unless(txpacket == 6, "txpacket = %d", txpacket);
 
   /* We need to send arp response here.. */
 
   send_pkt(&net_test, arp_resp, sizeof(arp_resp));
 
-  fail_unless(txpacket == (4 + DHCP_TEST_NUM_ARP_FRAMES), "TX %d packets, expected %d", txpacket, (4 + DHCP_TEST_NUM_ARP_FRAMES));
+  fail_unless(txpacket == 7, "txpacket = %d", txpacket);
   fail_unless(netif_is_up(&net_test));
 
   xid = htonl(netif_dhcp_data(&net_test)->xid); /* xid updated */
@@ -851,7 +806,7 @@ START_TEST(test_dhcp_relayed)
     tick_lwip();
   }
 
-  fail_unless(txpacket == (4 + DHCP_TEST_NUM_ARP_FRAMES), "TX %d packets, expected %d", txpacket, (5 + DHCP_TEST_NUM_ARP_FRAMES));
+  fail_unless(txpacket == 7, "txpacket = %d", txpacket);
 
   tcase = TEST_NONE;
   dhcp_stop(&net_test);
diff --git a/test/unit/ip4/test_ip4.c b/test/unit/ip4/test_ip4.c
index d663b2fe..a5a7fd93 100644
--- a/test/unit/ip4/test_ip4.c
+++ b/test/unit/ip4/test_ip4.c
@@ -1,7 +1,6 @@
 #include "test_ip4.h"
 
 #include "lwip/ip4.h"
-#include "lwip/etharp.h"
 #include "lwip/inet_chksum.h"
 #include "lwip/stats.h"
 #include "lwip/prot/ip.h"
@@ -13,55 +12,6 @@
 #error "This tests needs LWIP_IPV4, IP_REASSEMBLY; MIB2- and IPFRAG-statistics enabled"
 #endif
 
-static struct netif test_netif;
-static ip4_addr_t test_ipaddr, test_netmask, test_gw;
-static int linkoutput_ctr;
-
-/* reference internal lwip variable in netif.c */
-
-static err_t
-test_netif_linkoutput(struct netif *netif, struct pbuf *p)
-{
-  fail_unless(netif == &test_netif);
-  fail_unless(p != NULL);
-  linkoutput_ctr++;
-  return ERR_OK;
-}
-
-static err_t
-test_netif_init(struct netif *netif)
-{
-  fail_unless(netif != NULL);
-  netif->linkoutput = test_netif_linkoutput;
-  netif->output = etharp_output;
-  netif->mtu = 1500;
-  netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP;
-  netif->hwaddr_len = ETHARP_HWADDR_LEN;
-  return ERR_OK;
-}
-
-static void
-test_netif_add(void)
-{
-  IP4_ADDR(&test_gw, 192,168,0,1);
-  IP4_ADDR(&test_ipaddr, 192,168,0,1);
-  IP4_ADDR(&test_netmask, 255,255,0,0);
-
-  fail_unless(netif_default == NULL);
-  netif_add(&test_netif, &test_ipaddr, &test_netmask, &test_gw,
-    NULL, test_netif_init, NULL);
-  netif_set_default(&test_netif);
-  netif_set_up(&test_netif);
-}
-
-static void
-test_netif_remove(void)
-{
-  if (netif_default == &test_netif) {
-    netif_remove(&test_netif);
-  }
-}
-
 /* Helper functions */
 static void
 create_ip4_input_fragment(u16_t ip_id, u16_t start, u16_t len, int last)
@@ -121,11 +71,11 @@ ip4_teardown(void)
   /* poll until all memory is released... */
   tcpip_thread_poll_one();
   lwip_check_ensure_no_alloc(SKIP_POOL(MEMP_SYS_TIMEOUT));
-  test_netif_remove();
-  netif_set_up(netif_get_loopif());
 }
 
+
 /* Test functions */
+
 START_TEST(test_ip4_reass)
 {
   const u16_t ip_id = 128;
@@ -198,26 +148,6 @@ START_TEST(test_ip4_reass)
 }
 END_TEST
 
-/* packets to 127.0.0.1 shall not be sent out to netif_default */
-START_TEST(test_127_0_0_1)
-{
-  ip4_addr_t localhost;
-  struct pbuf* p;
-
-  LWIP_UNUSED_ARG(_i);
-
-  test_netif_add();
-  netif_set_down(netif_get_loopif());
-
-  IP4_ADDR(&localhost, 127, 0, 0, 1);
-  p = pbuf_alloc(PBUF_IP, 10, PBUF_POOL);
-
-  if(ip4_output(p, netif_ip4_addr(netif_default), &localhost, 0, 0, IP_PROTO_UDP) != ERR_OK) {
-    pbuf_free(p);
-  }
-  fail_unless(linkoutput_ctr == 0);
-}
-END_TEST
 
 /** Create the suite including all tests for this module */
 Suite *
@@ -225,7 +155,6 @@ ip4_suite(void)
 {
   testfunc tests[] = {
     TESTFUNC(test_ip4_reass),
-    TESTFUNC(test_127_0_0_1),
   };
   return create_suite("IPv4", tests, sizeof(tests)/sizeof(testfunc), ip4_setup, ip4_teardown);
 }
diff --git a/test/unit/lwip_unittests.c b/test/unit/lwip_unittests.c
index c93f05e2..497a44b2 100644
--- a/test/unit/lwip_unittests.c
+++ b/test/unit/lwip_unittests.c
@@ -21,13 +21,6 @@
 #include "lwip/tcpip.h"
 #endif
 
-/* This function is used for LWIP_RAND by some ports... */
-unsigned int
-lwip_port_rand(void)
-{
-  return rand();
-}
-
 Suite* create_suite(const char* name, testfunc *tests, size_t num_tests, SFun setup, SFun teardown)
 {
   size_t i;
diff --git a/test/unit/mdns/test_mdns.c b/test/unit/mdns/test_mdns.c
index 5a630f47..63851637 100644
--- a/test/unit/mdns/test_mdns.c
+++ b/test/unit/mdns/test_mdns.c
@@ -34,7 +34,6 @@
 
 #include "lwip/pbuf.h"
 #include "lwip/apps/mdns.h"
-#include "lwip/apps/mdns_domain.h"
 #include "lwip/apps/mdns_priv.h"
 
 START_TEST(readname_basic)
diff --git a/test/unit/udp/test_udp.c b/test/unit/udp/test_udp.c
index a9a6b25b..e26a83ec 100644
--- a/test/unit/udp/test_udp.c
+++ b/test/unit/udp/test_udp.c
@@ -335,138 +335,13 @@ START_TEST(test_udp_broadcast_rx_with_2_netifs)
 }
 END_TEST
 
-START_TEST(test_udp_bind)
-{
-  struct udp_pcb* pcb1;
-  struct udp_pcb* pcb2;
-  ip_addr_t ip1;
-  ip_addr_t ip2;
-  err_t err1;
-  err_t err2;
-  LWIP_UNUSED_ARG(_i);
-
-  /* bind on same port using different IP address types */
-  ip_addr_set_any_val(0, ip1);
-  ip_addr_set_any_val(1, ip2);
-
-  pcb1 = udp_new_ip_type(IPADDR_TYPE_V4);
-  pcb2 = udp_new_ip_type(IPADDR_TYPE_V6);
-
-  err1 = udp_bind(pcb1, &ip1, 2105);
-  err2 = udp_bind(pcb2, &ip2, 2105);
-
-  fail_unless(err1 == ERR_OK);
-  fail_unless(err2 == ERR_OK);
-
-  udp_remove(pcb1);
-  udp_remove(pcb2);
-
-  /* bind on same port using SAME IPv4 address type */
-  ip_addr_set_any_val(0, ip1);
-  ip_addr_set_any_val(0, ip2);
-
-  pcb1 = udp_new_ip_type(IPADDR_TYPE_V4);
-  pcb2 = udp_new_ip_type(IPADDR_TYPE_V4);
-
-  err1 = udp_bind(pcb1, &ip1, 2105);
-  err2 = udp_bind(pcb2, &ip2, 2105);
-
-  fail_unless(err1 == ERR_OK);
-  fail_unless(err2 == ERR_USE);
-
-  udp_remove(pcb1);
-  udp_remove(pcb2);
-
-  /* bind on same port using SAME IPv6 address type */
-  ip_addr_set_any_val(1, ip1);
-  ip_addr_set_any_val(1, ip2);
-
-  pcb1 = udp_new_ip_type(IPADDR_TYPE_V6);
-  pcb2 = udp_new_ip_type(IPADDR_TYPE_V6);
-
-  err1 = udp_bind(pcb1, &ip1, 2105);
-  err2 = udp_bind(pcb2, &ip2, 2105);
-
-  fail_unless(err1 == ERR_OK);
-  fail_unless(err2 == ERR_USE);
-
-  udp_remove(pcb1);
-  udp_remove(pcb2);
-
-  /* Bind with different IP address type */
-  ip_addr_set_any_val(0, ip1);
-  ip_addr_set_any_val(1, ip2);
-
-  pcb1 = udp_new_ip_type(IPADDR_TYPE_V6);
-  pcb2 = udp_new_ip_type(IPADDR_TYPE_V4);
-
-  err1 = udp_bind(pcb1, &ip1, 2105);
-  err2 = udp_bind(pcb2, &ip2, 2105);
-
-  fail_unless(err1 == ERR_OK);
-  fail_unless(err2 == ERR_OK);
-
-  udp_remove(pcb1);
-  udp_remove(pcb2);
-
-  /* Bind with different IP numbers */
-  IP_ADDR4(&ip1, 1, 2, 3, 4);
-  IP_ADDR4(&ip2, 4, 3, 2, 1);
-
-  pcb1 = udp_new_ip_type(IPADDR_TYPE_V6);
-  pcb2 = udp_new_ip_type(IPADDR_TYPE_V4);
-
-  err1 = udp_bind(pcb1, &ip1, 2105);
-  err2 = udp_bind(pcb2, &ip2, 2105);
-
-  fail_unless(err1 == ERR_OK);
-  fail_unless(err2 == ERR_OK);
-
-  udp_remove(pcb1);
-  udp_remove(pcb2);
-
-  /* Bind with same IP numbers */
-  IP_ADDR4(&ip1, 1, 2, 3, 4);
-  IP_ADDR4(&ip2, 1, 2, 3, 4);
-
-  pcb1 = udp_new_ip_type(IPADDR_TYPE_V6);
-  pcb2 = udp_new_ip_type(IPADDR_TYPE_V4);
-
-  err1 = udp_bind(pcb1, &ip1, 2105);
-  err2 = udp_bind(pcb2, &ip2, 2105);
-
-  fail_unless(err1 == ERR_OK);
-  fail_unless(err2 == ERR_USE);
-
-  udp_remove(pcb1);
-  udp_remove(pcb2);
-
-  /* bind on same port using ANY + IPv4 */
-  ip1 = *IP_ANY_TYPE;
-  IP_ADDR4(&ip2, 1, 2, 3, 4);
-
-  pcb1 = udp_new_ip_type(IPADDR_TYPE_ANY);
-  pcb2 = udp_new_ip_type(IPADDR_TYPE_V4);
-
-  err1 = udp_bind(pcb1, &ip1, 2105);
-  err2 = udp_bind(pcb2, &ip2, 2105);
-
-  fail_unless(err1 == ERR_OK);
-  fail_unless(err2 == ERR_USE);
-
-  udp_remove(pcb1);
-  udp_remove(pcb2);
-}
-END_TEST
-
 /** Create the suite including all tests for this module */
 Suite *
 udp_suite(void)
 {
   testfunc tests[] = {
     TESTFUNC(test_udp_new_remove),
-    TESTFUNC(test_udp_broadcast_rx_with_2_netifs),
-    TESTFUNC(test_udp_bind)
+    TESTFUNC(test_udp_broadcast_rx_with_2_netifs)
   };
   return create_suite("UDP", tests, sizeof(tests)/sizeof(testfunc), udp_setup, udp_teardown);
 }
diff --git a/travis.sh b/travis.sh
deleted file mode 100755
index a1bff5e5..00000000
--- a/travis.sh
+++ /dev/null
@@ -1,65 +0,0 @@
-#!/bin/bash
-
-RETVAL=0
-
-cd contrib/ports/unix/check
-
-#build and run unit tests
-make clean all
-
-# Build test using make, this tests the Makefile toolchain
-make check -j 4
-ERR=$?
-echo Return value from unittests: $ERR
-if [ $ERR != 0 ]; then
-       echo "++++++++++++++++++++++++++++++ unittests build failed"
-       RETVAL=1
-fi
-
-# Build example_app using cmake, this tests the CMake toolchain
-cd ../../../../
-# Copy lwipcfg for example app
-cp contrib/examples/example_app/lwipcfg.h.travis contrib/examples/example_app/lwipcfg.h
-
-# Generate CMake
-mkdir build
-cd build
-/usr/local/bin/cmake .. -G Ninja
-ERR=$?
-echo Return value from cmake generate: $ERR
-if [ $ERR != 0 ]; then
-       echo "++++++++++++++++++++++++++++++ cmake GENERATE failed"
-       RETVAL=1
-fi
-
-# Build CMake
-/usr/local/bin/cmake --build .
-ERR=$?
-echo Return value from build: $ERR
-if [ $ERR != 0 ]; then
-       echo "++++++++++++++++++++++++++++++ cmake build failed"
-       RETVAL=1
-fi
-
-# Build docs
-/usr/local/bin/cmake --build . --target lwipdocs
-ERR=$?
-echo Return value from lwipdocs: $ERR
-if [ $ERR != 0 ]; then
-       echo "++++++++++++++++++++++++++++++ lwIP documentation failed"
-       RETVAL=1
-fi
-
-# Test different lwipopts.h
-cd ..
-cd contrib/ports/unix/example_app
-./iteropts.sh
-ERR=$?
-echo Return value from iteropts: $ERR
-if [ $ERR != 0 ]; then
-       echo "++++++++++++++++++++++++++++++ lwIP iteropts test failed"
-       RETVAL=1
-fi
-
-echo Exit value: $RETVAL
-exit $RETVAL
